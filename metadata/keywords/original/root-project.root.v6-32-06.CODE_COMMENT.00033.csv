id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:220,Performance,load,loads,220,"// The code below generates two loads, both aligned as NeedAlign, and; // with the distance of NeedAlign between them. For that to cover the; // bits that need to be loaded (and without overlapping), the size of; // the loads should be equal to NeedAlign. This is true for all loadable; // types, but add an assertion in case something changes in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:277,Performance,load,loadable,277,"// The code below generates two loads, both aligned as NeedAlign, and; // with the distance of NeedAlign between them. For that to cover the; // bits that need to be loaded (and without overlapping), the size of; // the loads should be equal to NeedAlign. This is true for all loadable; // types, but add an assertion in case something changes in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:308,Testability,assert,assertion,308,"// The code below generates two loads, both aligned as NeedAlign, and; // with the distance of NeedAlign between them. For that to cover the; // bits that need to be loaded (and without overlapping), the size of; // the loads should be equal to NeedAlign. This is true for all loadable; // types, but add an assertion in case something changes in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:179,Performance,load,load,179,"/// isFPImmLegal - Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented by; /// AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:12,Safety,detect,detects,12,"// When LSR detects uses of the same base address to access different; // types (e.g. unions), it will assume a conservative type for these; // uses:; // LSR Use: Kind=Address of void in addrspace(4294967295), ...; // The type Ty passed here would then be ""void"". Skip the alignment; // checks, but do not return false right away, since that confuses; // LSR into crashing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:53,Security,access,access,53,"// When LSR detects uses of the same base address to access different; // types (e.g. unions), it will assume a conservative type for these; // uses:; // LSR Use: Kind=Address of void in addrspace(4294967295), ...; // The type Ty passed here would then be ""void"". Skip the alignment; // checks, but do not return false right away, since that confuses; // LSR into crashing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:94,Performance,optimiz,optimization,94,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:148,Performance,optimiz,optimization,148,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:114,Performance,perform,perform,114,"// ***************************************************************************; // Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes.; // ***************************************************************************; // If this is a tail call via a function pointer, then don't do it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:132,Performance,optimiz,optimization,132,"// ***************************************************************************; // Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes.; // ***************************************************************************; // If this is a tail call via a function pointer, then don't do it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:100,Safety,safe,safe,100,"// ***************************************************************************; // Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes.; // ***************************************************************************; // If this is a tail call via a function pointer, then don't do it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:10,Performance,optimiz,optimize,10,// Do not optimize if the calling conventions do not match and the conventions; // used are not C or Fast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:20,Performance,optimiz,optimize,20,// Do not tail call optimize vararg calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:24,Performance,optimiz,optimization,24,// Also avoid tail call optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:8,Safety,avoid,avoid,8,// Also avoid tail call optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:251,Availability,avail,available,251,"// In addition to the cases above, we also disable Tail Call Optimization if; // the calling convention code that at least one outgoing argument needs to; // go on the stack. We cannot check that here because at this point that; // information is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:61,Performance,Optimiz,Optimization,61,"// In addition to the cases above, we also disable Tail Call Optimization if; // the calling convention code that at least one outgoing argument needs to; // go on the stack. We cannot check that here because at this point that; // information is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:49,Performance,load,load,49,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:401,Performance,load,loaded,401,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:631,Performance,load,loaded,631,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:179,Safety,safe,safe,179,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:732,Testability,log,logic,732,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:54,Testability,test,tests,54,// TODO: This may be worth removing. Check regression tests for diffs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:4,Performance,Perform,Perform,4,"/// Perform a store-conditional operation to Addr. Return the status of the; /// store. This should be 0 if the store succeeded, non-zero otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:17,Performance,load,loads,17,// Do not expand loads and stores that don't exceed 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:17,Performance,load,loads,17,// Do not expand loads and stores that don't exceed 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:53,Integrability,Interface,Interface,53,"//===-- HexagonISelLowering.h - Hexagon DAG Lowering Interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Hexagon uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- HexagonISelLowering.h - Hexagon DAG Lowering Interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Hexagon uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:3,Integrability,Wrap,Wrappers,3,// Wrappers for ISD::*_EXTEND and ISD::TRUNCATE to prevent DAG,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:576,Integrability,wrap,wrapper,576,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:813,Integrability,wrap,wrapping,813,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:219,Modifiability,EXTEND,EXTEND,219,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:292,Modifiability,extend,extend,292,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:105,Usability,simpl,simplify,105,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:804,Usability,undo,undo,804,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:67,Performance,load,loaded,67,"// Align two vectors (in Op0, Op1) to one that would have; // been loaded from address in Op2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:82,Performance,load,load,82,"// Align vector address: Op0 & -Op1, except when it is; // an address in a vector load, then it's a no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:94,Performance,optimiz,optimization,94,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:148,Performance,optimiz,optimization,148,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:255,Performance,load,load,255,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:105,Performance,load,load,105,"// Custom-lower BUILD_VECTOR. The standard (target-independent); // handling of it would convert it to a load, which is not always; // the optimal choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:105,Performance,load,load,105,"// Custom-lower BUILD_VECTOR. The standard (target-independent); // handling of it would convert it to a load, which is not always; // the optimal choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:123,Performance,load,load,123,"// Custom-lower BUILD_VECTOR for vector pairs. The standard (target-; // independent) handling of it would convert it to a load, which is; // not always the optimal choice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Availability,Mask,Masked,3,// Masked load/store takes a mask that may need splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:29,Availability,mask,mask,29,// Masked load/store takes a mask that may need splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:10,Performance,load,load,10,// Masked load/store takes a mask that may need splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:107,Performance,load,loaded,107,"// Bool vectors are excluded by default, but make it explicit to; // emphasize that bool vectors cannot be loaded or stored.; // Also, disallow double vector stores (to prevent unnecessary; // store widening in DAG combiner).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:159,Energy Efficiency,efficient,efficiently,159,"// A special case is a situation where the vector is built entirely from; // elements extracted from another vector. This could be done via a shuffle; // more efficiently, but typically, the size of the source vector will not; // match the size of the vector being built (which precludes the use of a; // shuffle directly).; // This only handles a single source vector, and the vector being built; // should be of a sub-vector type of the source vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:27,Availability,mask,mask,27,"// Construct a new shuffle mask that will produce a vector with the same; // number of elements as the input vector, and such that the vector we; // want will be the initial subvector of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:24,Availability,mask,mask,24,"// Fill the rest of the mask with the unused elements of ExtVec in hopes; // that it will result in a permutation of ExtVec's elements. It's still; // fine if it doesn't (e.g. if undefs are present, or elements are; // repeated), but permutations can always be done efficiently via vdelta; // and vrdelta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:266,Energy Efficiency,efficient,efficiently,266,"// Fill the rest of the mask with the unused elements of ExtVec in hopes; // that it will result in a permutation of ExtVec's elements. It's still; // fine if it doesn't (e.g. if undefs are present, or elements are; // repeated), but permutations can always be done efficiently via vdelta; // and vrdelta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:66,Safety,avoid,avoid,66,// Find most common element to initialize vector with. This is to avoid; // unnecessary vinsert/valign for cases where the same value is present; // many times. Creates a histogram of the vector's elements to find the; // most common element n.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:157,Performance,perform,performed,157,"// Construct two halves in parallel, then or them together. Rn and Rm count; // number of rotations needed before the next element. One last rotation is; // performed post-loop to position the last element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Performance,Perform,Perform,3,// Perform last rotation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:73,Availability,down,down,73,"// Move the vector predicate SubV to a vector register, and scale it; // down to match the representation (bytes per type element) that VecV; // uses. The scaling down will pick every 2nd or 4th (every Scale-th; // in general) element and put them at the front of the resulting; // vector. This subvector will then be inserted into the Q2V of VecV.; // To avoid having an operation that generates an illegal type (short; // vector), generate a full size vector.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:163,Availability,down,down,163,"// Move the vector predicate SubV to a vector register, and scale it; // down to match the representation (bytes per type element) that VecV; // uses. The scaling down will pick every 2nd or 4th (every Scale-th; // in general) element and put them at the front of the resulting; // vector. This subvector will then be inserted into the Q2V of VecV.; // To avoid having an operation that generates an illegal type (short; // vector), generate a full size vector.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:356,Safety,avoid,avoid,356,"// Move the vector predicate SubV to a vector register, and scale it; // down to match the representation (bytes per type element) that VecV; // uses. The scaling down will pick every 2nd or 4th (every Scale-th; // in general) element and put them at the front of the resulting; // vector. This subvector will then be inserted into the Q2V of VecV.; // To avoid having an operation that generates an illegal type (short; // vector), generate a full size vector.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:508,Safety,avoid,avoid,508,"// Converting between a vector predicate and a scalar predicate. In the; // vector predicate, a group of BitBytes bits will correspond to a single; // i1 element of the source vector type. Those bits will all have the same; // value. The same will be true for ByteVec, where each byte corresponds; // to a bit in the vector predicate.; // The algorithm is to traverse the ByteVec, going over the i1 values from; // the source vector, and generate the corresponding representation in an; // 8-byte vector. To avoid repeated extracts from ByteVec, shuffle the; // elements so that the interesting 8 bytes will be in the low end of the; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:131,Deployability,update,update,131,"// The subvector being inserted must be entirely contained in one of; // the vectors V0 or V1. Set SingleV to the correct one, and update; // IdxV to be the index relative to the beginning of that vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:134,Availability,mask,mask,134,// ByteVec is the target vector VecV rotated in such a way that the; // subvector should be inserted at index 0. Generate a predicate mask; // and use vmux to do the insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:17,Modifiability,extend,extending,17,"// Sign- and any-extending of a vector predicate to a vector register is; // equivalent to Q2V. For zero-extensions, generate a vmux between 0 and; // a vector of 1s (where the 1s are of type matching the vector type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:288,Modifiability,extend,extend,288,"// A vector of i16 will be broken up into a build_vector of i16's.; // This is a problem, since at the time of operation legalization,; // all operations are expected to be type-legalized, and i16 is not; // a legal type. If any of the extracted elements is not of a valid; // type, sign-extend it to a valid one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:13,Modifiability,extend,extends,13,"// Lower any-extends of boolean vectors to sign-extends, since they; // translate directly to Q2V. Zero-extending could also be done equally; // fast, but Q2V is used/recognized in more places.; // For all other vectors, use zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:48,Modifiability,extend,extends,48,"// Lower any-extends of boolean vectors to sign-extends, since they; // translate directly to Q2V. Zero-extending could also be done equally; // fast, but Q2V is used/recognized in more places.; // For all other vectors, use zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:104,Modifiability,extend,extending,104,"// Lower any-extends of boolean vectors to sign-extends, since they; // translate directly to Q2V. Zero-extending could also be done equally; // fast, but Q2V is used/recognized in more places.; // For all other vectors, use zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:230,Modifiability,extend,extend,230,"// Lower any-extends of boolean vectors to sign-extends, since they; // translate directly to Q2V. Zero-extending could also be done equally; // fast, but Q2V is used/recognized in more places.; // For all other vectors, use zero-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:18,Modifiability,extend,extends,18,// Sign- and zero-extends are legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:43,Integrability,depend,depending,43,"// If the shift amount was 0, pick A or B, depending on the direction.; // The opposite shift will also be by 0, so the ""Or"" will be incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:35,Availability,mask,masked,35,// MSTORE; // HVX only has aligned masked stores.; // TODO: Fold negations of the mask into the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:82,Availability,mask,mask,82,// MSTORE; // HVX only has aligned masked stores.; // TODO: Fold negations of the mask into the store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:56,Modifiability,extend,extend,56,"// Compare the widths of elements of the two types, and extend the narrower; // type to match the with of the wider type. For vector types, apply this; // to the element type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite conversion between integer and floating-point in such a way that; // the integer type is extended/narrowed to match the bitwidth of the; // floating-point type, combined with additional integer-integer extensions; // or narrowings to match the original input/result types.; // E.g. f32 -> i8 ==> f32 -> i32 -> i8; //; // The input/result types are not required to be legal, but if they are; // legal, this function should not introduce illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:100,Modifiability,extend,extended,100,"// Rewrite conversion between integer and floating-point in such a way that; // the integer type is extended/narrowed to match the bitwidth of the; // floating-point type, combined with additional integer-integer extensions; // or narrowings to match the original input/result types.; // E.g. f32 -> i8 ==> f32 -> i32 -> i8; //; // The input/result types are not required to be legal, but if they are; // legal, this function should not introduce illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:30,Modifiability,extend,extends,30,"// In general, sign- and zero-extends can't be split and still; // be legal. The only exception is extending bool vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:99,Modifiability,extend,extending,99,"// In general, sign- and zero-extends can't be split and still; // be legal. The only exception is extending bool vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:13,Performance,load,loads,13,// Unaligned loads will be handled by the default lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the extension/truncation/saturation op into steps where each; // step changes the type widths by a factor of 2.; // E.g. i8 -> i16 remains unchanged, but i8 -> i32 ==> i8 -> i16 -> i32.; //; // Some of the vector types in Op may not be legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Usability,Simpl,Simplify,3,"// Simplify V:v2NiB --(bitcast)--> vNi2B --(truncate)--> vNiB; // to extract-subvector (shuffle V, pick even, pick odd)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Performance,Perform,Perform,3,"// Perform a deep clone of the expression, set Root to the root; // of the clone, and build a map from the cloned values to the; // original ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:8,Usability,simpl,simply,8,"// Now, simply replace OldV with NewV in Root.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:179,Availability,mask,masked,179,"// Match the following:; // select (X & (1 << i)) != 0 ? R ^ (Q << i) : R; // select (X & (1 << i)) == 0 ? R : R ^ (Q << i); // The condition may also check for equality with the masked value, i.e; // select (X & (1 << i)) == (1 << i) ? R ^ (Q << i) : R; // select (X & (1 << i)) != (1 << i) ? R : R ^ (Q << i);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:43,Modifiability,variab,variable,43,// TODO: Could also check for an induction variable containing single; // bit shifted left by 1 in each iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:66,Integrability,depend,depending,66,// Matched: select +++ ? R : R ^ T; // select +++ ? R ^ T : R; // depending on TrueIfZero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:109,Modifiability,variab,variable,109,"// The xor input value T is isolated into its own match so that it could; // be checked against an induction variable containing a shifted bit; // (todo).; // For now, check against (Q << i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:179,Availability,mask,masked,179,"// Match the following:; // select (X & 1) != 0 ? (R >> 1) ^ Q : (R >> 1); // select (X & 1) == 0 ? (R >> 1) : (R >> 1) ^ Q; // The condition may also check for equality with the masked value, i.e; // select (X & 1) == 1 ? (R >> 1) ^ Q : (R >> 1); // select (X & 1) != 1 ? (R >> 1) : (R >> 1) ^ Q",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:41,Testability,test,tested,41,"// The select's condition is true if the tested bit is 0.; // TrueV must be the shift, FalseV must be the xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:41,Testability,test,tested,41,"// The select's condition is true if the tested bit is 1.; // TrueV must be the xor, FalseV must be the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:99,Testability,test,test-bit,99,"// The basic pattern for R = P.Q is:; // for i = 0..31; // R = phi (0, R'); // if (P & (1 << i)) ; test-bit(P, i); // R' = R ^ (Q << i); //; // Similarly, the basic pattern for R = (P/Q).Q - P; // for i = 0..31; // R = phi(P, R'); // if (R & (1 << i)); // R' = R ^ (Q << i); // There exist idioms, where instead of Q being shifted left, P is shifted; // right. This produces a result that is shifted right by 32 bits (the; // non-shifted result is 64-bit).; //; // For R = P.Q, this would be:; // for i = 0..31; // R = phi (0, R'); // if ((P >> i) & 1); // R' = (R >> 1) ^ Q ; R is cycled through the loop, so it must; // else ; be shifted by 1, not i.; // R' = R >> 1; //; // And for the inverse:; // for i = 0..31; // R = phi (P, R'); // if (R & 1); // R' = (R >> 1) ^ Q; // else; // R' = R >> 1; // The left-shifting idioms share the same pattern:; // select (X & (1 << i)) ? R ^ (Q << i) : R; // Similarly for right-shifting idioms:; // select (X & 1) ? (R >> 1) ^ Q",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:133,Modifiability,variab,variable,133,"// X is not loop invariant. If X == R, this is the inverse pmpy.; // Otherwise, check for an xor with an invariant value. If the; // variable argument to the xor is R, then this is still a valid; // inverse pmpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Performance,Perform,Perform,3,// Perform the promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:9,Deployability,update,update,9,// Final update of the P's type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:38,Testability,log,logical,38,// Find all value cycles that contain logical right shifts by 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:49,Integrability,depend,depending,49,"// First, the shift amount will be CIV or CIV+1, depending on; // whether the value is early or late. Instead of creating CIV+1,; // do a single shift of the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Deployability,Update,Update,3,"// Update the users outside of the loop to account for having left; // shifts. They would normally be shifted right in the loop, so shift; // them right after the loop exit.; // Take advantage of the loop-closed SSA form, which has all the post-; // loop values in phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:16,Availability,mask,mask,16,// Create a bit mask to clear the high bits beyond IterCount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:24,Usability,clear,clear,24,// Create a bit mask to clear the high bits beyond IterCount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:10,Usability,clear,clearing,10,"// Again, clearing bits beyond IterCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:159,Modifiability,variab,variable,159,"// Restrictions:; // - The loop must consist of a single block.; // - The iteration count must be known at compile-time.; // - The loop must have an induction variable starting from 0, and; // incremented in each iteration of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Performance,Perform,Perform,3,"// Perform a preliminary scan of select instructions to see if any of them; // looks like a generator of the polynomial multiply steps. Assume that a; // loop can only contain a single transformable operation, so stop the; // traversal after the first reasonable candidate was found.; // XXX: Currently this approach can modify the loop before being 100% sure; // that the transformation can be carried out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:22,Usability,simpl,simplifications,22,// Run post-promotion simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:44,Performance,load,load,44,// The store must be feeding a non-volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:113,Performance,load,load,113,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:164,Performance,load,load,164,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:17,Performance,load,load,17,// The store and load must share the same stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:68,Security,access,access,68,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:136,Security,access,access,136,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:149,Security,Access,Access,149,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:208,Security,access,access,208,"/// mayLoopAccessLocation - Return true if the specified loop might access the; /// specified pointer location, which is a loop-strided access. The 'Access'; /// argument specifies what the verboten forms of access are (read or write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:66,Security,access,access,66,"// Get the location that may be stored across the loop. Since the access; // is strided positively through memory, we say that the modified location; // starts at the pointer and has infinite size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:67,Security,access,access,67,"// If the loop iterates a fixed number of times, we can refine the access; // size to be exactly the size of the memset, which is (BECount+1)*StoreSize",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:113,Performance,load,load,113,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:164,Performance,load,load,164,"// See if the pointer expression is an AddRec like {base,+,1} on the current; // loop, which indicates a strided load. If we have something else, it's a; // random load we can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:45,Performance,load,loaded,45,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy/memmove in the loop preheader now if we want. However,; // this would be unsafe to do if there is anything else in the loop that may; // read or write the memory region we're storing to. For memcpy, this; // includes the load that feeds the stores. Check for an alias by generating; // the base address and checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:315,Performance,load,load,315,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy/memmove in the loop preheader now if we want. However,; // this would be unsafe to do if there is anything else in the loop that may; // read or write the memory region we're storing to. For memcpy, this; // includes the load that feeds the stores. Check for an alias by generating; // the base address and checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:167,Safety,unsafe,unsafe,167,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy/memmove in the loop preheader now if we want. However,; // this would be unsafe to do if there is anything else in the loop that may; // read or write the memory region we're storing to. For memcpy, this; // includes the load that feeds the stores. Check for an alias by generating; // the base address and checking everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:16,Performance,load,load,16,// Check if the load is the offending instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:22,Performance,load,load,22,// It worked with the load ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:207,Integrability,depend,depend,207,"// In case of a memmove, the call to memmove will be executed instead; // of the loop, so we need to make sure that there is nothing else in; // the loop than the load, store and instructions that these two depend; // on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:163,Performance,load,load,163,"// In case of a memmove, the call to memmove will be executed instead; // of the loop, so we need to make sure that there is nothing else in; // the loop than the load, store and instructions that these two depend; // on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:39,Deployability,update,update,39,"// Create a new (empty) preheader, and update the PHI nodes in the; // header to use the new preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:13,Safety,safe,safe,13,"// Check for safe conditions to execute memmove.; // If stride is positive, copying things from higher to lower addresses; // is equivalent to memmove. For negative stride, it's the other way; // around. Copying forward in memory with positive stride may not be; // same as memmove since we may be copying values that we just stored; // in some previous iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:59,Integrability,depend,dependencies,59,"// Check if the instructions in Insts, together with their dependencies; // cover the loop in the sense that the loop could be safely eliminated once; // the instructions in Insts are removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:127,Safety,safe,safely,127,"// Check if the instructions in Insts, together with their dependencies; // cover the loop in the sense that the loop could be safely eliminated once; // the instructions in Insts are removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:77,Integrability,depend,depend,77,"// Collect all instructions from the loop that the instructions in Insts; // depend on (plus their dependencies, etc.). These instructions will; // constitute the expression trees that feed those in Insts, but the trees; // will be limited only to instructions contained in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:99,Integrability,depend,dependencies,99,"// Collect all instructions from the loop that the instructions in Insts; // depend on (plus their dependencies, etc.). These instructions will; // constitute the expression trees that feed those in Insts, but the trees; // will be limited only to instructions contained in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:45,Performance,optimiz,optimized,45,"// Look for store instructions, which may be optimized to memset/memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize the store into a memcpy, if it feeds an similarly strided load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:70,Performance,load,load,70,"// Optimize the store into a memcpy, if it feeds an similarly strided load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp:40,Energy Efficiency,Schedul,Scheduler,40,"//===- HexagonMachineScheduler.cpp - MI Scheduler for Hexagon -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp:400,Energy Efficiency,schedul,schedules,400,"//===- HexagonMachineScheduler.cpp - MI Scheduler for Hexagon -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp:30,Integrability,depend,dependence,30,/// Return true if there is a dependence between SUd and SUu.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h:53,Energy Efficiency,schedul,scheduler,53,"//===- HexagonMachineScheduler.h - Custom Hexagon MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom Hexagon MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h:401,Energy Efficiency,schedul,scheduler,401,"//===- HexagonMachineScheduler.h - Custom Hexagon MI scheduler --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Custom Hexagon MI scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:248,Testability,log,logic,248,"// Bail out if feederReg is a paired register (double regs in; // our case). One would think that we can check to see if a given; // register cmpReg1 or cmpReg2 is a sub register of feederReg; // using -- if (QRI->isSubRegister(feederReg, cmpReg1) logic; // before the callsite of this function; // But we can not as it comes in the following fashion.; // %d0 = Hexagon_S2_lsr_r_p killed %d0, killed %r2; // %r0 = KILL %r0, implicit killed %d0; // %p0 = CMPEQri killed %r0, 0; // Hence, we need to check if it's a KILL instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:472,Safety,hazard,hazards,472,"// Make sure there is no 'def' or 'use' of any of the uses of; // feeder insn between its definition, this MI and jump, jmpInst; // skipping compare, cmpInst.; // Here's the example.; // r21=memub(r22+r24<<#0); // p0 = cmp.eq(r21, #0); // r4=memub(r3+r21<<#0); // if (p0.new) jump:t .LBB29_45; // Without this check, it will be converted into; // r4=memub(r3+r21<<#0); // r21=memub(r22+r24<<#0); // p0 = cmp.eq(r21, #0); // if (p0.new) jump:t .LBB29_45; // and result WAR hazards if converted to New Value Jump.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:44,Performance,perform,performed,44,// These are the common checks that need to performed; // to determine if; // 1. compare instruction can be moved before jump.; // 2. feeder to the compare instruction can be moved before jump.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:26,Safety,avoid,avoid,26,// return *some value* to avoid compiler warning,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:70,Modifiability,variab,variable,70,// If we move NewValueJump before register allocation we'll need live variable; // analysis here too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:281,Modifiability,variab,variable,281,"// If ifconverter had not messed up with the kill flags of the; // operands, the following check on the kill flag would suffice.; // if(!jmpInstr->getOperand(0).isKill()) break;; // This predicate register is live out of BB; // this would only work if we can actually use Live; // variable analysis on phy regs - but LLVM does not; // provide LV analysis on phys regs.; //if(LVs.isLiveOut(predReg, *MBB)) break;; // Get all the successors of this block - which will always; // be 2. Check if the predicate register is live-in in those; // successor. If yes, we can not delete the predicate -; // I am doing this only because LLVM does not provide LiveOut; // at the BB level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:422,Performance,optimiz,optimize,422,"//===- HexagonOptAddrMode.cpp ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This implements a Hexagon-specific pass to optimize addressing mode for; // load/store instructions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:455,Performance,load,load,455,"//===- HexagonOptAddrMode.cpp ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This implements a Hexagon-specific pass to optimize addressing mode for; // load/store instructions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:97,Performance,load,load,97,"// Check if addasl instruction can be removed. This is possible only; // if it's feeding to only load/store instructions with base + register; // offset as these instruction can be tranformed to use 'absolute plus; // shifted register offset'.; // ex:; // Rs = ##foo; // Rx = addasl(Rs, Rt, #2); // Rd = memw(Rx + #28); // Above three instructions can be replaced with Rd = memw(Rt<<#2 + ##foo+28)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:34,Performance,load,load,34,// The reaching def of LRExtRR at load/store node should be same as the; // one reaching at the SN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:107,Modifiability,extend,extend,107,"// If the register is undefined (for example if it's a reserved register),; // it may still be possible to extend the range, but it's safer to be; // conservative and just punt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:134,Safety,safe,safer,134,"// If the register is undefined (for example if it's a reserved register),; // it may still be possible to extend the range, but it's safer to be; // conservative and just punt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:51,Modifiability,extend,extend,51,// only HVX vgather instructions handled; // TODO: extend the pass to other vector load/store operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:83,Performance,load,load,83,// only HVX vgather instructions handled; // TODO: extend the pass to other vector load/store operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:18,Modifiability,extend,extending,18,"// Since we'll be extending the live range of Rt in the following example,; // make sure that is safe. another definition of Rt doesn't exist between 'add'; // and load/store instruction.; //; // Ex: Rx= add(Rt,#10); // memw(Rx+#0) = Rs; // will be replaced with => memw(Rt+#10) = Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:164,Performance,load,load,164,"// Since we'll be extending the live range of Rt in the following example,; // make sure that is safe. another definition of Rt doesn't exist between 'add'; // and load/store instruction.; //; // Ex: Rx= add(Rt,#10); // memw(Rx+#0) = Rs; // will be replaced with => memw(Rt+#10) = Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:97,Safety,safe,safe,97,"// Since we'll be extending the live range of Rt in the following example,; // make sure that is safe. another definition of Rt doesn't exist between 'add'; // and load/store instruction.; //; // Ex: Rx= add(Rt,#10); // memw(Rx+#0) = Rs; // will be replaced with => memw(Rt+#10) = Rs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:3,Deployability,Update,Update,3,// Update all the uses of 'add' with the appropriate base and offset; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:155,Deployability,update,update,155,// Set the reachingDef for UseNode under consideration; // after updating the Add use. This local change is; // to avoid rebuilding of the RDF graph after update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:115,Safety,avoid,avoid,115,// Set the reachingDef for UseNode under consideration; // after updating the Add use. This local change is; // to avoid rebuilding of the RDF graph after update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce size by 1 as addasl itself can be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:19,Performance,load,load,19,"// Currently, only load/store and addasl are handled.; // Some other instructions to consider -; // A2_add -> A2_addi; // M4_mpyrr_addr -> M4_mpyrr_addi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce total size by 2 if original tfr can be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:165,Deployability,update,updated,165,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:430,Deployability,update,updated,430,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:487,Modifiability,extend,extended,487,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:117,Performance,load,load,117,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:401,Performance,perform,performed,401,"// Analyze all uses of 'add'. If the output of 'add' is used as an address; // in the base+immediate addressing mode load/store instructions, see if; // they can be updated to use the immediate value as an offet. Thus,; // providing us the opportunity to eliminate 'add'.; // Ex: Rx= add(Rt,#12); // memw(Rx+#0) = Rs; // This can be replaced with memw(Rt+#12) = Rs; //; // This transformation is only performed if all uses can be updated and; // the offset isn't required to be constant extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:52,Performance,Perform,Perform,52,// Analyze all uses and calculate increase in size. Perform the optimization; // only if there is no increase in size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:64,Performance,optimiz,optimization,64,// Analyze all uses and calculate increase in size. Perform the optimization; // only if there is no increase in size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:66,Modifiability,extend,extends,66,"//===- HexagonOptimizeSZextends.cpp - Remove unnecessary argument extends -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Pass that removes sign extends for function parameters. These parameters; // are already sign extended by the caller per Hexagon's ABI; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:406,Modifiability,extend,extends,406,"//===- HexagonOptimizeSZextends.cpp - Remove unnecessary argument extends -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Pass that removes sign extends for function parameters. These parameters; // are already sign extended by the caller per Hexagon's ABI; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:477,Modifiability,extend,extended,477,"//===- HexagonOptimizeSZextends.cpp - Remove unnecessary argument extends -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Pass that removes sign extends for function parameters. These parameters; // are already sign extended by the caller per Hexagon's ABI; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:24,Modifiability,extend,extends,24,// Try to optimize sign extends in formal parameters. It's relying on; // callee already sign extending the values. I'm not sure if our ABI; // requires callee to sign extend though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:94,Modifiability,extend,extending,94,// Try to optimize sign extends in formal parameters. It's relying on; // callee already sign extending the values. I'm not sure if our ABI; // requires callee to sign extend though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:168,Modifiability,extend,extend,168,// Try to optimize sign extends in formal parameters. It's relying on; // callee already sign extending the values. I'm not sure if our ABI; // requires callee to sign extend though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:10,Performance,optimiz,optimize,10,// Try to optimize sign extends in formal parameters. It's relying on; // callee already sign extending the values. I'm not sure if our ABI; // requires callee to sign extend though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:17,Availability,redundant,redundant,17,"// Try to remove redundant sext operations on Hexagon. The hardware; // already sign extends many 16 bit intrinsic operations to 32 bits.; // For example:; // %34 = tail call i32 @llvm.hexagon.A2.addh.l16.sat.ll(i32 %x, i32 %y); // %sext233 = shl i32 %34, 16; // %conv52 = ashr exact i32 %sext233, 16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:85,Modifiability,extend,extends,85,"// Try to remove redundant sext operations on Hexagon. The hardware; // already sign extends many 16 bit intrinsic operations to 32 bits.; // For example:; // %34 = tail call i32 @llvm.hexagon.A2.addh.l16.sat.ll(i32 %x, i32 %y); // %sext233 = shl i32 %34, 16; // %conv52 = ashr exact i32 %sext233, 16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:17,Safety,redund,redundant,17,"// Try to remove redundant sext operations on Hexagon. The hardware; // already sign extends many 16 bit intrinsic operations to 32 bits.; // For example:; // %34 = tail call i32 @llvm.hexagon.A2.addh.l16.sat.ll(i32 %x, i32 %y); // %sext233 = shl i32 %34, 16; // %conv52 = ashr exact i32 %sext233, 16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:40,Testability,log,logical,40,// The first operand of Ashr comes from logical shift left.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:367,Availability,redundant,redundant,367,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:562,Availability,redundant,redundant,562,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:925,Availability,redundant,redundant,925,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:382,Modifiability,extend,extends,382,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:47,Performance,Optimiz,Optimiztions,47,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:316,Performance,optimiz,optimizes,316,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:357,Performance,Optimiz,Optimizes,357,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:552,Performance,Optimiz,Optimizes,552,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:367,Safety,redund,redundant,367,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:562,Safety,redund,redundant,562,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:925,Safety,redund,redundant,925,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:17,Modifiability,extend,extends,17,// Look for sign extends:; // %170 = SXTW %166,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:245,Performance,load,loads,245,"// The actual base register (BP) is typically shared between many; // instructions where frame indices are being replaced. In scalar; // instructions the offset range is large, and the need for an extra; // add instruction is infrequent. Vector loads/stores, however, have; // a much smaller offset range: [-8, 7), or #s4. In those cases it; // makes sense to ""standardize"" the immediate in the ""addi"" instruction; // so that multiple loads/stores could be based on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:435,Performance,load,loads,435,"// The actual base register (BP) is typically shared between many; // instructions where frame indices are being replaced. In scalar; // instructions the offset range is large, and the need for an extra; // add instruction is infrequent. Vector loads/stores, however, have; // a much smaller offset range: [-8, 7), or #s4. In those cases it; // makes sense to ""standardize"" the immediate in the ""addi"" instruction; // so that multiple loads/stores could be based on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the offset as ""base + [-8, 7)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:103,Safety,avoid,avoid,103,"// Search backwards in the block for ""Reg = A2_addi BP, RealOffset"".; // This will give us a chance to avoid creating a new register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:3,Modifiability,Extend,Extending,3,"// Extending a range of a virtual register can be dangerous,; // since the scavenger will need to find a physical register; // for it. Avoid extending the range past a function call,; // and avoid overlapping it with another virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:141,Modifiability,extend,extending,141,"// Extending a range of a virtual register can be dangerous,; // since the scavenger will need to find a physical register; // for it. Avoid extending the range past a function call,; // and avoid overlapping it with another virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:135,Safety,Avoid,Avoid,135,"// Extending a range of a virtual register can be dangerous,; // since the scavenger will need to find a physical register; // for it. Avoid extending the range past a function call,; // and avoid overlapping it with another virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:191,Safety,avoid,avoid,191,"// Extending a range of a virtual register can be dangerous,; // since the scavenger will need to find a physical register; // for it. Avoid extending the range past a function call,; // and avoid overlapping it with another virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:19,Modifiability,extend,extend,19,"// Coalescing will extend the live interval of the destination register.; // If the destination register is a vector pair, avoid introducing function; // calls into the interval, since it could result in a spilling of a pair; // instead of a single vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:123,Safety,avoid,avoid,123,"// Coalescing will extend the live interval of the destination register.; // If the destination register is a vector pair, avoid introducing function; // calls into the interval, since it could result in a spilling of a pair; // instead of a single vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp:525,Availability,down,down,525,"//=== HexagonSplitConst32AndConst64.cpp - split CONST32/Const64 into HI/LO ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When the compiler is invoked with no small data, for instance, with the -G0; // command line option, then all CONST* opcodes should be broken down into; // appropriate LO and HI instructions. This splitting is done by this pass.; // The only reason this is not done in the DAG lowering itself is that there; // is no simple way of getting the register allocator to allot the same hard; // register to the result of LO and HI instructions. This pass is always; // scheduled after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp:846,Energy Efficiency,schedul,scheduled,846,"//=== HexagonSplitConst32AndConst64.cpp - split CONST32/Const64 into HI/LO ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When the compiler is invoked with no small data, for instance, with the -G0; // command line option, then all CONST* opcodes should be broken down into; // appropriate LO and HI instructions. This splitting is done by this pass.; // The only reason this is not done in the DAG lowering itself is that there; // is no simple way of getting the register allocator to allot the same hard; // register to the result of LO and HI instructions. This pass is always; // scheduled after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp:700,Usability,simpl,simple,700,"//=== HexagonSplitConst32AndConst64.cpp - split CONST32/Const64 into HI/LO ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When the compiler is invoked with no small data, for instance, with the -G0; // command line option, then all CONST* opcodes should be broken down into; // appropriate LO and HI instructions. This splitting is done by this pass.; // The only reason this is not done in the DAG lowering itself is that there; // is no simple way of getting the register allocator to allot the same hard; // register to the result of LO and HI instructions. This pass is always; // scheduled after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitConst32AndConst64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:145,Safety,safe,safe,145,"// In some cases a register may exist, but never be defined or used.; // It should never appear anywhere, but mark it as ""fixed"", just to be; // safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the profitability of splitting induction registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:227,Energy Efficiency,schedul,scheduler,227,"// If a register from this partition is used in a fixed instruction,; // and there is also a register in this partition that is used in; // a loop phi node, then decrease the splitting profit as this can; // confuse the modulo scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:8,Usability,simpl,simple,8,// Only simple jump-conditional (with or without negation).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:75,Integrability,depend,depends,75,// Get the registers on which the loop controlling compare instruction; // depends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:383,Modifiability,extend,extender,383,"// The operand to A2_tfrsi can only have 32 significant bits. Immediate; // values in MachineOperand are stored as 64-bit integers, and so the; // value -1 may be represented either as 64-bit -1, or 4294967295. Both; // will have the 32 higher bits truncated in the end, but -1 will remain; // as -1, while the latter may appear to be a large unsigned value; // requiring a constant extender. The casting to int32_t will select the; // former representation. (The same reasoning applies to all 32-bit; // values.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:839,Energy Efficiency,reduce,reduce,839,"//===- HexagonStoreWidening.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace sequences of ""narrow"" stores to adjacent memory locations with; // a fewer ""wide"" stores that have the same effect.; // For example, replace:; // S4_storeirb_io %100, 0, 0 ; store-immediate-byte; // S4_storeirb_io %100, 1, 0 ; store-immediate-byte; // with; // S4_storeirh_io %100, 0, 0 ; store-immediate-halfword; // The above is the general idea. The actual cases handled by the code; // may be a bit more complex.; // The purpose of this pass is to reduce the number of outstanding stores,; // or as one could say, ""reduce store queue pressure"". Also, wide stores; // mean fewer stores, and since there are only two memory instructions allowed; // per packet, it also means fewer packets, and ultimately fewer cycles.; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:906,Energy Efficiency,reduce,reduce,906,"//===- HexagonStoreWidening.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace sequences of ""narrow"" stores to adjacent memory locations with; // a fewer ""wide"" stores that have the same effect.; // For example, replace:; // S4_storeirb_io %100, 0, 0 ; store-immediate-byte; // S4_storeirb_io %100, 1, 0 ; store-immediate-byte; // with; // S4_storeirh_io %100, 0, 0 ; store-immediate-halfword; // The above is the general idea. The actual cases handled by the code; // may be a bit more complex.; // The purpose of this pass is to reduce the number of outstanding stores,; // or as one could say, ""reduce store queue pressure"". Also, wide stores; // mean fewer stores, and since there are only two memory instructions allowed; // per packet, it also means fewer packets, and ultimately fewer cycles.; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:919,Performance,queue,queue,919,"//===- HexagonStoreWidening.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace sequences of ""narrow"" stores to adjacent memory locations with; // a fewer ""wide"" stores that have the same effect.; // For example, replace:; // S4_storeirb_io %100, 0, 0 ; store-immediate-byte; // S4_storeirb_io %100, 1, 0 ; store-immediate-byte; // with; // S4_storeirh_io %100, 0, 0 ; store-immediate-halfword; // The above is the general idea. The actual cases handled by the code; // may be a bit more complex.; // The purpose of this pass is to reduce the number of outstanding stores,; // or as one could say, ""reduce store queue pressure"". Also, wide stores; // mean fewer stores, and since there are only two memory instructions allowed; // per packet, it also means fewer packets, and ultimately fewer cycles.; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:39,Security,access,accesses,39,// Check if the machine instruction MI accesses any storage aliased with; // any store in the group Stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:85,Security,access,access,85,"// Check if store instructions S1 and S2 are adjacent. More precisely,; // S2 has to access memory immediately following that accessed by S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:126,Security,access,accessed,126,"// Check if store instructions S1 and S2 are adjacent. More precisely,; // S2 has to access memory immediately following that accessed by S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:53,Energy Efficiency,power,power,53,// The initial value of SizeAccum should always be a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:219,Testability,Test,Test,219,"// The offset of a store will put restrictions on how wide the store can be.; // Offsets in stores of size 2^n bytes need to have the n lowest bits be 0.; // If the first store already exhausts the offset limits, quit. Test this; // by checking if the next wider size would exceed the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:121,Energy Efficiency,power,power,121,// Pow2Num will be the largest number of elements in OG such that the sum; // of sizes of stores 0...Pow2Num-1 will be a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:233,Energy Efficiency,power,power,233,"// Be greedy: keep accumulating stores as long as they are to adjacent; // memory locations, and as long as the total number of bytes stored; // does not exceed the limit (MaxSize).; // Keep track of when the total size covered is a power of 2, since; // this is a size a single store can cover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:186,Availability,recover,recover,186,"// InsertAt points at the first instruction that will be removed. We need; // to move it out of the way, so it remains valid after removing all the; // old stores, and so we are able to recover it back to the proper insertion; // position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:186,Safety,recover,recover,186,"// InsertAt points at the first instruction that will be removed. We need; // to move it out of the way, so it remains valid after removing all the; // old stores, and so we are able to recover it back to the proper insertion; // position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:342,Performance,perform,performed,342,"// Process a single basic block: create the store groups, and replace them; // with the widened stores, if possible. Processing of each basic block; // is independent from processing of any other basic block. This transfor-; // mation could be stopped after having processed any basic block without; // any ill effects (other than not having performed widening in the unpro-; // cessed blocks). Also, the basic blocks can be processed in any order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:139,Modifiability,variab,variables,139,"// Turn on QFloat if the HVX version is v68+.; // The function ParseSubtargetFeatures will set feature bits and initialize; // subtarget's variables all in one, so there isn't a good way to preprocess; // the feature string, other than by tinkering with it directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:50,Energy Efficiency,schedul,scheduling,50,"// Tiny core has a single thread, so back-to-back scheduling is enabled by; // default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:3,Safety,Avoid,Avoid,3,// Avoid types like <2 x i32*>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:105,Usability,simpl,simple,105,"// The given type may be something like <17 x i32>, which is not MVT,; // but can be represented as (non-simple) EVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:24,Energy Efficiency,power,power-of-,24,"// Round up EVT to have power-of-2 elements, and keep checking if it; // qualifies for HVX, dividing it in half after each step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:3,Deployability,Update,Update,3,// Update the latency of chain edges between v60 vector load or store; // instructions to be 1. These instruction cannot be scheduled in the; // same packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:124,Energy Efficiency,schedul,scheduled,124,// Update the latency of chain edges between v60 vector load or store; // instructions to be 1. These instruction cannot be scheduled in the; // same packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:14,Performance,latency,latency,14,// Update the latency of chain edges between v60 vector load or store; // instructions to be 1. These instruction cannot be scheduled in the; // same packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:56,Performance,load,load,56,// Update the latency of chain edges between v60 vector load or store; // instructions to be 1. These instruction cannot be scheduled in the; // same packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:14,Integrability,depend,dependence,14,// Change the dependence in the opposite direction too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:76,Energy Efficiency,schedul,scheduling,76,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:186,Energy Efficiency,reduce,reduce,186,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:242,Energy Efficiency,allocate,allocated,242,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:256,Energy Efficiency,schedul,scheduled,256,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:374,Energy Efficiency,allocate,allocate,374,"// Check if a call and subsequent A2_tfrpi instructions should maintain; // scheduling affinity. We are looking for the TFRI to be consumed in; // the next instruction. This should help reduce the instances of; // double register pairs being allocated and scheduled before a call; // when not used until after the call. This situation is exacerbated; // by the fact that we allocate the pair from the callee saves list,; // leading to excess spills and restores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:59,Energy Efficiency,schedul,scheduled,59,// Currently we only catch the situation when compare gets scheduled; // before preceding call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:11,Availability,redundant,redundant,11,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:373,Energy Efficiency,schedul,scheduler,373,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:478,Integrability,depend,dependence,478,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:11,Safety,redund,redundant,11,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:131,Integrability,depend,dependency,131,"// Create artificial edges between loads that could likely cause a bank; // conflict. Since such loads would normally not have any dependency; // between them, we cannot rely on existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:35,Performance,load,loads,35,"// Create artificial edges between loads that could likely cause a bank; // conflict. Since such loads would normally not have any dependency; // between them, we cannot rely on existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:97,Performance,load,loads,97,"// Create artificial edges between loads that could likely cause a bank; // conflict. Since such loads would normally not have any dependency; // between them, we cannot rely on existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:44,Performance,cache,cache,44,"// Is the access size is longer than the L1 cache line, skip the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:10,Security,access,access,10,"// Is the access size is longer than the L1 cache line, skip the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:45,Safety,avoid,avoid,45,// Scan only up to 32 instructions ahead (to avoid n^2 complexity).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:71,Performance,latency,latency,71,"// Bits 3 and 4 are the same, add an artificial edge and set extra; // latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:72,Energy Efficiency,schedul,scheduling,72,"/// Enable use of alias analysis during code generation (during MI; /// scheduling, DAGCombine, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:60,Energy Efficiency,schedul,schedule,60,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:74,Integrability,depend,dependency,74,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:4,Performance,Perform,Perform,4,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:47,Performance,latency,latency,47,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:45,Performance,latency,latency,45,// Instructions with .new operands have zero latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:11,Performance,latency,latency,11,// Set the latency for a copy to zero since we hope that is will get; // removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:93,Performance,latency,latency,93,"// If it's a REG_SEQUENCE/COPY, use its destination instruction to determine; // the correct latency.; // If there are multiple uses of the def of COPY/REG_SEQUENCE, set the latency; // only if the latencies on all the uses are equal, otherwise set it to; // default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:174,Performance,latency,latency,174,"// If it's a REG_SEQUENCE/COPY, use its destination instruction to determine; // the correct latency.; // If there are multiple uses of the def of COPY/REG_SEQUENCE, set the latency; // only if the latencies on all the uses are equal, otherwise set it to; // default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:29,Performance,Latency,Latency,29,"// For multiple uses, if the Latency is different across uses, reset; // DLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:10,Energy Efficiency,schedul,schedule,10,// Try to schedule uses near definitions to generate .cur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:7,Energy Efficiency,schedul,scheduling,7,// BSB scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:62,Performance,latency,latency,62,"// For some instructions (ex: COPY), we might end up with < 0 latency; // as they don't have any Itinerary class associated with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:3,Deployability,Update,Update,3,// Update the latency of opposite edge too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:14,Performance,latency,latency,14,// Update the latency of opposite edge too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:15,Performance,latency,latency,15,/// Change the latency between the two SUnits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:3,Deployability,Update,Update,3,// Update the latency of opposite edge too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:14,Performance,latency,latency,14,// Update the latency of opposite edge too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:28,Performance,latency,latency,28,"/// If the SUnit has a zero latency edge, return the other SUnit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:57,Energy Efficiency,schedul,schedule,57,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:109,Integrability,depend,dependence,109,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:91,Performance,latency,latency,91,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:143,Performance,latency,latency,143,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:40,Integrability,depend,dependent,40,"// The architecture doesn't allow three dependent instructions in the same; // packet. So, if the destination has a zero latency successor, then it's; // not a candidate for a zero latency predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:121,Performance,latency,latency,121,"// The architecture doesn't allow three dependent instructions in the same; // packet. So, if the destination has a zero latency successor, then it's; // not a candidate for a zero latency predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:181,Performance,latency,latency,181,"// The architecture doesn't allow three dependent instructions in the same; // packet. So, if the destination has a zero latency successor, then it's; // not a candidate for a zero latency predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:39,Integrability,depend,dependence,39,"// The caller frequently adds the same dependence twice. If so, then; // return true for this case too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:79,Integrability,depend,dependence,79,"// Reassign the latency for the previous bests, which requires setting; // the dependence edge in both directions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:16,Performance,latency,latency,16,"// Reassign the latency for the previous bests, which requires setting; // the dependence edge in both directions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:75,Integrability,depend,dependence,75,// Attempt to find another opprotunity for zero latency in a different; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:48,Performance,latency,latency,48,// Attempt to find another opprotunity for zero latency in a different; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:81,Integrability,depend,dependence,81,// Check if the previous best destination instruction has a new zero; // latency dependence opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:73,Performance,latency,latency,73,// Check if the previous best destination instruction has a new zero; // latency dependence opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:72,Integrability,depend,dependence,72,// Check if previous best source instruction has a new zero latency; // dependence opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:60,Performance,latency,latency,60,// Check if previous best source instruction has a new zero latency; // dependence opportunity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:49,Energy Efficiency,schedul,scheduling,49,/// True if the target should use Back-Skip-Back scheduling. This is the; /// default for V60.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:41,Energy Efficiency,schedul,scheduler,41,// Always use the TargetLowering default scheduler.; // FIXME: This will use the vliw scheduler which is probably just hurting; // compiler time and will be removed eventually anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:86,Energy Efficiency,schedul,scheduler,86,// Always use the TargetLowering default scheduler.; // FIXME: This will use the vliw scheduler which is probably just hurting; // compiler time and will be removed eventually anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:111,Energy Efficiency,schedul,scheduling,111,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:47,Integrability,depend,dependence,47,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:86,Performance,perform,performed,86,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:39,Energy Efficiency,schedul,scheduler,39,/// True if the subtarget should run a scheduler after register; /// allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:72,Energy Efficiency,schedul,scheduling,72,"/// Enable use of alias analysis during code generation (during MI; /// scheduling, DAGCombine, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:60,Energy Efficiency,schedul,schedule,60,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:74,Integrability,depend,dependency,74,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:4,Performance,Perform,Perform,4,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:47,Performance,latency,latency,47,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h:50,Performance,latency,latency,50,// Helper function responsible for increasing the latency only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:82,Safety,unsafe,unsafe-fp-math,82,"// Append the preexisting target features last, so that +mattr overrides; // the ""unsafe-fp-math"" function attribute.; // Creating a separate target feature is not strictly necessary, it only; // exists to make ""unsafe-fp-math"" force creating a new subtarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:212,Safety,unsafe,unsafe-fp-math,212,"// Append the preexisting target features last, so that +mattr overrides; // the ""unsafe-fp-math"" function attribute.; // Creating a separate target feature is not strictly necessary, it only; // exists to make ""unsafe-fp-math"" force creating a new subtarget.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:32,Deployability,Configurat,Configuration,32,/// Hexagon Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:32,Modifiability,Config,Configuration,32,/// Hexagon Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:10,Testability,log,logical,10,// Create logical operations on predicate registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:19,Security,expose,expose,19,// Rotate loops to expose bit-simplification opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:30,Usability,simpl,simplification,30,// Rotate loops to expose bit-simplification opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:7,Usability,simpl,simplification,7,// Bit simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:95,Deployability,release,release,95,"// TraceGVPlacement controls messages for all builds. For builds with assertions; // (debug or release), messages are also controlled by the usual debug flags; // (e.g. -debug and -debug-only=globallayout)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:29,Integrability,message,messages,29,"// TraceGVPlacement controls messages for all builds. For builds with assertions; // (debug or release), messages are also controlled by the usual debug flags; // (e.g. -debug and -debug-only=globallayout)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:105,Integrability,message,messages,105,"// TraceGVPlacement controls messages for all builds. For builds with assertions; // (debug or release), messages are also controlled by the usual debug flags; // (e.g. -debug and -debug-only=globallayout)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:70,Testability,assert,assertions,70,"// TraceGVPlacement controls messages for all builds. For builds with assertions; // (debug or release), messages are also controlled by the usual debug flags; // (e.g. -debug and -debug-only=globallayout)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:126,Modifiability,variab,variables,126,"// Returns true if the section name is such that the symbol will be put; // in a small data section.; // For instance, global variables with section attributes such as "".sdata""; // "".sdata.*"", "".sbss"", and "".sbss.*"" will go into small data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:15,Modifiability,variab,variables,15,"// Only global variables, not functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:215,Safety,safe,safe,215,"// If the type is a struct with no body provided, treat is conservatively.; // There cannot be actual definitions of object of such a type in this CU; // (only references), so assuming that they are not in sdata is safe. If; // these objects end up in the sdata, the references will still be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:22,Availability,down,down,22,"/// Descends any type down to ""elementary"" components,; /// discovering the smallest addressable one.; /// If zero is returned, declaration will not be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:31,Security,access,access,31,// Assign the smallest element access size to the highest; // value which assembler can handle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:50,Security,access,accessible,50,"// If -mno-sort-sda is not set, find out smallest accessible entity in; // declaration and add it to the section name string.; // Note. It does not track the actual usage of the value, only its de-; // claration. Also, compiler adds explicit pad fields to some struct; // declarations - they are currently counted towards smallest addres-; // sable entity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:3,Security,validat,validate,3,// validate each instance of user to be a live function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:15,Performance,load,loads,15,// Cost of HVX loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:47,Performance,load,loads,47,// Cost of constructing HVX vector from scalar loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:3,Performance,Load,Loads,3,// Loads of less than 32 bits will need extra inserts to compose a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:19,Performance,throughput,throughput,19,// TODO: Allow non-throughput costs that aren't binary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:42,Availability,mask,masked-mem-intrin,42,"// This function is called from scalarize-masked-mem-intrin, which runs; // in pre-isel. Use ST directly instead of calling isHVXVectorType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:42,Availability,mask,masked-mem-intrin,42,"// This function is called from scalarize-masked-mem-intrin, which runs; // in pre-isel. Use ST directly instead of calling isHVXVectorType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:94,Performance,load,load,94,// Only extensions from an integer type shorter than 32-bit to i32; // can be folded into the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp:59,Performance,load,load,59,"// Technically, this code could allow multiple uses of the load, and; // check if all the uses are the same extension operation, but this; // should be sufficient for most cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.h:6,Performance,cache,cache,6,// L1 cache prefetch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:487,Performance,optimiz,optimizations,487,"//===-- HexagonVectorCombine.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // HexagonVectorCombine is a utility class implementing a variety of functions; // that assist in vector-based optimizations.; //; // AlignVectors: replace unaligned vector loads and stores with aligned ones.; // HvxIdioms: recognize various opportunities to generate HVX intrinsic code.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:549,Performance,load,loads,549,"//===-- HexagonVectorCombine.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // HexagonVectorCombine is a utility class implementing a variety of functions; // that assist in vector-based optimizations.; //; // AlignVectors: replace unaligned vector loads and stores with aligned ones.; // HvxIdioms: recognize various opportunities to generate HVX intrinsic code.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:34,Testability,assert,assertions,34,// This function is only used for assertions at the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:47,Performance,load,loads,47,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:106,Performance,load,load,106,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:201,Performance,load,load,201,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:230,Performance,load,load,230,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:313,Performance,load,loaded,313,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:384,Performance,load,loaded,384,"// This code tries to replace unaligned vector loads/stores with aligned; // ones.; // Consider unaligned load:; // %v = original_load %some_addr, align <bad>; // %user = %v; // It will generate; // = load ..., align <good>; // = load ..., align <good>; // = valign; // etc.; // %synthesize = combine/shuffle the loaded data so that it looks; // exactly like what ""original_load"" has loaded.; // %user = %synthesize; // Similarly for stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:11,Integrability,depend,dependencies,11,// List of dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:13,Performance,load,load,13,// Is this a load group?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:109,Performance,load,loaded,109,"// A representation of ""interesting"" bytes within a given span of memory.; // These bytes are those that are loaded or stored, and they don't have; // to cover the entire span of memory.; //; // The representation works by picking a contiguous sequence of bytes; // from somewhere within a llvm::Value, and placing it at a given offset; // within the span.; //; // The sequence of bytes from llvm:Value is represented by Segment.; // Block is Segment, plus where it goes in the span.; //; // An important feature of ByteSpan is being able to make a ""section"",; // i.e. creating another ByteSpan corresponding to a range of offsets; // relative to the source span.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:34,Testability,assert,assertions,34,// This function is only used for assertions at the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:71,Availability,error,error,71,"// VS2017 and some versions of VS2019 have trouble compiling this:; // error C2976: 'std::map': too few template arguments; // VS 2019 16.x is known to work, except for 16.4/16.5 (MSC_VER 1924/1925)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:71,Performance,load,loads,71,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:101,Performance,load,loads,101,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:255,Performance,load,loads,255,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:392,Performance,load,loads,392,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:408,Performance,load,load,408,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:446,Performance,load,loads,446,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:452,Performance,load,loaded,452,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:495,Performance,load,loaded,495,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:533,Performance,load,loads,533,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:604,Performance,load,loads,604,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:658,Performance,load,load,658,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:667,Performance,load,load,667,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:905,Performance,load,load,905,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:921,Performance,load,load,921,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1069,Performance,load,loads,1069,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1248,Performance,load,loaded,1248,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1266,Performance,load,loads,1266,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1295,Performance,load,load,1295,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1325,Performance,load,load,1325,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1421,Performance,load,loaded,1421,"// namespace; // --- Begin AlignVectors; // For brevity, only consider loads. We identify a group of loads where we; // know the relative differences between their addresses, so we know how they; // are laid out in memory (relative to one another). These loads can overlap,; // can be shorter or longer than the desired vector length.; // Ultimately we want to generate a sequence of aligned loads that will load; // every byte that the original loads loaded, and have the program use these; // loaded values instead of the original loads.; // We consider the contiguous memory area spanned by all these loads.; //; // Let's say that a single aligned vector load can load 16 bytes at a time.; // If the program wanted to use a byte at offset 13 from the beginning of the; // original span, it will be a byte at offset 13+x in the aligned data for; // some x>=0. This may happen to be in the first aligned load, or in the load; // following it. Since we generally don't know what the that alignment value; // is at compile time, we proactively do valigns on the aligned loads, so that; // byte that was at offset 13 is still at offset 13 after the valigns.; //; // This will be the starting point for making the rest of the program use the; // data loaded by the new loads.; // For each original load, and its users:; // %v = load ...; // ... = %v; // ... = %v; // we create; // %new_v = extract/combine/shuffle data from loaded/valigned vectors so; // it contains the same value as %v did before; // then replace all users of %v with %new_v.; // ... = %new_v; // ... = %new_v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:51,Performance,load,load,51,// Predicate is nullptr if not creating predicated load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:27,Availability,Mask,Mask,27,// Here both Predicate and Mask are true or unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Availability,Mask,Mask,3,// Mask is unknown,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:22,Availability,Mask,Mask,22,// Both Predicate and Mask are unknown.; // Emulate masked store with predicated-load + mux + predicated-store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:52,Availability,mask,masked,52,// Both Predicate and Mask are unknown.; // Emulate masked store with predicated-load + mux + predicated-store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:81,Performance,load,load,81,// Both Predicate and Mask are unknown.; // Emulate masked store with predicated-load + mux + predicated-store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:8,Performance,load,load,8,"// Form load groups.; // To avoid complications with moving code across basic blocks, only form; // groups that are contained within a single basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:28,Safety,avoid,avoid,28,"// Form load groups.; // To avoid complications with moving code across basic blocks, only form; // groups that are contained within a single basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:30,Performance,load,load,30,// Leading instruction in the load group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:34,Performance,load,load,34,// Check if it's safe to move the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:33,Integrability,depend,dependencies,33,// And if it's safe to clone the dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:15,Safety,safe,safe,15,// And if it's safe to clone the dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:67,Performance,load,loads,67,// Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:29,Safety,avoid,avoid,29,"// Form store groups.; // To avoid complications with moving code across basic blocks, only form; // groups that are contained within a single basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:54,Availability,down,downward,54,"// For stores with return values we'd have to collect downward depenencies.; // There are no such stores that we handle at the moment, so omit that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:49,Safety,safe,safe,49,// For stores we need to be careful whether it's safe to move them.; // Stores that are otherwise safe to move together may not appear safe; // to move over one another (i.e. isSafeToMoveBefore may return false).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:98,Safety,safe,safe,98,// For stores we need to be careful whether it's safe to move them.; // Stores that are otherwise safe to move together may not appear safe; // to move over one another (i.e. isSafeToMoveBefore may return false).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:135,Safety,safe,safe,135,// For stores we need to be careful whether it's safe to move them.; // Stores that are otherwise safe to move together may not appear safe; // to move over one another (i.e. isSafeToMoveBefore may return false).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:67,Performance,load,loads,67,// Erase HVX groups on targets < HvxV62 (due to lack of predicated loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:150,Energy Efficiency,efficient,efficient,150,// Erase groups where every store is a full HVX vector. The reason is that; // aligning predicated stores generates complex code that may be less; // efficient than a sequence of unaligned vector stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:27,Integrability,depend,dependencies,27,"// Move all the loads (and dependencies) to where the first load is.; // Clone all deps to before Where, keeping order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:16,Performance,load,loads,16,"// Move all the loads (and dependencies) to where the first load is.; // Clone all deps to before Where, keeping order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:60,Performance,load,load,60,"// Move all the loads (and dependencies) to where the first load is.; // Clone all deps to before Where, keeping order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:11,Performance,load,load,11,"// Created load does not have to be ""Instruction"" (e.g. ""undef"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:38,Performance,load,loads,38,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:103,Performance,load,load,103,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:123,Performance,load,load,123,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:217,Performance,load,loads,217,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:261,Performance,load,loads,261,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:419,Performance,load,loads,419,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:472,Performance,load,loads,472,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:554,Performance,load,loads,554,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:593,Performance,load,loads,593,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:774,Performance,load,load,774,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1240,Safety,avoid,avoid,1240,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:93,Performance,load,loads,93,"// Multiple values from VSpan can map to the same value in ASpan. Since we; // try to create loads lazily, we need to find the earliest use for each; // value from ASpan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:173,Performance,load,loads,173,"// Make sure we only consider users in this block, but we need; // to remember if there were users outside the block too. This is; // because if no users are found, aligned loads will not be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:103,Performance,load,load,103,"// If vector shifting is potentially needed, accumulate metadata; // from source sections of twice the load width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:26,Integrability,depend,dependencies,26,// Move In and its upward dependencies to before To.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:22,Performance,load,loads,22,// Generate necessary loads at appropriate locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:56,Performance,load,load,56,"// In ASpan, each block will be either a single aligned load, or a; // valign of a pair of loads. In the latter case, an aligned load j; // will belong to the current valign, and the one in the previous; // block (for j > 0).; // Place the load at a location which will dominate the valign, assuming; // the valign will be placed right before the earliest user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:91,Performance,load,loads,91,"// In ASpan, each block will be either a single aligned load, or a; // valign of a pair of loads. In the latter case, an aligned load j; // will belong to the current valign, and the one in the previous; // block (for j > 0).; // Place the load at a location which will dominate the valign, assuming; // the valign will be placed right before the earliest user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:129,Performance,load,load,129,"// In ASpan, each block will be either a single aligned load, or a; // valign of a pair of loads. In the latter case, an aligned load j; // will belong to the current valign, and the one in the previous; // block (for j > 0).; // Place the load at a location which will dominate the valign, assuming; // the valign will be placed right before the earliest user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:240,Performance,load,load,240,"// In ASpan, each block will be either a single aligned load, or a; // valign of a pair of loads. In the latter case, an aligned load j; // will belong to the current valign, and the one in the previous; // block (for j > 0).; // Place the load at a location which will dominate the valign, assuming; // the valign will be placed right before the earliest user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:32,Performance,load,load,32,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:105,Performance,load,load,105,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:236,Performance,load,load,236,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:331,Performance,load,load,331,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:16,Safety,safe,safe,16,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:113,Safety,safe,safe,113,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:187,Safety,safe,safe,187,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:56,Integrability,depend,depends,56,"// We're generating a reduction, where each instruction depends on; // the previous one, so we need to order them according to the position; // of their inputs in the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:101,Availability,avail,available,101,// The processing of the data loaded by the aligned loads; // needs to be inserted after the data is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:30,Performance,load,loaded,30,// The processing of the data loaded by the aligned loads; // needs to be inserted after the data is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:52,Performance,load,loads,52,// The processing of the data loaded by the aligned loads; // needs to be inserted after the data is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:139,Availability,mask,masks,139,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:190,Availability,mask,mask,190,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:242,Availability,mask,mask,242,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:308,Availability,mask,mask,308,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:106,Safety,avoid,avoid,106,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:27,Availability,mask,masked,27,"// TODO: Needs support for masked loads/stores of ""scalar"" vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:34,Performance,load,loads,34,"// TODO: Needs support for masked loads/stores of ""scalar"" vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:547,Availability,down,down-aligned,547,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:594,Availability,down,down-alignment,594,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:261,Performance,load,loaded,261,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:509,Performance,load,loaded,509,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:199,Security,access,accessed,199,"// Conceptually, there is a vector of N bytes covering the addresses; // starting from the minimum offset (i.e. Base.Addr+Start). This vector; // represents a contiguous memory region that spans all accessed memory; // locations.; // The correspondence between loaded or stored values will be expressed; // in terms of this vector. For example, the 0th element of the vector; // from the Base address info will start at byte Start from the beginning; // of this conceptual vector.; //; // This vector will be loaded/stored starting at the nearest down-aligned; // address and the amount od the down-alignment will be AlignVal:; // valign(load_vector(align_down(Base+Start)), AlignVal)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:54,Performance,load,load,54,"// Set the builder's insertion point right before the load group, or; // immediately after the store group. (Instructions in a store group are; // listed in reverse order.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:294,Usability,simpl,simple,294,// Shift the offset of the maximally aligned instruction (OffAtMax); // back by just enough multiples of the required alignment to cover the; // distance from Start to OffAtMax.; // Calculate the address adjustment amount based on the address with the; // maximum alignment. This is to allow a simple gep instruction instead; // of potential bitcasts to i8*.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:167,Availability,mask,mask,167,"// WithMinOffset is the lowest address in the group,; // WithMinOffset.Addr = Base+Start.; // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb); // mask off unnecessary bits, so it's ok to just the original pointer as; // the alignment amount.; // Do an explicit down-alignment of the address to avoid creating an; // aligned instruction with an address that is not really aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:282,Availability,down,down-alignment,282,"// WithMinOffset is the lowest address in the group,; // WithMinOffset.Addr = Base+Start.; // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb); // mask off unnecessary bits, so it's ok to just the original pointer as; // the alignment amount.; // Do an explicit down-alignment of the address to avoid creating an; // aligned instruction with an address that is not really aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:315,Safety,avoid,avoid,315,"// WithMinOffset is the lowest address in the group,; // WithMinOffset.Addr = Base+Start.; // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb); // mask off unnecessary bits, so it's ok to just the original pointer as; // the alignment amount.; // Do an explicit down-alignment of the address to avoid creating an; // aligned instruction with an address that is not really aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:15,Performance,load,loads,15,"// The aligned loads/stores will use blocks that are either scalars,; // or HVX vectors. Let ""sector"" be the unified term for such a block.; // blend(scalar, vector) -> sector...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:102,Modifiability,extend,extended,102,"// The significant bits are calculated including the sign bit. This may; // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may; // result in 33 significant bits. To avoid extra words, skip the extra; // sign bit, but keep information that the value is to be treated as; // unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:184,Safety,avoid,avoid,184,"// The significant bits are calculated including the sign bit. This may; // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may; // result in 33 significant bits. To avoid extra words, skip the extra; // sign bit, but keep information that the value is to be treated as; // unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:26,Testability,test,test,26,// Number of bits used in test for unsignedness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:33,Energy Efficiency,power,power-of-,33,"// If the top bit of the nearest power-of-2 is zero, this value is; // positive. It could be treated as either signed or unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:33,Energy Efficiency,power,power,33,"// If the element width is not a power of 2, round it up; // to the next one. Do this for widths not exceeding 32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:99,Performance,perform,perform,99,"// Since there may have been some undefs appended to make shuffle operands; // have the same type, perform the last shuffle to only pick the original; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Modifiability,Extend,Extend,3,// Extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Availability,Mask,Mask,3,"// Mask is a vector <N x i1>, where each element corresponds to an; // element of FromTy. Remap it so that each element will correspond; // to an element of ToTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:3,Availability,Mask,Mask,3,// Mask <N x i1> -> sext to <N x FromTy> -> bitcast to <M x ToTy> ->; // -> trunc to <M x i1>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:2,Performance,Scalab,Scalable,2,/*Scalable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:39,Energy Efficiency,power,power-of-,39,"// If the list of values does not have power-of-2 elements, append copies; // of the sign bit to it, to make the size be 2^n.; // The reason for this is that the values will be joined in pairs, because; // otherwise the shuffles will result in convoluted code. With pairwise; // joins, the shuffles will hopefully be folded into a perfect shuffle.; // The output will need to be sign-extended to a type with element width; // being a power-of-2 anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:434,Energy Efficiency,power,power-of-,434,"// If the list of values does not have power-of-2 elements, append copies; // of the sign bit to it, to make the size be 2^n.; // The reason for this is that the values will be joined in pairs, because; // otherwise the shuffles will result in convoluted code. With pairwise; // joins, the shuffles will hopefully be folded into a perfect shuffle.; // The output will need to be sign-extended to a type with element width; // being a power-of-2 anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:384,Modifiability,extend,extended,384,"// If the list of values does not have power-of-2 elements, append copies; // of the sign bit to it, to make the size be 2^n.; // The reason for this is that the values will be joined in pairs, because; // otherwise the shuffles will result in convoluted code. With pairwise; // joins, the shuffles will hopefully be folded into a perfect shuffle.; // The output will need to be sign-extended to a type with element width; // being a power-of-2 anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:59,Integrability,wrap,wrap-around,59,"// Having too many inputs is ok: drop the high bits (usual wrap-around).; // If there are too few, fill them with the sign bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:17,Usability,simpl,simplify,17,"// First, try to simplify the subtraction directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:429,Availability,redundant,redundant,429,"//===- HexagonVectorLoopCarriedReuse.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:570,Integrability,depend,dependences,570,"//===- HexagonVectorLoopCarriedReuse.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:429,Safety,redund,redundant,429,"//===- HexagonVectorLoopCarriedReuse.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:73,Performance,perform,performs,73,"// For each interesting use I of PN, find an Instruction BEUser that; // performs the same operation as I on BEInst and whose other operands,; // if any, can also be rematerialized in OtherBB. We stop when we find the; // first such Instruction BEUser. This is because once BEUser is; // rematerialized in OtherBB, we may find more such ""fixup"" opportunities; // in this block. So, we'll start over again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:116,Safety,safe,safe,116,"// We are in LCSSA form. So, a value defined inside the Loop is used only; // inside the loop. So, the following is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:429,Availability,redundant,redundant,429,"//===- HexagonVectorLoopCarriedReuse.h ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //-----------------------------------------------------------------------------; // Motivation: Consider the case where we have the following loop structure.; //; // Loop:; // t0 = a[i];; // t1 = f(t0);; // t2 = g(t1);; // ...; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:570,Integrability,depend,dependences,570,"//===- HexagonVectorLoopCarriedReuse.h ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //-----------------------------------------------------------------------------; // Motivation: Consider the case where we have the following loop structure.; //; // Loop:; // t0 = a[i];; // t1 = f(t0);; // t2 = g(t1);; // ...; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:1800,Integrability,depend,dependence,1800," // Loop:; // t0 = a[i];; // t1 = f(t0);; // t2 = g(t1);; // ...; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:1848,Integrability,depend,dependence,1848,";; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find an",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:2969,Integrability,depend,dependences,2969,"de long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find any more such instructions I1 and I2.; //; // --- DepChains & Loop carried dependences ---; // Consider a single basic block loop such as; //; // LoopPreheader:; // X0 = ...; // Y0 = ...; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (X2, Loop)>; // ...; // X1 = ...; // ...; // cond_branch <Loop>; //; // Then there is a dependence between X2 and X1 that goes back one iteration,; // i.e. X1 is used as X2 in the very next iteration. We represent this as a; // DepChain from X2 to X1 (X2->X1).; // Similarly, there is a dependence between Y2 and X1 that goes back two; // iterations. X1 is used as Y2 two iterations after it is computed. This is; // represented by a DepChain as (Y2->X2->X1).; //; // A DepChain has the following properties.; // 1. Num of edges in DepChain = Number of Instructions in DepChain = Number of; // iterations of carried dependence + 1.; // 2. All instructions in the DepChain except the last are PHIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:3259,Integrability,depend,dependence,3259,"de long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find any more such instructions I1 and I2.; //; // --- DepChains & Loop carried dependences ---; // Consider a single basic block loop such as; //; // LoopPreheader:; // X0 = ...; // Y0 = ...; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (X2, Loop)>; // ...; // X1 = ...; // ...; // cond_branch <Loop>; //; // Then there is a dependence between X2 and X1 that goes back one iteration,; // i.e. X1 is used as X2 in the very next iteration. We represent this as a; // DepChain from X2 to X1 (X2->X1).; // Similarly, there is a dependence between Y2 and X1 that goes back two; // iterations. X1 is used as Y2 two iterations after it is computed. This is; // represented by a DepChain as (Y2->X2->X1).; //; // A DepChain has the following properties.; // 1. Num of edges in DepChain = Number of Instructions in DepChain = Number of; // iterations of carried dependence + 1.; // 2. All instructions in the DepChain except the last are PHIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:3458,Integrability,depend,dependence,3458,"de long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find any more such instructions I1 and I2.; //; // --- DepChains & Loop carried dependences ---; // Consider a single basic block loop such as; //; // LoopPreheader:; // X0 = ...; // Y0 = ...; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (X2, Loop)>; // ...; // X1 = ...; // ...; // cond_branch <Loop>; //; // Then there is a dependence between X2 and X1 that goes back one iteration,; // i.e. X1 is used as X2 in the very next iteration. We represent this as a; // DepChain from X2 to X1 (X2->X1).; // Similarly, there is a dependence between Y2 and X1 that goes back two; // iterations. X1 is used as Y2 two iterations after it is computed. This is; // represented by a DepChain as (Y2->X2->X1).; //; // A DepChain has the following properties.; // 1. Num of edges in DepChain = Number of Instructions in DepChain = Number of; // iterations of carried dependence + 1.; // 2. All instructions in the DepChain except the last are PHIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:3787,Integrability,depend,dependence,3787,"de long.; //; // Then, we traverse the uses of the PHI (X2) and the uses of the value of the; // PHI coming over the backedge (X1). We stop at the first pair of such users; // I1 (of X2) and I2 (of X1) that meet the following conditions.; // 1. I1 and I2 are the same operation, but with different operands.; // 2. X2 and X1 are used at the same operand number in the two instructions.; // 3. All other operands Op1 of I1 and Op2 of I2 are also such that there is a; // a DepChain from Op1 to Op2 of the same length as that between X2 and X1.; //; // We then make the following transformation; // LoopPreheader:; // X0 = a[0];; // Y0 = f(X0);; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (t4, Loop)>; // t1 = f(X2) <-- Will be removed by DCE.; // t2 = g(Y2); // ...; // X1 = a[i+1]; // t4 = f(X1); // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // We proceed until we cannot find any more such instructions I1 and I2.; //; // --- DepChains & Loop carried dependences ---; // Consider a single basic block loop such as; //; // LoopPreheader:; // X0 = ...; // Y0 = ...; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // Y2 = PHI<(Y0, LoopPreheader), (X2, Loop)>; // ...; // X1 = ...; // ...; // cond_branch <Loop>; //; // Then there is a dependence between X2 and X1 that goes back one iteration,; // i.e. X1 is used as X2 in the very next iteration. We represent this as a; // DepChain from X2 to X1 (X2->X1).; // Similarly, there is a dependence between Y2 and X1 that goes back two; // iterations. X1 is used as Y2 two iterations after it is computed. This is; // represented by a DepChain as (Y2->X2->X1).; //; // A DepChain has the following properties.; // 1. Num of edges in DepChain = Number of Instructions in DepChain = Number of; // iterations of carried dependence + 1.; // 2. All instructions in the DepChain except the last are PHIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h:429,Safety,redund,redundant,429,"//===- HexagonVectorLoopCarriedReuse.h ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass removes the computation of provably redundant expressions that have; // been computed earlier in a previous iteration. It relies on the use of PHIs; // to identify loop carried dependences. This is scalar replacement for vector; // types.; //; //-----------------------------------------------------------------------------; // Motivation: Consider the case where we have the following loop structure.; //; // Loop:; // t0 = a[i];; // t1 = f(t0);; // t2 = g(t1);; // ...; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // cond_branch <Loop>; //; // This can be converted to; // t00 = a[0];; // t10 = f(t00);; // t20 = g(t10);; // Loop:; // t2 = t20;; // t3 = a[i+1];; // t4 = f(t3);; // t5 = g(t4);; // t6 = op(t2, t5); // t20 = t5; // cond_branch <Loop>; //; // SROA does a good job of reusing a[i+1] as a[i] in the next iteration.; // Such a loop comes to this pass in the following form.; //; // LoopPreheader:; // X0 = a[0];; // Loop:; // X2 = PHI<(X0, LoopPreheader), (X1, Loop)>; // t1 = f(X2) <-- I1; // t2 = g(t1); // ...; // X1 = a[i+1]; // t4 = f(X1) <-- I2; // t5 = g(t4); // t6 = op(t2, t5); // cond_branch <Loop>; //; // In this pass, we look for PHIs such as X2 whose incoming values come only; // from the Loop Preheader and over the backedge and additionaly, both these; // values are the results of the same operation in terms of opcode. We call such; // a PHI node a dependence chain or DepChain. In this case, the dependence of X2; // over X1 is carried over only one iteration and so the DepChain is only one; // PHI node long.; //; // Then, we traverse the uses of ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorPrint.cpp:7,Performance,load,load,7,// Vec load or compute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorPrint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorPrint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:520,Performance,load,loads,520,"//===- HexagonVExtract.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass will replace multiple occurrences of V6_extractw from the same; // vector register with a combination of a vector store and scalar loads.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:3,Usability,Simpl,Simplified,3,// Simplified check for a compile-time constant value of ExtIdxR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:227,Availability,avail,available,227,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:86,Modifiability,variab,variable-sized,86,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:260,Performance,load,load,260,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:140,Security,access,accessible,140,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:3,Deployability,Update,Update,3,// Update the required stack alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:583,Availability,avail,available,583,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:645,Integrability,depend,depends,645,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:707,Integrability,depend,dependency,707,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:809,Integrability,depend,dependency,809,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:873,Integrability,depend,dependence,873,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:401,Usability,simpl,simple,401,"//===- HexagonPacketizer.cpp - VLIW packetizer ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a simple VLIW packetizer using DFA. The packetizer works on; // machine basic blocks. For each instruction I in BB, the packetizer consults; // the DFA to see if machine resources are available to execute I. If so, the; // packetizer checks if I depends on any instruction J in the current packet.; // If no dependency is found, I is added to current packet and machine resource; // is marked as taken. If any dependency is found, a target API call is made to; // prune the dependence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:99,Usability,simpl,simply,99,"// If it's not bundled with the successor (i.e. it is the last one; // in the bundle), then we can simply unbundle it from the predecessor,; // which will take care of updating the predecessor's flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:38,Testability,assert,asserting,38,// Get the size of the bundle without asserting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:40,Availability,failure,failures,40,// FIXME: This pass causes verification failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:101,Integrability,depend,dependence,101,"// Loop over all basic blocks and remove KILL pseudo-instructions; // These instructions confuse the dependence analysis. Consider:; // D0 = ... (Insn 0); // R0 = KILL R0, D0 (Insn 1); // R0 = ... (Insn 2); // Here, Insn 1 will result in the dependence graph not emitting an output; // dependence between Insn 0 and Insn 2. This can lead to incorrect; // packetization",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:242,Integrability,depend,dependence,242,"// Loop over all basic blocks and remove KILL pseudo-instructions; // These instructions confuse the dependence analysis. Consider:; // D0 = ... (Insn 0); // R0 = KILL R0, D0 (Insn 1); // R0 = ... (Insn 2); // Here, Insn 1 will result in the dependence graph not emitting an output; // dependence between Insn 0 and Insn 2. This can lead to incorrect; // packetization",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:286,Integrability,depend,dependence,286,"// Loop over all basic blocks and remove KILL pseudo-instructions; // These instructions confuse the dependence analysis. Consider:; // D0 = ... (Insn 0); // R0 = KILL R0, D0 (Insn 1); // R0 = ... (Insn 2); // Here, Insn 1 will result in the dependence graph not emitting an output; // dependence between Insn 0 and Insn 2. This can lead to incorrect; // packetization",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:69,Energy Efficiency,schedul,scheduling,69,// Find the first non-boundary starting from the end of the last; // scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:11,Energy Efficiency,schedul,scheduling,11,// Add the scheduling boundary if it's not block end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:36,Modifiability,extend,extender,36,// Reserve resources for a constant extender. Trigger an assertion if the; // reservation fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:57,Testability,assert,assertion,57,// Reserve resources for a constant extender. Trigger an assertion if the; // reservation fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate resources (i.e. 4 bytes) for constant extender. If succeeded,; // return true, otherwise, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:50,Modifiability,extend,extender,50,"// Allocate resources (i.e. 4 bytes) for constant extender. If succeeded,; // return true, otherwise, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:16,Integrability,depend,dependence,16,// Check for LR dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:117,Performance,load,load,117,// Check for existing uses of a vector register within the packet which; // would be affected by converting a vector load into .cur formt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:26,Deployability,update,update,26,/// Return true if we can update the offset in MI so that MI and MJ; /// can be packetized together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:22,Integrability,depend,dependences,22,"// Make sure that the dependences do not restrict adding MI to the packet.; // That is, ignore anti dependences, and make sure the only data dependence; // involves the specific register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:100,Integrability,depend,dependences,100,"// Make sure that the dependences do not restrict adding MI to the packet.; // That is, ignore anti dependences, and make sure the only data dependence; // involves the specific register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:141,Integrability,depend,dependence,141,"// Make sure that the dependences do not restrict adding MI to the packet.; // That is, ignore anti dependences, and make sure the only data dependence; // involves the specific register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:4,Usability,Undo,Undo,4,/// Undo the changed offset. This is needed if the instruction cannot be; /// added to the current packet due to a different instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:59,Performance,load,load,59,// The 2nd operand is always the post increment operand in load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:22,Integrability,depend,dependency,22,// Make sure there is dependency and can be new value'd.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:428,Performance,perform,perform,428,"// Make sure that other than the new-value register no other store instruction; // register has been modified in the same packet. Predicate registers can be; // modified by they should not be modified between the producer and the store; // instruction as it will make them both conditional on different values.; // We already know this to be true for all the instructions before and; // including PacketMI. Howerver, we need to perform the check for the; // remaining instructions in the packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:39,Integrability,depend,dependence,39,// We don't want to check PacketMI for dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:6,Integrability,depend,dependency,6,"// If dependency is trough an implicitly defined register, we should not; // newify the use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:71,Energy Efficiency,allocate,allocated,71,"// Create a dot new machine instruction to see if resources can be; // allocated. If not, bail out now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:61,Integrability,depend,dependency,61,"// Go through the packet instructions and search for an anti dependency between; // them and DepReg from MI. Consider this case:; // Trying to add; // a) %r1 = TFRI_cdNotPt %p3, 2; // to this packet:; // {; // b) %p0 = C2_or killed %p3, killed %p0; // c) %p3 = C2_tfrrp %r23; // d) %r1 = C2_cmovenewit %p3, 4; // }; // The P3 from a) and d) will be complements after; // a)'s P3 is converted to .new form; // Anti-dep between c) and b) is irrelevant for this case",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:20,Integrability,depend,dependencies,20,// We only care for dependencies to predicated instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling Unit for current insn in the packet,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:11,Integrability,depend,dependencies,11,// Look at dependencies between current members of the packet and; // predicate defining instruction MI. Make sure that dependency is; // on the exact register we care about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:120,Integrability,depend,dependency,120,// Look at dependencies between current members of the packet and; // predicate defining instruction MI. Make sure that dependency is; // on the exact register we care about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:52,Safety,detect,detects,52,"// Given two predicated instructions, this function detects whether; // the predicates are complements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling unit for candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:387,Integrability,depend,dependencies,387,"// One corner case deals with the following scenario:; // Trying to add; // a) %r24 = A2_tfrt %p0, %r25; // to this packet:; // {; // b) %r25 = A2_tfrf %p0, %r24; // c) %p0 = C2_cmpeqi %r26, 1; // }; //; // On general check a) and b) are complements, but presence of c) will; // convert a) to .new form, and then it is not a complement.; // We attempt to detect it by analyzing existing dependencies in the packet.; // Analyze relationships between all existing members of the packet.; // Look for Anti dependecy on the same predicate reg as used in the; // candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:503,Integrability,depend,dependecy,503,"// One corner case deals with the following scenario:; // Trying to add; // a) %r24 = A2_tfrt %p0, %r25; // to this packet:; // {; // b) %r25 = A2_tfrf %p0, %r24; // c) %p0 = C2_cmpeqi %r26, 1; // }; //; // On general check a) and b) are complements, but presence of c) will; // convert a) to .new form, and then it is not a complement.; // We attempt to detect it by analyzing existing dependencies in the packet.; // Analyze relationships between all existing members of the packet.; // Look for Anti dependecy on the same predicate reg as used in the; // candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:355,Safety,detect,detect,355,"// One corner case deals with the following scenario:; // Trying to add; // a) %r24 = A2_tfrt %p0, %r25; // to this packet:; // {; // b) %r25 = A2_tfrf %p0, %r24; // c) %p0 = C2_cmpeqi %r26, 1; // }; //; // On general check a) and b) are complements, but presence of c) will; // convert a) to .new form, and then it is not a complement.; // We attempt to detect it by analyzing existing dependencies in the packet.; // Analyze relationships between all existing members of the packet.; // Look for Anti dependecy on the same predicate reg as used in the; // candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling Unit for current insn in the packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:49,Integrability,depend,dependency,49,"// The corner case exist when there is true data dependency between; // candidate and one of current packet members, this dep is on; // predicate reg, and there already exist anti dep on the same pred in; // the packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:190,Integrability,depend,dependency,190,// Here I know that I is predicate setting instruction with true; // data dep to candidate on the register we care about - c) in the; // above example. Now I need to see if there is an anti dependency; // from c) to any other instruction in the same packet on the pred; // reg of interest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:243,Energy Efficiency,reduce,reduce,243,"// Consider inline asm to not be a solo instruction by default.; // Inline asm will be put in a packet temporarily, but then it will be; // removed, and placed outside of the packet (before or after, depending; // on dependencies). This is to reduce the impact of inline asm as a; // ""packet splitting"" instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:200,Integrability,depend,depending,200,"// Consider inline asm to not be a solo instruction by default.; // Inline asm will be put in a packet temporarily, but then it will be; // removed, and placed outside of the packet (before or after, depending; // on dependencies). This is to reduce the impact of inline asm as a; // ""packet splitting"" instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:217,Integrability,depend,dependencies,217,"// Consider inline asm to not be a solo instruction by default.; // Inline asm will be put in a packet temporarily, but then it will be; // removed, and placed outside of the packet (before or after, depending; // on dependencies). This is to reduce the impact of inline asm as a; // ""packet splitting"" instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:90,Testability,test,tests,90,"// Quick check if instructions MI and MJ cannot coexist in the same packet.; // Limit the tests to be ""one-way"", e.g. ""if MI->isBranch and MJ->isInlineAsm"",; // but not the symmetric case: ""if MJ->isBranch and MI->isInlineAsm"".; // For full test call this function twice:; // cannotCoexistAsymm(MI, MJ) || cannotCoexistAsymm(MJ, MI); // Doing the test only one way saves the amount of code in this function,; // since every test would need to be repeated with the MI and MJ reversed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:241,Testability,test,test,241,"// Quick check if instructions MI and MJ cannot coexist in the same packet.; // Limit the tests to be ""one-way"", e.g. ""if MI->isBranch and MJ->isInlineAsm"",; // but not the symmetric case: ""if MJ->isBranch and MI->isInlineAsm"".; // For full test call this function twice:; // cannotCoexistAsymm(MI, MJ) || cannotCoexistAsymm(MJ, MI); // Doing the test only one way saves the amount of code in this function,; // since every test would need to be repeated with the MI and MJ reversed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:347,Testability,test,test,347,"// Quick check if instructions MI and MJ cannot coexist in the same packet.; // Limit the tests to be ""one-way"", e.g. ""if MI->isBranch and MJ->isInlineAsm"",; // but not the symmetric case: ""if MJ->isBranch and MI->isInlineAsm"".; // For full test call this function twice:; // cannotCoexistAsymm(MI, MJ) || cannotCoexistAsymm(MJ, MI); // Doing the test only one way saves the amount of code in this function,; // since every test would need to be repeated with the MI and MJ reversed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:424,Testability,test,test,424,"// Quick check if instructions MI and MJ cannot coexist in the same packet.; // Limit the tests to be ""one-way"", e.g. ""if MI->isBranch and MJ->isInlineAsm"",; // but not the symmetric case: ""if MJ->isBranch and MI->isInlineAsm"".; // For full test call this function twice:; // cannotCoexistAsymm(MI, MJ) || cannotCoexistAsymm(MJ, MI); // Doing the test only one way saves the amount of code in this function,; // since every test would need to be repeated with the MI and MJ reversed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:217,Safety,avoid,avoid,217,"// An inline asm cannot be together with a branch, because we may not be; // able to remove the asm out after packetizing (i.e. if the asm must be; // moved past the bundle). Similarly, two asms cannot be together to avoid; // complications when determining their relative order outside of a bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:158,Integrability,depend,depends,158,"// Decide on where to insert the instruction that we are pulling out.; // Debug instructions always go before the bundle, but the placement of; // INLINE_ASM depends on potential dependencies. By default, try to; // put it before the bundle, but if the asm writes to a register that; // other instructions in the bundle read, then we need to place it; // after the bundle (to preserve the bundle semantics).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:179,Integrability,depend,dependencies,179,"// Decide on where to insert the instruction that we are pulling out.; // Debug instructions always go before the bundle, but the placement of; // INLINE_ASM depends on potential dependencies. By default, try to; // put it before the bundle, but if the asm writes to a register that; // other instructions in the bundle read, then we need to place it; // after the bundle (to preserve the bundle semantics).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:7,Integrability,depend,dependence,7,"// The dependence graph may not include edges between dead definitions,; // so without extra checks, we could end up packetizing two instruction; // defining the same (dead) register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:74,Energy Efficiency,schedul,scheduling,74,"// Adding I to a packet that has J.; // Regmasks are not reflected in the scheduling dependency graph, so; // we need to check them manually. This code assumes that regmasks only; // occur on calls, and the problematic case is when we add an instruction; // defining a register R to a packet that has a call that clobbers R via; // a regmask. Those cannot be packetized together, because the call will; // be executed last. That's also a reson why it is ok to add a call; // clobbering R to a packet that defines R.; // Look for regmasks in J.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:85,Integrability,depend,dependency,85,"// Adding I to a packet that has J.; // Regmasks are not reflected in the scheduling dependency graph, so; // we need to check them manually. This code assumes that regmasks only; // occur on calls, and the problematic case is when we add an instruction; // defining a register R to a packet that has a call that clobbers R via; // a regmask. Those cannot be packetized together, because the call will; // be executed last. That's also a reson why it is ok to add a call; // clobbering R to a packet that defines R.; // Look for regmasks in J.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Usability,Clear,Clear,3,// Clear IgnoreDepMIs when Packet starts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:41,Energy Efficiency,schedul,scheduling,41,"// Regmasks are not accounted for in the scheduling graph, so we need; // to explicitly check for dependencies caused by them. They should only; // appear on calls, so it's not too pessimistic to reject all regmask; // dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:98,Integrability,depend,dependencies,98,"// Regmasks are not accounted for in the scheduling graph, so we need; // to explicitly check for dependencies caused by them. They should only; // appear on calls, so it's not too pessimistic to reject all regmask; // dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:219,Integrability,depend,dependencies,219,"// Regmasks are not accounted for in the scheduling graph, so we need; // to explicitly check for dependencies caused by them. They should only; // appear on calls, so it's not too pessimistic to reject all regmask; // dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Security,Validat,Validate,3,"// Validate:; // 1. Packet does not have a store in it.; // 2. If the first operand of the nvj is newified, and the second; // operand is also a reg, it (second reg) is not defined in; // the same packet.; // 3. If the second operand of the nvj is newified, (which means; // first operand is also a reg), first reg is not defined in; // the same packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:12,Integrability,depend,dependency,12,// There no dependency between a prolog instruction and its successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:41,Integrability,depend,dependences,41,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:229,Integrability,depend,dependences,229,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:323,Integrability,depend,dependences,323,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:399,Integrability,depend,dependences,399,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:481,Integrability,depend,dependencies,481,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:32,Performance,load,load,32,// Data dpendence ok if we have load.cur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:91,Integrability,depend,dependence,91,"// For predicated instructions, if the predicates are complements then; // there can be no dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:71,Energy Efficiency,reduce,reduce,71,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:78,Integrability,depend,dependence,78,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:126,Integrability,depend,dependencies,126,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:268,Integrability,depend,dependence,268,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:335,Integrability,depend,dependence,335,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:444,Integrability,depend,dependce,444,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:14,Safety,safe,safe,14,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:470,Safety,avoid,avoid,470,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:16,Integrability,depend,dependences,16,// Ignore Order dependences between unconditional direct branches; // and non-control-flow instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:14,Integrability,depend,dependences,14,// Ignore all dependences for jumps except for true and output; // dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:67,Integrability,depend,dependences,67,// Ignore all dependences for jumps except for true and output; // dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:13,Integrability,depend,dependences,13,"// For Order dependences:; // 1. Volatile loads/stores can be packetized together, unless other; // rules prevent is.; // 2. Store followed by a load is not allowed.; // 3. Store followed by a store is valid.; // 4. Load followed by any memory operation is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:42,Performance,load,loads,42,"// For Order dependences:; // 1. Volatile loads/stores can be packetized together, unless other; // rules prevent is.; // 2. Store followed by a load is not allowed.; // 3. Store followed by a store is valid.; // 4. Load followed by any memory operation is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:145,Performance,load,load,145,"// For Order dependences:; // 1. Volatile loads/stores can be packetized together, unless other; // rules prevent is.; // 2. Store followed by a load is not allowed.; // 3. Store followed by a store is valid.; // 4. Load followed by any memory operation is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:216,Performance,Load,Load,216,"// For Order dependences:; // 1. Volatile loads/stores can be packetized together, unless other; // rules prevent is.; // 2. Store followed by a load is not allowed.; // 3. Store followed by a store is valid.; // 4. Load followed by any memory operation is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:48,Integrability,depend,dependence,48,// Don't reorder the loads if there is an order dependence. This would; // occur if the first instruction must go in slot0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:21,Performance,load,loads,21,// Don't reorder the loads if there is an order dependence. This would; // occur if the first instruction must go in slot0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:44,Integrability,depend,dependency,44,"// If J is neither load nor store, assume a dependency.; // If J is a load, but I is neither, also assume a dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:108,Integrability,depend,dependency,108,"// If J is neither load nor store, assume a dependency.; // If J is a load, but I is neither, also assume a dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:19,Performance,load,load,19,"// If J is neither load nor store, assume a dependency.; // If J is a load, but I is neither, also assume a dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:70,Performance,load,load,70,"// If J is neither load nor store, assume a dependency.; // If J is a load, but I is neither, also assume a dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:64,Performance,load,load,64,// Store followed by store: not OK on V2.; // Store followed by load: not OK on all.; // Load followed by store: OK on all.; // Load followed by load: OK on all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:89,Performance,Load,Load,89,// Store followed by store: not OK on V2.; // Store followed by load: not OK on all.; // Load followed by store: OK on all.; // Load followed by load: OK on all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:128,Performance,Load,Load,128,// Store followed by store: not OK on V2.; // Store followed by load: not OK on all.; // Load followed by store: OK on all.; // Load followed by load: OK on all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:145,Performance,load,load,145,// Store followed by store: not OK on V2.; // Store followed by load: not OK on all.; // Load followed by store: OK on all.; // Load followed by load: OK on all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:241,Deployability,update,updated,241,"// Special case for ALLOCFRAME: even though there is dependency; // between ALLOCFRAME and subsequent store, allow it to be packetized; // in a same packet. This implies that the store is using the caller's; // SP. Hence, offset needs to be updated accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:53,Integrability,depend,dependency,53,"// Special case for ALLOCFRAME: even though there is dependency; // between ALLOCFRAME and subsequent store, allow it to be packetized; // in a same packet. This implies that the store is using the caller's; // SP. Hence, offset needs to be updated accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:26,Integrability,depend,dependencies,26,"// There are certain anti-dependencies that cannot be ignored.; // Specifically:; // J2_call ... implicit-def %r0 ; SUJ; // R0 = ... ; SUI; // Those cannot be packetized together, since the call will observe; // the effect of the assignment to R0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:29,Integrability,depend,dependency,29,// If I has a regmask assume dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:28,Integrability,depend,dependences,28,"// Skip over remaining anti-dependences. Two instructions that are; // anti-dependent can share a packet, since in most such cases all; // operands are read before any modifications take place.; // The exceptions are branch and call instructions, since they are; // executed after all other instructions have completed (at least; // conceptually).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:76,Integrability,depend,dependent,76,"// Skip over remaining anti-dependences. Two instructions that are; // anti-dependent can share a packet, since in most such cases all; // operands are read before any modifications take place.; // The exceptions are branch and call instructions, since they are; // executed after all other instructions have completed (at least; // conceptually).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:112,Modifiability,extend,extender,112,"// We need to put both instructions in the same packet: MI and NvjMI.; // Either of them can require a constant extender. Try to add both to; // the current packet, and if that fails, end the packet and start a; // new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:15,Energy Efficiency,schedul,scheduling,15,// V60 forward scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:121,Safety,avoid,avoid,121,"// Check whether the previous packet is in a different loop. If this is the; // case, there is little point in trying to avoid a stall because that would; // favor the rare case (loop entry) over the common case (loop iteration).; //; // TODO: We should really be able to check all the incoming edges if this is; // the first packet in a basic block, so we can avoid stalls from the loop; // backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:361,Safety,avoid,avoid,361,"// Check whether the previous packet is in a different loop. If this is the; // case, there is little point in trying to avoid a stall because that would; // favor the rare case (loop entry) over the common case (loop iteration).; //; // TODO: We should really be able to check all the incoming edges if this is; // the first packet in a basic block, so we can avoid stalls from the loop; // backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:740,Deployability,pipeline,pipeliner,740,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:761,Deployability,pipeline,pipeline,761,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:43,Integrability,depend,dependence,43,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:10,Performance,latency,latency,10,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:297,Performance,latency,latency,297,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:495,Performance,latency,latency,495,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:551,Performance,latency,latency,551,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:688,Performance,latency,latency,688,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:935,Performance,latency,latency,935,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:16,Performance,latency,latency,16,// Check if the latency is greater than one between this instruction and any; // instruction in the previous packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:49,Integrability,depend,dependences,49,"// This holds the offset value, when pruning the dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:23,Integrability,depend,dependence,23,// Check if there is a dependence between some instruction already in this; // packet and this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:52,Availability,avail,available,52,// Only check for dependence if there are resources available to; // schedule this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:69,Energy Efficiency,schedul,schedule,69,// Only check for dependence if there are resources available to; // schedule this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:18,Integrability,depend,dependence,18,// Only check for dependence if there are resources available to; // schedule this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:26,Integrability,depend,dependence,26,// Track MIs with ignored dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:86,Integrability,depend,dependence,86,// Set to the number of cycles of stall a given instruction will incur; // because of dependence on instruction in previous packet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:53,Integrability,depend,dependece,53,// isLegalToPruneDependencies - Is it legal to prune dependece between SUI; // and SUJ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFCopy.cpp:3,Deployability,Update,Update,3,// Update the EM map in the copy's entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFCopy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFCopy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp:92,Performance,queue,queue,92,"// This drastically improves execution time in ""collect"" over using; // SetVector as a work queue, and popping the first element from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp:113,Safety,safe,safe,113,"// Check if the given instruction has observable side-effects, i.e. if; // it should be considered ""live"". It is safe for this function to be; // overly conservative (i.e. return ""true"" for all instructions), but it; // is not safe to return ""false"" for an instruction that should not be; // considered removable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp:227,Safety,safe,safe,227,"// Check if the given instruction has observable side-effects, i.e. if; // it should be considered ""live"". It is safe for this function to be; // overly conservative (i.e. return ""true"" for all instructions), but it; // is not safe to return ""false"" for an instruction that should not be; // considered removable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:898,Deployability,update,update,898,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:441,Integrability,interface,interface,441,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:558,Performance,optimiz,optimized,558,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:602,Usability,simpl,simplest,602,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:681,Usability,simpl,simply,681,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:29,Safety,detect,detect,29,// FIXME: need better way to detect AsmStreamer (upstream removed getKind()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:24,Availability,error,errors,24,// Check the bundle for errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:6,Availability,error,error,6,// No error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:3,Performance,Perform,Perform,3,// Perform matching with tablegen asmmatcher generated function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:162,Availability,error,error,162,"// Create instruction operand for bundle instruction; // Break this into a separate function Code here is less readable; // Think about how to get an instruction error to report correctly.; // SMLoc will return the ""{""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:60,Modifiability,extend,extended,60,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:99,Security,Access,AccessAlignment,99,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:155,Security,access,access,155,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:212,Security,Access,AccessAlignment,212,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:337,Security,Access,AccessAlignment,337,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:29,Safety,detect,detect,29,// FIXME: need better way to detect if AsmStreamer (upstream removed; // getKind()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:16,Security,access,access,16,"// The optional access argument specifies the size of the smallest memory; // access to be made to the symbol, expressed in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:78,Security,access,access,78,"// The optional access argument specifies the size of the smallest memory; // access to be made to the symbol, expressed in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:45,Energy Efficiency,power,power,45,"// NOTE: The alignment in the directive is a power of 2 value, the assembler; // may internally end up wanting an alignment in bytes.; // FIXME: Diagnose overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:3,Security,validat,validate,3,// validate register against architecture,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:14,Modifiability,extend,extend,14,// Don't lazy extend these expression variants,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:47,Availability,failure,failure,47,// FIXME: Calls to OutOfRange shoudl propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:29,Safety,detect,detect,29,// FIXME: need better way to detect AsmStreamer (upstream removed getKind()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp:106,Availability,down,down,106,// Forward declare these because the auto-generated code will reference them.; // Definitions are further down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp:12,Modifiability,extend,extenders,12,// constant extenders in duplex must always be in slot 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp:16,Modifiability,extend,extendable,16,"// r13_2 is not extendable, so if there are no extent bits, it's r13_2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/Disassembler/HexagonDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:3,Deployability,Update,Update,3,// Update the fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:3,Availability,Error,Error,3,// Error: value 1124 out of range: -1024-1023 when resolving; // symbol in file xprtsock.S,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:70,Modifiability,extend,extended,70,"// Since the existing branches that use this relocation cannot be; // extended, they should only be fixed up if the target is within range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value. The Value has been ""split up"" into the; // appropriate bitfields above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:3,Usability,Clear,Clear,3,// Clear reloc bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:129,Testability,test,test,129,/// MayNeedRelaxation - Check whether the given instruction may need; /// relaxation.; ///; /// \param Inst - The instruction to test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:4,Usability,Simpl,Simple,4,/// Simple predicate for targets where !Resolved implies requiring relaxation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:16,Modifiability,extend,extender,16,"// if immediate extender needed, add it in",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:62,Modifiability,extend,extended,62,// now copy over the original instruction(the one we may have extended),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:10,Availability,Error,Error,10,//assert(!Error);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp:2,Testability,assert,assert,2,//assert(!Error);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:3,Performance,Load,Loads,3,// Loads that can become current-value loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:39,Performance,load,loads,39,// Loads that can become current-value loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:17,Performance,load,load,17,// Current-value load instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:3,Modifiability,Extend,Extendable,3,// Extendable insns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:17,Modifiability,extend,extended,17,// Insns must be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:24,Modifiability,extend,extended,24,// Which operand may be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:34,Modifiability,extend,extending,34,// Number of bits of range before extending operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:13,Energy Efficiency,power,power-of-two,13,// Alignment power-of-two before extending operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:33,Modifiability,extend,extending,33,// Alignment power-of-two before extending operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:23,Performance,load,load,23,// Addressing mode for load/store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:19,Performance,load,load,19,// Access size for load/store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:3,Security,Access,Access,3,// Access size for load/store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:10,Safety,predict,predicted,10,// Branch predicted taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:100,Availability,mask,mask,100,// *** The code above must match HexagonInstrFormat*.td *** //; // Hexagon specific MO operand flag mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:91,Deployability,update,update,91,"// Hexagon-specific MachineOperand target flags.; //; // When changing these, make sure to update; // getSerializableDirectMachineOperandTargetFlags and; // getSerializableBitmaskMachineOperandTargetFlags if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:97,Availability,mask,mask,97,"// HMOTF_ConstExtended; // Addendum to above, indicates a const extended op; // Can be used as a mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:64,Modifiability,extend,extended,64,"// HMOTF_ConstExtended; // Addendum to above, indicates a const extended op; // Can be used as a mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Safety,Avoid,Avoid,3,// Avoid scoring the defined register multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:127,Testability,log,logical,127,"// P3:0 is a special case, since multiple predicate register definitions; // in a packet is allowed as the equivalent of their logical ""and"".; // Only an explicit definition of P3:0 is noted as such; if a; // side-effect, then note as a soft definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:13,Performance,load,loads,13,"// Temporary loads should be used in the same packet, but don't commit; // results, so it should be disregarded if another insn changes the same; // register.; // TODO: relies on the impossibility of a current and a temporary loads; // in the same packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:226,Performance,load,loads,226,"// Temporary loads should be used in the same packet, but don't commit; // results, so it should be disregarded if another insn changes the same; // register.; // TODO: relies on the impossibility of a current and a temporary loads; // in the same packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out if the new predicate register is not defined,; // or defined ""late""; // (e.g., ""{ if (p3.new)... ; p3 = sp1loop0(#r7:2, Rs) }"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out if predicate register defined ""late"" multiple times or; // defined late and regularly defined; // (e.g., ""{ p3 = sp1loop0(...); p3 = cmp.eq(...) }"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:50,Energy Efficiency,consumption,consumption,50,// Checks that statically prove correct new value consumption,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:99,Performance,load,load,99,"// The ProducerOpIsMemIndex logic checks for the index of the producer; // register operand. Z-reg load instructions have an implicit operand; // that's not encoded, so the producer won't appear as the 1-th def, it; // will be at the 0-th.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:28,Testability,log,logic,28,"// The ProducerOpIsMemIndex logic checks for the index of the producer; // register operand. Z-reg load instructions have an implicit operand; // that's not encoded, so the producer won't appear as the 1-th def, it; // will be at the 0-th.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,// Error out for definitions of loop registers at the end of a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out for explicit changes to registers also weakly defined; // (e.g., ""{ usr = r0; r0 = sfadd(...) }"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out on an unconditional change when there are any other; // changes, conditional or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out on conditional changes based on the same predicate; // (e.g., ""{ if (!p0) r0 =...; if (!p0) r0 =... }"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Availability,Error,Error,3,"// Error out on conditional changes based on the same predicate; // multiple times; // (e.g., ""if (p0) r0 =...; if (!p0) r0 =... }; if (!p0) r0 =..."").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.h:10,Performance,perform,performed,10,// Checks performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:45,Integrability,depend,depending,45,"//; // [2] The actual fixup is LO16 or HI16, depending on the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:51,Modifiability,extend,extenders,51,"// Check for unimplemented instructions. Immediate extenders; // are encoded as zero, so they need to be accounted for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:52,Availability,mask,masked,52,// 29 is the bit position.; // 0b1110 =0xE bits are masked off and down shifted by 1 bit.; // Last bit is moved to bit position 13,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:67,Availability,down,down,67,// 29 is the bit position.; // 0b1110 =0xE bits are masked off and down shifted by 1 bit.; // Last bit is moved to bit position 13,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:23,Modifiability,extend,extended,23,/// Some insns are not extended and thus have no bits. These cases require; /// a more brute force method for determining the correct relocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:34,Modifiability,extend,extended,34,"// Only sub-instruction #1 can be extended in a duplex. If MI is a; // sub-instruction #0, it is not extended even if Extended is true; // (it can be true for the duplex as a whole).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:101,Modifiability,extend,extended,101,"// Only sub-instruction #1 can be extended in a duplex. If MI is a; // sub-instruction #0, it is not extended even if Extended is true; // (it can be true for the duplex as a whole).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp:118,Modifiability,Extend,Extended,118,"// Only sub-instruction #1 can be extended in a duplex. If MI is a; // sub-instruction #0, it is not extended even if Extended is true; // (it can be true for the duplex as a whole).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.h:10,Integrability,rout,routine,10,// helper routine for getMachineOpValue(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCodeEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp:80,Testability,test,test,80,// Transfer and jump:; // Rd=#U6 ; jump #r9:2; // Rd=Rs ; jump #r9:2; // Do not test for jump range here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp:81,Deployability,update,update,81,/// tryCompound - Given a bundle check for compound insns when one; /// is found update the contents fo the bundle with the compound insn.; /// If a compound instruction is found then the bundle will have one; /// additional slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp:49,Deployability,update,update,49,"// Look for compounds until none are found, only update the bundle when; // a compound is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp:11,Deployability,update,update,11,// Need to update the bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCCompound.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:428,Energy Efficiency,reduce,reduce,428,"//===- HexagonMCDuplexInfo.cpp - Instruction bundle checking --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements duplexing of instructions to reduce code size; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:3,Testability,test,testing,3,"// testing for case of: Rx = add(Rx,#s7)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:20,Modifiability,extend,extended,20,// Slot 1 cannot be extended in duplexes PRM 10.5,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:36,Modifiability,extend,extended,36,// Only A2_addi and A2_tfrsi can be extended in duplex form PRM 10.5,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:31,Modifiability,extend,extenders,31,// Prevent 2 instructions with extenders from duplexing; // Note that MIb (slot1) can be extended and MIa (slot0); // can never be extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:89,Modifiability,extend,extended,89,// Prevent 2 instructions with extenders from duplexing; // Note that MIb (slot1) can be extended and MIa (slot0); // can never be extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:131,Modifiability,extend,extended,131,// Prevent 2 instructions with extenders from duplexing; // Note that MIb (slot1) can be extended and MIa (slot0); // can never be extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:28,Modifiability,extend,extender,28,"// If duplexing produces an extender, but the original did not; // have an extender, do not duplex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp:75,Modifiability,extend,extender,75,"// If duplexing produces an extender, but the original did not; // have an extender, do not duplex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCDuplexInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp:397,Testability,stub,stub,397,"//=== HexagonMCELFStreamer.cpp - Hexagon subclass of MCELFStreamer -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a stub that parses a MCInst bundle and passes the; // instructions on to the real streamer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp:50,Modifiability,extend,extended,50,// EmitCommonSymbol and EmitLocalCommonSymbol are extended versions of the; // functions found in MCELFStreamer.cpp taking AccessSize as an additional; // parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp:123,Security,Access,AccessSize,123,// EmitCommonSymbol and EmitLocalCommonSymbol are extended versions of the; // functions found in MCELFStreamer.cpp taking AccessSize as an additional; // parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp:3,Deployability,Update,Update,3,// Update the maximum alignment of the section if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:394,Modifiability,extend,extends,394,"//===- HexagonMCInstrInfo.cpp - Hexagon sub-class of MCInst ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class extends MCInstrInfo to allow Hexagon specific MCInstr queries; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:14,Modifiability,extend,extender,14,// Create the extender.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:24,Availability,error,errors,24,// Check the bundle for errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:39,Energy Efficiency,reduce,reduce,39,// If compounding and duplexing didn't reduce the size below; // 4 or less we have a packet that is too big.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:24,Availability,error,errors,24,// Check the bundle for errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:35,Modifiability,extend,extendable,35,/// Return the maximum value of an extendable operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:35,Modifiability,extend,extendable,35,/// Return the minimum value of an extendable operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:34,Modifiability,extend,extendable,34,/// Return whether the operand is extendable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:96,Security,access,accessing,96,"// If we're a single vector consumer of a double producer, set subreg bit; // based on if we're accessing the lower or upper register component",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:25,Performance,load,load,25,// do not reorder memory load/stores by default load/stores are re-ordered; // and by default loads can be re-ordered,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:48,Performance,load,load,48,// do not reorder memory load/stores by default load/stores are re-ordered; // and by default loads can be re-ordered,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:94,Performance,load,loads,94,// do not reorder memory load/stores by default load/stores are re-ordered; // and by default loads can be re-ordered,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:14,Modifiability,extend,extender,14,// Return the extender for instruction at Index or nullptr if none,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:17,Security,access,access,17,// Return memory access size in bytes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:17,Security,access,access,17,// Return memory access size,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:27,Modifiability,extend,extendable,27,// Return the index of the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:29,Modifiability,extend,extendable,29,// Return a reference to the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:40,Modifiability,extend,extendable,40,// Return the implicit alignment of the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:44,Modifiability,extend,extendable,44,// Return the number of logical bits of the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:24,Testability,log,logical,24,// Return the number of logical bits of the extendable operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:16,Modifiability,extend,extendable,16,// Check if the extendable operand is signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:40,Modifiability,extend,extendable,40,// Return the max value that a constant extendable operand can have; // without being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:86,Modifiability,extend,extended,86,// Return the max value that a constant extendable operand can have; // without being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:40,Modifiability,extend,extendable,40,// Return the min value that a constant extendable operand can have; // without being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:86,Modifiability,extend,extended,86,// Return the min value that a constant extendable operand can have; // without being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:27,Modifiability,extend,extender,27,// Does the packet have an extender for the instruction at Index,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:55,Modifiability,extend,extended,55,// Return whether the instruction needs to be constant extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:34,Modifiability,extend,extended,34,// Return true if the insn may be extended based on the operand value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:49,Modifiability,extend,extended,49,// Return whether the instruction must be always extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:52,Modifiability,extend,extender,52,// Returns whether this instruction is an immediate extender,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:39,Availability,avail,available,39,// Returns the maximum number of slots available in the given; // subtarget's packets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:60,Modifiability,extend,extend,60,// Would duplexing this instruction create a requirement to extend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCShuffler.cpp:94,Modifiability,extend,extender,94,"// if fixups present, make sure we don't insert too many nops that would; // later prevent an extender from being inserted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:3,Security,HasH,HasHvxVer,3,"// HasHvxVer is false, and UseHvx is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:2,Testability,assert,assert,2,//assert(!HexagonMCInstrInfo::isBundle(Inst));,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:2,Testability,assert,assert,2,//assert(!HexagonMCInstrInfo::isBundle(Inst));,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp:2,Testability,assert,assert,2,//assert(!HexagonMCInstrInfo::isBundle(Inst));,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h:111,Modifiability,extend,extender,111,"// Maximum number of instructions in a packet before shuffling,; // including a compound one or a duplex or an extender.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h:55,Security,expose,exposed,55,"/// Create a Hexagon MCSubtargetInfo instance. This is exposed so Asm parser,; /// etc. do not need to go through TargetRegistry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:114,Availability,avail,available,114,"// The priority is directly proportional to how restricted the insn is based; // on its flexibility to run on the available slots. So, the fewer slots it; // may run on, the higher its priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Mask,Mask,3,// Mask indicating which slot is unavailable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate slots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if the desired slots are already full.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:81,Availability,mask,mask,81,"// If this packet contains an instruction that bars slot-1 stores,; // we should mask off slot 1 from all of the store instructions in; // this packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:42,Availability,mask,masks,42,// These restrictions can modify the slot masks in the instructions; // in the Packet member. They should run unconditionally and their; // order does not matter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:42,Availability,mask,masks,42,"// These restrictions can modify the slot masks in the instructions; // in the Packet member, but they can also detect constraint failures; // which are fatal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:130,Availability,failure,failures,130,"// These restrictions can modify the slot masks in the instructions; // in the Packet member, but they can also detect constraint failures; // which are fatal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:112,Safety,detect,detect,112,"// These restrictions can modify the slot masks in the instructions; // in the Packet member, but they can also detect constraint failures; // which are fatal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Security,validat,validate,3,// validate first jump with this slot rule,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Security,validat,validate,3,// validate second jump with this slot rule,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:23,Deployability,configurat,configuration,23,"// both valid for this configuration, set new slot rules",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:23,Modifiability,config,configuration,23,"// both valid for this configuration, set new slot rules",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:52,Availability,mask,mask,52,"// if yes, great, if not then restore original slot mask; // restore original values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if insn may not be executed in any slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:12,Performance,load,load,12,// A single load must use slot #0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:11,Performance,load,load,11,// Pin the load to slot #0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:14,Performance,load,loads,14,// Slot1 only loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:20,Performance,Load,Loads,20,// }:mem_noshuf; // Loads must keep the original order ONLY if; // isMemReorderDisabled() == true,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if no more slots available for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:26,Availability,avail,available,26,// Error if no more slots available for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:40,Performance,load,loads,40,// Error if no more slots available for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:36,Availability,avail,available,36,// Pin the load to the highest slot available to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:11,Performance,load,load,11,// Pin the load to the highest slot available to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:32,Availability,avail,available,32,// Update the next highest slot available to loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Deployability,Update,Update,3,// Update the next highest slot available to loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:45,Performance,load,loads,45,// Update the next highest slot available to loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if no more slots available for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:26,Availability,avail,available,26,// Error if no more slots available for stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:37,Availability,avail,available,37,// Pin the store to the highest slot available to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:32,Availability,avail,available,32,// Update the next highest slot available to stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Deployability,Update,Update,3,// Update the next highest slot available to stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,Availability,Error,Error,3,// Error if a single store with another store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:17,Availability,mask,mask,17,// save off slot mask of instruction marked with A_PREFER_SLOT3; // and then pin it to slot #3,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:3,Availability,Mask,Mask,3,// Mask of the slots or units that may execute the insn and; // the weight or priority that the insn requires to be assigned a slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:30,Performance,load,load,30,// Flag whether the insn is a load or a store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:32,Performance,load,loads,32,"// Number of memory operations, loads, solo loads, stores, solo stores,; // single stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:44,Performance,load,loads,44,"// Number of memory operations, loads, solo loads, stores, solo stores,; // single stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h:14,Availability,error,error,14,// Return the error code for the last check or shuffling of the bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h:28,Integrability,interface,interface,28,"//===-- Lanai.h - Top-level interface for Lanai representation --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // Lanai back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h:112,Energy Efficiency,schedul,scheduling,112,"// createLanaiISelDag - This pass converts a legalized DAG into a; // Lanai-specific DAG, ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h:54,Performance,load,loads,54,// createLanaiMemAluCombinerPass - This pass combines loads/stores and; // arithmetic operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAluCode.h:53,Testability,test,tested,53,// Bits indicating post- and pre-operators should be tested and set using Is*; // and Make* utility functions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAluCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAluCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- LanaiAsmPrinter.cpp - Lanai LLVM assembly writer ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the Lanai assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:9,Usability,clear,cleared,9,// carry cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:12,Usability,clear,cleared,12,// oVerflow cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:12,Usability,clear,cleared,12,// oVerflow cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:9,Usability,clear,cleared,9,// carry cleared | unsigned less than,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp:383,Usability,Simpl,Simple,383,"//===-- LanaiDelaySlotFiller.cpp - Lanai delay slot filler ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Simple pass to fill delay slots with useful instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp:131,Safety,safe,safe,131,// RET is generated as part of epilogue generation and hence we know; // what the two instructions preceding it are and that it is safe to; // insert RET above them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp:3,Performance,Load,Loads,3,// Loads or stores cannot be moved past a store to the delay slot; // and stores cannot be moved past a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp:104,Performance,load,load,104,// Loads or stores cannot be moved past a store to the delay slot; // and stores cannot be moved past a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:3,Deployability,Update,Update,3,// Update maximum call frame size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:3,Deployability,Update,Update,3,// Update frame info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:145,Energy Efficiency,allocate,allocate,145,"// Generates the following sequence for function entry:; // st %fp,-4[*%sp] !push old FP; // add %sp,8,%fp !generate new FP; // sub %sp,0x4,%sp !allocate stack space (as needed)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:97,Energy Efficiency,allocate,allocate,97,// FIXME: This appears to be overallocating. Needs investigation.; // Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate space on the stack if needed; // sub %sp,StackSize,%sp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:36,Integrability,depend,depend,36,"// The function epilogue should not depend on the current stack pointer!; // It should use the frame pointer only. This is mandatory because; // of alloca; we also take advantage of it to omit stack adjustments; // before returning.; //; // Note that when we go to restore the preserved register values we must; // not try to address their slots by using offsets from the stack pointer.; // That's because the stack pointer may have been moved during the function; // execution due to a call to alloca(). Rather, we must restore all; // preserved registers via offsets from the frame pointer value.; //; // Note also that when the current frame is being ""popped"" (by adjusting; // the value of the stack pointer) on function exit, we must (for the; // sake of alloca) set the new value of the stack pointer based upon; // the current value of the frame pointer. We can't just add what we; // believe to be the (static) frame size to the stack pointer because; // if we did that, and alloca() had been called during this function,; // we would end up returning *without* having fully deallocated all of; // the space grabbed by alloca. If that happened, and a function; // containing one or more alloca() calls was called over and over again,; // then the stack would grow without limit!; //; // RET is lowered to; // ld -4[%fp],%pc # modify %pc (two delay slots); // as the return address is in the stack frame and mov to pc is allowed.; // emitEpilogue emits; // mov %fp,%sp # restore the stack pointer; // ld -8[%fp],%fp # restore the caller's frame pointer; // before RET and the delay slot filler will move RET such that these; // instructions execute in the delay slots of the load to PC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:1682,Performance,load,load,1682,"// The function epilogue should not depend on the current stack pointer!; // It should use the frame pointer only. This is mandatory because; // of alloca; we also take advantage of it to omit stack adjustments; // before returning.; //; // Note that when we go to restore the preserved register values we must; // not try to address their slots by using offsets from the stack pointer.; // That's because the stack pointer may have been moved during the function; // execution due to a call to alloca(). Rather, we must restore all; // preserved registers via offsets from the frame pointer value.; //; // Note also that when the current frame is being ""popped"" (by adjusting; // the value of the stack pointer) on function exit, we must (for the; // sake of alloca) set the new value of the stack pointer based upon; // the current value of the frame pointer. We can't just add what we; // believe to be the (static) frame size to the stack pointer because; // if we did that, and alloca() had been called during this function,; // we would end up returning *without* having fully deallocated all of; // the space grabbed by alloca. If that happened, and a function; // containing one or more alloca() calls was called over and over again,; // then the stack would grow without limit!; //; // RET is lowered to; // ld -4[%fp],%pc # modify %pc (two delay slots); // as the return address is in the stack frame and mov to pc is allowed.; // emitEpilogue emits; // mov %fp,%sp # restore the stack pointer; // ld -8[%fp],%fp # restore the caller's frame pointer; // before RET and the delay slot filler will move RET such that these; // instructions execute in the delay slots of the load to PC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:118,Performance,load,loaded,118,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:218,Security,access,access,218,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:287,Security,access,access,287,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:315,Security,access,accesses,315,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:9,Usability,clear,cleared,9,// carry cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:12,Usability,clear,cleared,12,// oVerflow cleared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:118,Availability,redundant,redundant,118,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:158,Availability,redundant,redundant,158,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:237,Availability,redundant,redundant,237,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:92,Deployability,update,update,92,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:118,Safety,redund,redundant,118,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:158,Safety,redund,redundant,158,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:237,Safety,redund,redundant,237,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:38,Availability,redundant,redundant,38,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:38,Safety,redund,redundant,38,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:91,Deployability,update,updated,91,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on; // CMP needs to be updated to be based on SUB. Push the condition; // code operands to OperandsToUpdate. If it is safe to remove; // CmpInstr, the condition code of these operands will be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:186,Safety,safe,safe,186,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on; // CMP needs to be updated to be based on SUB. Push the condition; // code operands to OperandsToUpdate. If it is safe to remove; // CmpInstr, the condition code of these operands will be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:66,Safety,safe,safe,66,// Z N V; // The instruction uses the V bit or C bit which is not safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:109,Performance,optimiz,optimize,109,"// If SR is not killed nor re-defined, we should check whether it is; // live-out. If it is live-out, do not optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:3,Deployability,Toggle,Toggle,3,// Toggle the optional operand to SR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:64,Safety,detect,detects,64,// Check if MI has any non-dead defs or physreg uses. This also detects; // predicated instructions which will be reading SR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:180,Energy Efficiency,allocate,allocated,180,// The output register value when the predicate is false is an implicit; // register operand tied to the first def. The tie makes the register; // allocator ensure the FalseReg is allocated the same register as operand 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:3,Deployability,Update,Update,3,// Update SeenMIs set: register newly created MI and erase removed DefMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:15,Performance,load,loads,15,// Handle only loads/stores with base register followed by immediate offset; // and with add as ALU op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:78,Energy Efficiency,efficient,efficient,78,"// See if the comparison instruction can be converted into something more; // efficient. E.g., on Lanai register-register instructions can set the flag; // register, obviating the need for a separate compare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:323,Performance,optimiz,optimize,323,"// Analyze the given select instruction, returning true if it cannot be; // understood. It is assumed that MI->isSelect() is true.; //; // When successful, return the controlling condition and the operands that; // determine the true and false result values.; //; // Result = SELECT Cond, TrueOp, FalseOp; //; // Lanai can optimize certain select instructions, for example by predicating; // the instruction defining one of the operands and sets Optimizable to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:446,Performance,Optimiz,Optimizable,446,"// Analyze the given select instruction, returning true if it cannot be; // understood. It is assumed that MI->isSelect() is true.; //; // When successful, return the controlling condition and the operands that; // determine the true and false result values.; //; // Result = SELECT Cond, TrueOp, FalseOp; //; // Lanai can optimize certain select instructions, for example by predicating; // the instruction defining one of the operands and sets Optimizable to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:187,Availability,failure,failure,187,"// Given a select instruction that was understood by analyzeSelect and; // returned Optimizable = true, attempt to optimize MI by merging it with one; // of its operands. Returns NULL on failure.; //; // When successful, returns the new select instruction. The client is; // responsible for deleting MI.; //; // If both sides of the select can be optimized, the TrueOp is modifed.; // PreferFalse is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:84,Performance,Optimiz,Optimizable,84,"// Given a select instruction that was understood by analyzeSelect and; // returned Optimizable = true, attempt to optimize MI by merging it with one; // of its operands. Returns NULL on failure.; //; // When successful, returns the new select instruction. The client is; // responsible for deleting MI.; //; // If both sides of the select can be optimized, the TrueOp is modifed.; // PreferFalse is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:115,Performance,optimiz,optimize,115,"// Given a select instruction that was understood by analyzeSelect and; // returned Optimizable = true, attempt to optimize MI by merging it with one; // of its operands. Returns NULL on failure.; //; // When successful, returns the new select instruction. The client is; // responsible for deleting MI.; //; // If both sides of the select can be optimized, the TrueOp is modifed.; // PreferFalse is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:347,Performance,optimiz,optimized,347,"// Given a select instruction that was understood by analyzeSelect and; // returned Optimizable = true, attempt to optimize MI by merging it with one; // of its operands. Returns NULL on failure.; //; // When successful, returns the new select instruction. The client is; // responsible for deleting MI.; //; // If both sides of the select can be optimized, the TrueOp is modifed.; // PreferFalse is not used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp:80,Performance,Load,Load,80,// Helper functions for ComplexPattern used on LanaiInstrInfo; // Used on Lanai Load/Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp:3,Performance,Load,Loading,3,// Loading from a constant address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp:112,Energy Efficiency,schedul,scheduling,112,"// createLanaiISelDag - This pass converts a legalized DAG into a; // Lanai-specific DAG, ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Modifiability,Extend,Extended,3,// Extended load operations for i1 types must be promoted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:12,Performance,load,load,12,// Extended load operations for i1 types must be promoted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:171,Performance,perform,performance,171,// TODO: Setting the minimum jump table entries needed before a; // switch is transformed to a jump table to 100 to avoid creating jump tables; // as this was causing bad performance compared to a large group of if; // statements. Re-evaluate this on new benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:116,Safety,avoid,avoid,116,// TODO: Setting the minimum jump table entries needed before a; // switch is transformed to a jump table to 100 to avoid creating jump tables; // as this was causing bad performance compared to a large group of if; // statements. Re-evaluate this on new benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:255,Testability,benchmark,benchmarks,255,// TODO: Setting the minimum jump table entries needed before a; // switch is transformed to a jump table to 100 to avoid creating jump tables; // as this was causing bad performance compared to a large group of if; // statements. Re-evaluate this on new benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:77,Availability,error,error,77,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:56,Integrability,rout,routine,56,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:47,Performance,optimiz,optimization,47,// Lanai target does not yet support tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:92,Performance,load,load,92,// LowerCCCArguments - transform physical registers into virtual registers and; // generate load operations for arguments places on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:88,Testability,assert,assert,88,"// If this is an 8/16-bit value, it is really passed promoted to 32; // bits. Insert an assert[sz]ext to capture this, then truncate to the; // right size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Performance,Load,Load,3,// Load the argument to a virtual register,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:52,Performance,load,load,52,// Create the SelectionDAG nodes corresponding to a load; // from this parameter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:177,Security,access,access,177,// The Lanai ABI for returning structs by value requires that we copy; // the sret argument into rv for the return. Save the argument into; // a virtual register so that we can access it from the return points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument; // which is a value necessary to VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.; // TODO: Should return-twice functions be handled?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:477,Usability,Guid,Guide,477,"// Convert to non-adjacent form (NAF) signed-digit representation.; // NAF is a signed-digit form where no adjacent digits are non-zero. It is the; // minimal Hamming weight representation of a number (on average 1/3 of the; // digits will be non-zero vs 1/2 for regular binary representation). And as; // the non-zero digits will be the only digits contributing to the instruction; // count, this is desirable. The next loop converts it to NAF (following the; // approach in 'Guide to Elliptic Curve Cryptography' [ISBN: 038795273X]) by; // choosing the non-zero coefficients such that the resulting quotient is; // divisible by 2 which will cause the next coefficient to be zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:214,Availability,down,down,214,"// For Lanai, the outgoing memory arguments area should be on top of the; // alloca area on the stack i.e., the outgoing memory arguments should be; // at a lower address than the alloca area. Move the alloca area down the; // stack by adding back the space reserved for outgoing arguments to SP; // here.; //; // We do not know what the size of the outgoing args is at this point.; // So, we add a pseudo instruction ADJDYNALLOC that will adjust the; // stack pointer. We replace this instruction with on that has the correct,; // known offset in emitPrologue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:40,Modifiability,variab,variable,40,"// If the code model is small or global variable will be placed in the small; // section, then assume address will fit in 21-bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Performance,Perform,Performs,3,// Performs the following for (ShOpLo + (ShOpHi << 32)) << ShAmt:; // LoBitsForHi = (ShAmt == 0) ? 0 : (ShOpLo >> (32-ShAmt)); // HiBitsForHi = ShOpHi << ShAmt; // Hi = (ShAmt >= 32) ? (ShOpLo << (ShAmt-32)) : (LoBitsForHi | HiBitsForHi); // Lo = (ShAmt >= 32) ? 0 : (ShOpLo << ShAmt); // return (Hi << 32) | Lo;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:50,Integrability,wrap,wrapped,50,"// Lanai shifts of larger than register sizes are wrapped rather than; // clamped, so we can't just emit ""lo << b"" if b is too big.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:390,Availability,mask,mask,390,// Performs the following for a >> b:; // unsigned r_high = a_high >> b;; // r_high = (32 - b <= 0) ? 0 : r_high;; //; // unsigned r_low = a_low >> b;; // r_low = (32 - b <= 0) ? r_high : r_low;; // r_low = (b == 0) ? r_low : r_low | (a_high << (32 - b));; // return (unsigned long long)r_high << 32 | r_low;; // Note: This takes advantage of Lanai's shift behavior to avoid needing to; // mask the shift amount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Performance,Perform,Performs,3,// Performs the following for a >> b:; // unsigned r_high = a_high >> b;; // r_high = (32 - b <= 0) ? 0 : r_high;; //; // unsigned r_low = a_low >> b;; // r_low = (32 - b <= 0) ? r_high : r_low;; // r_low = (b == 0) ? r_low : r_low | (a_high << (32 - b));; // return (unsigned long long)r_high << 32 | r_low;; // Note: This takes advantage of Lanai's shift behavior to avoid needing to; // mask the shift amount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:369,Safety,avoid,avoid,369,// Performs the following for a >> b:; // unsigned r_high = a_high >> b;; // r_high = (32 - b <= 0) ? 0 : r_high;; //; // unsigned r_low = a_low >> b;; // r_low = (32 - b <= 0) ? r_high : r_low;; // r_low = (b == 0) ? r_low : r_low | (a_high << (32 - b));; // return (unsigned long long)r_high << 32 | r_low;; // Note: This takes advantage of Lanai's shift behavior to avoid needing to; // mask the shift amount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:56,Safety,Detect,Detects,56,"// Return true if N is conditionally 0 or all ones.; // Detects these expressions where cc is an i1 value:; //; // (select cc 0, y) [AllOnes=0]; // (select cc y, 0) [AllOnes=0]; // (zext cc) [AllOnes=0]; // (sext cc) [AllOnes=0/1]; // (select cc -1, y) [AllOnes=1]; // (select cc y, -1) [AllOnes=1]; //; // * AllOnes determines whether to check for an all zero (AllOnes false) or an; // all ones operand (AllOnes true).; // * Invert is set when N is the all zero/ones constant when CC is false.; // * OtherOp is set to the alternative value of N.; //; // For example, for (select cc X, Y) and AllOnes = 0 if:; // * X = 0, Invert = False and OtherOp = Y; // * Y = 0, Invert = True and OtherOp = X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:3,Performance,Perform,PerformSUBCombine,3,// PerformSUBCombine - Target-specific dag combine xforms for ISD::SUB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:49,Integrability,Interface,Interface,49,"//===-- LanaiISelLowering.h - Lanai DAG Lowering Interface -....-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Lanai uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- LanaiISelLowering.h - Lanai DAG Lowering Interface -....-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Lanai uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:53,Modifiability,variab,variable,53,"// SELECT_CC - Operand 0 and operand 1 are selection variable, operand 3; // is condition code and operand 4 is flag operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:3,Integrability,Wrap,Wrapper,3,"// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,; // and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h:15,Integrability,wrap,wrapper,15,"// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,; // and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:480,Performance,load,load,480,"//===-- LanaiMemAluCombiner.cpp - Pass to combine memory & ALU operations -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Simple pass to combine memory and ALU operations; //; // The Lanai ISA supports instructions where a load/store modifies the base; // register used in the load/store operation. This pass finds suitable; // load/store and ALU instructions and combines them into one instruction.; //; // For example,; // ld [ %r6 -- ], %r12; // is a supported instruction that is not currently generated by the instruction; // selection pass of this backend. This pass generates these instructions by; // merging; // add %r6, -4, %r6; // followed by; // ld [ %r6 ], %r12; // in the same machine basic block into one machine instruction.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:534,Performance,load,load,534,"//===-- LanaiMemAluCombiner.cpp - Pass to combine memory & ALU operations -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Simple pass to combine memory and ALU operations; //; // The Lanai ISA supports instructions where a load/store modifies the base; // register used in the load/store operation. This pass finds suitable; // load/store and ALU instructions and combines them into one instruction.; //; // For example,; // ld [ %r6 -- ], %r12; // is a supported instruction that is not currently generated by the instruction; // selection pass of this backend. This pass generates these instructions by; // merging; // add %r6, -4, %r6; // followed by; // ld [ %r6 ], %r12; // in the same machine basic block into one machine instruction.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:585,Performance,load,load,585,"//===-- LanaiMemAluCombiner.cpp - Pass to combine memory & ALU operations -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Simple pass to combine memory and ALU operations; //; // The Lanai ISA supports instructions where a load/store modifies the base; // register used in the load/store operation. This pass finds suitable; // load/store and ALU instructions and combines them into one instruction.; //; // For example,; // ld [ %r6 -- ], %r12; // is a supported instruction that is not currently generated by the instruction; // selection pass of this backend. This pass generates these instructions by; // merging; // add %r6, -4, %r6; // followed by; // ld [ %r6 ], %r12; // in the same machine basic block into one machine instruction.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:379,Usability,Simpl,Simple,379,"//===-- LanaiMemAluCombiner.cpp - Pass to combine memory & ALU operations -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Simple pass to combine memory and ALU operations; //; // The Lanai ISA supports instructions where a load/store modifies the base; // register used in the load/store operation. This pass finds suitable; // load/store and ALU instructions and combines them into one instruction.; //; // For example,; // ld [ %r6 -- ], %r12; // is a supported instruction that is not currently generated by the instruction; // selection pass of this backend. This pass generates these instructions by; // merging; // add %r6, -4, %r6; // followed by; // ld [ %r6 ], %r12; // in the same machine basic block into one machine instruction.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:79,Testability,test,testing,79,// Determine if the machine instruction is a supported memory operation by; // testing if the computed merge opcode is a valid memory operation opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:30,Security,access,accesses,30,// Don't move volatile memory accesses; // TODO: unclear if we need to be as conservative about atomics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:3,Testability,Test,Test,3,// Test to see if two machine operands are of the same type. This test is less; // strict than the MachineOperand::isIdenticalTo function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:66,Testability,test,test,66,// Test to see if two machine operands are of the same type. This test is less; // strict than the MachineOperand::isIdenticalTo function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:23,Performance,load,load,23,// Insert new combined load/store + alu operation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:3,Safety,Abort,Abort,3,// Abort if ALU offset is not a register or immediate,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:156,Security,access,accessing,156,"// Create a pre-op if the ALU operation preceded the memory operation or the; // MemOffset is non-zero (i.e. the memory value should be adjusted before; // accessing it), else create a post-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:81,Performance,load,load,81,// Function determines if ALU operation (in alu_iter) can be combined with; // a load/store with base and offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:13,Performance,load,load,13,// Erase old load/store instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp:29,Deployability,Configurat,Configuration,29,// Lanai Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp:29,Modifiability,Config,Configuration,29,// Lanai Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp:82,Energy Efficiency,schedul,scheduling,82,// Run passes after prolog-epilog insertion and before the second instruction; // scheduling pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp:21,Performance,load,loaded,21,// A address must be loaded from a small section if its size is less than the; // small section size threshold. Data in this section must be addressed using; // gp_rel operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp:111,Security,access,access,111,"// Global values placed in sections starting with .ldata do not fit in; // 21-bits, so always use large memory access for them. FIXME: This is a; // workaround for a tool limitation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h:187,Energy Efficiency,reduce,reduce,187,// This increases the cost associated with multiplication and division; // to 64 times what the baseline arithmetic cost is. The arithmetic; // instruction cost was arbitrarily chosen to reduce the desirability; // of emitting arithmetic instructions that are emulated in software.; // TODO: Investigate the performance impact given specialized lowerings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h:308,Performance,perform,performance,308,// This increases the cost associated with multiplication and division; // to 64 times what the baseline arithmetic cost is. The arithmetic; // instruction cost was arbitrarily chosen to reduce the desirability; // of emitting arithmetic instructions that are emulated in software.; // TODO: Investigate the performance impact given specialized lowerings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:17,Testability,test,testing,17,// Functions for testing operand type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:43,Availability,error,error,43,// Matches memory operand. Returns true if error encountered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:264,Availability,robust,robust,264,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:222,Modifiability,Extend,Extend,222,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:3,Safety,Detect,Detects,3,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:104,Safety,detect,detected,104,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:167,Testability,test,test,167,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Disassembler/LanaiDisassembler.cpp:97,Availability,down,down,97,// Forward declare because the autogenerated code will reference this.; // Definition is further down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/Disassembler/LanaiDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Disassembler/LanaiDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiAsmBackend.cpp:3,Performance,Load,Load,3,// Load instruction and apply value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiFixupKinds.h:43,Availability,mask,masked,43,"// 21-bit symbol relocation, last two bits masked to 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiFixupKinds.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiFixupKinds.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp:60,Safety,abort,abort,60,// Handle the undefined value here for printing so we don't abort().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp:60,Safety,abort,abort,60,// Handle the undefined value here for printing so we don't abort().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCCodeEmitter.cpp:45,Performance,load,load,45,// Helper function to adjust P and Q bits on load and store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArch.h:32,Integrability,interface,interface,32,"//===-- LoongArch.h - Top-level interface for LoongArch ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // LoongArch back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===- LoongArchAsmPrinter.cpp - LoongArch LLVM Assembly Printer -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to GAS-format LoongArch assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:3,Usability,Simpl,Simple,3,// Simple pseudo-instructions have their lowering (with expansion to real; // instructions) auto-generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:93,Availability,error,error,93,// The modifier is 'w' but the operand is not an LSX register; Report an; // unknown operand error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp:94,Availability,error,error,94,// The modifier is 'u' but the operand is not an LASX register; Report an; // unknown operand error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.h:3,Integrability,Wrap,Wrapper,3,// Wrapper needed for tblgenned pseudo lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:536,Safety,avoid,avoiding,536,"//==- LoongArchExpandAtomicPseudoInsts.cpp - Expand atomic pseudo instrs. -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands atomic pseudo instructions into; // target instructions. This pass should be run at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LL/SC block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:39,Availability,mask,masktargetdata,39,// res = oldval ^ ((oldval ^ newval) & masktargetdata);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:135,Availability,mask,masktargetdata,135,"// .loop:; // ll.w destreg, (alignedaddr); // binop scratch, destreg, incr; // xor scratch, destreg, scratch; // and scratch, scratch, masktargetdata; // xor scratch, destreg, scratch; // sc.w scratch, scratch, (alignedaddr); // beqz scratch, loop",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:77,Availability,mask,mask,77,"//; // .loophead:; // ll.w destreg, (alignedaddr); // and scratch2, destreg, mask; // move scratch1, destreg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:76,Availability,mask,mask,76,"// .loopifbody:; // xor scratch1, destreg, incr; // and scratch1, scratch1, mask; // xor scratch1, destreg, scratch1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:63,Availability,mask,mask,63,"// .loophead:; // ll.[w|d] dest, (addr); // and scratch, dest, mask; // bne scratch, cmpval, tail",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp:38,Availability,mask,mask,38,"// .looptail:; // andn scratch, dest, mask; // or scratch, scratch, newval; // sc.[w|d] scratch, scratch, (addr); // beqz scratch, loophead; // b done",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandAtomicPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,// Emit the 5-insn large address load sequence with the `%pc` family of; // relocs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence with the `%got_pc` family; // of relocs, loading the result from GOT with `ldx.d` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:88,Performance,load,loading,88,"// Emit the 5-insn large address load sequence with the `%got_pc` family; // of relocs, loading the result from GOT with `ldx.d` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence with the `%ie_pc` family; // of relocs, loading the result with `ldx.d` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:87,Performance,load,loading,87,"// Emit the 5-insn large address load sequence with the `%ie_pc` family; // of relocs, loading the result with `ldx.d` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence with the `%got_pc` family; // of relocs, with the `pcalau12i` insn relocated with `%ld_pc_hi20`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence with the `%got_pc` family; // of relocs, with the `pcalau12i` insn relocated with `%gd_pc_hi20`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp:33,Performance,load,load,33,"// Emit the 5-insn large address load sequence, either directly or; // indirectly in case of going through the GOT, then JIRL_TAIL or; // JIRL_CALL to $addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchExpandPseudoInsts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:215,Modifiability,variab,variable,215,"// Return true if the specified function should have a dedicated frame; // pointer register. This is true if frame pointer elimination is; // disabled, if it needs dynamic stack realignment, if the function has; // variable sized allocas, or if the frame address is taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:3,Deployability,Update,Update,3,// Update frame info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:37,Energy Efficiency,allocate,allocate,37,// Early exit if there is no need to allocate space in the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:30,Energy Efficiency,reduce,reduce,30,// Split the SP adjustment to reduce the offsets of callee saved spill.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:183,Modifiability,variab,variable,183,"// FP will be used to restore the frame in the epilogue, so we need; // another base register BP to record SP after re-alignment. SP will; // track the current stack after allocating variable sized objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:47,Energy Efficiency,reduce,reduce,47,"// We would like to split the SP adjustment to reduce prologue/epilogue; // as following instructions. In this way, the offset of the callee saved; // register could fit in a single store.; // e.g.; // addi.d $sp, $sp, -2032; // st.d $ra, $sp, 2024; // st.d $fp, $sp, 2016; // addi.d $sp, $sp, -16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:561,Energy Efficiency,reduce,reduce,561,"// FirstSPAdjustAmount is chosen as (2048 - StackAlign) because 2048 will; // cause sp = sp + 2048 in the epilogue to be split into multiple; // instructions. Offsets smaller than 2048 can fit in a single load/store; // instruction, and we have to stick with the stack alignment.; // So (2048 - StackAlign) will satisfy the stack alignment.; //; // FIXME: This place may seem odd. When using multiple ADDI instructions to; // adjust the stack in Prologue, and there are no callee-saved registers, we; // can take advantage of the logic of split sp ajustment to reduce code; // changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:205,Performance,load,load,205,"// FirstSPAdjustAmount is chosen as (2048 - StackAlign) because 2048 will; // cause sp = sp + 2048 in the epilogue to be split into multiple; // instructions. Offsets smaller than 2048 can fit in a single load/store; // instruction, and we have to stick with the stack alignment.; // So (2048 - StackAlign) will satisfy the stack alignment.; //; // FIXME: This place may seem odd. When using multiple ADDI instructions to; // adjust the stack in Prologue, and there are no callee-saved registers, we; // can take advantage of the logic of split sp ajustment to reduce code; // changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:530,Testability,log,logic,530,"// FirstSPAdjustAmount is chosen as (2048 - StackAlign) because 2048 will; // cause sp = sp + 2048 in the epilogue to be split into multiple; // instructions. Offsets smaller than 2048 can fit in a single load/store; // instruction, and we have to stick with the stack alignment.; // So (2048 - StackAlign) will satisfy the stack alignment.; //; // FIXME: This place may seem odd. When using multiple ADDI instructions to; // adjust the stack in Prologue, and there are no callee-saved registers, we; // can take advantage of the logic of split sp ajustment to reduce code; // changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:60,Modifiability,variab,variables,60,// Do not preserve stack space within prologue for outgoing variables if the; // function contains variable size objects.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:99,Modifiability,variab,variable,99,// Do not preserve stack space within prologue for outgoing variables if the; // function contains variable size objects.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:281,Energy Efficiency,allocate,allocate,281,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:196,Modifiability,variab,variable,196,"// If space has not been reserved for a call frame, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP must be converted to instructions manipulating the stack; // pointer. This is necessary when there is a variable length stack; // allocation (e.g. alloca), which means it's not possible to allocate; // space for outgoing arguments from within the function prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:44,Performance,optimiz,optimizing,44,// Keep the conventional code flow when not optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchInstrInfo.h:3,Availability,Mask,Mask,3,// Mask assignments for floating-point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:78,Availability,mask,mask,78,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:35,Energy Efficiency,power,power,35,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:47,Availability,mask,mask,47,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:33,Performance,optimiz,optimized,33,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:3,Usability,Simpl,SimplifyDemandedBits,3,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:95,Energy Efficiency,schedul,scheduling,95,"// This pass converts a legalized DAG into a LoongArch-specific DAG, ready; // for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:404,Integrability,interface,interfaces,404,"//=- LoongArchISelLowering.cpp - LoongArch DAG Lowering Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that LoongArch uses to lower LLVM code into; // a selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,Modifiability,extend,extending,36,// Expand all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:46,Performance,load,loads,46,// Expand all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:28,Integrability,synchroniz,synchronize,28,"// singlethread fences only synchronize with signal handlers on the same; // thread and thus only need to preserve instruction order, not actually; // enforce memory ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:40,Security,access,access,40,// Use a PC-relative addressing mode to access the dynamic GOT address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:30,Availability,error,error,30,// Helper function that emits error message for intrinsics with chain and return; // merge values of a UNDEF and the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,Integrability,message,message,36,// Helper function that emits error message for intrinsics with chain and return; // merge values of a UNDEF and the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:30,Availability,error,error,30,// Helper function that emits error message for intrinsics with void return; // value and return the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,Integrability,message,message,36,// Helper function that emits error message for intrinsics with void return; // value and return the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:30,Availability,error,error,30,// Helper function that emits error message for intrinsics with/without chain; // and return a UNDEF or and the chain as the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,Integrability,message,message,36,// Helper function that emits error message for intrinsics with/without chain; // and return a UNDEF or and the chain as the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:41,Availability,mask,mask,41,// Op's second operand must be a shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:25,Availability,mask,mask,25,// Return if the shifted mask does not start at bit 0 or the sum of its; // length and lsb exceeds the word's size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:158,Availability,mask,mask,158,"// Pattern match BSTRPICK.; // $dst = and $src, (2**len- 1) , if len > 12; // => BSTRPICK $dst, $src, msb, lsb; // where lsb = 0 and msb = len - 1; // If the mask is <= 0xfff, andi can be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:100,Integrability,depend,depends,100,// Omit if the constant has more than 2 uses. This a conservative; // decision. Whether it is a win depends on the HW microarchitecture.; // However it should always be better for 1 and 2 uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:10,Performance,optimiz,optimize,10,"// Try to optimize to; // bstrpick $Rd, $Rs, msb, lsb; // slli $Rd, $Rd, lsb",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:25,Availability,Mask,Mask,25,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:70,Availability,Mask,MaskIdx,70,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:78,Availability,Mask,MaskLen-,78,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:104,Availability,Mask,Mask,104,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:122,Availability,mask,mask,122,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:132,Availability,Mask,MaskIdx,132,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:152,Availability,Mask,MaskIdx,152,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:160,Availability,Mask,MaskLen-,160,"// $dst = srl (and $src, Mask), Shamt; // =>; // BSTRPICK $dst, $src, MaskIdx+MaskLen-1, Shamt; // when Mask is a shifted mask, and MaskIdx <= Shamt <= MaskIdx+MaskLen-1; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:92,Availability,mask,mask,92,// The first operand must be an AND and the second operand of the AND must be; // a shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:52,Availability,mask,mask,52,"// 4th pattern to match BSTRINS:; // R = or (and X, mask), (shl Y, shamt); // where mask = (2**shamt - 1); // =>; // R = BSTRINS X, Y, ValBits - 1, shamt; // where ValBits = 32 or 64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:84,Availability,mask,mask,84,"// 4th pattern to match BSTRINS:; // R = or (and X, mask), (shl Y, shamt); // where mask = (2**shamt - 1); // =>; // R = BSTRINS X, Y, ValBits - 1, shamt; // where ValBits = 32 or 64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:52,Availability,mask,mask,52,"// 5th pattern to match BSTRINS:; // R = or (and X, mask), const; // where ~mask = (2**size - 1) << lsb, mask & const = 0; // =>; // R = BSTRINS X, (const >> lsb), msb, lsb; // where msb = lsb + size - 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:76,Availability,mask,mask,76,"// 5th pattern to match BSTRINS:; // R = or (and X, mask), const; // where ~mask = (2**size - 1) << lsb, mask & const = 0; // =>; // R = BSTRINS X, (const >> lsb), msb, lsb; // where msb = lsb + size - 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:105,Availability,mask,mask,105,"// 5th pattern to match BSTRINS:; // R = or (and X, mask), const; // where ~mask = (2**size - 1) << lsb, mask & const = 0; // =>; // R = BSTRINS X, (const >> lsb), msb, lsb; // where msb = lsb + size - 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:34,Availability,mask,mask,34,"// 6th pattern.; // a = b | ((c & mask) << shamt), where all positions in b to be overwritten; // by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, shamt + MaskLen - 1, shamt; //; // Note that the 1st pattern is a special situation of the 6th, i.e. the 6th; // pattern is more common than the 1st. So we put the 1st before the 6th in; // order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:178,Availability,Mask,MaskLen,178,"// 6th pattern.; // a = b | ((c & mask) << shamt), where all positions in b to be overwritten; // by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, shamt + MaskLen - 1, shamt; //; // Note that the 1st pattern is a special situation of the 6th, i.e. the 6th; // pattern is more common than the 1st. So we put the 1st before the 6th in; // order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:178,Availability,Mask,MaskIdx,178,"// 7th pattern.; // a = b | ((c << shamt) & shifted_mask), where all positions in b to be; // overwritten by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 7th pattern is more common than the 2nd. So we put the 2nd; // before the 7th in order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:188,Availability,Mask,MaskLen,188,"// 7th pattern.; // a = b | ((c << shamt) & shifted_mask), where all positions in b to be; // overwritten by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 7th pattern is more common than the 2nd. So we put the 2nd; // before the 7th in order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:201,Availability,Mask,MaskIdx,201,"// 7th pattern.; // a = b | ((c << shamt) & shifted_mask), where all positions in b to be; // overwritten by the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 7th pattern is more common than the 2nd. So we put the 2nd; // before the 7th in order to match as many nodes as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:169,Availability,Mask,MaskIdx,169,"// 8th pattern.; // a = b | (c & shifted_mask), where all positions in b to be overwritten by; // the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c >> MaskIdx, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 8th pattern is more common than the 4th and 5th patterns. So; // we put it here in order to match as many nodes as possible or generate less; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:178,Availability,Mask,MaskIdx,178,"// 8th pattern.; // a = b | (c & shifted_mask), where all positions in b to be overwritten by; // the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c >> MaskIdx, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 8th pattern is more common than the 4th and 5th patterns. So; // we put it here in order to match as many nodes as possible or generate less; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:188,Availability,Mask,MaskLen,188,"// 8th pattern.; // a = b | (c & shifted_mask), where all positions in b to be overwritten by; // the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c >> MaskIdx, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 8th pattern is more common than the 4th and 5th patterns. So; // we put it here in order to match as many nodes as possible or generate less; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:201,Availability,Mask,MaskIdx,201,"// 8th pattern.; // a = b | (c & shifted_mask), where all positions in b to be overwritten by; // the incoming bits are known to be zero.; // =>; // a = BSTRINS b, c >> MaskIdx, MaskIdx + MaskLen - 1, MaskIdx; //; // Similarly, the 8th pattern is more common than the 4th and 5th patterns. So; // we put it here in order to match as many nodes as possible or generate less; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear Divisor's kill flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:25,Integrability,depend,dependent,25,// TODO: Add more target-dependent nodes later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:427,Availability,avail,available,427,"//===----------------------------------------------------------------------===//; // Calling Convention Implementation; //===----------------------------------------------------------------------===//; // Eight general-purpose registers a0-a7 used for passing integer arguments,; // with a0-a1 reused to return values. Generally, the GPRs are used to pass; // fixed-point arguments, and floating-point arguments when no FPR is available; // or with soft float ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:66,Availability,failure,failure,66,// Implements the LoongArch calling convention. Returns true upon failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:51,Availability,avail,available,51,"// If passing a variadic argument, or if no FPR is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate to a register if possible, or else a stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:33,Performance,load,loading,33,// The caller is responsible for loading the full value if the argument is; // passed with CCValAssign::Indirect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:78,Performance,load,load,78,"// If the original argument was split and passed by reference, we need to; // load all parts of it here (using the same address).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:23,Modifiability,variab,variable,23,"// Offset of the first variable argument from stack pointer, and size of; // the vararg save area. For now, the varargs save area is either zero or; // large enough to hold a0-a7.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:24,Energy Efficiency,allocate,allocated,24,"// If all registers are allocated, then all varargs must be passed on the; // stack and we don't need to save any argregs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument; // which is a value necessary to VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:87,Performance,perform,perform,87,"// Check if the return value is used as only a return value, as otherwise; // we can't perform a tail-call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:91,Performance,perform,perform,91,"// If the ISD::CopyToReg has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:83,Safety,safe,safe,83,"// If the ISD::CopyToReg has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:52,Performance,optimiz,optimization,52,// Check whether the call is eligible for tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:105,Performance,perform,performing,105,// Calculate the total size to store. We don't have access to what we're; // actually storing other than performing the loop and collecting the; // info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:52,Security,access,access,52,// Calculate the total size to store. We don't have access to what we're; // actually storing other than performing the loop and collecting the; // info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Performance,Queue,Queue,3,// Queue up the argument copies and emit them at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue node if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:49,Modifiability,extend,extended,49,"// TODO: Add more AtomicRMWInst that needs to be extended.; // Since floating-point operation requires a non-trivial set of data; // operations, use CmpXChg to expand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:152,Availability,mask,mask,152,"// In the case of an atomicrmw xchg with a constant 0/-1 operand, replace; // the atomic instruction with an AtomicRMWInst::And/Or with appropriate; // mask, as this produces better code than the LL/SC loop emitted by; // int_loongarch_masked_atomicrmw_xchg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:45,Modifiability,extend,extend,45,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass GRLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:308,Modifiability,extend,extend,308,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass GRLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:56,Performance,load,loaded,56,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass GRLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:82,Performance,perform,performing,82,"// Must pass the shift amount needed to sign extend the loaded value prior; // to performing a signed comparison for min/max. ShiftAmt is the number of; // bits to shift the value into position. Pass GRLen-ShiftAmt-ValWidth, which; // is the number of bits to left+right shift the value in order to; // sign-extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:117,Availability,avail,available,117,"// LoongArch specific constraints in GCC: config/loongarch/constraints.md; //; // 'f': A floating-point register (if available).; // 'k': A memory operand whose address is formed by a base register and; // (optionally scaled) index register.; // 'l': A signed 16-bit constant.; // 'm': A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as st.w and ld.w.; // 'I': A signed 12-bit constant (for arithmetic instructions).; // 'J': Integer zero.; // 'K': An unsigned 12-bit constant (for logic instructions).; // ""ZB"": An address that is held in a general-purpose register. The offset is; // zero.; // ""ZC"": A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as ll.w and sc.w.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:42,Modifiability,config,config,42,"// LoongArch specific constraints in GCC: config/loongarch/constraints.md; //; // 'f': A floating-point register (if available).; // 'k': A memory operand whose address is formed by a base register and; // (optionally scaled) index register.; // 'l': A signed 16-bit constant.; // 'm': A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as st.w and ld.w.; // 'I': A signed 12-bit constant (for arithmetic instructions).; // 'J': Integer zero.; // 'K': An unsigned 12-bit constant (for logic instructions).; // ""ZB"": An address that is held in a general-purpose register. The offset is; // zero.; // ""ZC"": A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as ll.w and sc.w.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:584,Testability,log,logic,584,"// LoongArch specific constraints in GCC: config/loongarch/constraints.md; //; // 'f': A floating-point register (if available).; // 'k': A memory operand whose address is formed by a base register and; // (optionally scaled) index register.; // 'l': A signed 16-bit constant.; // 'm': A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as st.w and ld.w.; // 'I': A signed 12-bit constant (for arithmetic instructions).; // 'J': Integer zero.; // 'K': An unsigned 12-bit constant (for logic instructions).; // ""ZB"": An address that is held in a general-purpose register. The offset is; // zero.; // ""ZC"": A memory operand whose address is formed by a base register and; // offset that is suitable for use in instructions with the same; // addressing mode as ll.w and sc.w.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:64,Availability,avail,available,64,// Match those names to the widest floating point register type available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 16-bit signed immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 12-bit signed immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create an integer zero operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Security,Validat,Validate,3,// Validate & create a 12-bit unsigned immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:12,Performance,optimiz,optimization,12,// Omit the optimization if the data size exceeds GRLen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:33,Performance,optimiz,optimized,33,"// Reject multiplications can be optimized to; // (SLLI (ALSL x, x, 1/2/3/4), s).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:49,Performance,load,load,49,// Zexts are free if they can be combined with a load.; // Don't advertise i32->i64 zextload as being free for LA64. It interacts; // poorly with type legalization of compares preferring sext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:54,Integrability,Interface,Interface,54,"//=- LoongArchISelLowering.h - LoongArch DAG Lowering Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that LoongArch uses to lower LLVM code into; // a selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:405,Integrability,interface,interfaces,405,"//=- LoongArchISelLowering.h - LoongArch DAG Lowering Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that LoongArch uses to lower LLVM code into; // a selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:37,Availability,mask,mask,37,// Similar to CSRWR but with a write mask.; // Operand 0: A chain pointer.; // Operand 1: The new value to write.; // Operand 2: The write mask.; // Operand 3: The address of the required CSR.; // Result 0: The old value of the CSR.; // Result 1: The new chain pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:139,Availability,mask,mask,139,// Similar to CSRWR but with a write mask.; // Operand 0: A chain pointer.; // Operand 1: The new value to write.; // Operand 2: The write mask.; // Operand 3: The address of the required CSR.; // Result 0: The old value of the CSR.; // Result 1: The new chain pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:9,Security,access,access,9,// IOCSR access operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:12,Deployability,configurat,configuration,12,// Read CPU configuration information operation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:12,Modifiability,config,configuration,12,// Read CPU configuration information operation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h:3,Modifiability,Extend,Extended,3,// Extended vector element extraction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp:72,Energy Efficiency,allocate,allocate,72,// fp; // Reserve the base register if we need to realign the stack and allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp:85,Modifiability,variab,variable-sized,85,// fp; // Reserve the base register if we need to realign the stack and allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp:131,Testability,test,tested,131,// TODO: this implementation is a temporary placeholder which does just; // enough to allow other aspects of code generation to be tested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp:178,Performance,Tune,TuneCPU,178,"// Initialize CPU specific properties. We should add a tablegen feature for; // this in the future so we can specify it together with the subtarget; // features.; // TODO: Check TuneCPU and override defaults (that are for LA464) once we; // support optimizing for more uarchs.; // Default to the alignment settings empirically confirmed to perform best; // on LA464, with 4-wide instruction fetch and decode stages. These settings; // can also be overridden in initializeProperties.; //; // We default to such higher-than-minimum alignments because we assume that:; //; // * these settings should benefit most existing uarchs/users,; // * future general-purpose LoongArch cores are likely to have issue widths; // equal to or wider than 4,; // * instruction sequences best for LA464 should not pessimize other future; // uarchs, and; // * narrower cores would not suffer much (aside from slightly increased; // ICache footprint maybe), compared to the gains everywhere else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp:249,Performance,optimiz,optimizing,249,"// Initialize CPU specific properties. We should add a tablegen feature for; // this in the future so we can specify it together with the subtarget; // features.; // TODO: Check TuneCPU and override defaults (that are for LA464) once we; // support optimizing for more uarchs.; // Default to the alignment settings empirically confirmed to perform best; // on LA464, with 4-wide instruction fetch and decode stages. These settings; // can also be overridden in initializeProperties.; //; // We default to such higher-than-minimum alignments because we assume that:; //; // * these settings should benefit most existing uarchs/users,; // * future general-purpose LoongArch cores are likely to have issue widths; // equal to or wider than 4,; // * instruction sequences best for LA464 should not pessimize other future; // uarchs, and; // * narrower cores would not suffer much (aside from slightly increased; // ICache footprint maybe), compared to the gains everywhere else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp:340,Performance,perform,perform,340,"// Initialize CPU specific properties. We should add a tablegen feature for; // this in the future so we can specify it together with the subtarget; // features.; // TODO: Check TuneCPU and override defaults (that are for LA464) once we; // support optimizing for more uarchs.; // Default to the alignment settings empirically confirmed to perform best; // on LA464, with 4-wide instruction fetch and decode stages. These settings; // can also be overridden in initializeProperties.; //; // We default to such higher-than-minimum alignments because we assume that:; //; // * these settings should benefit most existing uarchs/users,; // * future general-purpose LoongArch cores are likely to have issue widths; // equal to or wider than 4,; // * instruction sequences best for LA464 should not pessimize other future; // uarchs, and; // * narrower cores would not suffer much (aside from slightly increased; // ICache footprint maybe), compared to the gains everywhere else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule the expansion of AtomicPseudos at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LL/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp:76,Safety,avoid,avoiding,76,"// Schedule the expansion of AtomicPseudos at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LL/SC block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:151,Availability,failure,failure,151,"// Attempts to match Name as a register (either using the default name or; // alternative ABI names), setting RegNo to the matching register. Upon; // failure, returns true and sets RegNo to 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:87,Integrability,message,message,87,"// If there is a next operand and it is 0, ignore it. Otherwise print a; // diagnostic message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:127,Availability,error,error,127,"/// Looks at a token type and creates the relevant operand from this; /// information, adding to Operands. Return true upon an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:28,Availability,error,error,28,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:34,Integrability,message,message,34,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/Disassembler/LoongArchDisassembler.cpp:38,Modifiability,extend,extend,38,"// Shift left Imm <S> bits, then sign-extend the number in the bottom <N+S>; // bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/Disassembler/LoongArchDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/Disassembler/LoongArchDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp:80,Usability,simpl,simply,80,// Calculate total Nops we need to insert. If there are none to insert; // then simply return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp:206,Availability,error,error,206,"// We need record relocation if SecA != SecB. Usually SecB is same as the; // section of Fixup, which will be record the relocation as PCRel. If SecB; // is not same as the section of Fixup, it will report error. Just return; // false and then this work can be finished by handleFixup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp:204,Safety,avoid,avoid,204,"// In SecA == SecB case. If the linker relaxation is enabled, we need record; // the ADD, SUB relocations. Otherwise the FixedValue has already been calc-; // ulated out in evaluateFixup, return true and avoid record relocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchBaseInfo.cpp:6,Safety,avoid,avoid,6,"// To avoid the BP value clobbered by a function call, we need to choose a; // callee saved register to save the value. The `last` `S` register (s9) is; // used for FP. So we choose the previous (s8) as BP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchBaseInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchBaseInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h:27,Integrability,interface,interface,27,"//===-- M68k.h - Top-level interface for M68k representation ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the entry points for global functions defined in the; /// M68k target library, as used by the LLVM JIT.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h:92,Energy Efficiency,schedul,scheduling,92,"/// This pass converts a legalized DAG into a M68k-specific DAG, ready for; /// instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68k.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kAsmPrinter.cpp:488,Integrability,depend,dependent,488,"//===-- M68kAsmPrinter.cpp - M68k LLVM Assembly Printer ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a printer that converts from our internal representation; /// of machine-dependent LLVM code to GAS-format M68k assembly language.; ///; //===----------------------------------------------------------------------===//; // TODO Conform to Motorola ASM syntax",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h:43,Integrability,Rout,Routines,43,"//===-- M68kCallingConv.h - M68k Custom CC Routines -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the custom routines for the M68k Calling Convention; /// that aren't done by tablegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h:426,Integrability,rout,routines,426,"//===-- M68kCallingConv.h - M68k Custom CC Routines -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the custom routines for the M68k Calling Convention; /// that aren't done by tablegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:487,Availability,mask,mask,487,"//===-- M68kCollapseMOVEMPass.cpp - Expand MOVEM pass -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// `MOVEM` is an instruction that moves multiple registers a time according to; /// the given mask. Thus sometimes it's pretty expensive.; /// This file contains a pass that collapses sequential MOVEM instructions into; /// a single one.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:32,Availability,Mask,Mask,32,// You need to call this before Mask update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:37,Deployability,update,update,37,// You need to call this before Mask update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:159,Availability,mask,mask,159,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:407,Availability,redundant,redundant,407,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:232,Performance,perform,perform,232,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:407,Safety,redund,redundant,407,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:178,Security,access,access,178,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:36,Availability,Mask,Mask,36,"// If current Type, Reg, Offset and Mask is in proper order then; // merge in the state",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp:501,Energy Efficiency,schedul,scheduling,501,"//===-- M68kExpandPseudo.cpp - Expand pseudo instructions -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a pass that expands pseudo instructions into target; /// instructions to allow proper scheduling, if-conversion, other late; /// optimizations, or simply the encoding of the instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp:544,Performance,optimiz,optimizations,544,"//===-- M68kExpandPseudo.cpp - Expand pseudo instructions -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a pass that expands pseudo instructions into target; /// instructions to allow proper scheduling, if-conversion, other late; /// optimizations, or simply the encoding of the instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp:562,Usability,simpl,simply,562,"//===-- M68kExpandPseudo.cpp - Expand pseudo instructions -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a pass that expands pseudo instructions into target; /// instructions to allow proper scheduling, if-conversion, other late; /// optimizations, or simply the encoding of the instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:56,Testability,log,logic,56,"// NOTE: this only has a subset of the full frame index logic. In; // particular, the FI < 0 and AfterFPPop logic is handled in; // M68kRegisterInfo::eliminateFrameIndex, but not here. Possibly; // (probably?) it should be moved into here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:108,Testability,log,logic,108,"// NOTE: this only has a subset of the full frame index logic. In; // particular, the FI < 0 and AfterFPPop logic is handled in; // M68kRegisterInfo::eliminateFrameIndex, but not here. Possibly; // (probably?) it should be moved into here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:205,Integrability,depend,depending,205,"// Offset will hold the offset from the stack pointer at function entry to the; // object.; // We need to factor in additional offsets applied during the prologue to the; // frame, base, and stack pointer depending on which is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:189,Performance,perform,perform,189,"// This function is normally used with SP which is Address Register, but AND,; // or any other logical instructions in M68k do not support ARs so we need; // to use a temp Data Register to perform the op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:95,Testability,log,logical,95,"// This function is normally used with SP which is Address Register, but AND,; // or any other logical instructions in M68k do not support ARs so we need; // to use a temp Data Register to perform the op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:173,Integrability,depend,depends,173,"// If we don't have FP, but need to generate unwind information,; // we need to set the correct CFA offset after the stack adjustment.; // How much we adjust the CFA offset depends on whether we're emitting; // CFI only for EH purposes or for debugging. EH only requires the CFA; // offset to be correct at each call site, while for debugging we want; // it to be more precise.; // TODO: When not using precise CFA, we also need to adjust for the; // InternalAmt here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:13,Performance,perform,performing,13,"// If we are performing frame pointer elimination and if the callee pops; // something off the stack pointer, add it back. We do this until we have; // more advanced stack pointer tracking ability.; // We are not tracking the stack pointer adjustment by the callee, so make; // sure we restore the stack pointer immediately after the call, there may; // be spill code inserted between the CALL and ADJCALLSTACKUP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:73,Performance,load,load,73,"// Rather than emit a long series of instructions for large offsets,; // load the offset into a register and do one sub/add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:9,Deployability,Update,Update,9,// FIXME Update CCR as well. For now we just; // conservatively say CCR implicit def is dead,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:22,Energy Efficiency,allocate,allocate,22,// Number of bytes to allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:98,Performance,optimiz,optimized,98,// Insert stack pointer adjustment for later moving of return addr. Only; // applies to tail call optimized functions where the callee argument stack; // size is bigger than the callers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:145,Deployability,Update,Update,145,"// Get the offset of the stack slot for the FP register, which is; // guaranteed to be the last slot by processFunctionBeforeFrameFinalized.; // Update the frame offset adjustment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:151,Energy Efficiency,allocate,allocated,151,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:117,Modifiability,variab,variable,117,"// If we need a base pointer, set it up here. It's whatever the value; // of the stack pointer is at this point. Any variable size objects; // will be allocated after this, so we can still use the base pointer; // to reference locals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:3,Deployability,Update,Update,3,// Update the base pointer with the current stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:69,Integrability,depend,dependence,69,// Stash value of base pointer. Saving SP instead of FP shortens; // dependence chain. Used by SjLj EH.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:138,Usability,Clear,Clear,138,"// TODO Interrupt handlers; // M68k Interrupt handling function cannot assume anything about the; // direction flag (DF in CCR register). Clear this flag by creating ""cld""; // instruction in each prologue of interrupt handler function. The ""cld""; // instruction should only in these cases:; // 1. The interrupt handling function uses any of the ""rep"" instructions.; // 2. Interrupt handling function calls another function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:181,Safety,safe,safely,181,"// 'move %FramePtr, SP' will not be recognized as an epilogue sequence.; // However, we may use this sequence if we have a frame pointer because the; // effects of the prologue can safely be undone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:191,Usability,undo,undone,191,"// 'move %FramePtr, SP' will not be recognized as an epilogue sequence.; // However, we may use this sequence if we have a frame pointer because the; // effects of the prologue can safely be undone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:164,Safety,avoid,avoiding,164,"// Since emitPrologue and emitEpilogue will handle spilling and restoring of; // the frame register, we can delete it from CSI list and not have to worry; // about avoiding it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:3,Performance,Cache,Cached,3,// Cached subtarget predicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:4,Integrability,Wrap,Wraps,4,/// Wraps up getting a CFI index and building a MachineInstr for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:446,Availability,avail,available,446,"/// This method determines which of the registers reported by; /// TargetRegisterInfo::getCalleeSavedRegs() should actually get saved.; /// The default implementation checks populates the \p SavedRegs bitset with; /// all registers which are modified in the function, targets may override; /// this function to save additional registers.; /// This method also sets up the register scavenger ensuring there is a free; /// register or a frameindex available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:52,Testability,log,logic,52,"/// Allows target to override spill slot assignment logic. If implemented,; /// assignCalleeSavedSpillSlots() should assign frame slots to all CSI; /// entries and return true. If this method returns false, spill slots will; /// be assigned using generic implementation. assignCalleeSavedSpillSlots(); /// may add, delete or rearrange elements of CSI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:157,Performance,load,load,157,/// Issues instruction(s) to restore all callee saved registers and returns; /// true if it isn't possible / profitable to do so by issuing a series of; /// load instructions via loadRegToStackSlot(). Returns false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:179,Performance,load,loadRegToStackSlot,179,/// Issues instruction(s) to restore all callee saved registers and returns; /// true if it isn't possible / profitable to do so by issuing a series of; /// load instructions via loadRegToStackSlot(). Returns false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:128,Modifiability,variab,variable,128,"/// Return true if the specified function should have a dedicated frame; /// pointer register. This is true if the function has variable sized; /// allocas, if it needs dynamic stack realignment, if frame pointer; /// elimination is disabled, or if the frame address is taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:74,Usability,simpl,simplified,74,"/// If there is a reserved call frame, the call frame pseudos can be; /// simplified. Having a FP, as in the default implementation, is not; /// sufficient here since we can't always use it. Use a more nuanced; /// condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:17,Performance,perform,perform,17,"// Do we need to perform FI resolution for this function. Normally, this is; // required only when the function has any stack objects. However, FI; // resolution actually has another job, not apparent from the title - it; // resolves callframe setup/destroy that were not simplified earlier.; //; // So, this is required for M68k functions that have push sequences even; // when there are no stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:272,Usability,simpl,simplified,272,"// Do we need to perform FI resolution for this function. Normally, this is; // required only when the function has any stack objects. However, FI; // resolution actually has another job, not apparent from the title - it; // resolves callframe setup/destroy that were not simplified earlier.; //; // So, this is required for M68k functions that have push sequences even; // when there are no stack objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h:773,Integrability,wrap,wrapping,773,"//===-- M68kInstrBuilder.h - Functions to build M68k insts ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file exposes functions that may be used with BuildMI from the; /// MachineInstrBuilder.h file to handle M68k'isms in a clean way.; ///; /// TODO The BuildMem function may be used with the BuildMI function to add; /// entire memory references in a single, typed, function call. M68k memory; /// references can be very complex expressions (described in the README), so; /// wrapping them up behind an easier to use interface makes sense.; /// Descriptions of the functions are included below.; ///; /// For reference, the order of operands for memory references is:; /// (Operand), Base, Scale, Index, Displacement.; ///; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h:814,Integrability,interface,interface,814,"//===-- M68kInstrBuilder.h - Functions to build M68k insts ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file exposes functions that may be used with BuildMI from the; /// MachineInstrBuilder.h file to handle M68k'isms in a clean way.; ///; /// TODO The BuildMem function may be used with the BuildMI function to add; /// entire memory references in a single, typed, function call. M68k memory; /// references can be very complex expressions (described in the README), so; /// wrapping them up behind an easier to use interface makes sense.; /// Descriptions of the functions are included below.; ///; /// For reference, the order of operands for memory references is:; /// (Operand), Base, Scale, Index, Displacement.; ///; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h:406,Security,expose,exposes,406,"//===-- M68kInstrBuilder.h - Functions to build M68k insts ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file exposes functions that may be used with BuildMI from the; /// MachineInstrBuilder.h file to handle M68k'isms in a clean way.; ///; /// TODO The BuildMem function may be used with the BuildMI function to add; /// entire memory references in a single, typed, function call. M68k memory; /// references can be very complex expressions (described in the README), so; /// wrapping them up behind an easier to use interface makes sense.; /// Descriptions of the functions are included below.; ///; /// For reference, the order of operands for memory references is:; /// (Operand), Base, Scale, Index, Displacement.; ///; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:71,Safety,abort,abort,71,"// In practice we should never have an undef CCR operand, if we do; // abort here as we are not prepared to preserve the flag.; // ??? Is this required?; // if (iter->getOperand(1).isUndef()); // return true;; // Working from the bottom, handle the first conditional branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:291,Energy Efficiency,efficient,efficient,291,// And we are allowed to modify the block and the target block of the; // conditional branch is the direct successor of this block:; //; // bcc l1; // bra l2; // l1:; // ...; // l2:; //; // we change it to this if allowed:; //; // bncc l2; // l1:; // ...; // l2:; //; // Which is a bit more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:322,Performance,cache,cache,322,"// We need the subreg of Dst to make instruction verifier happy because the; // real machine instruction consumes and produces values of the same size and; // the registers the will be used here fall into different classes and this; // makes IV cry. We could use a bigger operation, but this will put some; // pressure on cache and memory, so no.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:318,Energy Efficiency,allocate,allocate,318,"// Create the register. The code to initialize it is inserted later,; // by the M68kGlobalBaseReg pass (below).; //; // NOTE; // Normally M68k uses A5 register as global base pointer but this will; // create unnecessary spill if we use less then 4 registers in code; since A5; // is callee-save anyway we could try to allocate caller-save first and if; // lucky get one, otherwise it does not really matter which callee-save to; // use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h:9,Usability,Clear,Clear,9,// Carry Clear,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h:12,Usability,Clear,Clear,12,// Overflow Clear,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h:27,Modifiability,extend,extend,27,/// Move from register and extend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h:25,Modifiability,extend,extend,25,/// Move from memory and extend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:92,Energy Efficiency,schedul,scheduling,92,"/// This pass converts a legalized DAG into a M68k-specific DAG,; /// ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:103,Safety,avoid,avoids,103,"// TODO: Post-processing: Convert lea(,%reg,2) to lea(%reg,%reg), which has; // a smaller encoding and avoids a scaled-index.; // And make sure it is an indexed mode; // TODO: Post-processing: Convert foo to foo(%pc), even in non-PIC mode,; // because it has a smaller encoding.; // Make sure this must be done only if PC* modes are currently being matched",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:129,Availability,down,down,129,"/// Try to match M68kISD::Wrapper and M68kISD::WrapperPC nodes into an; /// addressing mode. These wrap things that will resolve down into a symbol; /// reference. If no match is possible, this returns true, otherwise it returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:26,Integrability,Wrap,Wrapper,26,"/// Try to match M68kISD::Wrapper and M68kISD::WrapperPC nodes into an; /// addressing mode. These wrap things that will resolve down into a symbol; /// reference. If no match is possible, this returns true, otherwise it returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:47,Integrability,Wrap,WrapperPC,47,"/// Try to match M68kISD::Wrapper and M68kISD::WrapperPC nodes into an; /// addressing mode. These wrap things that will resolve down into a symbol; /// reference. If no match is possible, this returns true, otherwise it returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:99,Integrability,wrap,wrap,99,"/// Try to match M68kISD::Wrapper and M68kISD::WrapperPC nodes into an; /// addressing mode. These wrap things that will resolve down into a symbol; /// reference. If no match is possible, this returns true, otherwise it returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:8,Integrability,wrap,wrapper,8,// This wrapper requires 32bit disp/imm field for Medium CM,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:93,Usability,simpl,simply,93,"// TODO: The ordering of the following SelectXXX is relatively...arbitrary,; // right now we simply sort them by descending complexity. Maybe we should; // adjust this by code model and/or relocation mode in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:418,Integrability,interface,interfaces,418,"//===-- M68kISelLowering.cpp - M68k DAG Lowering Impl -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interfaces that M68k uses to lower LLVM code into a; /// selection DAG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:59,Integrability,depend,dependences,59,// Add/Sub overflow ops with MVT::Glues are lowered to CCR dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:60,Availability,avail,available,60,/// Return true if the given stack call argument is already available in the; /// same position (relatively) of the caller's incoming argument stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Load,Load,3,"// Load the ""old"" Return address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:39,Performance,load,load,39,// Create the nodes corresponding to a load from this parameter slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:65,Performance,load,loading,65,// Because we are dealing with BE architecture we need to offset loading of; // partial types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:267,Performance,optimiz,optimization,267,"// TODO Interrupt handlers; // Calculate SP offset of interrupt parameter, re-arrange the slot normally; // taken by a return address.; // FIXME For now, all byval parameter objects are marked mutable. This can; // be changed with more analysis. In case of tail call optimization mark all; // arguments mutable. Since they could be overwritten by lowering of arguments; // in case of a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:30,Safety,detect,detected,30,// Sibcalls are automatically detected tailcalls which do not require; // ABI changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:46,Availability,avail,available,46,// This is a sibcall. The memory operands are available in caller's; // own caller's stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:69,Energy Efficiency,allocate,allocated,69,"// If we have an inalloca argument, all stack space has already been allocated; // for us and be right at the top of the stack. We don't support multiple; // arguments passed in memory when using inalloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Load,Load,3,// Load return address for tail calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads. In the case; // of tail call optimization arguments are handle later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:94,Performance,optimiz,optimization,94,"// Walk the register/memloc assignments, inserting copies/loads. In the case; // of tail call optimization arguments are handle later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:359,Integrability,depend,depends,359,"// Force all the incoming stack arguments to be loaded from the stack; // before any new outgoing arguments are stored to the stack, because the; // outgoing stack slots may alias the incoming argument stack slots, and; // the alias isn't otherwise explicit. This is slightly more conservative; // than necessary, because it means that each store effectively depends; // on every argument instead of just those arguments it would clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:48,Performance,load,loaded,48,"// Force all the incoming stack arguments to be loaded from the stack; // before any new outgoing arguments are stored to the stack, because the; // outgoing stack slots may alias the incoming argument stack slots, and; // the alias isn't otherwise explicit. This is slightly more conservative; // than necessary, because it means that each store effectively depends; // on every argument instead of just those arguments it would clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:23,Performance,load,load,23,// We should use extra load for direct calls to dllimported functions in; // non-JIT mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:9,Integrability,wrap,wrapper,9,// Add a wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:91,Testability,assert,assert,91,"// If this is an 8 or 16-bit value, it is really passed promoted to 32; // bits. Insert an assert[sz]ext to capture this, then truncate to the; // right size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:41,Performance,load,load,41,// If value is passed via pointer - do a load.; // TODO Make sure this handling on indirect arguments is correct,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:167,Security,access,access,167,// ABI require that for returning structs by value we copy the sret argument; // into %D0 for the return. Save the argument into a virtual register so; // that we can access it from the return points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:25,Modifiability,variab,variable,25,"// If the function takes variable number of arguments, make a frame index for; // the start of the first vararg value... for expansion of llvm.va_start. We; // can skip this if there are no va_start calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:39,Energy Efficiency,schedul,schedule,39,// FIXME Can we use a less constrained schedule?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:23,Deployability,update,updated,23,// Operand #0 = Chain (updated below),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:308,Security,access,access,308,"// Swift calling convention does not require we copy the sret argument; // into %d0 for the return, and SRetReturnReg is not set for Swift.; // ABI require that for returning structs by value we copy the sret argument; // into %D0 for the return. Save the argument into a virtual register so that; // we can access it from the return points.; //; // Checking Function.hasStructRetAttr() here is insufficient because the IR; // may not have an explicit sret argument. If MFI.CanLowerReturn is; // false, then an sret argument may be implicitly inserted in the SelDAG. In; // either case MFI->setSRetReturnReg() will have been called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:208,Deployability,update,updated,208,"// ??? Can i just move this to the top and escape this explanation?; // When we have both sret and another return value, we should use the; // original Chain stored in RetOps[0], instead of the current Chain updated; // in the above loop. If we only have sret, RetOps[0] equals to Chain.; // For the case of sret and another return value, we have; // Chain_0 at the function entry; // Chain_1 = getCopyToReg(Chain_0) in the above loop; // If we use Chain_1 in getCopyFromReg, we will have; // Val = getCopyFromReg(Chain_1); // Chain_2 = getCopyToReg(Chain_1, Val) from below; // getCopyToReg(Chain_0) will be glued together with; // getCopyToReg(Chain_1, Val) into Unit A, getCopyFromReg(Chain_1) will be; // in Unit B, and we will have cyclic dependency between Unit A and Unit B:; // Data dependency from Unit B to Unit A due to usage of Val in; // getCopyToReg(Chain_1, Val); // Chain dependency from Unit A to Unit B; // So here, we use RetOps[0] (i.e Chain_0) for getCopyFromReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:744,Integrability,depend,dependency,744,"// ??? Can i just move this to the top and escape this explanation?; // When we have both sret and another return value, we should use the; // original Chain stored in RetOps[0], instead of the current Chain updated; // in the above loop. If we only have sret, RetOps[0] equals to Chain.; // For the case of sret and another return value, we have; // Chain_0 at the function entry; // Chain_1 = getCopyToReg(Chain_0) in the above loop; // If we use Chain_1 in getCopyFromReg, we will have; // Val = getCopyFromReg(Chain_1); // Chain_2 = getCopyToReg(Chain_1, Val) from below; // getCopyToReg(Chain_0) will be glued together with; // getCopyToReg(Chain_1, Val) into Unit A, getCopyFromReg(Chain_1) will be; // in Unit B, and we will have cyclic dependency between Unit A and Unit B:; // Data dependency from Unit B to Unit A due to usage of Val in; // getCopyToReg(Chain_1, Val); // Chain dependency from Unit A to Unit B; // So here, we use RetOps[0] (i.e Chain_0) for getCopyFromReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:791,Integrability,depend,dependency,791,"// ??? Can i just move this to the top and escape this explanation?; // When we have both sret and another return value, we should use the; // original Chain stored in RetOps[0], instead of the current Chain updated; // in the above loop. If we only have sret, RetOps[0] equals to Chain.; // For the case of sret and another return value, we have; // Chain_0 at the function entry; // Chain_1 = getCopyToReg(Chain_0) in the above loop; // If we use Chain_1 in getCopyFromReg, we will have; // Val = getCopyFromReg(Chain_1); // Chain_2 = getCopyToReg(Chain_1, Val) from below; // getCopyToReg(Chain_0) will be glued together with; // getCopyToReg(Chain_1, Val) into Unit A, getCopyFromReg(Chain_1) will be; // in Unit B, and we will have cyclic dependency between Unit A and Unit B:; // Data dependency from Unit B to Unit A due to usage of Val in; // getCopyToReg(Chain_1, Val); // Chain dependency from Unit A to Unit B; // So here, we use RetOps[0] (i.e Chain_0) for getCopyFromReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:888,Integrability,depend,dependency,888,"// ??? Can i just move this to the top and escape this explanation?; // When we have both sret and another return value, we should use the; // original Chain stored in RetOps[0], instead of the current Chain updated; // in the above loop. If we only have sret, RetOps[0] equals to Chain.; // For the case of sret and another return value, we have; // Chain_0 at the function entry; // Chain_1 = getCopyToReg(Chain_0) in the above loop; // If we use Chain_1 in getCopyFromReg, we will have; // Val = getCopyFromReg(Chain_1); // Chain_2 = getCopyToReg(Chain_1, Val) from below; // getCopyToReg(Chain_0) will be glued together with; // getCopyToReg(Chain_1, Val) into Unit A, getCopyFromReg(Chain_1) will be; // in Unit B, and we will have cyclic dependency between Unit A and Unit B:; // Data dependency from Unit B to Unit A due to usage of Val in; // getCopyToReg(Chain_1, Val); // Chain dependency from Unit A to Unit B; // So here, we use RetOps[0] (i.e Chain_0) for getCopyFromReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:421,Performance,optimiz,optimization,421,"//===----------------------------------------------------------------------===//; // Fast Calling Convention (tail call) implementation; //===----------------------------------------------------------------------===//; // Like std call, callee cleans arguments, convention except that ECX is; // reserved for storing the tail called function address. Only 2 registers are; // free for argument passing (inreg). Tail call optimization is performed; // provided:; // * tailcallopt is enabled; // * caller/callee are fastcc; // On M68k_64 architecture with GOT-style position independent code only; // local (within module) calls are supported at the moment. To keep the stack; // aligned according to platform abi the function GetAlignedArgumentStackSize; // ensures that argument delta is always multiples of stack alignment. (Dynamic; // linkers need this - darwin's dyld for example) If a tail called function; // callee has more arguments than the caller the caller needs to make sure that; // there is room to move the RETADDR to. This is achieved by reserving an area; // the size of the argument delta right after the original RETADDR, but before; // the saved framepointer or the spilled registers e.g. caller(arg1, arg2); // calls callee(arg1, arg2,arg3,arg4) stack layout:; // arg1; // arg2; // RETADDR; // [ new RETADDR; // move area ]; // (possible EBP); // ESI; // EDI; // local1 ..; /// Make the stack size align e.g 16n + 12 aligned for a 16-byte align; /// requirement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:437,Performance,perform,performed,437,"//===----------------------------------------------------------------------===//; // Fast Calling Convention (tail call) implementation; //===----------------------------------------------------------------------===//; // Like std call, callee cleans arguments, convention except that ECX is; // reserved for storing the tail called function address. Only 2 registers are; // free for argument passing (inreg). Tail call optimization is performed; // provided:; // * tailcallopt is enabled; // * caller/callee are fastcc; // On M68k_64 architecture with GOT-style position independent code only; // local (within module) calls are supported at the moment. To keep the stack; // aligned according to platform abi the function GetAlignedArgumentStackSize; // ensures that argument delta is always multiples of stack alignment. (Dynamic; // linkers need this - darwin's dyld for example) If a tail called function; // callee has more arguments than the caller the caller needs to make sure that; // there is room to move the RETADDR to. This is achieved by reserving an area; // the size of the argument delta right after the original RETADDR, but before; // the saved framepointer or the spilled registers e.g. caller(arg1, arg2); // calls callee(arg1, arg2,arg3,arg4) stack layout:; // arg1; // arg2; // RETADDR; // [ new RETADDR; // move area ]; // (possible EBP); // ESI; // EDI; // local1 ..; /// Make the stack size align e.g 16n + 12 aligned for a 16-byte align; /// requirement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Availability,Mask,Mask,3,"// Mask out lower bits, add stackalignment once plus the 12 bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:53,Performance,optimiz,optimization,53,/// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:106,Performance,optimiz,optimization,106,/// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:34,Performance,perform,perform,34,// Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes. This is what gcc calls sibcall.; // Can't do sibcall if stack needs to be dynamically re-aligned. PEI needs to; // emit a special epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:52,Performance,optimiz,optimization,52,// Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes. This is what gcc calls sibcall.; // Can't do sibcall if stack needs to be dynamically re-aligned. PEI needs to; // emit a special epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:20,Safety,safe,safe,20,// Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes. This is what gcc calls sibcall.; // Can't do sibcall if stack needs to be dynamically re-aligned. PEI needs to; // emit a special epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:22,Performance,optimiz,optimization,22,// Also avoid sibcall optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:8,Safety,avoid,avoid,8,// Also avoid sibcall optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:18,Performance,optimiz,optimize,18,// Do not sibcall optimize vararg calls unless all arguments are passed via; // registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:94,Energy Efficiency,allocate,allocate,94,"// If the tailcall address may be in a register, then make sure it's; // possible to register allocate for it. The call address can; // only target %A0 or %A1 since the tail call must be scheduled after; // callee-saved registers are restored. These happen to be the same; // registers used to pass 'inreg' arguments so watch out for those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:187,Energy Efficiency,schedul,scheduled,187,"// If the tailcall address may be in a register, then make sure it's; // possible to register allocate for it. The call address can; // only target %A0 or %A1 since the tail call must be scheduled after; // callee-saved registers are restored. These happen to be the same; // registers used to pass 'inreg' arguments so watch out for those.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:254,Safety,safe,safer,254,"// Shifts and add instructions in M68000 and M68010 support; // up to 32 bits, but mul only has 16-bit variant. So it's almost; // certainly beneficial to lower 8/16/32-bit mul to their; // add / shifts counterparts. But for 64-bits mul, it might be; // safer to just leave it to compiler runtime implementations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:23,Testability,Test,Test,23,/// Create a BTST (Bit Test) node - Test bit \p BitNo in \p Src and set; /// condition according to equal/not-equal condition code \p CC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:36,Testability,Test,Test,36,/// Create a BTST (Bit Test) node - Test bit \p BitNo in \p Src and set; /// condition according to equal/not-equal condition code \p CC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:34,Modifiability,extend,extend,34,"// If the operand types disagree, extend the shift amount to match. Since; // BTST ignores high bits (like shifts) we can use anyextend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:51,Testability,TEST,TEST,51,// Use BTST if the immediate can't be encoded in a TEST instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:101,Performance,load,load,101,"// First determine if it is required or is profitable to flip the operands.; // If LHS is a foldable load, but RHS is not, flip the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:84,Testability,TEST,TEST,84,"// See if we can use the CCR value from the operand instead of; // doing a separate TEST. TEST always sets OF and CF to 0, so unless; // we prove that the arithmetic won't overflow, we can't use OF or CF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:90,Testability,TEST,TEST,90,"// See if we can use the CCR value from the operand instead of; // doing a separate TEST. TEST always sets OF and CF to 0, so unless; // we prove that the arithmetic won't overflow, we can't use OF or CF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:35,Testability,TEST,TEST,35,"// Emit a CMP with 0, which is the TEST pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:193,Energy Efficiency,reduce,reduced,193,// Truncate operations may prevent the merge of the SETCC instruction; // and the arithmetic instruction before it. Attempt to truncate the operands; // of the arithmetic instruction and use a reduced bit-width instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:127,Modifiability,variab,variable,127,"// NOTICE: In the code below we use ArithOp to hold the arithmetic operation; // which may be the result of a CAST. We use the variable 'Op', which is the; // non-casted variable when we check for possible users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:170,Modifiability,variab,variable,170,"// NOTICE: In the code below we use ArithOp to hold the arithmetic operation; // which may be the result of a CAST. We use the variable 'Op', which is the; // non-casted variable when we check for possible users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:25,Testability,log,logical,25,// If we have a constant logical shift that's only used in a comparison; // against zero turn it into an equivalent AND. This allows turning it into; // a TEST instruction later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:155,Testability,TEST,TEST,155,// If we have a constant logical shift that's only used in a comparison; // against zero turn it into an equivalent AND. This allows turning it into; // a TEST instruction later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid undefined shifts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Safety,Avoid,Avoid,3,// Avoid large immediates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:90,Testability,TEST,TEST,90,"// If the primary 'and' result isn't used, don't bother using; // M68kISD::AND, because a TEST instruction will be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:113,Performance,load,load-modify-store,113,"// Due to the ISEL shortcoming noted above, be conservative if this op is; // likely to be selected as part of a load-modify-store instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:77,Deployability,update,update,77,"// If we found that truncation is beneficial, perform the truncation and; // update 'Op'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:46,Performance,perform,perform,46,"// If we found that truncation is beneficial, perform the truncation and; // update 'Op'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:65,Performance,optimiz,optimizations,65,// Use a target machine opcode to prevent further DAGCombine; // optimizations that may separate the arithmetic operations; // from the setcc node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:35,Testability,TEST,TEST,35,"// Emit a CMP with 0, which is the TEST pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:117,Safety,avoid,avoided,117,// Only promote the compare up to I32 if it is a 16 bit operation; // with an immediate. 16 bit immediates are to be avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize to BTST if possible.; // Lower (X & (1 << N)) == 0 to BTST(X, N).; // Lower ((X >>u N) & 1) != 0 to BTST(X, N).; // Lower ((X >>s N) & 1) != 0 to BTST(X, N).; // Lower (trunc (X >> N) to i1) to BTST(X, N).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:54,Usability,simpl,simplify,54,"// Look for X == 0, X == 1, X != 0, or X != 1. We can simplify some forms of; // these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:36,Testability,log,logical,36,/// Return true if opcode is a M68k logical comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:17,Performance,optimiz,optimizations,17,"// Apply further optimizations for special cases; // (select (x != 0), -1, 0) -> neg & sbb; // (select (x == 0), 0, -1) -> neg & sbb",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:134,Safety,avoid,avoids,134,// M68k doesn't have an i8 cmov. If both operands are the result of a; // truncate widen the cmov and push the truncate through. This avoids; // introducing a new branch during isel and doesn't add any extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:52,Safety,avoid,avoided,52,// Block CopyFromReg so partial register stalls are avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:10,Performance,optimiz,optimization,10,// Simple optimization when Cond is a constant to avoid generating; // M68kISD::CMOV if possible.; // TODO: Generalize this to use SelectionDAG::computeKnownBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:50,Safety,avoid,avoid,50,// Simple optimization when Cond is a constant to avoid generating; // M68kISD::CMOV if possible.; // TODO: Generalize this to use SelectionDAG::computeKnownBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Usability,Simpl,Simple,3,// Simple optimization when Cond is a constant to avoid generating; // M68kISD::CMOV if possible.; // TODO: Generalize this to use SelectionDAG::computeKnownBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:144,Testability,test,test,144,"// Also, recognize the pattern generated by an FCMP_UNE. We can emit; // two branches instead of an explicit OR instruction with a; // separate test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:158,Testability,test,test,158,"// ISD::AND; // Also, recognize the pattern generated by an FCMP_OEQ. We can emit; // two branches instead of an explicit AND instruction with a; // separate test. However, we only do this if this block doesn't; // have a fall-through edge, because this requires an explicit; // jmp when the condition is false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:104,Integrability,wrap,wrapped,104,"// ConstantPool, JumpTable, GlobalAddress, and ExternalSymbol are lowered as; // their target countpart wrapped in the M68kISD::Wrapper node. Suppose N is; // one of the above mentioned nodes. It has to be wrapped because otherwise; // Select(N) returns N. So the raw TargetGlobalAddress nodes, etc. can only; // be used to form addressing mode. These wrapped nodes will be selected; // into MOV32ri.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:128,Integrability,Wrap,Wrapper,128,"// ConstantPool, JumpTable, GlobalAddress, and ExternalSymbol are lowered as; // their target countpart wrapped in the M68kISD::Wrapper node. Suppose N is; // one of the above mentioned nodes. It has to be wrapped because otherwise; // Select(N) returns N. So the raw TargetGlobalAddress nodes, etc. can only; // be used to form addressing mode. These wrapped nodes will be selected; // into MOV32ri.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:206,Integrability,wrap,wrapped,206,"// ConstantPool, JumpTable, GlobalAddress, and ExternalSymbol are lowered as; // their target countpart wrapped in the M68kISD::Wrapper node. Suppose N is; // one of the above mentioned nodes. It has to be wrapped because otherwise; // Select(N) returns N. So the raw TargetGlobalAddress nodes, etc. can only; // be used to form addressing mode. These wrapped nodes will be selected; // into MOV32ri.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:352,Integrability,wrap,wrapped,352,"// ConstantPool, JumpTable, GlobalAddress, and ExternalSymbol are lowered as; // their target countpart wrapped in the M68kISD::Wrapper node. Suppose N is; // one of the above mentioned nodes. It has to be wrapped because otherwise; // Select(N) returns N. So the raw TargetGlobalAddress nodes, etc. can only; // be used to form addressing mode. These wrapped nodes will be selected; // into MOV32ri.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:30,Performance,load,load,30,"// For symbols that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:80,Performance,load,load,80,"// For symbols that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:42,Testability,stub,stub,42,"// For symbols that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:30,Performance,load,load,30,"// For globals that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:80,Performance,load,load,80,"// For globals that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:42,Testability,stub,stub,42,"// For globals that require a load from a stub to get the address, emit the; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:27,Deployability,update,update,27,// Should have kill-flag - update below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:789,Performance,perform,perform,789,"// This code lowers all pseudo-CMOV instructions. Generally it lowers these; // as described above, by inserting a MBB, and then making a PHI at the join; // point to select the true and false operands of the CMOV in the PHI.; //; // The code also handles two different cases of multiple CMOV opcodes; // in a row.; //; // Case 1:; // In this case, there are multiple CMOVs in a row, all which are based on; // the same condition setting (or the exact opposite condition setting).; // In this case we can lower all the CMOVs using a single inserted MBB, and; // then make a number of PHIs at the join point to model the CMOVs. The only; // trickiness here, is that in a case like:; //; // t2 = CMOV cond1 t1, f1; // t3 = CMOV cond1 t2, f2; //; // when rewriting this into PHIs, we have to perform some renaming on the; // temps since you cannot have a PHI operand refer to a PHI result earlier; // in the same block. The ""simple"" but wrong lowering would be:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t2(BB1), f2(BB2); //; // but clearly t2 is not defined in BB1, so that is incorrect. The proper; // renaming is to note that on the path through BB1, t2 is really just a; // copy of t1, and do that renaming, properly generating:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t1(BB1), f2(BB2); //; // Case 2, we lower cascaded CMOVs such as; //; // (CMOV (CMOV F, T, cc1), T, cc2); //; // to two successives branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:922,Usability,simpl,simple,922,"// This code lowers all pseudo-CMOV instructions. Generally it lowers these; // as described above, by inserting a MBB, and then making a PHI at the join; // point to select the true and false operands of the CMOV in the PHI.; //; // The code also handles two different cases of multiple CMOV opcodes; // in a row.; //; // Case 1:; // In this case, there are multiple CMOVs in a row, all which are based on; // the same condition setting (or the exact opposite condition setting).; // In this case we can lower all the CMOVs using a single inserted MBB, and; // then make a number of PHIs at the join point to model the CMOVs. The only; // trickiness here, is that in a case like:; //; // t2 = CMOV cond1 t1, f1; // t3 = CMOV cond1 t2, f2; //; // when rewriting this into PHIs, we have to perform some renaming on the; // temps since you cannot have a PHI operand refer to a PHI result earlier; // in the same block. The ""simple"" but wrong lowering would be:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t2(BB1), f2(BB2); //; // but clearly t2 is not defined in BB1, so that is incorrect. The proper; // renaming is to note that on the path through BB1, t2 is really just a; // copy of t1, and do that renaming, properly generating:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t1(BB1), f2(BB2); //; // Case 2, we lower cascaded CMOVs such as; //; // (CMOV (CMOV F, T, cc1), T, cc2); //; // to two successives branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:1035,Usability,clear,clearly,1035,"// This code lowers all pseudo-CMOV instructions. Generally it lowers these; // as described above, by inserting a MBB, and then making a PHI at the join; // point to select the true and false operands of the CMOV in the PHI.; //; // The code also handles two different cases of multiple CMOV opcodes; // in a row.; //; // Case 1:; // In this case, there are multiple CMOVs in a row, all which are based on; // the same condition setting (or the exact opposite condition setting).; // In this case we can lower all the CMOVs using a single inserted MBB, and; // then make a number of PHIs at the join point to model the CMOVs. The only; // trickiness here, is that in a case like:; //; // t2 = CMOV cond1 t1, f1; // t3 = CMOV cond1 t2, f2; //; // when rewriting this into PHIs, we have to perform some renaming on the; // temps since you cannot have a PHI operand refer to a PHI result earlier; // in the same block. The ""simple"" but wrong lowering would be:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t2(BB1), f2(BB2); //; // but clearly t2 is not defined in BB1, so that is incorrect. The proper; // renaming is to note that on the path through BB1, t2 is really just a; // copy of t1, and do that renaming, properly generating:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t1(BB1), f2(BB2); //; // Case 2, we lower cascaded CMOVs such as; //; // (CMOV (CMOV F, T, cc1), T, cc2); //; // to two successives branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:139,Energy Efficiency,reduce,reduces,139,"// Check for case 1, where there are multiple CMOVs with the same condition; // first. Of the two cases of multiple CMOV lowerings, case 1 reduces the; // number of jumps the most.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:23,Modifiability,rewrite,rewrite,23,// Add this PHI to the rewrite table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:303,Energy Efficiency,allocate,allocated,303,// Lower dynamic stack allocation to _alloca call for Cygwin/Mingw targets.; // Calls to _alloca are needed to probe the stack when allocating more than 4k; // bytes in one go. Touching the stack at 4K increments is necessary to ensure; // that the guard pages used by the OS virtual memory manager are allocated in; // correct sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize a CCR definition used according to the condition code \p CC into; /// a simpler CCR value, potentially returning a new \p CC and replacing uses; /// of chain values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:85,Usability,simpl,simpler,85,"/// Optimize a CCR definition used according to the condition code \p CC into; /// a simpler CCR value, potentially returning a new \p CC and replacing uses; /// of chain values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize RES = M68kISD::SETCC CONDCODE, CCR_INPUT",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:10,Usability,simpl,simplify,10,// Try to simplify the CCR and condition code operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:10,Usability,simpl,simplify,10,"// Try to simplify the CCR and condition code operands.; // Make sure to not keep references to operands, as combineSetCCCCR can; // RAUW them under us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize RES, CCR = M68kISD::ADDX LHS, RHS, CCR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:47,Integrability,Interface,Interface,47,"//===-- M68kISelLowering.h - M68k DAG Lowering Interface --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interfaces that M68k uses to lower LLVM code into a; /// selection DAG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:418,Integrability,interface,interfaces,418,"//===-- M68kISelLowering.h - M68k DAG Lowering Interface --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interfaces that M68k uses to lower LLVM code into a; /// selection DAG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:21,Testability,log,logical,21,/// M68k compare and logical compare instructions. Subtracts the source; /// operand from the destination data register and sets the condition; /// codes according to the result. Immediate always goes first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:13,Testability,test,test,13,/// M68k bit-test instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:212,Testability,TEST,TEST,212,"// R = carry_bit ? ~0 : 0; /// M68k conditional moves. Operand 0 and operand 1 are the two values; /// to select from. Operand 2 is the condition code, and operand 3 is the; /// flag operand produced by a CMP or TEST instruction. It also writes a; /// flag result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:221,Testability,TEST,TEST,221,"/// M68k conditional branches. Operand 0 is the chain operand, operand 1; /// is the block to branch if condition is true, operand 2 is the; /// condition code, and operand 3 is the flag operand produced by a CMP; /// or TEST instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:6,Integrability,wrap,wrapper,6,"/// A wrapper node for TargetConstantPool,; /// TargetExternalSymbol, and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:12,Integrability,wrap,wrapper,12,/// Special wrapper used under M68k PIC mode for PC; /// relative displacements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:18,Modifiability,variab,variable,18,"// For allocating variable amounts of stack space when using; // segmented stacks. Check if the current stacklet has enough space, and; // falls back to heap allocation if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:11,Performance,load,load,11,/// Emit a load of return address if tail call; /// optimization is performed and it is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:52,Performance,optimiz,optimization,52,/// Emit a load of return address if tail call; /// optimization is performed and it is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:68,Performance,perform,performed,68,/// Emit a load of return address if tail call; /// optimization is performed and it is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:57,Performance,optimiz,optimization,57,/// Emit a store of the return address if tail call; /// optimization is performed and it is required (FPDiff!=0).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:73,Performance,perform,performed,73,/// Emit a store of the return address if tail call; /// optimization is performed and it is required (FPDiff!=0).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:97,Performance,load,load,97,/// LowerFormalArguments - transform physical registers into virtual; /// registers and generate load operations for arguments places on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:41,Testability,test,test,41,"/// Emit nodes that will be selected as ""test Op0,Op0"", or something; /// equivalent, for use with the given M68k condition code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:53,Performance,optimiz,optimization,53,/// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:106,Performance,optimiz,optimization,106,/// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMachineFunction.h:100,Performance,optimiz,optimization,100,/// The number of bytes by which return address stack slot is moved as the; /// result of tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kMachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMCInstLower.cpp:26,Energy Efficiency,efficient,efficient,26,"// FIXME We would like an efficient form for this, so we don't have to do a; // lot of extra uniquing. This fixme is originally from X86",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kMCInstLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMCInstLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.cpp:171,Modifiability,variab,variables,171,"// When we need stack realignment, we can't address the stack from the frame; // pointer. When we have dynamic allocas or stack-adjusting inline asm, we; // can't address variables from the stack pointer. MS inline asm can; // reference locals while also adjusting the stack pointer. When we can't; // use both the SP and the FP, we need a separate base pointer register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.h:129,Modifiability,variab,variable,129,"/// Physical register used as a base ptr in complex stack frames. I.e., when; /// we need a 3rd base, not just SP and FP, due to variable size stack; /// objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp:14,Energy Efficiency,schedul,scheduling,14,// Initialize scheduling itinerary for the specified CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp:78,Performance,load,loads,78,"// If the function is marked as non-lazy, generate an indirect call; // which loads from the GOT directly. This avoids run-time overhead; // at the cost of eager binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp:112,Safety,avoid,avoids,112,"// If the function is marked as non-lazy, generate an indirect call; // which loads from the GOT directly. This avoids run-time overhead; // at the cost of eager binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h:22,Modifiability,variab,variable,22,/// Classify a global variable reference for the current subtarget according; /// to how we should reference it in a non-pcrel context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h:22,Modifiability,variab,variable,22,/// Classify a global variable reference for the current subtarget according; /// to how we should reference it in a non-pcrel context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h:24,Modifiability,variab,variable,24,/// Classify a external variable reference for the current subtarget according; /// to how we should reference it in a non-pcrel context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:164,Performance,perform,performance,164,"// M68k pointers are always 32 bit wide even for 16-bit CPUs.; // The ABI only specifies 16-bit alignment.; // On at least the 68020+ with a 32-bit bus, there is a performance benefit; // to having 32-bit alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:90,Deployability,Pipeline,Pipeline,90,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:99,Deployability,Configurat,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:99,Modifiability,Config,Configuration,99,//===----------------------------------------------------------------------===//; // Pass Pipeline Configuration; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:109,Availability,mask,mask,109,"// These variables are used for the following forms:; // Addr: (OuterDisp); // RegMask: RegMask (as register mask); // Reg: %OuterReg; // RegIndirect: (%OuterReg); // RegPostIncrement: (%OuterReg)+; // RegPreDecrement: -(%OuterReg); // RegIndirectDisplacement: OuterDisp(%OuterReg); // RegIndirectDisplacementIndex:; // OuterDisp(%OuterReg, %InnerReg.Size * Scale, InnerDisp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:9,Modifiability,variab,variables,9,"// These variables are used for the following forms:; // Addr: (OuterDisp); // RegMask: RegMask (as register mask); // Reg: %OuterReg; // RegIndirect: (%OuterReg); // RegPostIncrement: (%OuterReg)+; // RegPreDecrement: -(%OuterReg); // RegIndirectDisplacement: OuterDisp(%OuterReg); // RegIndirectDisplacementIndex:; // OuterDisp(%OuterReg, %InnerReg.Size * Scale, InnerDisp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:80,Availability,mask,masks,80,// Only regular address / data registers are allowed to be used; // in register masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:9,Usability,simpl,simple,9,// Parse simple general-purpose registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:42,Availability,mask,mask,42,// Check for a plain register or register mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:46,Usability,simpl,simplify,46,"// First register range is a single register, simplify to just Reg; // so that it matches more operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:83,Availability,mask,mask,83,// This is the second register being specified - expand the Reg operand; // into a mask first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:169,Usability,simpl,simple,169,/// Returns the minimum size of a nop in bytes on this target. The assembler; /// will use this to emit excess padding in situations where the padding; /// required for simple alignment would be less than the minimum nop size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:118,Availability,failure,failure,118,"/// Write a sequence of optimal nops to the output, covering \p Count bytes.; /// \return - true on success, false on failure",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:41,Usability,clear,clear,41,// end anonymous namespace; /// ccCarry clear GEGreater than or equal; /// LSLower or same PLPlus; /// CSCarry set GTGreater than; /// LTLess than; /// EQEqual HIHigher; /// MIMinus VCOverflow clear; /// LELess than or equal; /// NENot equal VSOverflow set,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:204,Usability,clear,clear,204,// end anonymous namespace; /// ccCarry clear GEGreater than or equal; /// LSLower or same PLPlus; /// CSCarry set GTGreater than; /// LTLess than; /// EQEqual HIHigher; /// MIMinus VCOverflow clear; /// LELess than or equal; /// NENot equal VSOverflow set,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:153,Modifiability,variab,variable,153,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the slot in GOT which stores the information for accessing the TLS; /// variable. This is used when operating in Global Dynamic mode.; /// name@TLSGD",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:130,Security,access,accessing,130,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the slot in GOT which stores the information for accessing the TLS; /// variable. This is used when operating in Global Dynamic mode.; /// name@TLSGD",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:81,Modifiability,variab,variable,81,"/// On a symbol operand, this indicates that the immediate is the offset to; /// variable within the thread local storage when operating in Local Dynamic; /// mode.; /// name@TLSLD",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:153,Modifiability,variab,variable,153,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the slot in GOT which stores the information for accessing the TLS; /// variable. This is used when operating in Local Dynamic mode.; /// name@TLSLDM",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:130,Security,access,accessing,130,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the slot in GOT which stores the information for accessing the TLS; /// variable. This is used when operating in Local Dynamic mode.; /// name@TLSLDM",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:85,Modifiability,variab,variable,85,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the variable within the thread local storage when operating in Initial; /// Exec mode.; /// name@TLSIE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:85,Modifiability,variab,variable,85,"/// On a symbol operand, this indicates that the immediate is the offset to; /// the variable within in the thread local storage when operating in Local; /// Exec mode.; /// name@TLSLE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h:85,Testability,stub,stub,85,"// enum TOF; /// Return true if the specified TargetFlag operand is a reference to a stub; /// for a global, not the global itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:1074,Deployability,integrat,integrated,1074,"//===-- M68kInstPrinter.cpp - Convert M68k MCInst to asm --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains definitions for an M68k MCInst printer.; ///; //===----------------------------------------------------------------------===//; // TODO Conform with all supported Motorola ASM syntax; // Motorola's assembly has several syntax variants, especially on; // addressing modes.; // For example, you can write pc indirect w/ displacement as; // `x(%pc)`, where `x` is the displacement imm, or `(x,%pc)`.; // Currently we're picking the variant that is different from; // GCC, albeit being recognizable by GNU AS.; // Not sure what is the impact now (e.g. some syntax might; // not be recognized by some old consoles' toolchains, in which; // case we can not use our integrated assembler), but either way,; // it will be great to support all of the variants in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:1074,Integrability,integrat,integrated,1074,"//===-- M68kInstPrinter.cpp - Convert M68k MCInst to asm --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains definitions for an M68k MCInst printer.; ///; //===----------------------------------------------------------------------===//; // TODO Conform with all supported Motorola ASM syntax; // Motorola's assembly has several syntax variants, especially on; // addressing modes.; // For example, you can write pc indirect w/ displacement as; // `x(%pc)`, where `x` is the displacement imm, or `(x,%pc)`.; // Currently we're picking the variant that is different from; // GCC, albeit being recognizable by GNU AS.; // Not sure what is the impact now (e.g. some syntax might; // not be recognized by some old consoles' toolchains, in which; // case we can not use our integrated assembler), but either way,; // it will be great to support all of the variants in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:10,Availability,mask,mask,10,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:258,Availability,mask,mask,258,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:199,Deployability,continuous,continuous,199,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:516,Usability,intuit,intuitive,516,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:533,Usability,simpl,simply,533,"// A move mask is splitted into two parts:; // bits 0 ~ 7 correspond to D0 ~ D7 regs; // bits 8 ~ 15 correspond to A0 ~ A7 regs; //; // In the assembly syntax, we want to use a dash to replace; // a continuous range of registers. For example, if the bit; // mask is 0b101110, we want to print ""D1-D3,D5"" instead of; // ""D1,D2,D3,D4,D5"".; //; // However, we don't want a dash to cross between data registers; // and address registers (i.e. there shouldn't be a dash crossing; // bit 7 and 8) since that is not really intuitive. So we simply; // print the data register part (bit 0~7) and address register part; // separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp:27,Availability,avail,available,27,"// NOTE forcing (W,L) size available since M68020 only",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h:19,Availability,mask,mask,19,"/// Print register mask for MOVEM instruction in order D0-D7,A0-A7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h:19,Availability,mask,mask,19,"/// Print register mask for MOVEM instruction in order A7-A0,D7-D0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kInstPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCCodeEmitter.cpp:10,Deployability,patch,patch,10,"// If the patch point is at the first word, PC is pointing at the; // next word.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp:38,Testability,log,logics,38,// TODO Implement feature set parsing logics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp:71,Testability,test,tests,71,// Initial state of the frame pointer is SP+StackGrowth.; // TODO: Add tests for `cfi_*` directives,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMemOperandPrinter.h:439,Testability,log,logics,439,"//===-- M68kMemOperandPrinter.h - Memory operands printing ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains memory operand printing logics shared between AsmPrinter; // and MCInstPrinter.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMemOperandPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kMemOperandPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:409,Energy Efficiency,reduce,reduce,409,"//=== MicroMipsSizeReduction.cpp - MicroMips size reduction pass --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///\file; /// This pass is used to reduce the size of instructions where applicable.; ///; /// TODO: Implement microMIPS64 support.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:52,Modifiability,extend,extended,52,/// Order of operands to transfer; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:77,Performance,optimiz,optimizations,77,/// Order of operands to transfer; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:37,Modifiability,extend,extended,37,/// Reduction type; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:62,Performance,optimiz,optimizations,62,/// Reduction type; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:5,Energy Efficiency,Reduce,Reduce,5,///< Reduce two instructions into one instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:5,Energy Efficiency,Reduce,Reduce,5,///< Reduce one instruction into a smaller instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:49,Modifiability,extend,extended,49,/// Information about operands; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:74,Performance,optimiz,optimizations,74,/// Information about operands; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:4,Energy Efficiency,Reduce,ReduceTable,4,/// ReduceTable - A static table with information on mapping from wide; /// opcodes to narrow,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:16,Energy Efficiency,reduce,reduce,16,///< Pointer to reduce function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:26,Energy Efficiency,Reduce,ReduceFunction,26,// Function arguments for ReduceFunction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:4,Energy Efficiency,Reduce,Reduces,4,/// Reduces width of instructions in the specified basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:16,Energy Efficiency,reduce,reduce,16,"/// Attempts to reduce MI, returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce LW/SW instruction into LWSP/SWSP,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce two LW/SW instructions into LWP/SWP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce LBU/LHU instruction into LBU16/LHU16,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce SB/SH instruction into SB16/SH16,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce two MOVE instructions into MOVEP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce arithmetic instructions, returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce ADDIU into ADDIUSP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce ADDIU into ADDIUR1SP instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:15,Energy Efficiency,reduce,reduce,15,"// Attempts to reduce XOR into XOR16 instruction,; // returns true on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:137,Integrability,depend,depending,137,"// Changes opcode of an instruction, replaces an instruction with a; // new one, or replaces two instructions with a new instruction; // depending on their order i.e. if these are consecutive forward; // or consecutive backward",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:68,Energy Efficiency,Reduce,ReduceType,68,// This table must be sorted by WideOpc as a main criterion and; // ReduceType as a sub-criterion (when wide opcodes are the same).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:3,Energy Efficiency,Reduce,ReduceType,3,"// ReduceType, OpCodes, ReduceFunction,; // OpInfo(TransferOperands),; // ImmField(Shift, LBound, HBound, ImmFieldPosition)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:24,Energy Efficiency,Reduce,ReduceFunction,24,"// ReduceType, OpCodes, ReduceFunction,; // OpInfo(TransferOperands),; // ImmField(Shift, LBound, HBound, ImmFieldPosition)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:96,Modifiability,variab,variable,96,// Returns true if the operand Op is an immediate value; // and writes the immediate value into variable Imm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:23,Modifiability,variab,variable,23,// Returns true if the variable Value has the number of least-significant zero; // bits equal to Shift and if the shifted value is between the bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:29,Energy Efficiency,reduce,reduced,29,// Returns true if MI can be reduced to lwp/swp instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:3,Energy Efficiency,Reduce,ReduceToLwp,3,// ReduceToLwp = true/false - reduce to LWP/SWP instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:30,Energy Efficiency,reduce,reduce,30,// ReduceToLwp = true/false - reduce to LWP/SWP instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:9,Energy Efficiency,reduce,reduce,9,// Don't reduce bundled instructions or pseudo operations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:10,Energy Efficiency,reduce,reduce,10,// Try to reduce 32-bit instruction into 16-bit instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips.h:27,Integrability,interface,interface,27,"//===-- Mips.h - Top-level interface for Mips representation ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in; // the LLVM Mips back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp:14,Energy Efficiency,allocate,allocate,14,// No need to allocate space on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp:114,Modifiability,variab,variable,114,// Reserve call frame if the size of the maximum call frame fits into 15-bit; // immediate field and there are no variable sized objects on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:91,Modifiability,variab,variables,91,// Figure out if we need float point based on the function parameters.; // We need to move variables in and/or out of floating point; // registers because of the ABI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:44,Testability,stub,stub,44,// Make sure that we know we already need a stub for this function.; // Having called needsFPHelperFromSig,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:34,Testability,stub,stub,34,//; // see if we already have the stub; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:153,Testability,stub,stubs,153,"// This pass only makes sense when the underlying chip has floating point but; // we are compiling as mips16.; // For all mips16 functions (that are not stubs we have already generated), or; // declared via attributes as nomips16, we must:; // 1) fixup all returns of float, double, single and double complex; // by calling a helper function before the actual return.; // 2) generate helper functions (stubs) that can be called by mips32; // functions that will move parameters passed normally passed in; // floating point; // registers the soft float equivalents.; // 3) in the case of static relocation, generate helper functions so that; // mips16 functions can call extern functions of unknown type (mips16 or; // mips32).; // 4) TBD. For pic, calls to extern functions of unknown type are handled by; // predefined helper functions in libc but this work is currently done; // during call lowering but it should be moved here in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp:402,Testability,stub,stubs,402,"// This pass only makes sense when the underlying chip has floating point but; // we are compiling as mips16.; // For all mips16 functions (that are not stubs we have already generated), or; // declared via attributes as nomips16, we must:; // 1) fixup all returns of float, double, single and double complex; // by calling a helper function before the actual return.; // 2) generate helper functions (stubs) that can be called by mips32; // functions that will move parameters passed normally passed in; // floating point; // registers the soft float equivalents.; // 3) in the case of static relocation, generate helper functions so that; // mips16 functions can call extern functions of unknown type (mips16 or; // mips32).; // 4) TBD. For pic, calls to extern functions of unknown type are handled by; // predefined helper functions in libc but this work is currently done; // during call lowering but it should be moved here in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16HardFloat.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:184,Safety,safe,safe,184,// Adjust SP by Amount bytes where bytes can be up to 32bit number.; // This can only be called at times that we know that there is at least one free; // register.; // This is clearly safe at prologue and epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:176,Usability,clear,clearly,176,// Adjust SP by Amount bytes where bytes can be up to 32bit number.; // This can only be called at times that we know that there is at least one free; // register.; // This is clearly safe at prologue and epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:37,Performance,load,load,37,/// Emit a series of instructions to load an immediate.; // This is to adjust some FrameReg. We return the new register to be used; // in place of FrameReg and the adjusted immediate field (&NewImm),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp:15,Performance,Load,Load,15,// on PIC code Load GA,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp:8,Performance,load,loading,8,"// When loading from constant pools, load the lower address part in; // the instruction itself. Example, instead of:; // lui $2, %hi($CPI1_0); // addiu $2, $2, %lo($CPI1_0); // lwc1 $f0, 0($2); // Generate:; // lui $2, %hi($CPI1_0); // lwc1 $f0, %lo($CPI1_0)($2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp:37,Performance,load,load,37,"// When loading from constant pools, load the lower address part in; // the instruction itself. Example, instead of:; // lui $2, %hi($CPI1_0); // addiu $2, $2, %lo($CPI1_0); // lwc1 $f0, 0($2); // Generate:; // lui $2, %hi($CPI1_0); // lwc1 $f0, %lo($CPI1_0)($2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:51,Integrability,Interface,Interface,51,"//===-- Mips16ISelLowering.h - Mips16 DAG Lowering Interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Subclass of MipsTargetLowering specialized for mips16.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:16,Performance,optimiz,optimization,16,// No tail call optimization for mips16.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:46,Modifiability,inherit,inherited,46,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:556,Modifiability,inherit,inherited,556,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:1008,Performance,load,load,1008,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:1397,Testability,stub,stub,1397,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:1527,Testability,assert,assert,1527,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:45,Integrability,depend,depending,45,"//; // Prefixes are attached to stub numbers depending on the return type.; // return type: float sf_; // double df_; // single complex sc_; // double complext dc_; // others NO PREFIX; //; //; // The full name of a helper function is__mips16_call_stub +; // return type dependent prefix + stub number; //; // FIXME: This is something that probably should be in a different source file; // and perhaps done differently but my main purpose is to not waste runtime; // on something that we can enumerate in the source. Another possibility is; // to have a python script to generate these mapping tables. This will do; // for now. There are a whole series of helper function mapping arrays, one; // for each return type class as outlined above. There there are 11 possible; // entries. Ones with 0 are ones which should never be selected.; //; // All the arrays are similar except for ones which return neither; // sf, df, sc, dc, in which we only care about ones which have sf or df as a; // first parameter.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:271,Integrability,depend,dependent,271,"//; // Prefixes are attached to stub numbers depending on the return type.; // return type: float sf_; // double df_; // single complex sc_; // double complext dc_; // others NO PREFIX; //; //; // The full name of a helper function is__mips16_call_stub +; // return type dependent prefix + stub number; //; // FIXME: This is something that probably should be in a different source file; // and perhaps done differently but my main purpose is to not waste runtime; // on something that we can enumerate in the source. Another possibility is; // to have a python script to generate these mapping tables. This will do; // for now. There are a whole series of helper function mapping arrays, one; // for each return type class as outlined above. There there are 11 possible; // entries. Ones with 0 are ones which should never be selected.; //; // All the arrays are similar except for ones which return neither; // sf, df, sc, dc, in which we only care about ones which have sf or df as a; // first parameter.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:32,Testability,stub,stub,32,"//; // Prefixes are attached to stub numbers depending on the return type.; // return type: float sf_; // double df_; // single complex sc_; // double complext dc_; // others NO PREFIX; //; //; // The full name of a helper function is__mips16_call_stub +; // return type dependent prefix + stub number; //; // FIXME: This is something that probably should be in a different source file; // and perhaps done differently but my main purpose is to not waste runtime; // on something that we can enumerate in the source. Another possibility is; // to have a python script to generate these mapping tables. This will do; // for now. There are a whole series of helper function mapping arrays, one; // for each return type class as outlined above. There there are 11 possible; // entries. Ones with 0 are ones which should never be selected.; //; // All the arrays are similar except for ones which return neither; // sf, df, sc, dc, in which we only care about ones which have sf or df as a; // first parameter.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:290,Testability,stub,stub,290,"//; // Prefixes are attached to stub numbers depending on the return type.; // return type: float sf_; // double df_; // single complex sc_; // double complext dc_; // others NO PREFIX; //; //; // The full name of a helper function is__mips16_call_stub +; // return type dependent prefix + stub number; //; // FIXME: This is something that probably should be in a different source file; // and perhaps done differently but my main purpose is to not waste runtime; // on something that we can enumerate in the source. Another possibility is; // to have a python script to generate these mapping tables. This will do; // for now. There are a whole series of helper function mapping arrays, one; // for each return type class as outlined above. There there are 11 possible; // entries. Ones with 0 are ones which should never be selected.; //; // All the arrays are similar except for ones which return neither; // sf, df, sc, dc, in which we only care about ones which have sf or df as a; // first parameter.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:631,Deployability,patch,patch,631,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:426,Performance,optimiz,optimize,426,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:586,Performance,optimiz,optimization,586,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:35,Testability,stub,stub,35,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:187,Testability,stub,stub,187,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:229,Testability,stub,stub,229,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:269,Testability,stub,stub,269,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:451,Testability,stub,stub,451,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.h:51,Integrability,Interface,Interface,51,"//===-- Mips16ISelLowering.h - Mips16 DAG Lowering Interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Subclass of MipsTargetLowering specialized for mips16.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp:137,Energy Efficiency,allocate,allocated,137,// The following stack frame objects are always; // referenced relative to $sp:; // 1. Outgoing arguments.; // 2. Pointer to dynamically allocated stack space.; // 3. Locations for callee-saved registers.; // Everything else is referenced relative to whatever register; // getFrameRegister() returns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp:171,Energy Efficiency,allocate,allocated,171,"// Calculate final offset.; // - There is no need to change the offset if the frame object; // is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following,; // its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp:407,Modifiability,variab,variable,407,"// Calculate final offset.; // - There is no need to change the offset if the frame object; // is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following,; // its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp:32,Usability,clear,cleared,32,// Shift if the lower 16-bit is cleared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp:16,Usability,clear,cleared,16,"// If bit 15 is cleared, it doesn't make a difference whether the last; // instruction is an ADDiu or ORi. In that case, do not call GetInstSeqLsORi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp:8,Modifiability,extend,extend,8,// Sign-extend and shift operand of ADDiu and see if it still fits in 16-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:45,Performance,load,load,45,/// Analyze - Get an instruction sequence to load immediate Imm. The last; /// instruction in the sequence must be an ADDiu if LastInstrIsADDiu is; /// true;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:82,Performance,load,load,82,/// GetInstSeqLsADDiu - Get instruction sequences which end with an ADDiu to; /// load immediate Imm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:78,Performance,load,load,78,/// GetInstSeqLsORi - Get instrutcion sequences which end with an ORi to; /// load immediate Imm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:77,Performance,load,load,77,/// GetInstSeqLsSLL - Get instruction sequences which end with a SLL to; /// load immediate Imm,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:48,Performance,load,load,48,/// GetInstSeqLs - Get instruction sequences to load immediate Imm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===- MipsAsmPrinter.cpp - Mips LLVM Assembly Printer --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to GAS-format MIPS assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:128,Performance,optimiz,optimization,128,"// If there is an MO_JALR operand, insert:; //; // .reloc tmplabel, R_{MICRO}MIPS_JALR, symbol; // tmplabel:; //; // This is an optimization hint for the linker which may then replace; // an indirect call with a direct branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:55,Testability,test,test,55,"// FIXME: Enable feature predicate checks once all the test pass.; // Mips_MC::verifyInstructionPredicates(MI->getOpcode(),; // getSubtargetInfo().getFeatureBits());",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:265,Availability,down,downstream,265,// The inMips16Mode() test is not permanent.; // Some instructions are marked as pseudo right now which; // would make the test fail for the wrong reason but; // that will be fixed soon. We need this here because we are; // removing another test for this situation downstream in the; // callchain.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:22,Testability,test,test,22,// The inMips16Mode() test is not permanent.; // Some instructions are marked as pseudo right now which; // would make the test fail for the wrong reason but; // that will be fixed soon. We need this here because we are; // removing another test for this situation downstream in the; // callchain.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:123,Testability,test,test,123,// The inMips16Mode() test is not permanent.; // Some instructions are marked as pseudo right now which; // would make the test fail for the wrong reason but; // that will be fixed soon. We need this here because we are; // removing another test for this situation downstream in the; // callchain.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:241,Testability,test,test,241,// The inMips16Mode() test is not permanent.; // Some instructions are marked as pseudo right now which; // would make the test fail for the wrong reason but; // that will be fixed soon. We need this here because we are; // removing another test for this situation downstream in the; // callchain.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:221,Availability,Mask,Mask,221,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:241,Availability,mask,mask,241,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:455,Availability,mask,mask,455,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:751,Availability,mask,mask,751,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:860,Availability,mask,mask,860,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:1111,Availability,mask,mask,1111,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:1331,Availability,Mask,Mask,1331,"//===----------------------------------------------------------------------===//; //; // Mips Asm Directives; //; // -- Frame directive ""frame Stackpointer, Stacksize, RARegister""; // Describe the stack frame.; //; // -- Mask directives ""(f)mask bitmask, offset""; // Tells the assembler which registers are saved and where.; // bitmask - contain a little endian bitset indicating which registers are; // saved on function prologue (e.g. with a 0x80000000 mask, the; // assembler knows the register 31 (RA) is saved at prologue.; // offset - the position before stack pointer subtraction indicating where; // the first saved register on prologue is located. (e.g. with a; //; // Consider the following function prologue:; //; // .frame $fp,48,$ra; // .mask 0xc0000000,-8; // addiu $sp, $sp, -48; // sw $ra, 40($sp); // sw $fp, 36($sp); //; // With a 0xc0000000 mask, the assembler knows the register 31 (RA) and; // 30 (FP) are saved at prologue. As the save order on prologue is from; // left to right, RA is saved first. A -8 offset means that after the; // stack pointer subtration, the first register in the mask (RA) will be; // saved at address 48-8=40.; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // Mask directives; //===----------------------------------------------------------------------===//; // Create a bitmask with all callee saved registers for CPU or Floating Point; // registers. For CPU registers consider RA, GP and FP for saving if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:64,Availability,mask,masked,64,// NaCl sandboxing requires that indirect call instructions are masked.; // This means that function entry points should be bundle-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:8,Modifiability,sandbox,sandboxing,8,// NaCl sandboxing requires that indirect call instructions are masked.; // This means that function entry points should be bundle-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:8,Testability,sandbox,sandboxing,8,// NaCl sandboxing requires that indirect call instructions are masked.; // This means that function entry points should be bundle-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:131,Testability,log,logic,131,"// There are instruction for this macros, but they must; // always be at the function end, and we can't emit and; // break with BB logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:3,Performance,Load,Load,3,"// Load/Store memory operands -- imm($reg); // If PIC target the target is loaded as the; // pattern lw $25,%call16($28); // opNum can be invalid if instruction has reglist as operand.; // MemOperand is always last operand of instruction (base + offset).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:75,Performance,load,loaded,75,"// Load/Store memory operands -- imm($reg); // If PIC target the target is loaded as the; // pattern lw $25,%call16($28); // opNum can be invalid if instruction has reglist as operand.; // MemOperand is always last operand of instruction (base + offset).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:38,Performance,load,load,38,// when using stack locations for not load/store instructions; // print the same way as all normal 3 operand instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:97,Testability,test,test,97,"// FIXME: This condition should be a lot more complicated that it is here.; // Ideally it should test for properties of the ABI and not the ABI; // itself.; // For the moment, I'm only correcting enough to make MIPS-IV work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:259,Integrability,depend,depends,259,"// GCC's choice of assembler options for inline assembly code ('at', 'macro'; // and 'reorder') is different from LLVM's choice for generated code ('noat',; // 'nomacro' and 'noreorder').; // In order to maintain compatibility with inline assembly code which depends; // on GCC's assembler options being used, we have to switch to those options; // for the duration of the inline assembly block and then switch back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:99,Testability,stub,stub,99,//; // make the comment field identifying the return and parameter; // types of the floating point stub; // # Stub function to call rettype xxxx (params); //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:110,Testability,Stub,Stub,110,//; // make the comment field identifying the return and parameter; // types of the floating point stub; // # Stub function to call rettype xxxx (params); //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:120,Deployability,patch,patch,120,"//; // We need to add a MipsMCExpr class to MCTargetDesc to fully implement; // stubs without raw text but this current patch is for compiler generated; // functions and they all return some value.; // The calling sequence for non pic is different in that case and we need; // to implement %lo and %hi in order to handle the case of no return value; // See the corresponding method in Mips16HardFloat for details.; //; // mov the return address to S2.; // we have no stack space to store it and we are about to make another call.; // We need to make sure that the enclosing function knows to save S2; // This should have already been handled.; //; // Mov $18, $31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:80,Testability,stub,stubs,80,"//; // We need to add a MipsMCExpr class to MCTargetDesc to fully implement; // stubs without raw text but this current patch is for compiler generated; // functions and they all return some value.; // The calling sequence for non pic is different in that case and we need; // to implement %lo and %hi in order to handle the case of no return value; // See the corresponding method in Mips16HardFloat for details.; //; // mov the return address to S2.; // we have no stack space to store it and we are about to make another call.; // We need to make sure that the enclosing function knows to save S2; // This should have already been handled.; //; // Mov $18, $31",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:99,Testability,stub,stubs,99,"//; // do the return; // if (Signature->RetSig == NoFPRet); // llvm_unreachable(""should not be any stubs here with no return value"");; // else",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:15,Testability,stub,stubs,15,// Emit needed stubs; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:243,Deployability,patch,patching,243,"// For mips32 we want to emit the following pattern:; //; // .Lxray_sled_N:; // ALIGN; // B .tmpN; // 11 NOP instructions (44 bytes); // ADDIU T9, T9, 52; // .tmpN; //; // We need the 44 bytes (11 instructions) because at runtime, we'd; // be patching over the full 48 bytes (12 instructions) with the following; // pattern:; //; // ADDIU SP, SP, -8; // NOP; // SW RA, 4(SP); // SW T9, 0(SP); // LUI T9, %hi(__xray_FunctionEntry/Exit); // ORI T9, T9, %lo(__xray_FunctionEntry/Exit); // LUI T0, %hi(function_id); // JALR T9; // ORI T0, T0, %lo(function_id); // LW T9, 0(SP); // LW RA, 4(SP); // ADDIU SP, SP, 8; //; // We add 52 bytes to t9 because we want to adjust the function pointer to; // the actual start of function i.e. the address just after the noop sled.; // We do this because gp displacement relocation is emitted at the start of; // of the function i.e after the nop sled and to correctly calculate the; // global offset table address, t9 must hold the address of the instruction; // containing the gp displacement relocation.; // FIXME: Is this correct for the static relocation model?; //; // For mips64 we want to emit the following pattern:; //; // .Lxray_sled_N:; // ALIGN; // B .tmpN; // 15 NOP instructions (60 bytes); // .tmpN; //; // We need the 60 bytes (15 instructions) because at runtime, we'd; // be patching over the full 64 bytes (16 instructions) with the following; // pattern:; //; // DADDIU SP, SP, -16; // NOP; // SD RA, 8(SP); // SD T9, 0(SP); // LUI T9, %highest(__xray_FunctionEntry/Exit); // ORI T9, T9, %higher(__xray_FunctionEntry/Exit); // DSLL T9, T9, 16; // ORI T9, T9, %hi(__xray_FunctionEntry/Exit); // DSLL T9, T9, 16; // ORI T9, T9, %lo(__xray_FunctionEntry/Exit); // LUI T0, %hi(function_id); // JALR T9; // ADDIU T0, T0, %lo(function_id); // LD T9, 0(SP); // LD RA, 8(SP); // DADDIU SP, SP, 16; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:1328,Deployability,patch,patching,1328,"// For mips32 we want to emit the following pattern:; //; // .Lxray_sled_N:; // ALIGN; // B .tmpN; // 11 NOP instructions (44 bytes); // ADDIU T9, T9, 52; // .tmpN; //; // We need the 44 bytes (11 instructions) because at runtime, we'd; // be patching over the full 48 bytes (12 instructions) with the following; // pattern:; //; // ADDIU SP, SP, -8; // NOP; // SW RA, 4(SP); // SW T9, 0(SP); // LUI T9, %hi(__xray_FunctionEntry/Exit); // ORI T9, T9, %lo(__xray_FunctionEntry/Exit); // LUI T0, %hi(function_id); // JALR T9; // ORI T0, T0, %lo(function_id); // LW T9, 0(SP); // LW RA, 4(SP); // ADDIU SP, SP, 8; //; // We add 52 bytes to t9 because we want to adjust the function pointer to; // the actual start of function i.e. the address just after the noop sled.; // We do this because gp displacement relocation is emitted at the start of; // of the function i.e after the nop sled and to correctly calculate the; // global offset table address, t9 must hold the address of the instruction; // containing the gp displacement relocation.; // FIXME: Is this correct for the static relocation model?; //; // For mips64 we want to emit the following pattern:; //; // .Lxray_sled_N:; // ALIGN; // B .tmpN; // 15 NOP instructions (60 bytes); // .tmpN; //; // We need the 60 bytes (15 instructions) because at runtime, we'd; // be patching over the full 64 bytes (16 instructions) with the following; // pattern:; //; // DADDIU SP, SP, -16; // NOP; // SD RA, 8(SP); // SD T9, 0(SP); // LUI T9, %highest(__xray_FunctionEntry/Exit); // ORI T9, T9, %higher(__xray_FunctionEntry/Exit); // DSLL T9, T9, 16; // ORI T9, T9, %hi(__xray_FunctionEntry/Exit); // DSLL T9, T9, 16; // ORI T9, T9, %lo(__xray_FunctionEntry/Exit); // LUI T0, %hi(function_id); // JALR T9; // ADDIU T0, T0, %lo(function_id); // LD T9, 0(SP); // LD RA, 8(SP); // DADDIU SP, SP, 16; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3038,Deployability,pipeline,pipeline,3038,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3246,Deployability,pipeline,pipeline,3246,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2979,Modifiability,extend,extended,2979,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1955,Performance,load,load,1955," to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce haza",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:601,Safety,hazard,hazards,601,"//===----------------------- MipsBranchExpansion.cpp ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This pass do two things:; /// - it expands a branch or jump instruction into a long branch if its offset; /// is too large to fit into its immediate field,; /// - it inserts nops to prevent forbidden slot hazards.; ///; /// The reason why this pass combines these two tasks is that one of these two; /// tasks can break the result of the previous one.; ///; /// Example of that is a situation where at first, no branch should be expanded,; /// but after adding at least one nop somewhere in the code to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:929,Safety,hazard,hazard,929,"//===----------------------- MipsBranchExpansion.cpp ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This pass do two things:; /// - it expands a branch or jump instruction into a long branch if its offset; /// is too large to fit into its immediate field,; /// - it inserts nops to prevent forbidden slot hazards.; ///; /// The reason why this pass combines these two tasks is that one of these two; /// tasks can break the result of the previous one.; ///; /// Example of that is a situation where at first, no branch should be expanded,; /// but after adding at least one nop somewhere in the code to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbid",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1213,Safety,hazard,hazard,1213,"ns.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This pass do two things:; /// - it expands a branch or jump instruction into a long branch if its offset; /// is too large to fit into its immediate field,; /// - it inserts nops to prevent forbidden slot hazards.; ///; /// The reason why this pass combines these two tasks is that one of these two; /// tasks can break the result of the previous one.; ///; /// Example of that is a situation where at first, no branch should be expanded,; /// but after adding at least one nop somewhere in the code to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1402,Safety,hazard,hazard,1402,"; /// \file; ///; /// This pass do two things:; /// - it expands a branch or jump instruction into a long branch if its offset; /// is too large to fit into its immediate field,; /// - it inserts nops to prevent forbidden slot hazards.; ///; /// The reason why this pass combines these two tasks is that one of these two; /// tasks can break the result of the previous one.; ///; /// Example of that is a situation where at first, no branch should be expanded,; /// but after adding at least one nop somewhere in the code to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Rese",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1845,Safety,hazard,hazard,1845," to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce haza",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1874,Safety,Hazard,Hazards,1874," to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce haza",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2010,Safety,hazard,hazard,2010,"d, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor er",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2613,Safety,hazard,hazards,2613,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2812,Safety,hazard,hazards,2812,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2892,Safety,hazard,hazards,2892,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3047,Safety,hazard,hazards,3047,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3078,Safety,hazard,hazards,3078,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3255,Safety,hazard,hazards,3255,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3286,Safety,hazard,hazard,3286,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3313,Safety,hazard,hazard,3313,"garding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor errata that; /// require instruction reorganization, etc.; ///; /// This pass has to run after the delay slot filler as that pass can introduce; /// pipeline hazards such as compact branch hazard, hence the existing hazard; /// recognizer is not suitable.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:2209,Usability,PAUSE,PAUSE,2209,"d, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce hazards in previously; /// processed instuctions.; ///; /// In future this pass can be extended (or new pass can be created) to handle; /// other pipeline hazards, such as various MIPS1 hazards, processor er",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:31,Deployability,pipeline,pipeline,31,/// Returns a pass that clears pipeline hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:40,Safety,hazard,hazards,40,/// Returns a pass that clears pipeline hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:24,Usability,clear,clears,24,/// Returns a pass that clears pipeline hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:166,Integrability,wrap,wrapping,166,// We must select between the MIPS32r6/MIPS64r6 BALC (which is a normal; // instruction) and the pre-MIPS32r6/MIPS64r6 definition (which is an; // pseudo-instruction wrapping BGEZAL).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:241,Performance,load,load,241,"// At this point, offset where we need to branch does not fit into; // immediate field of the branch instruction and is not in the same; // segment as jump instruction. Therefore we will break it into couple; // instructions, where we first load the offset into register, and then we; // do branch register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:14,Safety,hazard,hazard,14,// Delay slot hazard handling. Use lookahead over state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:18,Safety,hazard,hazards,18,// Forbidden slot hazards are only defined for MIPSR6 but not microMIPSR6.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:3,Performance,Load,Load,3,// Load delay slot hazards are only for MIPS1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:19,Safety,hazard,hazards,19,// Load delay slot hazards are only for MIPS1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:43,Modifiability,sandbox,sandboxing,43,"// The offset calculation does not include sandboxing instructions; // that will be added later in the MC layer. Since at this point we; // don't know the exact amount of code that ""sandboxing"" will add, we; // conservatively estimate that code will not grow more than 100%.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:182,Modifiability,sandbox,sandboxing,182,"// The offset calculation does not include sandboxing instructions; // that will be added later in the MC layer. Since at this point we; // don't know the exact amount of code that ""sandboxing"" will add, we; // conservatively estimate that code will not grow more than 100%.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:43,Testability,sandbox,sandboxing,43,"// The offset calculation does not include sandboxing instructions; // that will be added later in the MC layer. Since at this point we; // don't know the exact amount of code that ""sandboxing"" will add, we; // conservatively estimate that code will not grow more than 100%.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:182,Testability,sandbox,sandboxing,182,"// The offset calculation does not include sandboxing instructions; // that will be added later in the MC layer. Since at this point we; // don't know the exact amount of code that ""sandboxing"" will add, we; // conservatively estimate that code will not grow more than 100%.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp:229,Integrability,depend,dependent,229,/// Handle cases when f64 is split into 2 32-bit GPRs. This is a custom; /// assignment because generic code assumes getNumRegistersForCallingConv is; /// accurate. In this case it is not because the type/number are context; /// dependent on other arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp:77,Integrability,depend,depends,77,"// FIXME: Should use MipsCCState::getSpecialCallingConvForCallee, but it; // depends on looking directly at the call target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCallLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.cpp:82,Integrability,rout,routine,82,"// If the Ty is i128 and the function being called is a long double emulation; // routine, then the original type is f128.; // FIXME: This is unsound because these functions could be indirectly called",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h:69,Integrability,rout,routine,69,/// This function returns true if CallSym is a long double emulation routine.; ///; /// FIXME: Changing the ABI based on the callee name is unsound. The lib func; /// address could be captured.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h:96,Security,access,accessing,96,// The AnalyzeCallOperands in the base class is not usable since we must; // provide a means of accessing ArgListEntry::IsFixed. Delete them from this; // class. This doesn't stop them being used via the base class though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h:52,Usability,usab,usable,52,// The AnalyzeCallOperands in the base class is not usable since we must; // provide a means of accessing ArgListEntry::IsFixed. Delete them from this; // class. This doesn't stop them being used via the base class though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:53,Performance,load,loads,53,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:421,Performance,load,loads,421,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:489,Performance,Load,Loading,489,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:630,Performance,load,loaded,630,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:662,Performance,load,load,662,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:648,Usability,simpl,simple,648,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:72,Testability,test,testing,72,// FIXME: This option should be removed once it has received sufficient testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:29,Testability,test,tests,29,"// Rather than do make check tests with huge amounts of code, we force; // the test to use this amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:79,Testability,test,test,79,"// Rather than do make check tests with huge amounts of code, we force; // the test to use this amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:54,Performance,load,load,54,// For testing purposes we tell it to not use relaxed load forms so that it; // will split blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:7,Testability,test,testing,7,// For testing purposes we tell it to not use relaxed load forms so that it; // will split blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:258,Integrability,rout,routine,258,// FIXME: need to go through this whole constant islands port and check; // the math for branch ranges and clean this up and make some functions; // to calculate things that are done many times identically.; // Need to refactor some of the code to call this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:219,Modifiability,refactor,refactor,219,// FIXME: need to go through this whole constant islands port and check; // the math for branch ranges and clean this up and make some functions; // to calculate things that are done many times identically.; // Need to refactor some of the code to call this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:742,Usability,resume,resume,742,"/// CPUser - One user of a constant pool, keeping the machine instruction; /// pointer, the constant pool being referenced, and the max displacement; /// allowed from the instruction to the CP. The HighWaterMark records the; /// highest basic block where a new CPEntry can be placed. To ensure this; /// pass terminates, the CP entries are initially placed at the end of the; /// function and then move monotonically to lower addresses. The; /// exception to this rule is when the current CP entry for a particular; /// CPUser is out of range, but there is another CP entry for the same; /// constant value in range. We want to use the existing in-range CP; /// entry, but if it later moves out of range, the search for new water; /// should resume where it left off. The HighWaterMark is used to record; /// that point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Performance,Perform,Perform,3,"// Perform the initial placement of the constant pool entries. To start with,; // we put them all at the end of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Usability,Clear,Clear,3,"// Clear NewWaterList now. If we split a block for branches, it should; // appear as ""new water"" for the next iteration of constant pool placement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:25,Performance,Perform,Perform,25,"/// doInitialPlacement - Perform the initial placement of the constant pool; /// entries. To start with, we put them all at the end of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:99,Deployability,update,updates,99,/// computeBlockSize - Compute the size and some alignment information for MBB.; /// This function updates BBInfo directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:4,Deployability,update,updateForInsertedWaterBlock,4,"/// updateForInsertedWaterBlock - When a block is newly inserted into the; /// machine function, it upsets all of the block numbers. Renumber the blocks; /// and update the arrays that parallel this numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:162,Deployability,update,update,162,"/// updateForInsertedWaterBlock - When a block is newly inserted into the; /// machine function, it upsets all of the block numbers. Renumber the blocks; /// and update the arrays that parallel this numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:77,Availability,avail,available,77,"// Next, update WaterList. Specifically, we need to add NewMBB as having; // available water after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:9,Deployability,update,update,9,"// Next, update WaterList. Specifically, we need to add NewMBB as having; // available water after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:107,Deployability,Update,Update,107,"/// Split the basic block containing MI into two blocks, which are joined by; /// an unconditional branch. Update data structures and renumber blocks to; /// account for this change and returns the newly created block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:164,Availability,avail,available,164,// Add an unconditional branch from OrigBB to NewBB.; // Note the new unconditional branch is not being recorded.; // There doesn't seem to be meaningful DebugInfo available; this doesn't; // correspond to anything in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Deployability,Update,Update,3,// Update the CFG. All succs of OrigBB are now succs of NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Deployability,Update,Update,3,"// Update internal data structures to account for the newly inserted MBB.; // This is almost the same as updateForInsertedWaterBlock, except that; // the Water goes after OrigBB, not NewBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:105,Deployability,update,updateForInsertedWaterBlock,105,"// Update internal data structures to account for the newly inserted MBB.; // This is almost the same as updateForInsertedWaterBlock, except that; // the Water goes after OrigBB, not NewBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:78,Availability,avail,available,78,"// Next, update WaterList. Specifically, we need to add OrigMBB as having; // available water after it (but not if it's already there, which happens; // when splitting before a conditional branch that is followed by an; // unconditional branch - in that case we want to insert NewBB).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:9,Deployability,update,update,9,"// Next, update WaterList. Specifically, we need to add OrigMBB as having; // available water after it (but not if it's already there, which happens; // when splitting before a conditional branch that is followed by an; // unconditional branch - in that case we want to insert NewBB).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:146,Deployability,update,updated,146,"// If the original WaterList entry was ""new water"" on this iteration,; // propagate that to the new island. This is just keeping NewWaterList; // updated to match the WaterList, which will be updated below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:192,Deployability,update,updated,192,"// If the original WaterList entry was ""new water"" on this iteration,; // propagate that to the new island. This is just keeping NewWaterList; // updated to match the WaterList, which will be updated below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:28,Deployability,Update,Update,28,// We are adding new water. Update NewWaterList.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:156,Energy Efficiency,reduce,reduces,156,// Remove the original WaterList entry; we want subsequent insertions in; // this vicinity to go after the one we're about to insert. This; // considerably reduces the number of times we have to move the same CPE; // more than once and is also important to ensure the algorithm terminates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:3,Deployability,Update,Update,3,// Update internal data structures to account for the newly inserted MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:69,Deployability,Update,Update,69,/// removeDeadCPEMI - Remove a dead constant pool entry instruction. Update; /// sizes and offsets of impacted basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:245,Deployability,update,updated,245,"// Add an unconditional branch to the destination and invert the branch; // condition to jump over it:; // bteqz L1; // =>; // bnez L2; // b L1; // L2:; // If the branch is at the end of its MBB and that has a fall-through block,; // direct the updated conditional branch to the fall-through block. Otherwise,; // split the MBB before the next instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:56,Usability,simpl,simply,56,// Last MI in the BB is an unconditional branch. Can we simply invert the; // condition and swap destinations:; // beqz L1; // b L2; // =>; // bnez L2; // b L1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:76,Deployability,update,update,76,// Insert a new conditional branch and a new unconditional branch.; // Also update the ImmBranch as well as adding a new entry for the new branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:383,Usability,Simpl,Simple,383,"//===- MipsDelaySlotFiller.cpp - Mips Delay Slot Filler -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Simple pass to fill delay slots with useful instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:30,Performance,load,loads,30,/// Base class for inspecting loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:29,Performance,load,loads,29,/// Flags indicating whether loads or stores have been seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:26,Performance,load,loads,26,/// This subclass accepts loads from stacks and constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:57,Performance,load,loads,57,/// This subclass accepts loads from stacks and constant loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:30,Integrability,depend,dependence,30,/// This subclass uses memory dependence information to determine whether a; /// memory instruction can be moved to a delay slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:4,Deployability,Update,Update,4,/// Update Defs and Uses. Return true if there exist dependences that; /// disqualify the delay slot candidate between V and values in Uses and; /// Defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:53,Integrability,depend,dependences,53,/// Update Defs and Uses. Return true if there exist dependences that; /// disqualify the delay slot candidate between V and values in Uses and; /// Defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:29,Performance,load,loads,29,/// Flags indicating whether loads or stores with no underlying objects have; /// been seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:119,Deployability,update,updates,119,/// This function checks if it is valid to move Candidate to the delay slot; /// and returns true if it isn't. It also updates memory and register; /// dependence information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:152,Integrability,depend,dependence,152,/// This function checks if it is valid to move Candidate to the delay slot; /// and returns true if it isn't. It also updates memory and register; /// dependence information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:84,Performance,load,loads,84,"// If MI is an ordered or volatile memory reference, disallow moving; // subsequent loads and stores to delay slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:3,Deployability,Update,Update,3,// Update call site info for the Branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:513,Safety,avoid,avoid,513,"// For microMIPS if instruction is BEQ or BNE with one ZERO register, then; // instead of adding NOP replace this instruction with the corresponding; // compact branch instruction, i.e. BEQZC or BNEZC. Additionally; // PseudoReturn and PseudoIndirectBranch are expanded to JR_MM, so they can; // be replaced with JRC16_MM.; // For MIPSR6 attempt to produce the corresponding compact (no delay slot); // form of the CTI. For indirect jumps this will not require inserting a; // NOP and for branches will hopefully avoid requiring a NOP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:29,Deployability,update,update,29,"// However, we still need to update the register def-use information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:38,Availability,mask,masked,38,"// In NaCl, instructions that must be masked are forbidden in delay slots.; // We only check for loads, stores and SP changes. Calls, returns and; // branches are not checked because non-NaCl targets never put them in; // delay slots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:97,Performance,load,loads,97,"// In NaCl, instructions that must be masked are forbidden in delay slots.; // We only check for loads, stores and SP changes. Calls, returns and; // branches are not checked because non-NaCl targets never put them in; // delay slots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:40,Performance,optimiz,optimization,40,// This is complicated by the tail call optimization. For non-PIC code; // there is only a 32bit sized unconditional branch which can be assumed; // to be able to reach the target. b16 only has a range of +/- 1 KB.; // It's entirely possible that the target function is reachable with b16; // but we don't have enough information to make that decision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:21,Performance,load,loads,21,// Only allow moving loads from stack or constants if any of the SuccBB's; // predecessors have multiple successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:487,Energy Efficiency,schedul,scheduling,487,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:631,Energy Efficiency,schedul,scheduling,631,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:533,Performance,optimiz,optimizations,533,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:758,Safety,avoid,avoid,758,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:886,Safety,abort,abort,886,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:41,Availability,Mask,Mask,41,"// loop1MBB:; // ll dest, 0(ptr); // and Mask', dest, Mask; // bne Mask', ShiftCmpVal, exitMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:54,Availability,Mask,Mask,54,"// loop1MBB:; // ll dest, 0(ptr); // and Mask', dest, Mask; // bne Mask', ShiftCmpVal, exitMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:67,Availability,Mask,Mask,67,"// loop1MBB:; // ll dest, 0(ptr); // and Mask', dest, Mask; // bne Mask', ShiftCmpVal, exitMBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:28,Availability,Mask,Mask,28,"// sinkMBB:; // srl srlres, Mask', shiftamt; // sign_extend dest,srlres",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:84,Availability,mask,mask,84,"// and andres, oldval, incr2; // nor binopres, $0, andres; // and newval, binopres, mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:32,Usability,clear,clear,32,// For little endian we need to clear uninterested bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:23,Availability,Mask,Mask,23,"// and OldVal, OldVal, Mask; // and Incr, Incr, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:48,Availability,Mask,Mask,48,"// and OldVal, OldVal, Mask; // and Incr, Incr, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:27,Availability,Mask,Mask,27,"// and BinOpRes, BinOpRes, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:61,Availability,mask,mask,61,"// <binop> binopres, oldval, incr2; // and newval, binopres, mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:38,Availability,mask,mask,38,"// atomic.swap; // and newval, incr2, mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:41,Availability,mask,mask,41,"// sinkMBB:; // and maskedoldval1,oldval,mask; // srl srlres,maskedoldval1,shiftamt; // sign_extend dest,srlres",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Modifiability,variab,variables,15,// Convenience variables to avoid some queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:28,Safety,avoid,avoid,28,// Convenience variables to avoid some queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:13,Integrability,rout,routines,13,// Selection routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:18,Integrability,rout,routines,18,// Utility helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Integrability,rout,routines,15,// Emit helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:17,Integrability,rout,routines,17,// Call handling routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:46,Modifiability,extend,extended,46,// If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:34,Deployability,patch,patch,34,// We will extend this in a later patch:; // If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:11,Modifiability,extend,extend,11,// We will extend this in a later patch:; // If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:88,Modifiability,extend,extended,88,// We will extend this in a later patch:; // If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:76,Availability,redundant,redundant,76,"// Because of how EmitCmp is called with fast-isel, you can; // end up with redundant ""andi"" instructions after the sequences emitted below.; // We should try and solve this issue in the future.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:76,Safety,redund,redundant,76,"// Because of how EmitCmp is called with fast-isel, you can; // end up with redundant ""andi"" instructions after the sequences emitted below.; // We should try and solve this issue in the future.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:52,Deployability,patch,patches,52,//; // more cases will be handled here in following patches.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:52,Deployability,patch,patches,52,//; // more cases will be handled here in following patches.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:10,Performance,load,loads,10,// Atomic loads need special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:20,Availability,redundant,redundant,20,// This can cause a redundant sltiu to be generated.; // FIXME: try and eliminate this in a future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:99,Deployability,patch,patch,99,// This can cause a redundant sltiu to be generated.; // FIXME: try and eliminate this in a future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:20,Safety,redund,redundant,20,// This can cause a redundant sltiu to be generated.; // FIXME: try and eliminate this in a future patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:36,Availability,mask,mask,36,"// For the general case, we need to mask with 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:43,Modifiability,extend,extend,43,// Attempt to fast-select a floating-point extend instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:202,Deployability,patch,patch,202,//; // FIXME: This path will currently return false. It was copied; // from the AArch64 port and should be essentially fine for Mips too.; // The work to finish up this path will be done in a follow-on patch.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:24,Modifiability,extend,extended,24,// Special handling for extended integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple cases. i.e. All arguments are directly mapped to; // registers of the appropriate type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:18,Modifiability,extend,extend,18,"// It must be any extend, this shouldn't happen for clang-generated IR; // so just fall back on SelectionDAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:38,Modifiability,extend,extended,38,// The O32 ABI does not permit a zero-extended i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:28,Energy Efficiency,allocate,allocates,28,"// Allocating an FGR32 also allocates the super-register AFGR64, and; // ABI rules require us to skip the corresponding GPR32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:28,Energy Efficiency,allocate,allocates,28,"// Allocating an FGR32 also allocates the super-register AFGR64, and; // ABI rules require us to skip the corresponding GPR32 pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:23,Usability,simpl,simple,23,// FIXME: Only handle *simple* calls for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:18,Availability,mask,mask,18,// Add a register mask with the call-preserved registers.; // Proper defs for return values will be added by setPhysRegsDeadExcept().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:3,Safety,Avoid,Avoid,3,// Avoid a cross-class copy. This is very unlikely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:24,Modifiability,extend,extended,24,// Special handling for extended integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:108,Testability,test,test,108,"// FastISel does not have plumbing to deal with extensions where the SrcVT or; // DestVT are odd things, so test to make sure that they are both types we can; // handle (i1/i8/i16/i32 for SrcVT and i8/i16/i32/i64 for DestVT), otherwise; // bail out to SelectionDAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:67,Modifiability,extend,extended,67,"// If AShr or LShr, then we need to make sure the operand0 is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp:176,Energy Efficiency,allocate,allocated,176,"//===----------------------------------------------------------------------===//; //; // Stack Frame Processing methods; // +----------------------------+; //; // The stack is allocated decrementing the stack pointer on; // the first instruction of a function prologue. Once decremented,; // all stack references are done thought a positive offset; // from the stack/frame pointer, so the stack is considering; // to grow up! Otherwise terrible hacks would have to be made; // to get this stack ABI compliant :); //; // The stack frame required by the ABI (after call):; // Offset; //; // 0 ----------; // 4 Args to pass; // . saved $GP (used in PIC); // . Alloca allocations; // . Local Area; // . CPU ""Callee Saved"" Registers; // . saved FP; // . saved RA; // . FPU ""Callee Saved"" Registers; // StackSize -----------; //; // Offset - offset from sp after stack allocation on function prologue; //; // The sp is the stack pointer subtracted/added from the stack size; // at the Prologue/Epilogue; //; // References to the previous stack (to obtain arguments) are done; // with offsets that exceeds the stack size: (stacksize+(4*(num_arg-1)); //; // Examples:; // - reference to the actual stack frame; // for any local area var there is smt like : FI >= 0, StackOffset: 4; // sw REGX, 4(SP); //; // - reference to previous stack frame; // suppose there's a load to the 5th arguments : FI < 0, StackOffset: 16.; // The emitted instruction will be something like:; // lw REGX, 16+StackSize(SP); //; // Since the total stack size is unknown on LowerFormalArguments, all; // stack references (ObjectOffset) created to reference the function; // arguments, are negative numbers. This way, on eliminateFrameIndex it's; // possible to detect those references and the offsets are adjusted to; // their real location.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp:1358,Performance,load,load,1358,"//===----------------------------------------------------------------------===//; //; // Stack Frame Processing methods; // +----------------------------+; //; // The stack is allocated decrementing the stack pointer on; // the first instruction of a function prologue. Once decremented,; // all stack references are done thought a positive offset; // from the stack/frame pointer, so the stack is considering; // to grow up! Otherwise terrible hacks would have to be made; // to get this stack ABI compliant :); //; // The stack frame required by the ABI (after call):; // Offset; //; // 0 ----------; // 4 Args to pass; // . saved $GP (used in PIC); // . Alloca allocations; // . Local Area; // . CPU ""Callee Saved"" Registers; // . saved FP; // . saved RA; // . FPU ""Callee Saved"" Registers; // StackSize -----------; //; // Offset - offset from sp after stack allocation on function prologue; //; // The sp is the stack pointer subtracted/added from the stack size; // at the Prologue/Epilogue; //; // References to the previous stack (to obtain arguments) are done; // with offsets that exceeds the stack size: (stacksize+(4*(num_arg-1)); //; // Examples:; // - reference to the actual stack frame; // for any local area var there is smt like : FI >= 0, StackOffset: 4; // sw REGX, 4(SP); //; // - reference to previous stack frame; // suppose there's a load to the 5th arguments : FI < 0, StackOffset: 16.; // The emitted instruction will be something like:; // lw REGX, 16+StackSize(SP); //; // Since the total stack size is unknown on LowerFormalArguments, all; // stack references (ObjectOffset) created to reference the function; // arguments, are negative numbers. This way, on eliminateFrameIndex it's; // possible to detect those references and the offsets are adjusted to; // their real location.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp:1729,Safety,detect,detect,1729,"//===----------------------------------------------------------------------===//; //; // Stack Frame Processing methods; // +----------------------------+; //; // The stack is allocated decrementing the stack pointer on; // the first instruction of a function prologue. Once decremented,; // all stack references are done thought a positive offset; // from the stack/frame pointer, so the stack is considering; // to grow up! Otherwise terrible hacks would have to be made; // to get this stack ABI compliant :); //; // The stack frame required by the ABI (after call):; // Offset; //; // 0 ----------; // 4 Args to pass; // . saved $GP (used in PIC); // . Alloca allocations; // . Local Area; // . CPU ""Callee Saved"" Registers; // . saved FP; // . saved RA; // . FPU ""Callee Saved"" Registers; // StackSize -----------; //; // Offset - offset from sp after stack allocation on function prologue; //; // The sp is the stack pointer subtracted/added from the stack size; // at the Prologue/Epilogue; //; // References to the previous stack (to obtain arguments) are done; // with offsets that exceeds the stack size: (stacksize+(4*(num_arg-1)); //; // Examples:; // - reference to the actual stack frame; // for any local area var there is smt like : FI >= 0, StackOffset: 4; // sw REGX, 4(SP); //; // - reference to previous stack frame; // suppose there's a load to the 5th arguments : FI < 0, StackOffset: 16.; // The emitted instruction will be something like:; // lw REGX, 16+StackSize(SP); //; // Since the total stack size is unknown on LowerFormalArguments, all; // stack references (ObjectOffset) created to reference the function; // arguments, are negative numbers. This way, on eliminateFrameIndex it's; // possible to detect those references and the offsets are adjusted to; // their real location.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp:134,Modifiability,variab,variable,134,"// hasFP - Return true if the specified function should have a dedicated frame; // pointer register. This is true if the function has variable sized allocas,; // if it needs dynamic stack realignment, if frame pointer elimination is; // disabled, or if the frame address is taken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:25,Safety,hazard,hazard,25,/// insertNoop - If data hazard condition is found insert the target nop; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:165,Safety,unsafe,unsafe,165,/// Predicate for distingushing between control transfer instructions and all; /// other instructions for handling forbidden slots. Consider inline assembly; /// as unsafe as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:70,Performance,load,load,70,/// Predicate for distinguishing instructions that are hazardous in a load delay; /// slot. Consider inline assembly as unsafe as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:55,Safety,hazard,hazardous,55,/// Predicate for distinguishing instructions that are hazardous in a load delay; /// slot. Consider inline assembly as unsafe as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:120,Safety,unsafe,unsafe,120,/// Predicate for distinguishing instructions that are hazardous in a load delay; /// slot. Consider inline assembly as unsafe as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:55,Performance,load,load,55,/// Predicate for distingushing instructions that have load delay slots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:15,Modifiability,Variab,Variable,15,// Inline Asm: Variable size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:416,Deployability,update,updated,416,"// Certain branches have two forms: e.g beq $1, $zero, dest vs beqz $1, dest; // Pick the zero form of the branch for readable assembly and for greater; // branch distance in non-microMIPS mode.; // Additional MIPSR6 does not permit the use of register $zero for compact; // branches.; // FIXME: Certain atomic sequences on mips64 generate 32bit references to; // Mips::ZERO, which is incorrect. This test should be updated to use; // Subtarget.getABI().GetZeroReg() when those atomic sequences and others; // are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:401,Testability,test,test,401,"// Certain branches have two forms: e.g beq $1, $zero, dest vs beqz $1, dest; // Pick the zero form of the branch for readable assembly and for greater; // branch distance in non-microMIPS mode.; // Additional MIPSR6 does not permit the use of register $zero for compact; // branches.; // FIXME: Certain atomic sequences on mips64 generate 32bit references to; // Mips::ZERO, which is incorrect. This test should be updated to use; // Subtarget.getABI().GetZeroReg() when those atomic sequences and others; // are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:3,Performance,Perform,Perform,3,// Perform target specific instruction verification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:31,Performance,load,loaded,31,"// When SrcReg is $zero, treat loaded value as immediate only.; // Ex. $a2 = ADDiu $zero, 10",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:57,Performance,load,load,57,/// Predicate to determine if an instruction can go in a load delay slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:51,Performance,load,load,51,/// Predicate to determine if an instruction has a load delay slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:32,Safety,hazard,hazard,32,/// Insert nop instruction when hazard condition is found,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:4,Performance,Perform,Perform,4,/// Perform target specific instruction verification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:12,Modifiability,extend,extends,12,// Ori zero extends immediate. Used for values with zeros in high 16 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:14,Modifiability,extend,extends,14,// ADDiu sign extends immediate. Used for values with 1s in high 17 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:15,Modifiability,extend,extending,15,// Unspecified extending load is selected into zeroExtending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:25,Performance,load,load,25,// Unspecified extending load is selected into zeroExtending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:61,Performance,load,load,61,// Unspecified extending load is selected into zeroExtending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:15,Performance,load,load,15,"// Try to fold load/store + G_PTR_ADD + G_CONSTANT; // %SignedOffset:(s32) = G_CONSTANT i32 16_bit_signed_immediate; // %Addr:(p0) = G_PTR_ADD %BaseAddr, %SignedOffset; // %LoadResult/%StoreSrc = load/store %Addr(p0); // into:; // %LoadResult/%StoreSrc = NewOpc %BaseAddr(p0), 16_bit_signed_immediate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:173,Performance,Load,LoadResult,173,"// Try to fold load/store + G_PTR_ADD + G_CONSTANT; // %SignedOffset:(s32) = G_CONSTANT i32 16_bit_signed_immediate; // %Addr:(p0) = G_PTR_ADD %BaseAddr, %SignedOffset; // %LoadResult/%StoreSrc = load/store %Addr(p0); // into:; // %LoadResult/%StoreSrc = NewOpc %BaseAddr(p0), 16_bit_signed_immediate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:196,Performance,load,load,196,"// Try to fold load/store + G_PTR_ADD + G_CONSTANT; // %SignedOffset:(s32) = G_CONSTANT i32 16_bit_signed_immediate; // %Addr:(p0) = G_PTR_ADD %BaseAddr, %SignedOffset; // %LoadResult/%StoreSrc = load/store %Addr(p0); // into:; // %LoadResult/%StoreSrc = NewOpc %BaseAddr(p0), 16_bit_signed_immediate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:232,Performance,Load,LoadResult,232,"// Try to fold load/store + G_PTR_ADD + G_CONSTANT; // %SignedOffset:(s32) = G_CONSTANT i32 16_bit_signed_immediate; // %Addr:(p0) = G_PTR_ADD %BaseAddr, %SignedOffset; // %LoadResult/%StoreSrc = load/store %Addr(p0); // into:; // %LoadResult/%StoreSrc = NewOpc %BaseAddr(p0), 16_bit_signed_immediate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:20,Security,access,access,20,// Unaligned memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:183,Testability,log,logically,183,"// Default compare result in gpr register will be `true`.; // We will move `false` (MIPS::Zero) to gpr result when fcmp gives false; // using MOVF_I. When orignal predicate (Cond) is logically negated; // MipsFCMPCondCode, result is inverted i.e. MOVT_I is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp:67,Deployability,pipeline,pipeline,67,// There are multiple MipsDAGToDAGISel instances added to the pass pipeline.; // We need to preserve StackProtector for the next one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp:59,Performance,Load,Load,59,/// ComplexPattern used on MipsInstrInfo; /// Used on Mips Load/Store instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp:116,Safety,avoid,avoid,116,"/// Convert vector addition with vector subtraction if that allows to encode; /// constant as an immediate and thus avoid extra 'ldi' instruction.; /// add X, <-1, -1...> --> sub X, <1, 1...>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h:51,Energy Efficiency,power,power,51,/// Select constant vector splats whose value is a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h:71,Energy Efficiency,power,power,71,/// Select constant vector splats whose value is the inverse of a; /// power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h:116,Safety,avoid,avoid,116,"/// Convert vector addition with vector subtraction if that allows to encode; /// constant as an immediate and thus avoid extra 'ldi' instruction.; /// add X, <-1, -1...> --> sub X, <1, 1...>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:405,Integrability,interface,interfaces,405,"//===- MipsISelLowering.cpp - Mips DAG Lowering Implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Mips uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:117,Integrability,depend,dependant,117,// The MIPS MSA ABI passes vector arguments in the integer register set.; // The number of integer registers used is dependant on the ABI used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Performance,Load,Load,3,// Load extented operations for i1 types must be promoted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:21,Modifiability,extend,extending,21,"// MIPS doesn't have extending float->double load/store. Set LoadExtAction; // for f32, f16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:45,Performance,load,load,45,"// MIPS doesn't have extending float->double load/store. Set LoadExtAction; // for f32, f16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:61,Performance,Load,LoadExtAction,61,"// MIPS doesn't have extending float->double load/store. Set LoadExtAction; // for f32, f16",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:7,Performance,Load,LoadExtAction,7,// Set LoadExtAction for f16 vectors to Expand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:26,Availability,avail,available,26,// These libcalls are not available in 32-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:246,Performance,load,load,246,"// If the RHS (False) is 0, we swap the order of the operands; // of ISD::SELECT (obviously also inverting the condition) so that we can; // take advantage of conditional moves using the $0 register.; // Example:; // return (a != 0) ? x : 0;; // load $reg, x; // movz $reg, $0, a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:100,Performance,optimiz,optimizations,100,// If both operands are integer constants there's a possibility that we; // can do some interesting optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:47,Performance,optimiz,optimizations,47,// We'll also ignore MVT::i64 operands as this optimizations proves; // to be ineffective because of the required sign extensions as the result; // of a SETCC operator is always MVT::i32 for non-vector types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:13,Performance,optimiz,optimize,13,// Could not optimize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:241,Performance,load,load,241,"// Since RHS (False) is 0, we swap the order of the True/False operands; // (obviously also inverting the condition) so that we can; // take advantage of conditional moves using the $0 register.; // Example:; // return (a != 0) ? x : 0;; // load $reg, x; // movz $reg, $0, a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:41,Availability,mask,mask,41,// Op's second operand must be a shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,Availability,mask,mask,25,// Return if the shifted mask does not start at bit 0 or the sum of its size; // and Pos exceeds the word's size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:56,Availability,mask,mask,56,"// Pattern match CINS.; // $dst = and (shl $src , pos), mask; // => cins $dst, $src, pos, size; // mask is a shifted mask with consecutive 1's, pos = shift amount,; // size = population count.; // The second operand of the shift must be an immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:99,Availability,mask,mask,99,"// Pattern match CINS.; // $dst = and (shl $src , pos), mask; // => cins $dst, $src, pos, size; // mask is a shifted mask with consecutive 1's, pos = shift amount,; // size = population count.; // The second operand of the shift must be an immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:117,Availability,mask,mask,117,"// Pattern match CINS.; // $dst = and (shl $src , pos), mask; // => cins $dst, $src, pos, size; // mask is a shifted mask with consecutive 1's, pos = shift amount,; // size = population count.; // The second operand of the shift must be an immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:126,Availability,mask,mask,126,"// Pattern match EXT.; // $dst = and $src, (2**size - 1) , if size > 16; // => ext $dst, $src, pos, size , pos = 0; // If the mask is <= 0xffff, andi can be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:17,Availability,mask,mask,17,// Return if the mask doesn't start at position 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:13,Availability,mask,masks,13,// The shift masks must have the same position and size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:60,Availability,mask,mask,60,// Return if the shift amount and the first bit position of mask are not the; // same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:71,Usability,clear,cleared,71,// Don't generate INS if constant OR operand doesn't fit into bits; // cleared by constant AND operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:758,Modifiability,extend,extended,758,"// For MIPS64, madd / msub instructions are inefficent to use with 64 bit; // arithmetic. E.g.; // (add (mul a b) c) =>; // let res = (madd (mthi (drotr c 32))x(mtlo c) a b) in; // MIPS64: (or (dsll (mfhi res) 32) (dsrl (dsll (mflo res) 32) 32); // or; // MIPS64R2: (dins (mflo res) (mfhi res) 32 32); //; // The overhead of setting up the Hi/Lo registers and reassembling the; // result makes this a dubious optimzation for MIPS64. The core of the; // problem is that Hi/Lo contain the upper and lower 32 bits of the; // operand and result.; //; // It requires a chain of 4 add/mul for MIPS64R2 to get better code; // density than doing it naively, 5 for MIPS64. Additionally, using; // madd/msub on MIPS64 requires the operands actually be 32 bit sign; // extended operands, not true 64 bit values.; //; // FIXME: For the moment, disable this completely for MIPS64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:114,Modifiability,extend,extended,114,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:225,Performance,perform,perform,225,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:238,Performance,optimiz,optimization,238,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:288,Performance,perform,performing,288,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:308,Performance,optimiz,optimization,308,"// maddu and madd are unusual instructions in that on MIPS64 bits 63..31; // must be in canonical form, i.e. sign extended. For MIPS32, the operands; // of the multiply must have 32 or more sign bits, otherwise we cannot; // perform this optimization. We have to check this here as we're performing; // this optimization pre-legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:42,Availability,mask,mask,42,// AND's second operand must be a shifted mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,Availability,mask,mask,25,// Return if the shifted mask does not start at bit 0 or the sum of its size; // and Pos exceeds the word's size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:34,Testability,test,test,34,"// We can use ANDI+SLTIU as a bit test. Y contains the bit position.; // For MIPSR2 or later, we may be able to use the `ext` instruction or its'; // double-word variants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear Divisor's kill flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:97,Integrability,inject,inject,97,// We would normally delete the original instruction here but in this case; // we only needed to inject an additional instruction rather than replace it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:97,Security,inject,inject,97,// We would normally delete the original instruction here but in this case; // we only needed to inject an additional instruction rather than replace it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:1591,Integrability,synchroniz,synchronizable,1591,"// The scratch registers here with the EarlyClobber | Define | Implicit; // flags is used to persuade the register allocator and the machine; // verifier to accept the usage of this register. This has to be a real; // register which has an UNDEF value but is dead after the instruction which; // is unique among the registers chosen for the instruction.; // The EarlyClobber flag has the semantic properties that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction.; // The Define flag is needed to coerce the machine verifier that an Undef; // value isn't a problem.; // The Dead flag is needed as the value in scratch isn't used by any other; // instruction. Kill isn't used as Dead is more precise.; // The implicit flag is here due to the interaction between the other flags; // and the machine verifier.; // For correctness purpose, a new pseudo is introduced here. We need this; // new pseudo, so that FastRegisterAllocator does not see an ll/sc sequence; // that is spread over >1 basic blocks. A register allocator which; // introduces (or any codegen infact) a store, can violate the expectations; // of the hardware.; //; // An atomic read-modify-write sequence starts with a linked load; // instruction and ends with a store conditional instruction. The atomic; // read-modify-write sequence fails if any of the following conditions; // occur between the execution of ll and sc:; // * A coherent store is completed by another process or coherent I/O; // module into the block of synchronizable physical memory containing; // the word. The size and alignment of the block is; // implementation-dependent.; // * A coherent store is executed between an LL and SC sequence on the; // same processor to the block of synchornizable physical memory; // containing the word.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:1705,Integrability,depend,dependent,1705,"// The scratch registers here with the EarlyClobber | Define | Implicit; // flags is used to persuade the register allocator and the machine; // verifier to accept the usage of this register. This has to be a real; // register which has an UNDEF value but is dead after the instruction which; // is unique among the registers chosen for the instruction.; // The EarlyClobber flag has the semantic properties that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction.; // The Define flag is needed to coerce the machine verifier that an Undef; // value isn't a problem.; // The Dead flag is needed as the value in scratch isn't used by any other; // instruction. Kill isn't used as Dead is more precise.; // The implicit flag is here due to the interaction between the other flags; // and the machine verifier.; // For correctness purpose, a new pseudo is introduced here. We need this; // new pseudo, so that FastRegisterAllocator does not see an ll/sc sequence; // that is spread over >1 basic blocks. A register allocator which; // introduces (or any codegen infact) a store, can violate the expectations; // of the hardware.; //; // An atomic read-modify-write sequence starts with a linked load; // instruction and ends with a store conditional instruction. The atomic; // read-modify-write sequence fails if any of the following conditions; // occur between the execution of ll and sc:; // * A coherent store is completed by another process or coherent I/O; // module into the block of synchronizable physical memory containing; // the word. The size and alignment of the block is; // implementation-dependent.; // * A coherent store is executed between an LL and SC sequence on the; // same processor to the block of synchornizable physical memory; // containing the word.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:1294,Performance,load,load,1294,"// The scratch registers here with the EarlyClobber | Define | Implicit; // flags is used to persuade the register allocator and the machine; // verifier to accept the usage of this register. This has to be a real; // register which has an UNDEF value but is dead after the instruction which; // is unique among the registers chosen for the instruction.; // The EarlyClobber flag has the semantic properties that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction.; // The Define flag is needed to coerce the machine verifier that an Undef; // value isn't a problem.; // The Dead flag is needed as the value in scratch isn't used by any other; // instruction. Kill isn't used as Dead is more precise.; // The implicit flag is here due to the interaction between the other flags; // and the machine verifier.; // For correctness purpose, a new pseudo is introduced here. We need this; // new pseudo, so that FastRegisterAllocator does not see an ll/sc sequence; // that is spread over >1 basic blocks. A register allocator which; // introduces (or any codegen infact) a store, can violate the expectations; // of the hardware.; //; // An atomic read-modify-write sequence starts with a linked load; // instruction and ends with a store conditional instruction. The atomic; // read-modify-write sequence fails if any of the following conditions; // occur between the execution of ll and sc:; // * A coherent store is completed by another process or coherent I/O; // module into the block of synchronizable physical memory containing; // the word. The size and alignment of the block is; // implementation-dependent.; // * A coherent store is executed between an LL and SC sequence on the; // same processor to the block of synchornizable physical memory; // containing the word.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:141,Availability,mask,maskupper,141,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // sll incr2,incr,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:173,Availability,mask,mask,173,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // sll incr2,incr,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:178,Availability,mask,maskupper,178,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // sll incr2,incr,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:214,Availability,mask,mask,214,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // sll incr2,incr,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:265,Performance,load,load,265,"// Lower atomic compare and swap to a pseudo instruction, taking care to; // define a scratch register for the pseudo instruction's expansion. The; // instruction is expanded after the register allocator as to prevent; // the insertion of stores between the linked load and the store conditional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:283,Availability,error,errors,283,"// We need to create copies of the various registers and kill them at the; // atomic pseudo. If the copies are not made, when the atomic is expanded; // after fast register allocation, the spills will end up outside of the; // blocks that their values are defined in, causing livein errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:182,Availability,mask,maskupper,182,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:214,Availability,mask,mask,214,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:219,Availability,mask,maskupper,219,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:255,Availability,mask,mask,255,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:269,Availability,mask,maskedcmpval,269,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:315,Availability,mask,maskedcmpval,315,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:346,Availability,mask,maskednewval,346,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:392,Availability,mask,maskednewval,392,"// thisMBB:; // addiu masklsb2,$0,-4 # 0xfffffffc; // and alignedaddr,ptr,masklsb2; // andi ptrlsb2,ptr,3; // xori ptrlsb2,ptrlsb2,3 # Only for BE; // sll shiftamt,ptrlsb2,3; // ori maskupper,$0,255 # 0xff; // sll mask,maskupper,shiftamt; // nor mask2,$0,mask; // andi maskedcmpval,cmpval,255; // sll shiftedcmpval,maskedcmpval,shiftamt; // andi maskednewval,newval,255; // sll shiftednewval,maskednewval,shiftamt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:129,Performance,load,loads,129,"// Every other architecture would use shouldAssumeDSOLocal in here, but; // mips is special.; // * In PIC code mips requires got loads even for local statics!; // * To save on got entries, for local statics the got entry contains the; // page and an additional add instruction takes care of the low bits.; // * It is legal to access a hidden symbol with a non hidden undefined,; // so one cannot guarantee that all access to a hidden symbol will know; // it is hidden.; // * Mips linkers don't support creating a page and a full got entry for; // the same symbol.; // * Given all that, we have to use a full got entry for hidden symbols :-(",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:326,Security,access,access,326,"// Every other architecture would use shouldAssumeDSOLocal in here, but; // mips is special.; // * In PIC code mips requires got loads even for local statics!; // * To save on got entries, for local statics the got entry contains the; // page and an additional add instruction takes care of the low bits.; // * It is legal to access a hidden symbol with a non hidden undefined,; // so one cannot guarantee that all access to a hidden symbol will know; // it is hidden.; // * Mips linkers don't support creating a page and a full got entry for; // the same symbol.; // * Given all that, we have to use a full got entry for hidden symbols :-(",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:415,Security,access,access,415,"// Every other architecture would use shouldAssumeDSOLocal in here, but; // mips is special.; // * In PIC code mips requires got loads even for local statics!; // * To save on got entries, for local statics the got entry contains the; // page and an additional add instruction takes care of the low bits.; // * It is legal to access a hidden symbol with a non hidden undefined,; // so one cannot guarantee that all access to a hidden symbol will know; // it is hidden.; // * Mips linkers don't support creating a page and a full got entry for; // the same symbol.; // * Given all that, we have to use a full got entry for hidden symbols :-(",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:322,Availability,down,down,322,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:125,Energy Efficiency,reduce,reduce,125,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:273,Energy Efficiency,reduce,reduce,273,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:58,Performance,load,load,58,"// In big-endian mode we must adjust the pointer when the load size is smaller; // than the argument slot size. We must also reduce the known alignment to; // match. For example in the N64 ABI, we must add 4 bytes to the offset to get; // the correct half of the slot, and reduce the alignment from 8 (slot; // alignment) down to 4 (type alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Performance,Load,Load,3,// Load the actual argument out of the pointer VAList,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear MSB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:209,Modifiability,rewrite,rewrite,209,"// FIXME: For mips32r2, the sequence of (BuildPairF64 (ins (ExtractElementF64; // Op 1), $zero, 31 1) (ExtractElementF64 Op 0)) and the Op has one use, we; // should be able to drop the usage of mfc1/mtc1 and rewrite the register in; // place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Usability,Clear,Clear,3,// Clear MSB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:44,Performance,load,load,44,// Expand an unaligned 32 or 64-bit integer load node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:13,Performance,load,load,13,// Return if load is aligned or if MemVT is neither i32 nor i64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:30,Performance,load,load,30,"// Expand; // (set dst, (i64 (load baseptr))); // to; // (set tmp, (ldl (add baseptr, 7), undef)); // (set dst, (ldr baseptr, tmp))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:30,Performance,load,load,30,"// Expand; // (set dst, (i32 (load baseptr))) or; // (set dst, (i64 (sextload baseptr))) or; // (set dst, (i64 (extload baseptr))); // to; // (set tmp, (lwl (add baseptr, 3), undef)); // (set dst, (lwr baseptr, tmp))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:770,Availability,avail,available,770,"//===----------------------------------------------------------------------===//; // Calling Convention Implementation; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // TODO: Implement a generic logic using tblgen that can support this.; // Mips O32 ABI rules:; // ---; // i32 - Passed in A0, A1, A2, A3 and stack; // f32 - Only passed in f32 registers if no int reg has been used yet to hold; // an argument. Otherwise, passed in A1, A2, A3 and stack.; // f64 - Only passed in two aliased f32 registers if no int reg has been used; // yet to hold an argument. Otherwise, use A2, A3 and stack. If A1 is; // not used, it must be shadowed. If only A3 is available, shadow it and; // go to stack.; // vXiX - Received as scalarized i32s, passed in A0 - A3 and the stack.; // vXf32 - Passed in either a pair of registers {A0, A1}, {A2, A3} or {A0 - A3}; // with the remainder spilled to the stack.; // vXf64 - Passed in either {A0, A1, A2, A3} or {A2, A3} and in both cases; // spilling the remainder to the stack.; //; // For vararg functions, all arguments are passed in A0, A1, A2, A3 and stack.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:313,Testability,log,logic,313,"//===----------------------------------------------------------------------===//; // Calling Convention Implementation; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // TODO: Implement a generic logic using tblgen that can support this.; // Mips O32 ABI rules:; // ---; // i32 - Passed in A0, A1, A2, A3 and stack; // f32 - Only passed in f32 registers if no int reg has been used yet to hold; // an argument. Otherwise, passed in A1, A2, A3 and stack.; // f64 - Only passed in two aliased f32 registers if no int reg has been used; // yet to hold an argument. Otherwise, use A2, A3 and stack. If A1 is; // not used, it must be shadowed. If only A3 is available, shadow it and; // go to stack.; // vXiX - Received as scalarized i32s, passed in A0 - A3 and the stack.; // vXf32 - Passed in either a pair of registers {A0, A1}, {A2, A3} or {A0 - A3}; // with the remainder spilled to the stack.; // vXf64 - Passed in either {A0, A1, A2, A3} or {A2, A3} and in both cases; // spilling the remainder to the stack.; //; // For vararg functions, all arguments are passed in A0, A1, A2, A3 and stack.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:19,Energy Efficiency,allocate,allocated,19,"// f32 and f64 are allocated in A0, A1, A2, A3 when either of the following; // is true: function is vararg, argument is 3rd or higher, there is previous; // argument which is not f32 or f64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:134,Energy Efficiency,Allocate,Allocate,134,"// This is the start of an vector that was scalarized into an unknown number; // of components. It doesn't matter how many there are. Allocate one of the; // notional 8 byte aligned registers which map onto the argument stack, and; // shadow the register lost to alignment requirements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:79,Energy Efficiency,allocate,allocate,79,"// If we're an intermediate component of the split, we can just attempt to; // allocate a register directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:52,Energy Efficiency,allocate,allocated,52,"// If this is the first part of an i64 arg,; // the allocated register must be either A0 or A2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:68,Availability,avail,available,68,"// Allocate int register and shadow next int register. If first; // available register is Mips::A1 or Mips::A3, shadow it too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate int register and shadow next int register. If first; // available register is Mips::A1 or Mips::A3, shadow it too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:32,Availability,avail,available,32,// we are guaranteed to find an available float register,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:224,Testability,stub,stub,224,"// Insert node ""GP copy globalreg"" before call to function.; //; // R_MIPS_CALL* operators (emitted when non-internal functions are called; // in PIC mode) allow symbols to be resolved via lazy binding.; // The lazy binding stub requires GP to point to the GOT.; // Note that we don't need GP to point to the GOT for indirect calls; // (when R_MIPS_CALL* is not used for the call) because Mips linker generates; // lazy binding stub for a function only when R_MIPS_CALL* are the only relocs; // used for the function (that is, Mips linker doesn't generate lazy binding; // stub for a function whose address is taken in the program).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:428,Testability,stub,stub,428,"// Insert node ""GP copy globalreg"" before call to function.; //; // R_MIPS_CALL* operators (emitted when non-internal functions are called; // in PIC mode) allow symbols to be resolved via lazy binding.; // The lazy binding stub requires GP to point to the GOT.; // Note that we don't need GP to point to the GOT for indirect calls; // (when R_MIPS_CALL* is not used for the call) because Mips linker generates; // lazy binding stub for a function only when R_MIPS_CALL* are the only relocs; // used for the function (that is, Mips linker doesn't generate lazy binding; // stub for a function whose address is taken in the program).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:573,Testability,stub,stub,573,"// Insert node ""GP copy globalreg"" before call to function.; //; // R_MIPS_CALL* operators (emitted when non-internal functions are called; // in PIC mode) allow symbols to be resolved via lazy binding.; // The lazy binding stub requires GP to point to the GOT.; // Note that we don't need GP to point to the GOT for indirect calls; // (when R_MIPS_CALL* is not used for the call) because Mips linker generates; // lazy binding stub for a function only when R_MIPS_CALL* are the only relocs; // used for the function (that is, Mips linker doesn't generate lazy binding; // stub for a function whose address is taken in the program).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:18,Availability,mask,mask,18,// Add a register mask operand representing the call-preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:215,Energy Efficiency,allocate,allocate,215,"// There is one case where CALLSEQ_START..CALLSEQ_END can be nested, which; // is during the lowering of a call with a byval argument which produces; // a call to memcpy. For the O32 case, this causes the caller to allocate; // stack space for the reserved argument area for the callee, then recursively; // again for the memcpy call. In the NEWABI case, this doesn't occur as those; // ABIs mandate that the callee allocates the reserved argument area. We do; // still produce nested CALLSEQ_START..CALLSEQ_END with zero space though.; //; // If the callee has a byval argument and memcpy is used, we are mandated; // to already have produced a reserved argument area for the callee for O32.; // Therefore, the reserved argument area can be reused for both calls.; //; // Other cases of calling memcpy cannot have a chain with a CALLSEQ_START; // present, as we have yet to hook that node onto the chain.; //; // Hence, the CALLSEQ_START and CALLSEQ_END nodes can be eliminated in this; // case. GCC does a similar trick, in that wherever possible, it calculates; // the maximum out going argument area (including the reserved area), and; // preallocates the stack space on entrance to the caller.; //; // FIXME: We should do the same for efficiency and space.; // Note: The check on the calling convention below must match; // MipsABIInfo::GetCalleeAllocdArgSizeInBytes().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:416,Energy Efficiency,allocate,allocates,416,"// There is one case where CALLSEQ_START..CALLSEQ_END can be nested, which; // is during the lowering of a call with a byval argument which produces; // a call to memcpy. For the O32 case, this causes the caller to allocate; // stack space for the reserved argument area for the callee, then recursively; // again for the memcpy call. In the NEWABI case, this doesn't occur as those; // ABIs mandate that the callee allocates the reserved argument area. We do; // still produce nested CALLSEQ_START..CALLSEQ_END with zero space though.; //; // If the callee has a byval argument and memcpy is used, we are mandated; // to already have produced a reserved argument area for the callee for O32.; // Therefore, the reserved argument area can be reused for both calls.; //; // Other cases of calling memcpy cannot have a chain with a CALLSEQ_START; // present, as we have yet to hook that node onto the chain.; //; // Hence, the CALLSEQ_START and CALLSEQ_END nodes can be eliminated in this; // case. GCC does a similar trick, in that wherever possible, it calculates; // the maximum out going argument area (including the reserved area), and; // preallocates the stack space on entrance to the caller.; //; // FIXME: We should do the same for efficiency and space.; // Note: The check on the calling convention below must match; // MipsABIInfo::GetCalleeAllocdArgSizeInBytes().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the reserved argument area. It seems strange to do this from the; // caller side but removing it breaks the frame size calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:41,Performance,Load,Load,41,// Chain is the output chain of the last Load/Store or CopyToReg node.; // ByValChain is the output chain of the last Memcpy node created for copying; // byval arguments to the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:92,Safety,avoid,avoid,92,"// If the parameter is passed through reg $D, which splits into; // two physical registers, avoid creating call site info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:210,Testability,assert,assertions,210,"// If this is an value smaller than the argument slot size (32-bit for O32,; // 64-bit for N32/N64), it has been promoted in some way to the argument slot; // size. Extract the value and insert any appropriate assertions regarding; // sign/zero extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:316,Performance,load,load,316,//===----------------------------------------------------------------------===//; // Formal Arguments Calling Convention Implementation; //===----------------------------------------------------------------------===//; /// LowerFormalArguments - transform physical registers into virtual registers; /// and generate load operations for arguments places on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:10,Performance,load,load,10,// Create load nodes to retrieve arguments from the stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:178,Security,access,access,178,// The mips ABIs for returning structs by value requires that we copy; // the sret argument into $v0 for the return. Save the argument into; // a virtual register so that we can access it from the return points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:37,Modifiability,config,config,37,// Mips specific constraints; // GCC config/mips/constraints.md; //; // 'd' : An address register. Equivalent to r; // unless generating MIPS16 code.; // 'y' : Equivalent to r; retained for; // backwards compatibility.; // 'c' : A register suitable for use in an indirect; // jump. This will always be $25 for -mabicalls.; // 'l' : The lo register. 1 word storage.; // 'x' : The hilo register pair. Double word storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:21,Security,access,access,21,// Parse $msa(ir|csr|access|save|modify|request|map|unmap); // No numeric characters follow the name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,Availability,error,error,25,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:31,Integrability,message,message,31,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:25,Availability,error,error,25,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:31,Integrability,message,message,31,// This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:158,Availability,error,error,158,// use the concatenated `hi` and `lo` registers; // to store doubleword values; // Fixme: Not triggering the use of both hi and low; // This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:164,Integrability,message,message,164,// use the concatenated `hi` and `lo` registers; // to store doubleword values; // Fixme: Not triggering the use of both hi and low; // This will generate an error message,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:77,Availability,error,error,77,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:56,Integrability,rout,routine,56,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:22,Integrability,depend,depending,22,"// ""r+i"" or just ""i"", depending on HasBaseReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:218,Energy Efficiency,Schedul,ScheduleDAGInstrs,218,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:110,Integrability,depend,dependencies,110,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:298,Integrability,depend,dependencies,298,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:55,Performance,load,load,55,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:315,Performance,load,loads,315,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:174,Usability,clear,clears,174,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:58,Performance,load,loads,58,// Copy the remainder of the byval argument with sub-word loads and shifts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Performance,Load,Load,3,// Load subword.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:13,Performance,load,loaded,13,// Shift the loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:23,Modifiability,variab,variable,23,// Offset of the first variable argument from stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:39,Modifiability,variab,variable,39,// Record the frame index of the first variable argument; // which is a value necessary to VASTART.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:141,Energy Efficiency,allocate,allocated,141,"// Copy the integer registers that have not been used for argument passing; // to the argument register save area. For O32, the save area is allocated; // in the caller's stack frame, while for N32/64, it is allocated in the; // callee's stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:208,Energy Efficiency,allocate,allocated,208,"// Copy the integer registers that have not been used for argument passing; // to the argument register save area. For O32, the save area is allocated; // in the caller's stack frame, while for N32/64, it is allocated in the; // callee's stack frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:161,Testability,test,test,161,"// If Alignment > RegSizeInBytes, the first arg register must be even.; // FIXME: This condition happens to do the right thing but it's not the; // right way to test it. We want to check that the stack frame offset; // of the register is aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:22,Energy Efficiency,allocate,allocated,22,// Mark the registers allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:176,Energy Efficiency,reduce,reduces,176,"// D_SELECT substitutes two SELECT nodes that goes one after another and; // have the same condition operand. On machines which don't have; // conditional-move instruction, it reduces unnecessary branch instructions; // which are result of using two diamond patterns that are result of two; // SELECT pseudo instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 6 can load from adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:22,Performance,load,load,22,// Mips release 6 can load from adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 5 needs to use instructions that can load from an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:53,Performance,load,load,53,// Mips release 5 needs to use instructions that can load from an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 6 can load from adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:22,Performance,load,load,22,// Mips release 6 can load from adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 5 needs to use instructions that can load from an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:53,Performance,load,load,53,// Mips release 5 needs to use instructions that can load from an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 6 can store to adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 5 needs to use instructions that can store to an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 6 can store to adress that is not naturally-aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:8,Deployability,release,release,8,// Mips release 5 needs to use instructions that can store to an unaligned; // memory address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:46,Integrability,Interface,Interface,46,"//===- MipsISelLowering.h - Mips DAG Lowering Interface ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Mips uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:405,Integrability,interface,interfaces,405,"//===- MipsISelLowering.h - Mips DAG Lowering Interface ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that Mips uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:52,Security,access,accessing,52,// Get the High 16 bits from a 32 bit immediate for accessing the GOT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:52,Security,access,accessing,52,// Get the High 16 bits from a 32-bit immediate for accessing TLS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:25,Availability,error,error,25,"// Interrupt, exception, error trap Return",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:23,Availability,mask,mask,23,// Vector Shuffle with mask as an operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:3,Modifiability,Extend,Extended,3,// Extended vector element extraction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:3,Performance,Load,Load,3,// Load/Store Left/Right nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:10,Availability,down,down,10,/// Break down vectors to the correct number of gpr sized integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:128,Integrability,wrap,wrapper,128,"// This method creates the following nodes, which are necessary for; // computing a local symbol's address:; //; // (add (load (wrapper $gp, %got(sym)), %lo(sym))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:122,Performance,load,load,122,"// This method creates the following nodes, which are necessary for; // computing a local symbol's address:; //; // (add (load (wrapper $gp, %got(sym)), %lo(sym))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:124,Integrability,wrap,wrapper,124,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address:; //; // (load (wrapper $gp, %got(sym)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:118,Performance,load,load,118,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address:; //; // (load (wrapper $gp, %got(sym)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:142,Integrability,wrap,wrapper,142,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address in large-GOT mode:; //; // (load (wrapper (add %hi(sym), $gp), %lo(sym)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:136,Performance,load,load,136,"// This method creates the following nodes, which are necessary for; // computing a global symbol's address in large-GOT mode:; //; // (load (wrapper (add %hi(sym), $gp), %lo(sym)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:3,Performance,Cache,Cache,3,"// Cache the ABI from the TargetMachine, we use it everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:94,Performance,optimiz,optimization,94,/// isEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:28,Modifiability,variab,variable,28,/// writeVarArgRegs - Write variable function arguments passed in registers; /// to the stack. Also create a stack frame object for the first variable; /// argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:142,Modifiability,variab,variable,142,/// writeVarArgRegs - Write variable function arguments passed in registers; /// to the stack. Also create a stack frame object for the first variable; /// argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:105,Availability,failure,failure,105,"/// This function parses registers that appear in inline-asm constraints.; /// It returns pair (0, 0) on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:179,Performance,load,load,179,"/// isFPImmLegal - Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:11,Energy Efficiency,power,power,11,// Assumes power of 2 memory size. Subtargets that have only naturally-aligned; // memory access need to perform additional legalization here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:105,Performance,perform,perform,105,// Assumes power of 2 memory size. Subtargets that have only naturally-aligned; // memory access need to perform additional legalization here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:90,Security,access,access,90,// Assumes power of 2 memory size. Subtargets that have only naturally-aligned; // memory access need to perform additional legalization here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:7,Energy Efficiency,power,power,7,// Non power of two memory access is never legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:27,Security,access,access,27,// Non power of two memory access is never legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:248,Performance,perform,performs,248,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:324,Performance,load,load,324,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:60,Security,access,access,60,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:102,Security,access,access,102,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:274,Security,access,access,274,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:68,Energy Efficiency,power,power-of-,68,"// Custom lower scalar memory access, up to 8 bytes, for:; // - non-power-of-2 MemSizes; // - unaligned 2 or 8 byte MemSizes for MIPS32r5 and older",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:30,Security,access,access,30,"// Custom lower scalar memory access, up to 8 bytes, for:; // - non-power-of-2 MemSizes; // - unaligned 2 or 8 byte MemSizes for MIPS32r5 and older",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:52,Energy Efficiency,power,power,52,"// Split MemSize into two, P2HalfMemSize is largest power of two smaller; // then MemSize. e.g. 8 = 4 + 4 , 6 = 4 + 2, 3 = 2 + 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:24,Performance,load,load,24,"// This is anyextending load, use 4 byte lwr/lwl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:183,Availability,mask,mask,183,"// Let 0xABCDEFGH be given unsigned in MI.getOperand(1). First let's convert; // unsigned to double. Mantissa has 52 bits so we use following trick:; // First make floating point bit mask 0x43300000ABCDEFGH.; // Mask represents 2^52 * 0x1.00000ABCDEFGH i.e. 0x100000ABCDEFGH.0 .; // Next, subtract 2^52 * 0x1.0000000000000 i.e. 0x10000000000000.0 from it.; // Done. Trunc double to float if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:212,Availability,Mask,Mask,212,"// Let 0xABCDEFGH be given unsigned in MI.getOperand(1). First let's convert; // unsigned to double. Mantissa has 52 bits so we use following trick:; // First make floating point bit mask 0x43300000ABCDEFGH.; // Mask represents 2^52 * 0x1.00000ABCDEFGH i.e. 0x100000ABCDEFGH.0 .; // Next, subtract 2^52 * 0x1.0000000000000 i.e. 0x10000000000000.0 from it.; // Done. Trunc double to float if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:497,Safety,avoid,avoid,497,"// For O32 ABI, the following instruction sequence is emitted to initialize; // the global base register:; //; // 0. lui $2, %hi(_gp_disp); // 1. addiu $2, $2, %lo(_gp_disp); // 2. addu $globalbasereg, $2, $t9; //; // We emit only the last instruction here.; //; // GNU linker requires that the first two instructions appear at the beginning; // of a function and no instructions be inserted before or between them.; // The two instructions are emitted during lowering to MC layer in order to; // avoid any reordering.; //; // Register $2 (Mips::V0) is added to the list of live-in registers to ensure; // the value instruction 1 (addiu) defines is valid when instruction 2 (addu); // reads it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:41,Availability,Error,ErrorPC,41,"// ISRs require spill slots for Status & ErrorPC Coprocessor 0 registers.; // The current implementation only supports Mips32r2+ not Mips64rX. Status; // is always 32 bits, ErrorPC is 32 or 64 bits dependent on architecture,; // however Mips32r2+ is the supported architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:173,Availability,Error,ErrorPC,173,"// ISRs require spill slots for Status & ErrorPC Coprocessor 0 registers.; // The current implementation only supports Mips32r2+ not Mips64rX. Status; // is always 32 bits, ErrorPC is 32 or 64 bits dependent on architecture,; // however Mips32r2+ is the supported architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:198,Integrability,depend,dependent,198,"// ISRs require spill slots for Status & ErrorPC Coprocessor 0 registers.; // The current implementation only supports Mips32r2+ not Mips64rX. Status; // is always 32 bits, ErrorPC is 32 or 64 bits dependent on architecture,; // however Mips32r2+ is the supported architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.h:55,Integrability,Rout,Routine,55,/// ISR - Whether the function is an Interrupt Service Routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:33,Performance,Optimiz,Optimize,33,"//===- MipsOptimizePICCall.cpp - Optimize PIC Calls -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass eliminates unnecessary instructions that set up $gp and replace; // instructions that load target function addresses with copy instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:479,Performance,load,load,479,"//===- MipsOptimizePICCall.cpp - Optimize PIC Calls -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass eliminates unnecessary instructions that set up $gp and replace; // instructions that load target function addresses with copy instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:4,Testability,Test,Test,4,"/// Test if MI jumps to a function via a register.; ///; /// Also, return the virtual register containing the target function's address; /// and the underlying object in Reg and Val respectively, if the function's; /// address can be resolved lazily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:85,Performance,load,load,85,/// Return the number of instructions that dominate the current; /// instruction and load the function address from object Entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:78,Performance,load,loads,78,/// Return the destination virtual register of the last instruction; /// that loads from object Entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:4,Deployability,Update,Update,4,/// Update ScopedHT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:3,Performance,Optimiz,OptimizePICCall,3,// OptimizePICCall methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:79,Performance,load,load,79,"// If a function has been called more than twice, we do not have to emit a; // load instruction to get the function address from the GOT, but can; // instead reuse the address that has been loaded before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:190,Performance,load,loaded,190,"// If a function has been called more than twice, we do not have to emit a; // load instruction to get the function address from the GOT, but can; // instead reuse the address that has been loaded before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:169,Testability,stub,stub,169,// Erase the $gp operand if this isn't the first time a function has; // been called. $gp needs to be set up only if the function call can go; // through a lazy binding stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:28,Performance,load,loads,28,// Get the instruction that loads the function address from the GOT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:39,Performance,load,loads,39,// See if DefMI is an instruction that loads from a GOT entry that holds the; // address of a lazy binding stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:107,Testability,stub,stub,107,// See if DefMI is an instruction that loads from a GOT entry that holds the; // address of a lazy binding stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:14,Performance,Optimiz,OptimizeCall,14,/// Return an OptimizeCall object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp:382,Performance,optimiz,optimization,382,"//===---- MipsOs16.cpp for Mips Option -Os16 --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an optimization phase for the MIPS target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp:90,Modifiability,variab,variables,90,// Figure out if we need float point based on the function signature.; // We need to move variables in and/or out of floating point; // registers because of the ABI; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp:32,Energy Efficiency,power,power,32,// Don't attempt to combine non power of 2 loads or unaligned loads when; // subtarget doesn't support them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp:43,Performance,load,loads,43,// Don't attempt to combine non power of 2 loads or unaligned loads when; // subtarget doesn't support them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp:62,Performance,load,loads,62,// Don't attempt to combine non power of 2 loads or unaligned loads when; // subtarget doesn't support them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsPreLegalizerCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp:315,Availability,avail,available,315,"// Excluding WaitingForTypeOfMI, MI is either connected to chains of ambiguous; // instructions or has no other adjacent instructions. Anyway InstType could; // not be determined. There could be unexplored path from some of; // WaitingForTypeOfMI's adjacent instructions to an instruction with only one; // mapping available.; // We are done with this branch, add MI to WaitingForTypeOfMI's WaitingQueue,; // this way when WaitingForTypeOfMI figures out its InstType same InstType; // will be assigned to all instructions in this branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp:26,Availability,avail,available,26,"// Only 64 bit mapping is available in fprb and will be marked as custom, i.e.; // will be split into two 32 bit registers in gprb.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp:37,Availability,avail,available,37,// Check if LLT sizes match sizes of available register banks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:141,Safety,avoid,avoid,141,/// Some instructions are used with both floating point and integer operands.; /// We assign InstType to such instructions as it helps us to avoid cross bank; /// copies. InstType deppends on context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:95,Safety,avoid,avoid,95,/// Connected with instruction that interprets 'bags of bits' as integers.; /// Select gprb to avoid cross bank copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:109,Safety,avoid,avoid,109,/// Connected with instruction that interprets 'bags of bits' as floating; /// point numbers. Select fprb to avoid cross bank copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:87,Safety,avoid,avoid,87,/// Represents moving 'bags of bits' around. Select same bank for entire; /// chain to avoid cross bank copies. Currently we select fprb for s64 and; /// gprb for s32 Ambiguous operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:107,Usability,clear,clear,107,"/// MI is about to get destroyed (using narrow scalar). Internal data is; /// saved based on MI's address, clear it since it is no longer valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:34,Modifiability,sandbox,sandbox,34,// Reserve registers for the NaCl sandbox.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:34,Testability,sandbox,sandbox,34,// Reserve registers for the NaCl sandbox.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:29,Availability,mask,mask,29,// Reserved for control flow mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:30,Availability,mask,mask,30,// Reserved for memory access mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:23,Security,access,access,23,// Reserved for memory access mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:74,Energy Efficiency,allocate,allocate,74,// Reserve the base register if we need to both realign the stack and; // allocate variable-sized objects at runtime. This should test the; // same conditions as MipsFrameLowering::hasBP().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:83,Modifiability,variab,variable-sized,83,// Reserve the base register if we need to both realign the stack and; // allocate variable-sized objects at runtime. This should test the; // same conditions as MipsFrameLowering::hasBP().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:130,Testability,test,test,130,// Reserve the base register if we need to both realign the stack and; // allocate variable-sized objects at runtime. This should test the; // same conditions as MipsFrameLowering::hasBP().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:109,Availability,error,error,109,"// Avoid realigning functions that explicitly do not want to be realigned.; // Normally, we should report an error when a function should be dynamically; // realigned but also has the attribute no-realign-stack. Unfortunately,; // with this attribute, MachineFrameInfo clamps each new object's alignment; // to that of the stack's alignment as specified by the ABI. As a result,; // the information of whether we have objects with larger alignment; // requirement than the stack's alignment is already lost at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:3,Safety,Avoid,Avoid,3,"// Avoid realigning functions that explicitly do not want to be realigned.; // Normally, we should report an error when a function should be dynamically; // realigned but also has the attribute no-realign-stack. Unfortunately,; // with this attribute, MachineFrameInfo clamps each new object's alignment; // to that of the stack's alignment as specified by the ABI. As a result,; // the information of whether we have objects with larger alignment; // requirement than the stack's alignment is already lost at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:12,Performance,perform,perform,12,// We can't perform dynamic stack realignment if we can't reserve the; // frame pointer register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:89,Modifiability,variab,variable,89,// We can realign the stack if we know the maximum call frame size and we; // don't have variable sized objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:67,Modifiability,variab,variable,67,// We have to reserve the base pointer register in the presence of variable; // sized objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Performance,load,load,3,"// load $vr, FI; // copy ccond, $vr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Performance,load,load,3,"// load $vr0, FI; // copy lo, $vr0; // load $vr1, FI + 4; // copy hi, $vr1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:39,Performance,load,load,39,"// load $vr0, FI; // copy lo, $vr0; // load $vr1, FI + 4; // copy hi, $vr1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:150,Availability,avail,available,150,"/// This method expands the same instruction that MipsSEInstrInfo::; /// expandBuildPairF64 does, for the case when ABI is fpxx and mthc1 is not; /// available and the case where the ABI is FP64A. It is implemented here; /// because frame indexes are eliminated before MipsSEInstrInfo::; /// expandBuildPairF64 is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:34,Availability,avail,available,34,"// For fpxx and when mthc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmtc1 is available doesn't need to be handled here; // because it never creates a BuildPairF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mtc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:110,Availability,avail,available,110,"// For fpxx and when mthc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmtc1 is available doesn't need to be handled here; // because it never creates a BuildPairF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mtc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:108,Availability,avail,available,108,// It should be impossible to have FGR64 on MIPS-II or MIPS32r1 (which are; // the cases where mthc1 is not available). 64-bit architectures and; // MIPS32r2 or later can use FGR64 though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:155,Availability,avail,available,155,"/// This method expands the same instruction that MipsSEInstrInfo::; /// expandExtractElementF64 does, for the case when ABI is fpxx and mfhc1 is not; /// available and the case where the ABI is FP64A. It is implemented here; /// because frame indexes are eliminated before MipsSEInstrInfo::; /// expandExtractElementF64 is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:34,Availability,avail,available,34,"// For fpxx and when mfhc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmfc1 is available doesn't need to be handled here; // because it never creates a ExtractElementF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mfc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:110,Availability,avail,available,110,"// For fpxx and when mfhc1 is not available, use:; // spill + reload via ldc1; //; // The case where dmfc1 is available doesn't need to be handled here; // because it never creates a ExtractElementF64 node.; //; // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence; // for odd-numbered double precision values (because the lower 32-bits is; // transferred with mfc1 which is redirected to the upper half of the even; // register). Unfortunately, we have to make this decision before register; // allocation so for now we use a spill/reload sequence for all; // double-precision values in regardless of being an odd/even register.; //; // For the cases that should be covered here MipsSEISelDAGToDAG adds $sp as; // implicit operand, so other passes (like ShrinkWrapping) are aware that; // stack is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:108,Availability,avail,available,108,// It should be impossible to have FGR64 on MIPS-II or MIPS32r1 (which are; // the cases where mfhc1 is not available). 64-bit architectures and; // MIPS32r2 or later can use FGR64 though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:14,Energy Efficiency,allocate,allocate,14,// No need to allocate space on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:13,Availability,error,error,13,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:316,Deployability,configurat,configuration,316,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:316,Modifiability,config,configuration,316,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:136,Safety,hazard,hazards,136,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:239,Safety,hazard,hazard,239,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:265,Safety,hazard,hazard,265,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:116,Usability,clear,clear,116,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:219,Usability,clear,clear,219,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:276,Usability,clear,clearing,276,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:59,Performance,perform,perform,59,"// The GP register contains the ""user"" value, so we cannot perform; // any gp relative loads until we restore the ""kernel"" or ""system"" gp; // value. Until support is written we shall only accept the static; // relocation model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:87,Performance,load,loads,87,"// The GP register contains the ""user"" value, so we cannot perform; // any gp relative loads until we restore the ""kernel"" or ""system"" gp; // value. Until support is written we shall only accept the static; // relocation model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Performance,Perform,Perform,3,// Perform ISR handling like GCC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:102,Availability,mask,masked,102,"// Build the configuration for disabling lower priority interrupts. Non EIC; // interrupts need to be masked off with zero, EIC from the Cause register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:13,Deployability,configurat,configuration,13,"// Build the configuration for disabling lower priority interrupts. Non EIC; // interrupts need to be masked off with zero, EIC from the Cause register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:13,Modifiability,config,configuration,13,"// Build the configuration for disabling lower priority interrupts. Non EIC; // interrupts need to be masked off with zero, EIC from the Cause register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:76,Availability,mask,masking,76,"// If the interrupt we're tied to is the EIC, switch the source for the; // masking off interrupts to the cause register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Availability,Mask,Mask,3,"// Mask off KSU, ERL, EXL",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:3,Performance,Perform,Perform,3,// Perform ISR handling like GCC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:114,Modifiability,variab,variable,114,// Reserve call frame if the size of the maximum call frame fits into 16-bit; // immediate field and there are no variable sized objects on the stack.; // Make sure the second register scavenger spill slot can be accessed with one; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:213,Security,access,accessed,213,// Reserve call frame if the size of the maximum call frame fits into 16-bit; // immediate field and there are no variable sized objects on the stack.; // Make sure the second register scavenger spill slot can be accessed with one; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:36,Performance,load,load,36,"// Expand pseudo instructions which load, store or copy accumulators.; // Add an emergency spill slot if a pseudo was expanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:61,Modifiability,variab,variable,61,"// MSA has a minimum offset of 10 bits signed. If there is a variable; // sized object on the stack, the estimation cannot account for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:3,Performance,Load,Load,3,// Load HI/LO through K0. Notably the DestReg is encoded into the; // instruction itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:707,Energy Efficiency,schedul,scheduler,707,"// FIXME: Strictly speaking MFHC1 only reads the top 32-bits however, we; // claim to read the whole 64-bits as part of a white lie used to; // temporarily work around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MFHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:680,Integrability,depend,dependency,680,"// FIXME: Strictly speaking MFHC1 only reads the top 32-bits however, we; // claim to read the whole 64-bits as part of a white lie used to; // temporarily work around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MFHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:17,Availability,avail,available,17,"// When mthc1 is available, use:; // mtc1 Lo, $fp; // mthc1 Hi, $fp; //; // Otherwise, for O32 FPXX ABI:; // spill + reload via ldc1; // This case is handled by the frame lowering code.; //; // Otherwise, for FP32:; // mtc1 Lo, $fp; // mtc1 Hi, $fp + 1; //; // The case where dmtc1 is available doesn't need to be handled here; // because it never creates a BuildPairF64 node.; // FPXX on MIPS-II or MIPS32r1 should have been handled with a spill/reload; // in MipsSEFrameLowering.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:285,Availability,avail,available,285,"// When mthc1 is available, use:; // mtc1 Lo, $fp; // mthc1 Hi, $fp; //; // Otherwise, for O32 FPXX ABI:; // spill + reload via ldc1; // This case is handled by the frame lowering code.; //; // Otherwise, for FP32:; // mtc1 Lo, $fp; // mtc1 Hi, $fp + 1; //; // The case where dmtc1 is available doesn't need to be handled here; // because it never creates a BuildPairF64 node.; // FPXX on MIPS-II or MIPS32r1 should have been handled with a spill/reload; // in MipsSEFrameLowering.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:620,Energy Efficiency,schedul,scheduler,620,// FIXME: The .addReg(DstReg) is a white lie used to temporarily work; // around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MTHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp:593,Integrability,depend,dependency,593,// FIXME: The .addReg(DstReg) is a white lie used to temporarily work; // around a widespread bug in the -mfp64 support.; // The problem is that none of the 32-bit fpu ops mention the fact; // that they clobber the upper 32-bits of the 64-bit FPR. Fixing that; // requires a major overhaul of the FPU implementation which can't; // be done right now due to time constraints.; // MTHC1 is one of two instructions that are affected since they are; // the only instructions that don't read the lower 32-bits.; // We therefore pretend that it reads the bottom 32-bits to; // artificially create a dependency and prevent the scheduler; // changing the behaviour of the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:80,Performance,load,load,80,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:208,Performance,load,loaded,208,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:335,Performance,load,loading,335,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:205,Performance,load,loaded,205,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:37,Performance,load,load,37,"/// Emit a series of instructions to load an immediate. If NewImm is a; /// non-NULL parameter, the last instruction is not emitted, but instead; /// its immediate operand is returned in NewImm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:266,Safety,avoid,avoid,266,"/// Expand pseudo Int-to-FP conversion instructions.; ///; /// For example, the following pseudo instruction; /// PseudoCVT_D32_W D2, A5; /// gets expanded into these two instructions:; /// MTC1 F4, A5; /// CVT_D32_W D2, F4; ///; /// We do this expansion post-RA to avoid inserting a floating point copy; /// instruction between MTC1 and CVT_D32_W.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:58,Usability,clear,clear,58,// My reading of the MIPS DSP 3.01 specification isn't as clear as I; // would like about whether bit 20 always gets overwritten by addwc.; // Hence take an extremely conservative view and presume it's sticky. We; // therefore need to clear it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:235,Usability,clear,clear,235,// My reading of the MIPS DSP 3.01 specification isn't as clear as I; // would like about whether bit 20 always gets overwritten by addwc.; // Hence take an extremely conservative view and presume it's sticky. We; // therefore need to clear it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:59,Performance,Load,Load,59,/// ComplexPattern used on MipsInstrInfo; /// Used on Mips Load/Store instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:15,Performance,Load,Load,15,// on PIC code Load GA,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:8,Performance,load,loading,8,"// When loading from constant pools, load the lower address part in; // the instruction itself. Example, instead of:; // lui $2, %hi($CPI1_0); // addiu $2, $2, %lo($CPI1_0); // lwc1 $f0, 0($2); // Generate:; // lui $2, %hi($CPI1_0); // lwc1 $f0, %lo($CPI1_0)($2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:37,Performance,load,load,37,"// When loading from constant pools, load the lower address part in; // the instruction itself. Example, instead of:; // lui $2, %hi($CPI1_0); // addiu $2, $2, %lo($CPI1_0); // lwc1 $f0, 0($2); // Generate:; // lui $2, %hi($CPI1_0); // lwc1 $f0, %lo($CPI1_0)($2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:59,Performance,Load,Load,59,/// ComplexPattern used on MipsInstrInfo; /// Used on Mips Load/Store instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:22,Performance,Load,Load,22,/// Used on microMIPS Load/Store unaligned instructions (12-bit offset),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:50,Energy Efficiency,power,power,50,"// Select constant vector splats whose value is a power of 2.; //; // In addition to the requirements of selectVSplat(), this function returns; // true and sets Imm if:; // * The splat value is the same width as the elements of the vector; // * The splat value is a power of two.; //; // This function looks through ISD::BITCAST nodes.; // TODO: This might not be appropriate for big-endian MSA since BITCAST is; // sometimes a shuffle in big-endian mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:266,Energy Efficiency,power,power,266,"// Select constant vector splats whose value is a power of 2.; //; // In addition to the requirements of selectVSplat(), this function returns; // true and sets Imm if:; // * The splat value is the same width as the elements of the vector; // * The splat value is a power of two.; //; // This function looks through ISD::BITCAST nodes.; // TODO: This might not be appropriate for big-endian MSA since BITCAST is; // sometimes a shuffle in big-endian mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:100,Testability,test,test,100,"// Extract the run of set bits starting with bit zero from the bitwise; // inverse of ImmValue, and test that the inverse of this is the same; // as the original value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:59,Testability,test,test,59,"// Extract the run of set bits starting with bit zero, and test that the; // result is the same as the original value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:344,Testability,test,test,344,"// Manually match MipsISD::Ins nodes to get the correct instruction. It has; // to be done in this fashion so that we respect the differences between; // dins and dinsm, as the difference is that the size operand has the range; // 0 < size <= 32 for dins while dinsm has the range 2 <= size <= 64 which; // means SelectionDAGISel would have to test all the operands at once to; // match the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:3,Security,Validat,Validating,3,// Validating the node operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:352,Performance,load,load,352,"// Select appropriate ldi.[bhwd] instructions for constant splats of; // 128-bit when MSA is enabled. Fixup any register class mismatches that; // occur as a result.; //; // This allows the compiler to use a wider range of immediates than would; // otherwise be allowed. If, for example, v4i32 could only use ldi.h then; // it would not be possible to load { 0x01010101, 0x01010101, 0x01010101,; // 0x01010101 } without using a constant pool. This would be sub-optimal; // when // 'ldi.b wd, 1' is capable of producing that bit-pattern in the; // same set/ of registers. Similarly, ldi.h isn't capable of producing {; // 0x00000000, 0x00000001, 0x00000000, 0x00000001 } but 'ldi.d wd, 1' can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:19,Performance,perform,perform,19,// N32 and N64 can perform some tricks that O32 can't for signed 32 bit; // integers due to having 64bit registers. lui will cause the necessary; // zero/sign extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:39,Performance,perform,perform,39,"// If we have a 64 bit Splat value, we perform a similar sequence to the; // above:; //; // MIPS32: MIPS64:; // lui $res, %highest(val) lui $res, %highest(val); // ori $res, $res, %higher(val) ori $res, $res, %higher(val); // lui $res2, %hi(val) lui $res2, %hi(val); // ori $res2, %res2, %lo(val) ori $res2, %res2, %lo(val); // $res3 = fill $res2 dinsu $res, $res2, 0, 32; // $res4 = insert.w $res3[1], $res fill.d $res; // splat.d $res4, 0; //; // The ability to use dinsu is guaranteed as MSA requires MIPSR5.; // This saves having to materialize the value by shifts and ors.; //; // FIXME: Implement the preferred sequence for MIPS64R6:; //; // MIPS64R6:; // ori $res, $zero, %lo(val); // daui $res, $res, %hi(val); // dahi $res, $res, %higher(val); // dati $res, $res, %highest(cal); // fill.d $res; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:179,Performance,optimiz,optimization,179,"// Independent of whether we're targeting MIPS64 or not, the basic; // operations are the same. Also, directly use the $zero register if; // the 16 bit chunk is zero.; //; // For optimization purposes we always synthesize the splat value as; // an i32 value, then if we're targetting MIPS64, use SUBREG_TO_REG; // just before combining the values with dinsu to produce an i64. This; // enables SelectionDAG to aggressively share components of splat values; // where possible.; //; // FIXME: This is the general constant synthesis problem. This code; // should be factored out into a class shared between all the; // classes that need it. Specifically, for a splat size of 64; // bits that's a negative number we can do better than LUi/ORi; // for the upper 32bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h:51,Energy Efficiency,power,power,51,/// Select constant vector splats whose value is a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h:71,Energy Efficiency,power,power,71,/// Select constant vector splats whose value is the inverse of a; /// power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:52,Integrability,Interface,Interface,52,"//===- MipsSEISelLowering.cpp - MipsSE DAG Lowering Interface -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Subclass of MipsTargetLowering specialized for mips32/64.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:36,Modifiability,extend,extending,36,// Expand all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:46,Performance,load,loads,46,// Expand all truncating stores and extending loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:54,Security,access,access,54,"// MIPS32r6/MIPS64r6 is required to support unaligned access. It's; // implementation defined whether this is handled by hardware, software, or; // a hybrid of the two but it's expected that most implementations will; // handle the majority of cases in hardware.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:286,Availability,redundant,redundant,286,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:67,Performance,Perform,Performs,67,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:241,Performance,perform,performed,241,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:312,Performance,perform,performed,312,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:286,Safety,redund,redundant,286,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Availability,Mask,Mask,3,// Mask+1 is not a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:19,Energy Efficiency,power,power,19,// Mask+1 is not a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Testability,Test,Test,3,// Test whether the given node is an all-ones build_vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Testability,Test,Test,3,// Test whether N is the bitwise inverse of OfNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:120,Availability,mask,mask,120,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:161,Availability,mask,mask,161,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:222,Availability,mask,mask,222,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Performance,Perform,Perform,3,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:60,Performance,Perform,Performs,60,"// Perform combines where ISD::OR is the root node.; //; // Performs the following transformations:; // - (or (and $a, $mask), (and $b, $inv_mask)) => (vselect $mask, $a, $b); // where $inv_mask is the bitwise inverse of $mask and the 'or' has a 128-bit; // vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:31,Availability,mask,mask,31,"// If Op0Op0 is an appropriate mask, try to find it's inverse in either; // Op1Op0, or Op1Op1. Keep track of the Cond, IfSet, and IfClr nodes, while; // looking.; // IfClr will be set if we find a valid match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:57,Availability,mask,mask,57,"// If IfClr is not yet set, and Op0Op1 is an appropriate mask, try the same; // thing again using this mask.; // IfClr will be set if we find a valid match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:103,Availability,mask,mask,103,"// If IfClr is not yet set, and Op0Op1 is an appropriate mask, try the same; // thing again using this mask.; // IfClr will be set if we find a valid match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:202,Availability,down,down,202,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:160,Energy Efficiency,power,powers,160,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:318,Performance,optimiz,optimization,318,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:394,Performance,optimiz,optimization,394,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:999,Performance,perform,perform,999,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:1012,Performance,optimiz,optimization,1012,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:1175,Performance,optimiz,optimization,1175,"// Estimate the number of operations the below transform will turn a; // constant multiply into. The number is approximately equal to the minimal; // number of powers of two that constant can be broken down to by adding; // or subtracting them.; //; // If we have taken more than 12[1] / 8[2] steps to attempt the; // optimization for a native sized value, it is more than likely that this; // optimization will make things worse.; //; // [1] MIPS64 requires 6 instructions at most to materialize any constant,; // multiplication requires at least 4 cycles, but another cycle (or two); // to retrieve the result from the HI/LO registers.; //; // [2] For MIPS32, more than 8 steps is expensive as the constant could be; // materialized in 2 instructions, multiplication requires at least 4; // cycles, but another cycle (or two) to retrieve the result from the; // HI/LO registers.; //; // TODO:; // - MaxSteps needs to consider the `VT` of the constant for the current; // target.; // - Consider to perform this optimization after type legalization.; // That allows to remove a workaround for types not supported natively.; // - Take in account `-Os, -Oz` flags because this optimization; // increases code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:11,Energy Efficiency,power,power,11,"// If c is power of 2, return (shl x, log2(c)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:376,Availability,redundant,redundant,376,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:138,Performance,Perform,Performs,138,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:312,Performance,perform,performed,312,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:402,Performance,perform,performed,402,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:466,Performance,perform,performDSPShiftCombine,466,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:376,Safety,redund,redundant,376,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:23,Usability,clear,cleared,23,// Exception has to be cleared with eret.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:30,Performance,load,load,30,// Replace a double precision load with two i32 loads and a buildpair64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:48,Performance,load,loads,48,// Replace a double precision load with two i32 loads and a buildpair64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:7,Performance,load,load,7,// i32 load from lower address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:7,Performance,load,load,7,// i32 load from higher address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:30,Performance,perform,performed,30,// v2i64 BUILD_VECTOR must be performed via v4i32 so split into i32's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:59,Modifiability,Extend,Extend,59,"// We couldnt constant fold, do a vector shift instead; // Extend i32 to i64 if necessary. Sign or zero extend doesn't matter since; // only values 0-63 are valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:104,Modifiability,extend,extend,104,"// We couldnt constant fold, do a vector shift instead; // Extend i32 to i64 if necessary. Sign or zero extend doesn't matter since; // only values 0-63 are valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:10,Availability,Mask,Mask,10,"// bsel_v(Mask, IfClear, IfSet) -> (vselect Mask, IfSet, IfClear)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:44,Availability,Mask,Mask,44,"// bsel_v(Mask, IfClear, IfSet) -> (vselect Mask, IfSet, IfClear)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:11,Availability,Mask,Mask,11,"// bseli_v(Mask, IfClear, IfSet) -> (vselect Mask, IfSet, IfClear)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:45,Availability,Mask,Mask,45,"// bseli_v(Mask, IfClear, IfSet) -> (vselect Mask, IfSet, IfClear)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:66,Availability,down,down,66,// If ResTy is v2i64 then the type legalizer will break this node down into; // an equivalent v4i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:78,Availability,mask,masks,78,"// We can't lower via VECTOR_SHUFFLE because it requires constant shuffle; // masks, nor can we lower via BUILD_VECTOR & EXTRACT_VECTOR_ELT because; // EXTRACT_VECTOR_ELT can't extract i64's on MIPS32.; // Instead we lower to MipsISD::VSHF and match from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:13,Availability,error,error,13,// Report an error for out of range values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:169,Modifiability,extend,extend,169,// Lower ISD::EXTRACT_VECTOR_ELT into MipsISD::VEXTRACT_SEXT_ELT.; //; // The non-value bits resulting from ISD::EXTRACT_VECTOR_ELT are undefined. We; // choose to sign-extend but we could have equally chosen zero-extend. The; // DAGCombiner will fold any sign/zero extension of the ISD::EXTRACT_VECTOR_ELT; // result into this node later (possibly changing it to a zero-extend in the; // process).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:214,Modifiability,extend,extend,214,// Lower ISD::EXTRACT_VECTOR_ELT into MipsISD::VEXTRACT_SEXT_ELT.; //; // The non-value bits resulting from ISD::EXTRACT_VECTOR_ELT are undefined. We; // choose to sign-extend but we could have equally chosen zero-extend. The; // DAGCombiner will fold any sign/zero extension of the ISD::EXTRACT_VECTOR_ELT; // result into this node later (possibly changing it to a zero-extend in the; // process).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:371,Modifiability,extend,extend,371,// Lower ISD::EXTRACT_VECTOR_ELT into MipsISD::VEXTRACT_SEXT_ELT.; //; // The non-value bits resulting from ISD::EXTRACT_VECTOR_ELT are undefined. We; // choose to sign-extend but we could have equally chosen zero-extend. The; // DAGCombiner will fold any sign/zero extension of the ISD::EXTRACT_VECTOR_ELT; // result into this node later (possibly changing it to a zero-extend in the; // process).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:205,Energy Efficiency,power,power,205,// Lowers ISD::BUILD_VECTOR into appropriate SelectionDAG nodes for the; // backend.; //; // Lowers according to the following rules:; // - Constant splats are legal as-is as long as the SplatBitSize is a power of; // 2 less than or equal to 64 and the value fits into a signed 10-bit; // immediate; // - Constant splats are lowered to bitconverted BUILD_VECTORs if SplatBitSize; // is a power of 2 less than or equal to 64 and the value does not fit into a; // signed 10-bit immediate; // - Non-constant splats are legal as-is.; // - Non-constant non-splats are lowered to sequences of INSERT_VECTOR_ELT.; // - All others are illegal and must be expanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:388,Energy Efficiency,power,power,388,// Lowers ISD::BUILD_VECTOR into appropriate SelectionDAG nodes for the; // backend.; //; // Lowers according to the following rules:; // - Constant splats are legal as-is as long as the SplatBitSize is a power of; // 2 less than or equal to 64 and the value fits into a signed 10-bit; // immediate; // - Constant splats are lowered to bitconverted BUILD_VECTORs if SplatBitSize; // is a power of 2 less than or equal to 64 and the value does not fit into a; // signed 10-bit immediate; // - Non-constant splats are legal as-is.; // - Non-constant non-splats are lowered to sequences of INSERT_VECTOR_ELT.; // - All others are illegal and must be expanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:269,Availability,mask,mask,269,"// Lower VECTOR_SHUFFLE into SHF (if possible).; //; // SHF splits the vector into blocks of four elements, then shuffles these; // elements according to a <4 x i2> constant (encoded as an integer immediate).; //; // It is therefore possible to lower into SHF when the mask takes the form:; // <a, b, c, d, a+4, b+4, c+4, d+4, a+8, b+8, c+8, d+8, ...>; // When undef's appear they are treated as if they were whatever value is; // necessary in order to fit the above forms.; //; // For example:; // %2 = shufflevector <8 x i16> %0, <8 x i16> undef,; // <8 x i32> <i32 3, i32 2, i32 1, i32 0,; // i32 7, i32 6, i32 5, i32 4>; // is lowered to:; // (SHF_H $w0, $w1, 27); // where the 27 comes from:; // 3 + (2 << 2) + (1 << 4) + (0 << 6)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:10,Availability,mask,mask,10,"// If the mask has an undef, replace it with the current index.; // Note that it might still be undef if the current index is also undef",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:54,Availability,mask,mask,54,// Check that non-undef values are the same as in the mask. If they; // aren't then give up,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:81,Availability,mask,mask,81,"// Determine whether VECTOR_SHUFFLE is a SPLATI.; //; // It is a SPLATI when the mask is:; // <x, x, x, ...>; // where x is any valid index.; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:176,Availability,mask,mask,176,"// Determine whether VECTOR_SHUFFLE is a SPLATI.; //; // It is a SPLATI when the mask is:; // <x, x, x, ...>; // where x is any valid index.; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:164,Availability,mask,mask,164,"// Lower VECTOR_SHUFFLE into ILVEV (if possible).; //; // ILVEV interleaves the even elements from each vector.; //; // It is possible to lower into ILVEV when the mask consists of two of the; // following forms interleaved:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 2, 2, 4, 4, ...>; // <0, n, 2, n+2, 4, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:432,Availability,mask,mask,432,"// Lower VECTOR_SHUFFLE into ILVEV (if possible).; //; // ILVEV interleaves the even elements from each vector.; //; // It is possible to lower into ILVEV when the mask consists of two of the; // following forms interleaved:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 2, 2, 4, 4, ...>; // <0, n, 2, n+2, 4, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:163,Availability,mask,mask,163,"// Lower VECTOR_SHUFFLE into ILVOD (if possible).; //; // ILVOD interleaves the odd elements from each vector.; //; // It is possible to lower into ILVOD when the mask consists of two of the; // following forms interleaved:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 1, 3, 3, 5, 5, ...>; // <1, n+1, 3, n+3, 5, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:435,Availability,mask,mask,435,"// Lower VECTOR_SHUFFLE into ILVOD (if possible).; //; // ILVOD interleaves the odd elements from each vector.; //; // It is possible to lower into ILVOD when the mask consists of two of the; // following forms interleaved:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 1, 3, 3, 5, 5, ...>; // <1, n+1, 3, n+3, 5, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:203,Availability,mask,mask,203,"// Lower VECTOR_SHUFFLE into ILVR (if possible).; //; // ILVR interleaves consecutive elements from the right (lowest-indexed) half of; // each vector.; //; // It is possible to lower into ILVR when the mask consists of two of the; // following forms interleaved:; // <0, 1, 2, ...>; // <n, n+1, n+2, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 1, 1, 2, 2, ...>; // <0, n, 1, n+1, 2, n+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:471,Availability,mask,mask,471,"// Lower VECTOR_SHUFFLE into ILVR (if possible).; //; // ILVR interleaves consecutive elements from the right (lowest-indexed) half of; // each vector.; //; // It is possible to lower into ILVR when the mask consists of two of the; // following forms interleaved:; // <0, 1, 2, ...>; // <n, n+1, n+2, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 0, 1, 1, 2, 2, ...>; // <0, n, 1, n+1, 2, n+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:203,Availability,mask,mask,203,"// Lower VECTOR_SHUFFLE into ILVL (if possible).; //; // ILVL interleaves consecutive elements from the left (highest-indexed) half; // of each vector.; //; // It is possible to lower into ILVL when the mask consists of two of the; // following forms interleaved:; // <x, x+1, x+2, ...>; // <n+x, n+x+1, n+x+2, ...>; // where n is the number of elements in the vector and x is half n.; // For example:; // <x, x, x+1, x+1, x+2, x+2, ...>; // <x, n+x, x+1, n+x+1, x+2, n+x+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:515,Availability,mask,mask,515,"// Lower VECTOR_SHUFFLE into ILVL (if possible).; //; // ILVL interleaves consecutive elements from the left (highest-indexed) half; // of each vector.; //; // It is possible to lower into ILVL when the mask consists of two of the; // following forms interleaved:; // <x, x+1, x+2, ...>; // <n+x, n+x+1, n+x+2, ...>; // where n is the number of elements in the vector and x is half n.; // For example:; // <x, x, x+1, x+1, x+2, x+2, ...>; // <x, n+x, x+1, n+x+1, x+2, n+x+2, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:180,Availability,mask,mask,180,"// Lower VECTOR_SHUFFLE into PCKEV (if possible).; //; // PCKEV copies the even elements of each vector into the result vector.; //; // It is possible to lower into PCKEV when the mask consists of two of the; // following forms concatenated:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 2, 4, ..., 0, 2, 4, ...>; // <0, 2, 4, ..., n, n+2, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:459,Availability,mask,mask,459,"// Lower VECTOR_SHUFFLE into PCKEV (if possible).; //; // PCKEV copies the even elements of each vector into the result vector.; //; // It is possible to lower into PCKEV when the mask consists of two of the; // following forms concatenated:; // <0, 2, 4, ...>; // <n, n+2, n+4, ...>; // where n is the number of elements in the vector.; // For example:; // <0, 2, 4, ..., 0, 2, 4, ...>; // <0, 2, 4, ..., n, n+2, n+4, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:179,Availability,mask,mask,179,"// Lower VECTOR_SHUFFLE into PCKOD (if possible).; //; // PCKOD copies the odd elements of each vector into the result vector.; //; // It is possible to lower into PCKOD when the mask consists of two of the; // following forms concatenated:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 3, 5, ..., 1, 3, 5, ...>; // <1, 3, 5, ..., n+1, n+3, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:462,Availability,mask,mask,462,"// Lower VECTOR_SHUFFLE into PCKOD (if possible).; //; // PCKOD copies the odd elements of each vector into the result vector.; //; // It is possible to lower into PCKOD when the mask consists of two of the; // following forms concatenated:; // <1, 3, 5, ...>; // <n+1, n+3, n+5, ...>; // where n is the number of elements in the vector.; // For example:; // <1, 3, 5, ..., 1, 3, 5, ...>; // <1, 3, 5, ..., n+1, n+3, n+5, ...>; //; // When undef's appear in the mask they are treated as if they were whatever; // value is necessary in order to fit the above forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:467,Energy Efficiency,reduce,reduces,467,"// Lower VECTOR_SHUFFLE into VSHF.; //; // This mostly consists of converting the shuffle indices in Indices into a; // BUILD_VECTOR and adding it as an operand to the resulting VSHF. There is; // also code to eliminate unused operands of the VECTOR_SHUFFLE. For example,; // if the type is v8i16 and all the indices are less than 8 then the second; // operand is unused and can be replaced with anything. We choose to replace it; // with the used operand since this reduces the number of instructions overall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:61,Integrability,depend,depending,61,// Lower VECTOR_SHUFFLE into one of a number of instructions depending on the; // indices in the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:182,Performance,perform,performed,182,"// Emit the COPY_FW pseudo instruction.; //; // copy_fw_pseudo $fd, $ws, n; // =>; // copy_u_w $rt, $ws, $n; // mtc1 $rt, $fd; //; // When n is zero, the equivalent operation can be performed with (potentially); // zero instructions due to register overlaps. This optimization is never valid; // for lane 1 because it would require FR=0 mode which isn't supported by MSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:264,Performance,optimiz,optimization,264,"// Emit the COPY_FW pseudo instruction.; //; // copy_fw_pseudo $fd, $ws, n; // =>; // copy_u_w $rt, $ws, $n; // mtc1 $rt, $fd; //; // When n is zero, the equivalent operation can be performed with (potentially); // zero instructions due to register overlaps. This optimization is never valid; // for lane 1 because it would require FR=0 mode which isn't supported by MSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:189,Performance,perform,performed,189,"// Emit the COPY_FD pseudo instruction.; //; // copy_fd_pseudo $fd, $ws, n; // =>; // splati.d $wt, $ws, $n; // copy $fd, $wt:sub_64; //; // When n is zero, the equivalent operation can be performed with (potentially); // zero instructions due to register overlaps. This optimization is always; // valid because FR=1 mode which is the only supported mode in MSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:271,Performance,optimiz,optimization,271,"// Emit the COPY_FD pseudo instruction.; //; // copy_fd_pseudo $fd, $ws, n; // =>; // splati.d $wt, $ws, $n; // copy $fd, $wt:sub_64; //; // When n is zero, the equivalent operation can be performed with (potentially); // zero instructions due to register overlaps. This optimization is always; // valid because FR=1 mode which is the only supported mode in MSA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:320,Energy Efficiency,allocate,allocated,320,"// Emit the ST_F16_PSEDUO instruction to store a f16 value from an MSA; // register.; //; // STF16 MSA128F16:$wd, mem_simm10:$addr; // =>; // copy_u.h $rtemp,$wd[0]; // sh $rtemp, $addr; //; // Safety: We can't use st.h & co as they would over write the memory after; // the destination. It would require half floats be allocated 16 bytes(!) of; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:194,Safety,Safe,Safety,194,"// Emit the ST_F16_PSEDUO instruction to store a f16 value from an MSA; // register.; //; // STF16 MSA128F16:$wd, mem_simm10:$addr; // =>; // copy_u.h $rtemp,$wd[0]; // sh $rtemp, $addr; //; // Safety: We can't use st.h & co as they would over write the memory after; // the destination. It would require half floats be allocated 16 bytes(!) of; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:14,Performance,load,load,14,"// Caution: A load via the GOT can expand to a GPR32 operand, a load via; // spill and reload can expand as a GPR64 operand. Examine the; // operand in detail and default to ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:64,Performance,load,load,64,"// Caution: A load via the GOT can expand to a GPR32 operand, a load via; // spill and reload can expand as a GPR64 operand. Examine the; // operand in detail and default to ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:342,Availability,fault,fault,342,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:41,Performance,load,load,41,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:355,Performance,load,load,355,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:441,Performance,load,load,441,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:186,Safety,Safe,Safety,186,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:14,Performance,load,load,14,"// Caution: A load via the GOT can expand to a GPR32 operand, a load via; // spill and reload can expand as a GPR64 operand. Examine the; // operand in detail and default to ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:64,Performance,load,load,64,"// Caution: A load via the GOT can expand to a GPR32 operand, a load via; // spill and reload can expand as a GPR64 operand. Examine the; // operand in detail and default to ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:97,Safety,Safe,Safety,97,"// Emit the FPROUND_PSEUDO instruction.; //; // Round an FGR64Opnd, FGR32Opnd to an f16.; //; // Safety: Cycle the operand through the GPRs so the result always ends up; // the correct MSA register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fs; // / FGR64Opnd:$Fs and MSA128F16:$Wd to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship.; //; // For FPG32Opnd:; //; // FPROUND MSA128F16:$wd, FGR32Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // fexdo.w $wd, $wtemp, $wtemp; //; // For FPG64Opnd on mips32r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // mfhc1 $rtemp2, $fs; // insert.w $wtemp[1], $rtemp2; // insert.w $wtemp[3], $rtemp2; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $temp2, $temp2; //; // For FGR64Opnd on mips64r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // dmfc1 $rtemp, $fs; // fill.d $rtemp, $wtemp; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $wtemp2, $wtemp2; //; // Safety note: As $wtemp is UNDEF, we may provoke a spurious exception if the; // undef bits are ""just right"" and the exception enable bits are; // set. By using fill.w to replicate $fs into all elements over; // insert.w for one element, we avoid that potiential case. If; // fexdo.[hw] causes an exception in, the exception is valid and it; // occurs for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:1297,Safety,Safe,Safety,1297,"// Emit the FPROUND_PSEUDO instruction.; //; // Round an FGR64Opnd, FGR32Opnd to an f16.; //; // Safety: Cycle the operand through the GPRs so the result always ends up; // the correct MSA register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fs; // / FGR64Opnd:$Fs and MSA128F16:$Wd to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship.; //; // For FPG32Opnd:; //; // FPROUND MSA128F16:$wd, FGR32Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // fexdo.w $wd, $wtemp, $wtemp; //; // For FPG64Opnd on mips32r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // mfhc1 $rtemp2, $fs; // insert.w $wtemp[1], $rtemp2; // insert.w $wtemp[3], $rtemp2; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $temp2, $temp2; //; // For FGR64Opnd on mips64r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // dmfc1 $rtemp, $fs; // fill.d $rtemp, $wtemp; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $wtemp2, $wtemp2; //; // Safety note: As $wtemp is UNDEF, we may provoke a spurious exception if the; // undef bits are ""just right"" and the exception enable bits are; // set. By using fill.w to replicate $fs into all elements over; // insert.w for one element, we avoid that potiential case. If; // fexdo.[hw] causes an exception in, the exception is valid and it; // occurs for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:1537,Safety,avoid,avoid,1537,"// Emit the FPROUND_PSEUDO instruction.; //; // Round an FGR64Opnd, FGR32Opnd to an f16.; //; // Safety: Cycle the operand through the GPRs so the result always ends up; // the correct MSA register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fs; // / FGR64Opnd:$Fs and MSA128F16:$Wd to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship.; //; // For FPG32Opnd:; //; // FPROUND MSA128F16:$wd, FGR32Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // fexdo.w $wd, $wtemp, $wtemp; //; // For FPG64Opnd on mips32r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // mfhc1 $rtemp2, $fs; // insert.w $wtemp[1], $rtemp2; // insert.w $wtemp[3], $rtemp2; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $temp2, $temp2; //; // For FGR64Opnd on mips64r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // dmfc1 $rtemp, $fs; // fill.d $rtemp, $wtemp; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $wtemp2, $wtemp2; //; // Safety note: As $wtemp is UNDEF, we may provoke a spurious exception if the; // undef bits are ""just right"" and the exception enable bits are; // set. By using fill.w to replicate $fs into all elements over; // insert.w for one element, we avoid that potiential case. If; // fexdo.[hw] causes an exception in, the exception is valid and it; // occurs for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:477,Security,access,accessed,477,"// Emit the FPROUND_PSEUDO instruction.; //; // Round an FGR64Opnd, FGR32Opnd to an f16.; //; // Safety: Cycle the operand through the GPRs so the result always ends up; // the correct MSA register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fs; // / FGR64Opnd:$Fs and MSA128F16:$Wd to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship.; //; // For FPG32Opnd:; //; // FPROUND MSA128F16:$wd, FGR32Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // fexdo.w $wd, $wtemp, $wtemp; //; // For FPG64Opnd on mips32r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // mfhc1 $rtemp2, $fs; // insert.w $wtemp[1], $rtemp2; // insert.w $wtemp[3], $rtemp2; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $temp2, $temp2; //; // For FGR64Opnd on mips64r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // dmfc1 $rtemp, $fs; // fill.d $rtemp, $wtemp; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $wtemp2, $wtemp2; //; // Safety note: As $wtemp is UNDEF, we may provoke a spurious exception if the; // undef bits are ""just right"" and the exception enable bits are; // set. By using fill.w to replicate $fs into all elements over; // insert.w for one element, we avoid that potiential case. If; // fexdo.[hw] causes an exception in, the exception is valid and it; // occurs for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform the register class copy as mentioned above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:107,Safety,Safe,Safety,107,"// Emit the FPEXTEND_PSEUDO instruction.; //; // Expand an f16 to either a FGR32Opnd or FGR64Opnd.; //; // Safety: Cycle the result through the GPRs so the result always ends up; // the correct floating point register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fd; // / FGR64Opnd:$Fd and MSA128F16:$Ws to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship. I; // haven't checked.; //; // For FGR32Opnd:; //; // FPEXTEND FGR32Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // copy_s.w $rtemp, $ws[0]; // mtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips64:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.d $rtemp, $wtemp2s[0]; // dmtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips32:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.w $rtemp, $wtemp2[0]; // mtc1 $rtemp, $ftemp; // copy_s.w $rtemp2, $wtemp2[1]; // $fd = mthc1 $rtemp2, $ftemp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:497,Security,access,accessed,497,"// Emit the FPEXTEND_PSEUDO instruction.; //; // Expand an f16 to either a FGR32Opnd or FGR64Opnd.; //; // Safety: Cycle the result through the GPRs so the result always ends up; // the correct floating point register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fd; // / FGR64Opnd:$Fd and MSA128F16:$Ws to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship. I; // haven't checked.; //; // For FGR32Opnd:; //; // FPEXTEND FGR32Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // copy_s.w $rtemp, $ws[0]; // mtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips64:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.d $rtemp, $wtemp2s[0]; // dmtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips32:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.w $rtemp, $wtemp2[0]; // mtc1 $rtemp, $ftemp; // copy_s.w $rtemp2, $wtemp2[1]; // $fd = mthc1 $rtemp2, $ftemp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:3,Performance,Perform,Perform,3,// Perform the safety regclass copy mentioned above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:15,Safety,safe,safety,15,// Perform the safety regclass copy mentioned above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h:50,Integrability,Interface,Interface,50,"//===- MipsSEISelLowering.h - MipsSE DAG Lowering Interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Subclass of MipsTargetLowering specialized for mips32/64.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h:67,Integrability,depend,depending,67,/// Lower VECTOR_SHUFFLE into one of a number of instructions; /// depending on the indices in the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:54,Performance,load,load,54,/// Get the size of the offset supported by the given load/store/inline asm.; /// The result includes the effects of any scale factors applied to the; /// instruction immediate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:63,Performance,load,load,63,/// Get the scale factor applied to the immediate in the given load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:133,Energy Efficiency,allocate,allocated,133,// The following stack frame objects are always referenced relative to $sp:; // 1. Outgoing arguments.; // 2. Pointer to dynamically allocated stack space.; // 3. Locations for callee-saved registers.; // 4. Locations for eh data registers.; // 5. Locations for ISR saved Coprocessor 0 registers 12 & 14.; // Everything else is referenced relative to whatever register; // getFrameRegister() returns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:167,Energy Efficiency,allocate,allocated,167,"// Calculate final offset.; // - There is no need to change the offset if the frame object is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following, its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:399,Modifiability,variab,variable,399,"// Calculate final offset.; // - There is no need to change the offset if the frame object is one of the; // following: an outgoing argument, pointer to a dynamically allocated; // stack space or a $gp restore location,; // - If the frame object is any of the following, its offset must be adjusted; // by adding the size of the stack:; // incoming argument, callee-saved register location or local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:42,Availability,avail,available,42,"// Make sure Offset fits within the field available.; // For MSA instructions, this is a 10-bit signed immediate (scaled by; // element size), otherwise it is a 16-bit signed immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:23,Testability,test,tested,23,// MIPS-I has not been tested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:107,Deployability,integrat,integrated,107,// Don't even attempt to generate code for MIPS-V. It has not; // been tested and currently exists for the integrated assembler only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:107,Integrability,integrat,integrated,107,// Don't even attempt to generate code for MIPS-V. It has not; // been tested and currently exists for the integrated assembler only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:71,Testability,test,tested,71,// Don't even attempt to generate code for MIPS-V. It has not; // been tested and currently exists for the integrated assembler only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp:14,Energy Efficiency,schedul,scheduling,14,// Initialize scheduling itinerary for the specified CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing dsp warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing msa warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing crc warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing ginv warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing Mips1 warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,Safety,avoid,avoid,11,// Used to avoid printing virt warnings multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:3,Performance,Optimiz,Optimize,3,// Optimize for space by compiling all functions as Mips 16 unless; // it needs floating point. Functions needing floating point are; // compiled as Mips32,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:7,Safety,hazard,hazard,7,// Use hazard variants of the jump register instructions for indirect; // function calls and jump tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:198,Integrability,rout,routines,198,// Hard float for mips16 means essentially to compile as soft float; // but to use a runtime library for soft float that is written with; // native mips32 floating point instructions (those runtime routines; // run in mips32 hard float mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:45,Security,access,access,45,"/// Does the system support unaligned memory access.; ///; /// MIPS32r6/MIPS64r6 require full unaligned access support but does not; /// specify which component of the system provides it. Hardware, software, and; /// hybrid implementations are all valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:104,Security,access,access,104,"/// Does the system support unaligned memory access.; ///; /// MIPS32r6/MIPS64r6 require full unaligned access support but does not; /// specify which component of the system provides it. Hardware, software, and; /// hybrid implementations are all valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:31,Availability,avail,available,31,// 32 bit registers are always available and the stack is at least 64 bit; // aligned. On N64 64 bit registers are also available and the stack is; // 128 bit aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:120,Availability,avail,available,120,// 32 bit registers are always available and the stack is at least 64 bit; // aligned. On N64 64 bit registers are also available and the stack is; // 128 bit aligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:86,Integrability,depend,depend,86,// This needs to be done before we create a new subtarget since any; // creation will depend on the TM and the code generation flags on the; // function that reside in TargetOptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:29,Deployability,Configurat,Configuration,29,/// Mips Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:29,Modifiability,Config,Configuration,29,/// Mips Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:94,Availability,avail,available,94,"// The current implementation of long branch pass requires a scratch; // register ($at) to be available before branch instructions. Tail merging; // can break this requirement, so disable it when long branch pass is; // enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector pass using; // the ISelDag to gen Mips code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:37,Performance,perform,performs,37,// The microMIPS size reduction pass performs instruction reselection for; // instructions which can be remapped to a 16 bit instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:69,Safety,hazard,hazards,69,// The delay slot filler pass can potientially create forbidden slot hazards; // for MIPSR6 and therefore it should go before MipsBranchExpansion pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:221,Modifiability,extend,extending,221,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:70,Safety,hazard,hazards,70,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:140,Safety,hazard,hazards,140,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:180,Safety,hazard,hazard,180,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:460,Safety,hazard,hazards,460,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h:8,Deployability,Pipeline,Pipeline,8,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h:17,Deployability,Configurat,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h:17,Modifiability,Config,Configuration,17,// Pass Pipeline Configuration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:21,Performance,load,loaded,21,// A address must be loaded from a small section if its size is less than the; // small section size threshold. Data in this section must be addressed using; // gp_rel operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:34,Availability,avail,available,34,// Return if small section is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:15,Modifiability,variab,variables,15,"// Only global variables, not functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:10,Modifiability,variab,variable,10,"// If the variable has an explicit section, it is placed in that section but; // it's addressing mode may change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:26,Modifiability,variab,variable,26,// Explicitly placing any variable in the small data section overrides; // the global -G value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:20,Security,access,accessing,20,"// Otherwise reject accessing it through the gp pointer. There are some; // historic cases which GCC doesn't appear to respect any more. These; // are .lit4, .lit8 and .srdata. For the moment reject these as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.h:19,Modifiability,variab,variable,19,/// Describe a TLS variable address within debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:360,Availability,avail,available,360,/// Emit a store instruction with an offset. If the offset is out of range; /// then it will be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:402,Availability,error,error,402,/// Emit a store instruction with an offset. If the offset is out of range; /// then it will be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:348,Availability,avail,available,348,/// Emit a .cprestore directive. If the offset is out of range then it will; /// be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h:390,Availability,error,error,390,/// Emit a .cprestore directive. If the offset is out of range then it will; /// be synthesized using the assembler temporary.; ///; /// GetATReg() is a callback that can be used to obtain the current assembler; /// temporary and is only called when the assembler temporary is required. It; /// must handle the case where no assembler temporary is available (typically; /// by reporting an error).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:241,Availability,mask,mask,241,// Set of features that are either architecture features or referenced; // by them (e.g.: FeatureNaN2008 implied by FeatureMips32r6).; // The full table can be found in MipsGenSubtargetInfo.inc (MipsFeatureKV[]).; // The reason we need this mask is explained in the selectArch function.; // FIXME: Ideally we would like TableGen to generate this information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:41,Integrability,message,message,41,// Print a warning along with its fix-it message at the given range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:136,Availability,error,error,136,/// Returns the internal register number for the current AT. Also checks if; /// the current AT is unavailable (set to $0) and gives an error if it is.; /// This should be used in pseudo-instruction expansions which need AT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:233,Deployability,Toggle,ToggleFeature,233,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:400,Deployability,Toggle,ToggleFeature,400,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:104,Integrability,depend,dependencies,104,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:316,Integrability,depend,dependencies,316,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:137,Usability,clear,clears,137,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:348,Usability,clear,clear,348,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:423,Usability,clear,clears,423,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:472,Usability,clear,cleared,472,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:534,Usability,clear,cleared,534,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:1062,Usability,Clear,Clearing,1062,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:1094,Usability,clear,clear,1094,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:25,Availability,avail,available,25,// Initialize the set of available features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:21,Integrability,depend,depending,21,/// GPR32 and GPR64 (depending on isGP64bit()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:26,Integrability,depend,depending,26,"/// FGR32, FGR64, AFGR64 (depending on context and; /// isFP64bit())",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:36,Integrability,depend,depending,36,"/// HI32DSP, LO32DSP, and ACC64DSP (depending on; /// context).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:6,Usability,simpl,simple,6,/// A simple token,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:52,Testability,Assert,Asserts,52,"/// Render the operand to an MCInst as a GPR32; /// Asserts if the wrong number of operands are requested, or the operand; /// is not a k_RegisterIndex compatible with RegKind_GPR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:52,Testability,Assert,Asserts,52,"/// Render the operand to an MCInst as a GPR64; /// Asserts if the wrong number of operands are requested, or the operand; /// is not a k_RegisterIndex compatible with RegKind_GPR",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:109,Availability,failure,failure,109,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.; // FIXME: This should propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,Deployability,integrat,integrated-as,35,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.; // FIXME: This should propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,Integrability,integrat,integrated-as,35,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.; // FIXME: This should propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,Deployability,integrat,integrated-as,35,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,Integrability,integrat,integrated-as,35,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:9,Performance,optimiz,optimization,9,"// As an optimization hint for the linker, before the JALR we add:; // .reloc tmplabel, R_{MICRO}MIPS_JALR, symbol; // tmplabel:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:36,Performance,load,load,36,// Try to create 16-bit GP relative load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:6,Performance,load,load,6,// if load; // TODO: Handle this with the AsmOperandClass.PredicateMethod.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:152,Safety,avoid,avoiding,152,"// When 'FillDelaySlot' is true, the existing logic will add; // noreorder before instruction and reorder after it. So there; // need exclude this case avoiding two '.set reorder'.; // The format of the first case is:; // .set noreorder; // bnezc; // nop; // .set reorder",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:46,Testability,log,logic,46,"// When 'FillDelaySlot' is true, the existing logic will add; // noreorder before instruction and reorder after it. So there; // need exclude this case avoiding two '.set reorder'.; // The format of the first case is:; // .set noreorder; // bnezc; // nop; // .set reorder",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:201,Integrability,wrap,wrap,201,// Save current instruction`s forbidden slot and whether set reorder.; // This is the judgment condition for whether to add nop.; // We would add a couple of '.set noreorder' and '.set reorder' to; // wrap the current instruction and the next instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:41,Availability,recover,recover,41,"// When current instruction was not CTI, recover reorder state.; // The format of the second case is:; // .set noreoder; // bnezc; // add; // .set reorder",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:41,Safety,recover,recover,41,"// When current instruction was not CTI, recover reorder state.; // The format of the second case is:; // .set noreoder; // bnezc; // add; // .set reorder",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Performance,Load,Load,3,// Load the $gp from the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:47,Availability,recover,recover,47,"// If has pending forbidden slot, fill nop and recover reorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:47,Safety,recover,recover,47,"// If has pending forbidden slot, fill nop and recover reorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:4,Performance,Load,Load,4,/// Load (or add) an immediate into a register.; ///; /// @param ImmValue The immediate to load.; /// @param DstReg The register that will hold the immediate.; /// @param SrcReg A register to add to the immediate or Mips::NoRegister; /// for a simple initialization.; /// @param Is32BitImm Is ImmValue 32-bit or 64-bit?; /// @param IsAddress True if the immediate represents an address. False if it; /// is an integer.; /// @param IDLoc Location of the immediate in the source file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:91,Performance,load,load,91,/// Load (or add) an immediate into a register.; ///; /// @param ImmValue The immediate to load.; /// @param DstReg The register that will hold the immediate.; /// @param SrcReg A register to add to the immediate or Mips::NoRegister; /// for a simple initialization.; /// @param Is32BitImm Is ImmValue 32-bit or 64-bit?; /// @param IsAddress True if the immediate represents an address. False if it; /// is an integer.; /// @param IDLoc Location of the immediate in the source file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:244,Usability,simpl,simple,244,/// Load (or add) an immediate into a register.; ///; /// @param ImmValue The immediate to load.; /// @param DstReg The register that will hold the immediate.; /// @param SrcReg A register to add to the immediate or Mips::NoRegister; /// for a simple initialization.; /// @param Is32BitImm Is ImmValue 32-bit or 64-bit?; /// @param IsAddress True if the immediate represents an address. False if it; /// is an integer.; /// @param IDLoc Location of the immediate in the source file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:8,Modifiability,extend,extend,8,"// Sign extend up to 64-bit so that the predicates match the hardware; // behaviour. In particular, isInt<16>(0xffff8000) and similar should be; // true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:83,Availability,avail,available,83,// At this point we need AT to perform the expansions and we exit if it is; // not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:31,Performance,perform,perform,31,// At this point we need AT to perform the expansions and we exit if it is; // not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:99,Availability,mask,masks,99,// Traditional behaviour seems to special case this particular value. It's; // not clear why other masks are handled differently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:83,Usability,clear,clear,83,// Traditional behaviour seems to special case this particular value. It's; // not clear why other masks are handled differently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:51,Modifiability,extend,extending,51,// Expand to an ORi instead of a LUi to avoid sign-extending into the; // upper 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:40,Safety,avoid,avoid,40,// Expand to an ORi instead of a LUi to avoid sign-extending into the; // upper 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:200,Performance,load,load,200,// The remaining case is packed with a sequence of dsll and ori with zeros; // being omitted and any neighbouring dsll's being coalesced.; // The highest 32-bit's are equivalent to a 32-bit immediate load.; // Load bits 32-63 of ImmValue into bits 0-31 of the temporary register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:210,Performance,Load,Load,210,// The remaining case is packed with a sequence of dsll and ori with zeros; // being omitted and any neighbouring dsll's being coalesced.; // The highest 32-bit's are equivalent to a 32-bit immediate load.; // Load bits 32-63 of ImmValue into bits 0-31 of the temporary register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:22,Usability,usab,usable,22,// la can't produce a usable address when addresses are 64-bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:66,Availability,avail,available,66,"// If $rs is the same as $rd, we need to use AT.; // If it is not available we exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:73,Performance,load,loaded,73,"// FIXME: In case of N32 / N64 ABI and emabled XGOT, local addresses; // loaded using R_MIPS_GOT_PAGE / R_MIPS_GOT_OFST pair of relocations.; // FIXME: Implement XGOT for microMIPS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:255,Availability,redundant,redundant,255,"// Loading address from XGOT; // External GOT: lui $tmp, %got_hi(symbol)($gp); // addu $tmp, $tmp, $gp; // lw $tmp, %got_lo(symbol)($tmp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Performance,Load,Loading,3,"// Loading address from XGOT; // External GOT: lui $tmp, %got_hi(symbol)($gp); // addu $tmp, $tmp, $gp; // lw $tmp, %got_lo(symbol)($tmp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:255,Safety,redund,redundant,255,"// Loading address from XGOT; // External GOT: lui $tmp, %got_hi(symbol)($gp); // addu $tmp, $tmp, $gp; // lw $tmp, %got_lo(symbol)($tmp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:197,Availability,redundant,redundant,197,"// The remaining cases are:; // Small offset: ld $tmp, %got_disp(symbol)($gp); // >daddiu $tmp, $tmp, offset; // >daddu $rd, $tmp, $rs; // The daddiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:197,Safety,redund,redundant,197,"// The remaining cases are:; // Small offset: ld $tmp, %got_disp(symbol)($gp); // >daddiu $tmp, $tmp, offset; // >daddu $rd, $tmp, $rs; // The daddiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:110,Modifiability,extend,extended,110,// FIXME: Offsets greater than 16 bits are not yet implemented.; // FIXME: The correct range is a 32-bit sign-extended number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:311,Availability,redundant,redundant,311,"// The remaining cases are:; // External GOT: lw $tmp, %got(symbol)($gp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // Local GOT: lw $tmp, %got(symbol+offset)($gp); // addiu $tmp, $tmp, %lo(symbol+offset)($gp); // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:311,Safety,redund,redundant,311,"// The remaining cases are:; // External GOT: lw $tmp, %got(symbol)($gp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // Local GOT: lw $tmp, %got(symbol+offset)($gp); // addiu $tmp, $tmp, %lo(symbol+offset)($gp); // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:184,Availability,avail,available,184,// We need AT for the 64-bit expansion in the cases where the optional; // source register is the destination register and for the superscalar; // scheduled form.; //; // If it is not available we exit if the destination is the same as the; // source register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:147,Energy Efficiency,schedul,scheduled,147,// We need AT for the 64-bit expansion in the cases where the optional; // source register is the destination register and for the superscalar; // scheduled form.; //; // If it is not available we exit if the destination is the same as the; // source register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:82,Availability,avail,available,82,"// If the $rs is different from $rd or if $rs isn't specified and we; // have $at available:; // (d)la $rd, sym/sym($rs) => lui $rd, %highest(sym); // lui $at, %hi(sym); // daddiu $rd, $rd, %higher(sym); // daddiu $at, $at, %lo(sym); // dsll32 $rd, $rd, 0; // daddu $rd, $rd, $at; // (daddu $rd, $rd, $rs); //; // Which is preferred for superscalar issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:67,Availability,avail,available,67,"// We have a case where SrcReg == DstReg and we don't have $at; // available. We can't expand this case, so error out appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:108,Availability,error,error,108,"// We have a case where SrcReg == DstReg and we don't have $at; // available. We can't expand this case, so error out appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:66,Availability,avail,available,66,"// If $rs is the same as $rd, we need to use AT.; // If it is not available we exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:198,Integrability,depend,depending,198,"// Each double-precision register DO-D15 overlaps with two of the single; // precision registers F0-F31. As an example, all of the following hold true:; // D0 + 1 == F1, F1 + 1 == D1, F1 + 1 == F2, depending on the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:399,Performance,load,load,399,"// FIXME: This method is too general. In principle we should compute the number; // of instructions required to synthesize the immediate inline compared to; // synthesizing the address inline and relying on non .text sections.; // For static O32 and N32 this may yield a small benefit, for static N64 this is; // likely to yield a much larger benefit as we have to synthesize a 64bit; // address to load a 64 bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:367,Modifiability,extend,extended,367,"// FIXME: This is technically correct but gives a different result to gas,; // but gas is incomplete there (it has a fixme noting it doesn't work with; // 64-bit addresses).; // FIXME: With -msym32 option, the address expansion for N64 should probably; // use the O32 / N32 case. It's safe to use the 64 address expansion as the; // symbol's value is considered sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:285,Safety,safe,safe,285,"// FIXME: This is technically correct but gives a different result to gas,; // but gas is incomplete there (it has a fixme noting it doesn't work with; // 64-bit addresses).; // FIXME: With -msym32 option, the address expansion for N64 should probably; // use the O32 / N32 case. It's safe to use the 64 address expansion as the; // symbol's value is considered sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:10,Modifiability,Enhance,Enhance,10,// FIXME: Enhance this expansion to use the .lit4 & .lit8 sections; // where appropriate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:10,Modifiability,Enhance,Enhance,10,// FIXME: Enhance this expansion to use the .lit4 & .lit8 sections; // where appropriate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:83,Availability,avail,available,83,// At this point we need AT to perform the expansions; // and we exit if it is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:31,Performance,perform,perform,31,// At this point we need AT to perform the expansions; // and we exit if it is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:215,Energy Efficiency,reduce,reduce,215,// FIXME:; // c) Check that immediates of R_MIPS_GOT16/R_MIPS_LO16 relocations; // do not exceed 16-bit.; // d) Use R_MIPS_GOT_PAGE/R_MIPS_GOT_OFST relocations instead; // of R_MIPS_GOT_DISP in appropriate cases to reduce number; // of GOT entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:12,Performance,load,load,12,// Emit the load or store with the adjusted base and offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:83,Availability,avail,available,83,// At this point we need AT to perform the expansions; // and we exit if it is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:31,Performance,perform,perform,31,// At this point we need AT to perform the expansions; // and we exit if it is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:138,Energy Efficiency,efficient,efficient,138,"// FIXME: All of these Opcode-specific if's are needed for compatibility; // with GAS' behaviour. However, they may not generate the most efficient; // code in some circumstances.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:557,Modifiability,variab,variable,557,"// If the $rs is $0 and the pseudo-branch is BLTU (0 < x) or; // if the $rt is $0 and the pseudo-branch is BGTU (x > 0),; // the pseudo-branch will be taken only when the non-zero register is; // different from 0, so we emit a BNEZ.; //; // If the $rs is $0 and the pseudo-branch is BGEU (0 >= x) or; // if the $rt is $0 and the pseudo-branch is BLEU (x <= 0),; // the pseudo-branch will be taken only when the non-zero register is; // equal to 0, so we emit a BEQZ.; //; // Because only BLEU and BGEU branch on equality, we can use the; // AcceptsEquality variable to decide when to emit the BEQZ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:103,Availability,avail,available,103,"// If neither the SrcReg nor the TrgReg are $0, we need AT to perform the; // expansions. If it is not available, we return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:62,Performance,perform,perform,62,"// If neither the SrcReg nor the TrgReg are $0, we need AT to perform the; // expansions. If it is not available, we return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:540,Modifiability,variab,variable,540,"// SLT fits well with 2 of our 4 pseudo-branches:; // BLT, where $rs < $rt, translates into ""slt $at, $rs, $rt"" and; // BGT, where $rs > $rt, translates into ""slt $at, $rt, $rs"".; // If the result of the SLT is 1, we branch, and if it's 0, we don't.; // This is accomplished by using a BNEZ with the result of the SLT.; //; // The other 2 pseudo-branches are opposites of the above 2 (BGE with BLT; // and BLE with BGT), so we change the BNEZ into a BEQZ.; // Because only BGE and BLE branch on equality, we can use the; // AcceptsEquality variable to decide when to emit the BEQZ.; // Note that the order of the SLT arguments doesn't change between; // opposites.; //; // The same applies to the unsigned variants, except that SLTu is used; // instead of SLT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:190,Performance,optimiz,optimization,190,"// If the macro expansion of (d)div(u) or (d)rem(u) would always trap or; // break, insert the trap/break and exit. This gives a different result to; // GAS. GAS has an inconsistency/missed optimization in that not all cases; // are handled equivalently. As the observed behaviour is the same, we're ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:22,Performance,load,load,22,// Compute left/right load/store offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:7,Performance,load,loads,7,"// For loads, clobber the base register with the second load instead of the; // first if the BaseReg == FirstReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:56,Performance,load,load,56,"// For loads, clobber the base register with the second load instead of the; // first if the BaseReg == FirstReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:293,Performance,perform,performs,293,"// As described the MIPSR6 spec, the compact branches that compare registers; // must:; // a) Not use the zero register.; // b) Not use the same register twice.; // c) rs < rt for bnec, beqc.; // NB: For this case, the encoding will swap the operands as their; // ordering doesn't matter. GAS performs this transformation too.; // Hence, that constraint does not have to be enforced.; //; // The compact branches that branch iff the signed addition of two registers; // would overflow must have rs >= rt. That can be handled like beqc/bnec with; // operand swapping. They do not have restriction of using the zero register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:84,Safety,avoid,avoid,84,// This is used on UImm5 operands that have a corresponding UImm5_32; // operand to avoid confusing the user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:107,Availability,error,error,107,"// If there wasn't a custom match, try the generic matcher below. Otherwise,; // there was a match, but an error occurred, in which case, just return that; // the operand parsing failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:181,Availability,error,error,181,"// AFAIK, we only support numeric registers and named GPR's in CFI; // directives.; // Don't worry about eating tokens before failing. Using an unrecognised; // register is a parse error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:75,Integrability,rout,routine,75,"// If symbol is unset, it might be created in the `parseSetAssignment`; // routine as an alias for a numeric register name.; // Lookup in the aliases list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:12,Availability,error,error,12,"// Show the error, but treat invalid register; // number as a normal one to continue parsing; // and catch other possible errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:122,Availability,error,errors,122,"// Show the error, but treat invalid register; // number as a normal one to continue parsing; // and catch other possible errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:20,Performance,load,load,20,"/// Sometimes (i.e. load/stores) the operand may be followed immediately by; /// either this.; /// ::= '(', register, ')'; /// handle it before we iterate so we don't get tripped up by the lack of; /// a comma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:206,Availability,error,error,206,"// This target-overriden function exists to maintain current behaviour for; // e.g.; // dahi $3, $3, 0x5678; // as tested in test/MC/Mips/mips64r6/valid.s.; // FIXME: Should this test actually fail with an error? If so, then remove; // this overloaded method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:115,Testability,test,tested,115,"// This target-overriden function exists to maintain current behaviour for; // e.g.; // dahi $3, $3, 0x5678; // as tested in test/MC/Mips/mips64r6/valid.s.; // FIXME: Should this test actually fail with an error? If so, then remove; // this overloaded method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:125,Testability,test,test,125,"// This target-overriden function exists to maintain current behaviour for; // e.g.; // dahi $3, $3, 0x5678; // as tested in test/MC/Mips/mips64r6/valid.s.; // FIXME: Should this test actually fail with an error? If so, then remove; // this overloaded method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:179,Testability,test,test,179,"// This target-overriden function exists to maintain current behaviour for; // e.g.; // dahi $3, $3, 0x5678; // as tested in test/MC/Mips/mips64r6/valid.s.; // FIXME: Should this test actually fail with an error? If so, then remove; // this overloaded method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:70,Availability,error,error,70,"// Eat ""noat"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:69,Availability,error,error,69,"// Eat ""reg"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:71,Availability,error,error,71,"// Eat ""nodsp"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:74,Availability,error,error,74,"// Eat ""nomips3d"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:72,Availability,error,error,72,"// Eat ""mips16"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:74,Availability,error,error,74,"// Eat ""nomips16"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:68,Availability,error,error,68,"// Eat ""mt"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:70,Availability,error,error,70,"// Eat ""nomt"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:71,Availability,error,error,71,"// Eat ""nocrc"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:72,Availability,error,error,72,"// Eat ""novirt"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:72,Availability,error,error,72,"// Eat ""noginv"".; // If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:113,Availability,error,error,113,"// If we don't recognize the option passed to the .nan; // directive (e.g. no option or unknown option), emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:23,Integrability,message,message,23,// TODO : get a better message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the abiflags information with the FeatureBits information we; // changed above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated abiflags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted at the end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the abiflags information with the FeatureBits information we; // changed above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated abiflags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted at the end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:81,Deployability,update,updated,81,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated ABI Flags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Integrability,Synchroniz,Synchronize,3,// Synchronize the abiflags information with the FeatureBits information we; // changed above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:42,Deployability,update,updated,42,"// If printing assembly, use the recently updated abiflags information.; // If generating ELF, don't do anything (the .MIPS.abiflags section gets; // emitted at the end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:135,Availability,error,error,135,// This returns false if this function recognizes the directive; // regardless of whether it is successfully handles or reports an; // error. Otherwise it returns true to give the generic parser a; // chance at recognizing it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:14,Usability,undo,undocumented,14,"// There's an undocumented extension that allows an integer to; // follow the name of the procedure which AFAICS is ignored by GAS.; // Example: .ent foo,2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:287,Availability,error,error,287,"// Even though we accept this undocumented extension for compatibility; // reasons, the additional integer argument does not actually change; // the behaviour of the '.ent' directive, so we would like to discourage; // its use. We do this by not referring to the extended version in; // error messages which are not directly related to its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:293,Integrability,message,messages,293,"// Even though we accept this undocumented extension for compatibility; // reasons, the additional integer argument does not actually change; // the behaviour of the '.ent' directive, so we would like to discourage; // its use. We do this by not referring to the extended version in; // error messages which are not directly related to its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:263,Modifiability,extend,extended,263,"// Even though we accept this undocumented extension for compatibility; // reasons, the additional integer argument does not actually change; // the behaviour of the '.ent' directive, so we would like to discourage; // its use. We do this by not referring to the extended version in; // error messages which are not directly related to its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:30,Usability,undo,undocumented,30,"// Even though we accept this undocumented extension for compatibility; // reasons, the additional integer argument does not actually change; // the behaviour of the '.ent' directive, so we would like to discourage; // its use. We do this by not referring to the extended version in; // error messages which are not directly related to its use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:110,Availability,error,error,110,"// If the user was explicitly trying to use the extended version,; // we still give helpful extension-related error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:116,Integrability,message,messages,116,"// If the user was explicitly trying to use the extended version,; // we still give helpful extension-related error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:48,Modifiability,extend,extended,48,"// If the user was explicitly trying to use the extended version,; // we still give helpful extension-related error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:4,Availability,mask,mask,4,"// .mask bitmask, frame_offset; // bitmask: One bit for each register used.; // frame_offset: Offset from Canonical Frame Address ($sp on entry) where; // first register is expected to be saved.; // Examples:; // .mask 0x80000000, -4; // .fmask 0x80000000, -4; //; // Parse the bitmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:214,Availability,mask,mask,214,"// .mask bitmask, frame_offset; // bitmask: One bit for each register used.; // frame_offset: Offset from Canonical Frame Address ($sp on entry) where; // first register is expected to be saved.; // Examples:; // .mask 0x80000000, -4; // .fmask 0x80000000, -4; //; // Parse the bitmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:54,Availability,error,error,54,"// If this is not the end of the statement, report an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp:133,Availability,down,down,133,// end anonymous namespace; // Forward declare these because the autogenerated code will reference them.; // Definitions are further down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp:27,Integrability,depend,depends,27,// The size of the n field depends on the element size; // The register class also depends on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp:83,Integrability,depend,depends,83,// The size of the n field depends on the element size; // The register class also depends on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp:132,Testability,log,logic,132,"// Attempt to read the instruction so that we can attempt to decode it. If; // the buffer is not 4 bytes long, let the higher level logic figure out; // what to do with a size of zero and MCDisassembler::Fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIFlagsSection.h:3,Availability,Mask,Mask,3,// Mask of ASEs used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIFlagsSection.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIFlagsSection.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h:33,Modifiability,variab,variable,33,/// The registers to use for the variable argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h:32,Energy Efficiency,allocate,allocated,32,/// Obtain the size of the area allocated by the callee for arguments.; /// CallingConv::FastCall affects the value for O32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:164,Availability,error,error,164,"/// WriteNopData - Write an (optimal) nop sequence of Count bytes; /// to the given output. If the target cannot generate such a sequence,; /// it should return an error.; ///; /// \return - True on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.h:28,Integrability,Interface,Interfaces,28,/// @name Target Relaxation Interfaces; /// @{; /// fixupNeedsRelaxation - Target specific predicate for whether a given; /// fixup requires the associated instruction to be relaxed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsBaseInfo.h:338,Availability,toler,tolerated,338,"//===------------------------------------------------------------------===//; // Instruction encodings. These are the standard/most common forms for; // Mips instructions.; //; // Pseudo - This represents an instruction that is a pseudo instruction; // or one that has not been implemented yet. It is illegal to code generate; // it, but tolerated for intermediate implementation stages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsBaseInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsBaseInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:1578,Performance,load,loading,1578,"equired by the MIPS ABI.; ///; /// MIPS has a few relocations that have an AHL component in the expression used; /// to evaluate them. This AHL component is an addend with the same number of; /// bits as a symbol value but not all of our ABI's are able to supply a; /// sufficiently sized addend in a single relocation.; ///; /// The O32 ABI for example, uses REL relocations which store the addend in the; /// section data. All the relocations with AHL components affect 16-bit fields; /// so the addend for a single relocation is limited to 16-bit. This ABI; /// resolves the limitation by linking relocations (e.g. R_MIPS_HI16 and; /// R_MIPS_LO16) and distributing the addend between the linked relocations. The; /// ABI mandates that such relocations must be next to each other in a; /// particular order (e.g. R_MIPS_HI16 must be immediately followed by a; /// matching R_MIPS_LO16) but the rule is less strict in practice.; ///; /// The de facto standard is lenient in the following ways:; /// - 'Immediately following' does not refer to the next relocation entry but; /// the next matching relocation.; /// - There may be multiple high parts relocations for one low part relocation.; /// - There may be multiple low part relocations for one high part relocation.; /// - The AHL addend in each part does not have to be exactly equal as long as; /// the difference does not affect the carry bit from bit 15 into 16. This is; /// to allow, for example, the use of %lo(foo) and %lo(foo+4) when loading; /// both halves of a long long.; ///; /// See getMatchingLoType() for a description of which high part relocations; /// match which low part relocations. One particular thing to note is that; /// R_MIPS_GOT16 and similar only have AHL addends if they refer to local; /// symbols.; ///; /// It should also be noted that this function is not affected by whether; /// the symbol was kept or rewritten into a section-relative equivalent. We; /// always match using the expressions from the source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:194,Safety,safe,safe,194,"// On REL ABI's (e.g. O32), these relocations form pairs. The pairing is done; // by the static linker by matching the symbol and offset.; // We only see one relocation at a time but it's still safe to relocate with; // the section so long as both relocations make the same decision.; //; // Some older linkers may require the symbol for particular cases. Such cases; // are not supported yet but can be added as required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:23,Safety,safe,safe,23,// FIXME: It should be safe to return false for the STO_MIPS_MICROMIPS but; // we neglect to handle the adjustment to the LSB of the addend that; // it causes in applyFixup() and similar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:106,Safety,safe,safe,106,// FIXME: Many of these relocations should probably return false but this; // hasn't been confirmed to be safe yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:91,Deployability,integrat,integrated,91,// FIXME: Many of these should probably return false but MIPS16 isn't; // supported by the integrated assembler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:91,Integrability,integrat,integrated,91,// FIXME: Many of these should probably return false but MIPS16 isn't; // supported by the integrated assembler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFStreamer.h:43,Safety,avoid,avoid,43,// Overriding these functions allows us to avoid recording of these labels; // in EmitLabel and later marking them as microMIPS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFStreamer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFStreamer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp:3,Performance,Load,Load,3,"// Load/Store memory operands -- imm($reg); // If PIC target the target is loaded as the; // pattern lw $25,%call16($28); // opNum can be invalid if instruction had reglist as operand.; // MemOperand is always last operand of instruction (base + offset).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp:75,Performance,load,loaded,75,"// Load/Store memory operands -- imm($reg); // If PIC target the target is loaded as the; // pattern lw $25,%call16($28); // opNum can be invalid if instruction had reglist as operand.; // MemOperand is always last operand of instruction (base + offset).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp:38,Performance,load,load,38,// when using stack locations for not load/store instructions; // print the same way as all normal 3 operand instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h:116,Integrability,depend,dependencies,116,// These enumeration declarations were originally in MipsInstrInfo.h but; // had to be moved here to avoid circular dependencies between; // LLVMMipsCodeGen and LLVMMipsAsmPrinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h:101,Safety,avoid,avoid,101,// These enumeration declarations were originally in MipsInstrInfo.h but; // had to be moved here to avoid circular dependencies between; // LLVMMipsCodeGen and LLVMMipsAsmPrinter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp:121,Integrability,rout,routine,121,"// end namespace llvm; // If the D<shift> instruction has a shift amount that is greater; // than 31 (checked in calling routine), lower it to a D<shift>32 instruction",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp:27,Integrability,synchroniz,synchronized,27,// Calling function is not synchronized,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp:217,Energy Efficiency,efficient,efficient,217,"// Non-pseudo instructions that get changed for direct object; // only based on operand values.; // If this list of instructions get much longer we will move; // the check to a function call. Until then, this is more efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h:13,Modifiability,sandbox,sandbox,13,// NaCl MIPS sandbox's instruction bundle size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h:13,Testability,sandbox,sandbox,13,// NaCl MIPS sandbox's instruction bundle size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCNaCl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:516,Availability,mask,masking,516,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:626,Availability,mask,masking,626,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:721,Availability,mask,mask,721,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:488,Modifiability,sandbox,sandbox,488,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:582,Security,access,access,582,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:488,Testability,sandbox,sandbox,488,"//===-- MipsNaClELFStreamer.cpp - ELF Object Output for Mips NaCl ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements MCELFStreamer for Mips NaCl. It emits .o object files; // as required by NaCl's SFI sandbox. It inserts address-masking instructions; // before dangerous control-flow and memory access instructions. It inserts; // address-masking instructions after instructions that change the stack; // pointer. It ensures that the mask and the dangerous instruction are always; // emitted in the same bundle. It aligns call + branch delay to the bundle end,; // so that return address is always aligned to the start of next bundle.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:58,Availability,mask,mask,58,/// Extend the generic MCELFStreamer class so that it can mask dangerous; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:4,Modifiability,Extend,Extend,4,/// Extend the generic MCELFStreamer class so that it can mask dangerous; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:26,Modifiability,sandbox,sandboxing,26,// Whether we started the sandboxing sequence for calls. Calls are bundled; // with branch delays and aligned to the bundle end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:26,Testability,sandbox,sandboxing,26,// Whether we started the sandboxing sequence for calls. Calls are bundled; // with branch delays and aligned to the bundle end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:62,Availability,mask,mask,62,// Sandbox indirect branch or return instruction by inserting mask operation; // before it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox indirect branch or return instruction by inserting mask operation; // before it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox indirect branch or return instruction by inserting mask operation; // before it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:46,Availability,mask,mask,46,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:18,Security,access,access,18,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:18,Security,access,access,18,// Sandbox memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox SP change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox SP change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:105,Availability,mask,mask,105,/// This function is the one used to emit instruction data into the ELF; /// streamer. We override it to mask dangerous instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,// Sandbox indirect jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,// Sandbox indirect jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,"// Sandbox loads, stores and SP changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:11,Performance,load,loads,11,"// Sandbox loads, stores and SP changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,"// Sandbox loads, stores and SP changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:103,Availability,mask,mask,103,"// Sandbox calls by aligning call and branch delay to the bundle end.; // For indirect calls, emit the mask before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Modifiability,Sandbox,Sandbox,3,"// Sandbox calls by aligning call and branch delay to the bundle end.; // For indirect calls, emit the mask before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Testability,Sandbox,Sandbox,3,"// Sandbox calls by aligning call and branch delay to the bundle end.; // For indirect calls, emit the mask before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:13,Modifiability,sandbox,sandboxing,13,// Start the sandboxing sequence by emitting call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:13,Testability,sandbox,sandboxing,13,// Start the sandboxing sequence by emitting call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:14,Modifiability,sandbox,sandboxing,14,// Finish the sandboxing sequence by emitting branch delay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:14,Testability,sandbox,sandboxing,14,// Finish the sandboxing sequence by emitting branch delay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:15,Modifiability,sandbox,sandboxing,15,"// None of the sandboxing applies, just emit the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:15,Testability,sandbox,sandboxing,15,"// None of the sandboxing applies, just emit the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:3,Performance,Load,Load,3,// Load instructions with base address register in position 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:65,Availability,mask,masking,65,// The contents of SP and thread pointer register do not require masking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:11,Performance,load,load,11,/// Emit a load instruction with an immediate offset. DstReg and TmpReg are; /// permitted to be the same register iff DstReg is distinct from BaseReg and; /// DstReg is a GPR. It is the callers responsibility to identify such cases; /// and pass the appropriate register in TmpReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:12,Performance,load,load,12,// Emit the load with the adjusted base and offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:495,Integrability,depend,dependency,495,"// Set the header flags that we can in the constructor.; // FIXME: This is a fairly terrible hack. We set the rest; // of these in the destructor. The problem here is two-fold:; //; // a: Some of the eflags can be set/reset by directives.; // b: There aren't any usage paths that initialize the ABI; // pointer until after we initialize either an assembler; // or the target machine.; // We can fix this by making the target streamer construct; // the ABI, but this is fraught with wide ranging dependency; // issues as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:260,Availability,failure,failure,260,"// FIXME: Fix a dependency issue by instantiating the ABI object to some; // default based off the triple. The triple doesn't describe the target; // fully, but any external user of the API that uses the MCTargetStreamer; // would otherwise crash on assertion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:16,Integrability,depend,dependency,16,"// FIXME: Fix a dependency issue by instantiating the ABI object to some; // default based off the triple. The triple doesn't describe the target; // fully, but any external user of the API that uses the MCTargetStreamer; // would otherwise crash on assertion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:250,Testability,assert,assertion,250,"// FIXME: Fix a dependency issue by instantiating the ABI object to some; // default based off the triple. The triple doesn't describe the target; // fully, but any external user of the API that uses the MCTargetStreamer; // would otherwise crash on assertion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:3,Deployability,Update,Update,3,// Update e_header flags. See the FIXME and comment above in; // the constructor for a full rundown on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:65,Security,access,access,65,"// The ELFObjectWriter can determine the absolute size as it has access to; // the layout information of the assembly file, so a size expression rather; // than an absolute value is ok here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:99,Security,access,accessed,99,"// There's a GNU extension controlled by -mno-shared that allows; // locally-binding symbols to be accessed using absolute addresses.; // This is currently not supported. When supported -mno-shared makes; // .cpload expand to:; // lui $gp, %hi(__gnu_local_gp); // addiu $gp, $gp, %lo(__gnu_local_gp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430.h:28,Integrability,interface,interface,28,"//==-- MSP430.h - Top-level interface for MSP430 representation --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in; // the LLVM MSP430 backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430AsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- MSP430AsmPrinter.cpp - MSP430 LLVM assembly writer ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to the MSP430 assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430AsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430AsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp:36,Usability,Guid,Guide,36,"// According to CC430 Family User's Guide, Section 4.5.1.3, branch; // instructions have the signed 10-bit word offset field, so first we need to; // convert the distance from bytes to words, then check if it fits in 10-bit; // signed integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp:3,Deployability,Update,Update,3,// Update the successor lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp:73,Safety,safe,safer,73,"// It may be not necessary to start all over at this point, but it's; // safer do this anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:148,Deployability,Update,Update,148,// Get the offset of the stack slot for the EBP register... which is; // guaranteed to be the last slot by processFunctionBeforeFrameFinalized.; // Update the frame offset adjustment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:3,Deployability,Update,Update,3,// Update FP with the new base value...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp:13,Performance,perform,performing,13,"// If we are performing frame pointer elimination and if the callee pops; // something off the stack pointer, add it back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.h:4,Integrability,Wrap,Wraps,4,/// Wraps up getting a CFI index and building a MachineInstr for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430FrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:116,Energy Efficiency,schedul,scheduling,116,"/// createMSP430ISelDag - This pass converts a legalized DAG into a; /// MSP430-specific DAG, ready for instruction scheduling.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:122,Availability,down,down,122,"/// MatchWrapper - Try to match MSP430ISD::Wrapper node into an addressing mode.; /// These wrap things that will resolve down into a symbol reference. If no; /// match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:43,Integrability,Wrap,Wrapper,43,"/// MatchWrapper - Try to match MSP430ISD::Wrapper node into an addressing mode.; /// These wrap things that will resolve down into a symbol reference. If no; /// match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:92,Integrability,wrap,wrap,92,"/// MatchWrapper - Try to match MSP430ISD::Wrapper node into an addressing mode.; /// These wrap things that will resolve down into a symbol reference. If no; /// match is possible, this returns true, otherwise it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp:59,Usability,clear,clear,59,"// Handle ""X | C"" as ""X + C"" iff X is known to have C bits clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:56,Performance,load,loads,56,// FIXME: Is this correct?; // We have post-incremented loads / stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:20,Energy Efficiency,efficient,efficiently,20,// FIXME: Implement efficiently multiplication by a constant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:25,Testability,test,test,25,// Implemented to verify test case assertions in; // tests/codegen/msp430/shift-amount-threshold-b.ll,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:35,Testability,assert,assertions,35,// Implemented to verify test case assertions in; // tests/codegen/msp430/shift-amount-threshold-b.ll,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:53,Testability,test,tests,53,// Implemented to verify test case assertions in; // tests/codegen/msp430/shift-amount-threshold-b.ll,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:48,Performance,optimiz,optimization,48,// MSP430 target does not yet support tail call optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:94,Performance,load,load,94,/// LowerCCCArguments - transform physical registers into virtual registers and; /// generate load operations for arguments places on the stack.; // FIXME: struct return stuff,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:85,Testability,assert,assert,85,"// If this is an 8-bit value, it is really passed promoted to 16; // bits. Insert an assert[sz]ext to capture this, then truncate to the; // right size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Performance,Load,Load,3,// Load the argument to a virtual register,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:52,Performance,load,load,52,// Create the SelectionDAG nodes corresponding to a load; //from this parameter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:61,Safety,avoid,avoiding,61,"// Guarantee that all emitted copies are stuck together,; // avoiding something bad.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Deployability,Update,Update,3,// Update chain.; // Add the glue if we have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:58,Performance,load,loads,58,"// Walk the register/memloc assignments, inserting copies/loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:24,Performance,optimiz,optimization,24,"// aka COND_Z; // Minor optimization: if LHS is a constant, swap operands, then the; // constant can be folded into comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:25,Performance,optimiz,optimization,25,"// aka COND_NZ; // Minor optimization: if LHS is a constant, swap operands, then the; // constant can be folded into comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:30,Testability,test,testing,30,"// If we are doing an AND and testing against zero, then the CMP; // will not be generated. The AND (or BIT) will generate the condition codes,; // but they are different from CMP.; // FIXME: since we're doing a post-processing, use a pseudoinstr here, so; // lowering & isel wouldn't diverge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:8,Performance,load,load,8,// Just load the return address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:167,Performance,load,load,167,"/// getPostIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:203,Performance,load,load,203,"/// getPostIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:26,Modifiability,extend,extends,26,// MSP430 implicitly zero-extends 8-bit results in 16-bit registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:26,Modifiability,extend,extends,26,// MSP430 implicitly zero-extends 8-bit results in 16-bit registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the block containing instructions after shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges by transferring all successors of the current; // block to the new block which will contain the Phi node for the select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:3,Deployability,Update,Update,3,// Update machine-CFG edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:51,Integrability,Interface,Interface,51,"//===-- MSP430ISelLowering.h - MSP430 DAG Lowering Interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that MSP430 uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- MSP430ISelLowering.h - MSP430 DAG Lowering Interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that MSP430 uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:39,Usability,clear,cleared,39,"/// Rotate right via carry, carry gets cleared beforehand by clrc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:4,Integrability,Wrap,Wrapper,4,"/// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,; /// and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:16,Integrability,wrap,wrapper,16,"/// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,; /// and TargetGlobalAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:54,Modifiability,variab,variable,54,"/// SELECT_CC - Operand 0 and operand 1 are selection variable, operand 3; /// is condition code and operand 4 is flag operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:107,Modifiability,extend,extends,107,"/// isZExtFree - Return true if any actual instruction that defines a value; /// of type Ty1 implicit zero-extends the value to Ty2 in the result; /// register. This does not necessarily include registers defined in unknown; /// ways, such as incoming arguments, or copies from unknown virtual; /// registers. Also, if isTruncateFree(Ty2, Ty1) is true, this does not; /// necessarily apply to truncate instructions. e.g. on msp430, all; /// instructions that define 8-bit values implicit zero-extend the result; /// out to 16 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h:493,Modifiability,extend,extend,493,"/// isZExtFree - Return true if any actual instruction that defines a value; /// of type Ty1 implicit zero-extends the value to Ty2 in the result; /// register. This does not necessarily include registers defined in unknown; /// ways, such as incoming arguments, or copies from unknown virtual; /// registers. Also, if isTruncateFree(Ty2, Ty1) is true, this does not; /// necessarily apply to truncate instructions. e.g. on msp430, all; /// instructions that define 8-bit values implicit zero-extend the result; /// out to 16 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430MCInstLower.cpp:27,Energy Efficiency,efficient,efficient,27,"// FIXME: We would like an efficient form for this, so we don't have to do a; // lot of extra uniquing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430MCInstLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430MCInstLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430RegisterInfo.cpp:21,Performance,load,load,21,"// This is actually ""load effective address"" of the stack slot; // instruction. We have only two-address instructions, thus we need to; // expand it into mov + add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430RegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430RegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430Subtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp:31,Deployability,Configurat,Configuration,31,/// MSP430 Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp:31,Modifiability,Config,Configuration,31,/// MSP430 Code Generator Pass Configuration Options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp:3,Deployability,Install,Install,3,// Install an instruction selector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430TargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp:3,Availability,Mask,Mask,3,// Mask 10 bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp:57,Availability,mask,mask,57,"// For each byte of the fragment that the fixup touches, mask in the; // bits from the fixup value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430AsmBackend.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCAsmInfo.cpp:197,Testability,test,tested,197,"// Since MSP430-GCC already generates 32-bit DWARF information, we will; // also store 16-bit pointers as 32-bit pointers in DWARF, because using; // 32-bit DWARF pointers is already a working and tested path for LLDB; // as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCAsmInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCAsmInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MCTargetDesc/MSP430MCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/cl_common_defines.h:10,Integrability,synchroniz,synchronization,10,// Memory synchronization,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/cl_common_defines.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/cl_common_defines.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h:28,Integrability,interface,interface,28,"//===-- NVPTX.h - Top-level interface for NVPTX representation --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in; // the LLVM NVPTX back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h:46,Availability,mask,mask,46,"// A field inside TSFlags needs a shift and a mask. The usage is; // always as follows :; // ((TSFlags & fieldMask) >> fieldShift); // The enum keeps the mask, the shift, and all valid values of the; // field in one place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h:154,Availability,mask,mask,154,"// A field inside TSFlags needs a shift and a mask. The usage is; // always as follows :; // ((TSFlags & fieldMask) >> fieldShift); // The enum keeps the mask, the shift, and all valid values of the; // field in one place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTX.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the NVPTXAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h:3,Integrability,Wrap,Wrapper,3,// Wrapper around ExternalAAWrapperPass so that the default; // constructor gets the callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- NVPTXAsmPrinter.cpp - NVPTX LLVM assembly writer ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to NVPTX assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:82,Integrability,depend,depends,82,/// DiscoverDependentGlobals - Return a set of GlobalVariables on which \p V; /// depends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:126,Integrability,depend,dependents,126,"/// VisitGlobalVariableForEmission - Add \p GV to the list of GlobalVariable; /// instances to be emitted, but only after any dependents have been added; /// first.s",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:25,Integrability,depend,dependency,25,// Do we have a circular dependency?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:26,Integrability,depend,dependents,26,// Make sure we visit all dependents first,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:17,Performance,load,load,17,"// For a surface load of vector size N, the Nth operand will be the surfref",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:24,Modifiability,variab,variable,24,"/* Find out if a global variable can be demoted to local scope.; * Currently, this is valid for CUDA shared variables, which have local; * scope and global lifetime. So the conditions to check are :; * 1. Is the global variable in shared address space?; * 2. Does it have local linkage?; * 3. Is the global variable referenced only in one function?; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:108,Modifiability,variab,variables,108,"/* Find out if a global variable can be demoted to local scope.; * Currently, this is valid for CUDA shared variables, which have local; * scope and global lifetime. So the conditions to check are :; * 1. Is the global variable in shared address space?; * 2. Does it have local linkage?; * 3. Is the global variable referenced only in one function?; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:219,Modifiability,variab,variable,219,"/* Find out if a global variable can be demoted to local scope.; * Currently, this is valid for CUDA shared variables, which have local; * scope and global lifetime. So the conditions to check are :; * 1. Is the global variable in shared address space?; * 2. Does it have local linkage?; * 3. Is the global variable referenced only in one function?; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:307,Modifiability,variab,variable,307,"/* Find out if a global variable can be demoted to local scope.; * Currently, this is valid for CUDA shared variables, which have local; * scope and global lifetime. So the conditions to check are :; * 1. Is the global variable in shared address space?; * 2. Does it have local linkage?; * 3. Is the global variable referenced only in one function?; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:48,Modifiability,variab,variable,48,"// The use is in the initialization of a global variable; // that is a function pointer, so print a declaration; // for the original function",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,error,error,3,// error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,error,error,3,// error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:220,Integrability,depend,dependent,220,"// As ptxas does not support forward references of globals, we need to first; // sort the list of module-level globals in def-use order. We visit each; // global variable in order, and ensure that we emit it *after* its dependent; // globals. We use a little extra memory maintaining both a set and a list to; // have fast searches while maintaining a strict ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:162,Modifiability,variab,variable,162,"// As ptxas does not support forward references of globals, we need to first; // sort the list of module-level globals in def-use order. We visit each; // global variable in order, and ensure that we emit it *after* its dependent; // globals. We use a little extra memory maintaining both a set and a list to; // have fast searches while maintaining a strict ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:21,Modifiability,variab,variable,21,"// Visit each global variable, in order",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:33,Modifiability,variab,variables,33,// Print out module-level global variables in proper order,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:83,Modifiability,variab,variables,83,"// This function emits appropriate linkage directives for; // functions and global variables.; //; // extern function declaration -> .extern; // extern function definition -> .visible; // external global variable with init -> .visible; // external without init -> .extern; // appending -> not allowed, assert.; // for any linkage other than; // internal, private, linker_private,; // linker_private_weak, linker_private_weak_def_auto,; // we emit -> .weak.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:204,Modifiability,variab,variable,204,"// This function emits appropriate linkage directives for; // functions and global variables.; //; // extern function declaration -> .extern; // extern function definition -> .visible; // external global variable with init -> .visible; // external without init -> .extern; // appending -> not allowed, assert.; // for any linkage other than; // internal, private, linker_private,; // linker_private_weak, linker_private_weak_def_auto,; // we emit -> .weak.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:302,Testability,assert,assert,302,"// This function emits appropriate linkage directives for; // functions and global variables.; //; // extern function declaration -> .extern; // extern function definition -> .visible; // external global variable with init -> .visible; // external without init -> .extern; // appending -> not allowed, assert.; // for any linkage other than; // internal, private, linker_private,; // linker_private_weak, linker_private_weak_def_auto,; // we emit -> .weak.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:30,Modifiability,variab,variables,30,// Skip LLVM intrinsic global variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:46,Safety,avoid,avoid,46,// FIXME - need better way (e.g. Metadata) to avoid generating this global,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:14,Modifiability,variab,variable,14,// Ptx allows variable initilization only for constant and global state; // spaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:61,Modifiability,variab,variables,61,"// The frontend adds zero-initializer to device and constant variables; // that don't have an initial value, and UndefValue to shared; // variables, so skip warning for this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:138,Modifiability,variab,variables,138,"// The frontend adds zero-initializer to device and constant variables; // that don't have an initial value, and UndefValue to shared; // variables, so skip warning for this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:192,Security,access,accesses,192,"// Although PTX has direct support for struct type and array type and; // LLVM IR is very similar to PTX, the LLVM CodeGen does not support for; // targets that support these high level field accesses. Structs, arrays; // and vectors are lowered into arrays of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:14,Modifiability,variab,variable,14,// Ptx allows variable initilization only for constant and; // global state spaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:30,Availability,mask,mask,30,// Print in bytes and use the mask() operator for pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:23,Availability,mask,mask,23,"// Generate a per-byte mask() operator for the symbol, which looks like:; // .global .u8 addr[] = {0xFF(foo), 0xFF00(foo), 0xFF0000(foo), ...};; // See https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#initializers",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:192,Security,access,accesses,192,"// Although PTX has direct support for struct type and array type and LLVM IR; // is very similar to PTX, the LLVM CodeGen does not support for targets that; // support these high level field accesses. Structs and arrays are lowered; // into arrays of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:96,Energy Efficiency,allocate,allocated,96,"// Non-zero Bytes indicates that we need to zero-fill everything. Otherwise,; // only the space allocated by CPV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:25,Integrability,depend,depend,25,"// We emit the value and depend on the assembler to truncate the generated; // expression properly. This is important for differences between; // blockaddress labels. Since the two labels are in the same function, it; // is reasonable to treat their delta as a 32-bit value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:128,Usability,simpl,simplifies,128,// Handle casts to pointers by changing them into casts to the appropriate; // integer type. This promotes constant folding and simplifies this code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:3,Availability,Error,Error,3,// Error,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:64,Availability,mask,mask,64,"// Otherwise the pointer is smaller than the resultant integer, mask off; // the high bits so we are sure to get a proper truncation if the input is; // a constant expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:21,Performance,optimiz,optimized,21,"// If the code isn't optimized, there may be outstanding folding; // opportunities. Attempt to fold the expression using DataLayout as a; // last resort before giving up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:474,Integrability,depend,dependent,474,"//===-- NVPTXAsmPrinter.h - NVPTX LLVM assembly writer ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to NVPTX assembly language.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:143,Integrability,interface,interface,143,"// The ptx syntax and format is very different from that usually seem in a .s; // file,; // therefore we are not able to use the MCAsmStreamer interface here.; //; // We are handcrafting the output method here.; //; // A better approach is to clone the MCAsmStreamer to a MCPTXAsmStreamer; // (subclass of MCStreamer).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:416,Availability,mask,mask,416,"// Used to buffer the emitted string for initializing global aggregates.; //; // Normally an aggregate (array, vector, or structure) is emitted as a u8[].; // However, if either element/field of the aggregate is a non-NULL address,; // and all such addresses are properly aligned, then the aggregate is; // emitted as u32[] or u64[]. In the case of unaligned addresses, the; // aggregate is emitted as u8[], and the mask() operator is used for all; // pointers.; //; // We first layout the aggregate in 'buffer' in bytes, except for those; // symbol addresses. For the i-th symbol address in the aggregate, its; // corresponding 4-byte or 8-byte elements in 'buffer' are filled with 0s.; // symbolPosInBuffer[i-1] records its position in 'buffer', and Symbols[i-1]; // records the Value*.; //; // Once we have this AggBuffer setup, we can choose how to print it out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:296,Integrability,depend,depending,296,"// SymbolsBeforeStripping[i] is the original form of Symbols[i] before; // stripping pointer casts, i.e.,; // Symbols[i] == SymbolsBeforeStripping[i]->stripPointerCasts().; //; // We need to keep these values because AggBuffer::print decides whether to; // emit a ""generic()"" cast for Symbols[i] depending on the address space of; // SymbolsBeforeStripping[i].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:11,Modifiability,variab,variables,11,// List of variables demoted to a function scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:86,Modifiability,variab,variables,86,"// Used to control the need to emit .generic() in the initializer of; // module scope variables.; // Although ptx supports the hybrid mode like the following,; // .global .u32 a;; // .global .u32 b;; // .global .u32 addr[] = {a, generic(b)}; // we have difficulty representing the difference in the NVVM IR.; //; // Since the address value should always be generic in CUDA C and always; // be specific in OpenCL, we use this simple control here.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:425,Usability,simpl,simple,425,"// Used to control the need to emit .generic() in the initializer of; // module scope variables.; // Although ptx supports the hybrid mode like the following,; // .global .u32 a;; // .global .u32 b;; // .global .u32 addr[] = {a, generic(b)}; // we have difficulty representing the difference in the NVVM IR.; //; // Since the address value should always be generic in CUDA C and always; // be specific in OpenCL, we use this simple control here.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:57,Modifiability,variab,variables,57,// Make emitGlobalVariable() no-op for NVPTX.; // Global variables have been already emitted by the time the base AsmPrinter; // attempts to do so in doFinalization() (see NVPTXAsmPrinter::emitGlobals()).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp:412,Modifiability,variab,variables,412,"//===-- NVPTXAssignValidGlobalNames.cpp - Assign valid names to globals ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Clean up the names of global variables in the module to not contain symbols; // that are invalid in PTX.; //; // Currently NVPTX, like other backends, relies on generic symbol name; // sanitizing done by MC. However, the ptxas assembler is more stringent and; // disallows some additional characters in symbol names. This pass makes sure; // such names do not reach MC at all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp:568,Security,sanitiz,sanitizing,568,"//===-- NVPTXAssignValidGlobalNames.cpp - Assign valid names to globals ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Clean up the names of global variables in the module to not contain symbols; // that are invalid in PTX.; //; // Currently NVPTX, like other backends, relies on generic symbol name; // sanitizing done by MC. However, the ptxas assembler is more stringent and; // disallows some additional characters in symbol names. This pass makes sure; // such names do not reach MC at all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp:212,Safety,avoid,avoid,212,"// setName doesn't do extra work if the name does not change.; // Note: this does not create collisions - if setName is asked to set the; // name to something that already exists, it adds a proper postfix to; // avoid collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp:423,Performance,load,load,423,"//===-- NVPTXAtomicLower.cpp - Lower atomics of local memory ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp:416,Usability,simpl,simple,416,"//===-- NVPTXAtomicLower.cpp - Lower atomics of local memory ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h:423,Performance,load,load,423,"//===-- NVPTXAtomicLower.h - Lower atomics of local memory ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h:416,Usability,simpl,simple,416,"//===-- NVPTXAtomicLower.h - Lower atomics of local memory ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp:28,Modifiability,variab,variables,28,"// NVPTX has no way to emit variables at specific sections or support for; // the traditional constructor sections. Instead, we emit mangled global; // names so the runtime can build the list manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp:27,Security,hash,hash,27,// We append a semi-unique hash and the priority to the global name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp:35,Usability,simpl,simply,35,"// This isn't respected by Nvidia, simply put here for clarity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp:79,Security,access,accesses,79,"// Emits; // mov %SPL, %depot;; // cvta.local %SP, %SPL;; // for local address accesses in MF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp:3,Usability,Simpl,Simply,3,"// Simply discard ADJCALLSTACKDOWN,; // ADJCALLSTACKUP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:406,Modifiability,variab,variables,406,"//===-- GenericToNVVM.cpp - Convert generic module to NVVM module - C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Convert generic global variables into either .global or .const access based; // on the variable's ""constant"" qualifier.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:470,Modifiability,variab,variable,470,"//===-- GenericToNVVM.cpp - Convert generic module to NVVM module - C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Convert generic global variables into either .global or .const access based; // on the variable's ""constant"" qualifier.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:446,Security,access,access,446,"//===-- GenericToNVVM.cpp - Convert generic module to NVVM module - C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Convert generic global variables into either .global or .const access based; // on the variable's ""constant"" qualifier.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:33,Modifiability,variab,variable,33,"// Create a clone of each global variable that has the default address space.; // The clone is created with the global address space specifier, and the pair; // of original global variable and its clone is placed in the GVMap for later; // use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:180,Modifiability,variab,variable,180,"// Create a clone of each global variable that has the default address space.; // The clone is created with the global address space specifier, and the pair; // of original global variable and its clone is placed in the GVMap for later; // use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:39,Modifiability,variab,variable,39,"// Return immediately, if every global variable has a specific address space; // specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:101,Modifiability,variab,variables,101,"// Walk through the instructions in function defitinions, and replace any use; // of original global variables in GVMap with a use of the corresponding; // copies in GVMap. If necessary, promote constants to instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:27,Modifiability,variab,variable,27,"// Walk through the global variable initializers, and replace any use of; // original global variables in GVMap with a use of the corresponding copies; // in GVMap. The copies need to be bitcast to the original global variable; // types, as we cannot use cvta in global variable initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:93,Modifiability,variab,variables,93,"// Walk through the global variable initializers, and replace any use of; // original global variables in GVMap with a use of the corresponding copies; // in GVMap. The copies need to be bitcast to the original global variable; // types, as we cannot use cvta in global variable initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:218,Modifiability,variab,variable,218,"// Walk through the global variable initializers, and replace any use of; // original global variables in GVMap with a use of the corresponding copies; // in GVMap. The copies need to be bitcast to the original global variable; // types, as we cannot use cvta in global variable initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:270,Modifiability,variab,variable,270,"// Walk through the global variable initializers, and replace any use of; // original global variables in GVMap with a use of the corresponding copies; // in GVMap. The copies need to be bitcast to the original global variable; // types, as we cannot use cvta in global variable initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:78,Modifiability,variab,variable,78,"// At this point, the remaining uses of GV should be found only in global; // variable initializers, as other uses have been already been removed; // while walking through the instructions in function definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:33,Modifiability,variab,variable,33,"// If the constant C is a global variable and is found in GVMap, substitute; //; // addrspacecast GVMap[C] to addrspace(0); //; // for our use of C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:80,Modifiability,variab,variable,80,"// If any element in the constant vector or aggregate C is or uses a global; // variable in GVMap, the constant C needs to be reconstructed, using a set; // of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:67,Modifiability,variab,variable,67,"// If any operand in the constant expression C is or uses a global variable; // in GVMap, the constant expression C needs to be reconstructed, using a; // set of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:44,Modifiability,variab,variable,44,"// Check if any element is or uses a global variable in GVMap, and thus; // converted to another value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp:44,Modifiability,variab,variable,44,"// Check if any operand is or uses a global variable in GVMap, and thus; // converted to another value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXGenericToNVVM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp:40,Performance,optimiz,optimization,40,"//===-- NVPTXImageOptimizer.cpp - Image optimization pass -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR-level optimizations of image access code,; // including:; //; // 1. Eliminate istypep intrinsics when image access qualifier is known; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp:413,Performance,optimiz,optimizations,413,"//===-- NVPTXImageOptimizer.cpp - Image optimization pass -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR-level optimizations of image access code,; // including:; //; // 1. Eliminate istypep intrinsics when image access qualifier is known; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp:436,Security,access,access,436,"//===-- NVPTXImageOptimizer.cpp - Image optimization pass -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR-level optimizations of image access code,; // including:; //; // 1. Eliminate istypep intrinsics when image access qualifier is known; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp:515,Security,access,access,515,"//===-- NVPTXImageOptimizer.cpp - Image optimization pass -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR-level optimizations of image access code,; // including:; //; // 1. Eliminate istypep intrinsics when image access qualifier is known; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h:117,Integrability,interface,interface,117,"/* The following virtual functions are used in register allocation.; * They are not implemented because the existing interface and the logic; * at the caller side do not work for the elementized vector load and store.; *; * virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual unsigned isStoreToStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual void storeRegToStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned SrcReg, bool isKill, int FrameIndex,; * const TargetRegisterClass *RC,; * Register VReg) const;; * virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned DestReg, int FrameIndex,; * const TargetRegisterClass *RC,; * const TargetRegisterInfo *TRI,; * Register VReg) const;; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h:202,Performance,load,load,202,"/* The following virtual functions are used in register allocation.; * They are not implemented because the existing interface and the logic; * at the caller side do not work for the elementized vector load and store.; *; * virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual unsigned isStoreToStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual void storeRegToStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned SrcReg, bool isKill, int FrameIndex,; * const TargetRegisterClass *RC,; * Register VReg) const;; * virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned DestReg, int FrameIndex,; * const TargetRegisterClass *RC,; * const TargetRegisterInfo *TRI,; * Register VReg) const;; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h:623,Performance,load,loadRegFromStackSlot,623,"/* The following virtual functions are used in register allocation.; * They are not implemented because the existing interface and the logic; * at the caller side do not work for the elementized vector load and store.; *; * virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual unsigned isStoreToStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual void storeRegToStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned SrcReg, bool isKill, int FrameIndex,; * const TargetRegisterClass *RC,; * Register VReg) const;; * virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned DestReg, int FrameIndex,; * const TargetRegisterClass *RC,; * const TargetRegisterInfo *TRI,; * Register VReg) const;; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h:135,Testability,log,logic,135,"/* The following virtual functions are used in register allocation.; * They are not implemented because the existing interface and the logic; * at the caller side do not work for the elementized vector load and store.; *; * virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual unsigned isStoreToStackSlot(const MachineInstr *MI,; * int &FrameIndex) const;; * virtual void storeRegToStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned SrcReg, bool isKill, int FrameIndex,; * const TargetRegisterClass *RC,; * Register VReg) const;; * virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,; * MachineBasicBlock::iterator MBBI,; * unsigned DestReg, int FrameIndex,; * const TargetRegisterClass *RC,; * const TargetRegisterInfo *TRI,; * Register VReg) const;; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:114,Energy Efficiency,schedul,scheduling,114,"/// createNVPTXISelDag - This pass converts a legalized DAG into a; /// NVPTX-specific DAG, ready for instruction scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:88,Performance,load,load,88,"// There's no way to specify FP16 and BF16 immediates in .(b)f16 ops, so we; // have to load them into an .(b)f16 register first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:53,Security,access,access,53,// There's no point scattering f16x2 if we only ever access one; // element of it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:450,Energy Efficiency,power,powerful,450,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:308,Modifiability,variab,variables,308,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:48,Performance,load,loads,48,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:139,Performance,load,loads,139,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:146,Performance,Load,Loads,146,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:275,Performance,load,loads,275,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:435,Performance,Perform,Perform,435,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:650,Performance,load,loads,650,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:218,Modifiability,variab,variables,218,// We use getUnderlyingObjects() here instead of getUnderlyingObject() mainly; // because the former looks through phi nodes while the latter does not. We; // need to look through phi nodes to handle pointer induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:31,Energy Efficiency,reduce,reduce,31,// Helper function template to reduce amount of boilerplate code for; // opcode selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:28,Performance,load,loads,28,// In order to lower atomic loads with stronger guarantees we would need to; // use load.acquire or insert fences. However these features were only added; // with PTX ISA 6.0 / sm_70.; // TODO: Check if we can actually use the new instructions and implement them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:84,Performance,load,load,84,// In order to lower atomic loads with stronger guarantees we would need to; // use load.acquire or insert fences. However these features were only added; // with PTX ISA 6.0 / sm_70.; // TODO: Check if we can actually use the new instructions and implement them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:44,Availability,avail,available,44,// Volatile Setting; // - .volatile is only available for .global and .shared; // - .volatile has the same memory synchronization semantics as .relaxed.sys,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:114,Integrability,synchroniz,synchronization,114,// Volatile Setting; // - .volatile is only available for .global and .shared; // - .volatile has the same memory synchronization semantics as .relaxed.sys,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:25,Performance,load,loaded,25,// v2f16/v2bf16/v2i16 is loaded using ld.b32,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:44,Availability,avail,availalble,44,// Volatile Setting; // - .volatile is only availalble for .global and .shared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:39,Performance,Load,LoadSDNode,39,// The last operand holds the original LoadSDNode::getExtensionType() value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:126,Performance,load,load,126,"// v8x16 is a special case. PTX doesn't have ld.v8.16; // instruction. Instead, we split the vector into v2x16 chunks and; // load them with ld.v4.b32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:30,Performance,load,loaded,30,// vectors of 16bits type are loaded/stored as multiples of v2x16 elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:46,Performance,load,load,46,"// Build the ""promoted"" result VTList for the load. If we are really loading; // i8s, then the return type will be promoted to i16 since we do not expose; // 8-bit registers in NVPTX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:69,Performance,load,loading,69,"// Build the ""promoted"" result VTList for the load. If we are really loading; // i8s, then the return type will be promoted to i16 since we do not expose; // 8-bit registers in NVPTX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:147,Security,expose,expose,147,"// Build the ""promoted"" result VTList for the load. If we are really loading; // i8s, then the return type will be promoted to i16 since we do not expose; // 8-bit registers in NVPTX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:104,Modifiability,extend,extending,104,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:114,Performance,load,load,114,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:142,Performance,load,load,142,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:266,Performance,load,load,266,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:566,Safety,redund,redundancies,566,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:240,Testability,log,logic,240,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:14,Modifiability,extend,extending-load,14,"// We have an extending-load. The instruction we selected operates on the; // smaller type, but the SDNode we are replacing has the larger type. We; // need to emit a CVT to make the types match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:24,Performance,load,load,24,"// We have an extending-load. The instruction we selected operates on the; // smaller type, but the SDNode we are replacing has the larger type. We; // need to emit a CVT to make the types match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:98,Performance,load,load,98,"// For each output value, apply the manual sign/zero-extension and make sure; // all users of the load go through that CVT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:90,Deployability,release,release,90,// In order to lower atomic loads with stronger guarantees we would need to; // use store.release or insert fences. However these features were only added; // with PTX ISA 6.0 / sm_70.; // TODO: Check if we can actually use the new instructions and implement them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:28,Performance,load,loads,28,// In order to lower atomic loads with stronger guarantees we would need to; // use store.release or insert fences. However these features were only added; // with PTX ISA 6.0 / sm_70.; // TODO: Check if we can actually use the new instructions and implement them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:44,Availability,avail,available,44,// Volatile Setting; // - .volatile is only available for .global and .shared; // - .volatile has the same memory synchronization semantics as .relaxed.sys,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:114,Integrability,synchroniz,synchronization,114,// Volatile Setting; // - .volatile is only available for .global and .shared; // - .volatile has the same memory synchronization semantics as .relaxed.sys,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:44,Availability,avail,availalble,44,// Volatile Setting; // - .volatile is only availalble for .global and .shared,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:35,Modifiability,extend,extend,35,"// Special case: if we have a sign-extend/zero-extend node, insert the; // conversion instruction first, and use that as the value operand to; // the selected StoreParam node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:47,Modifiability,extend,extend,47,"// Special case: if we have a sign-extend/zero-extend node, insert the; // conversion instruction first, and use that as the value operand to; // the selected StoreParam node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:69,Energy Efficiency,efficient,efficient,69,/// SelectBFE - Look for instruction sequences that can be made more efficient; /// by using the 'bfe' (bit-field extract) PTX instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:53,Availability,mask,mask,53,"// Canonicalize the operands; // We want 'and %val, %mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:22,Availability,mask,mask,22,// We need a constant mask on the RHS of the AND,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:15,Availability,mask,mask,15,// Extract the mask bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:29,Availability,mask,masks,29,"// We *could* handle shifted masks here, but doing so would require an; // 'and' operation to fix up the low-order bits so we would trade; // shr+and for bfe+and, which has the same throughput",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:182,Performance,throughput,throughput,182,"// We *could* handle shifted masks here, but doing so would require an; // 'and' operation to fix up the low-order bits so we would trade; // shr+and for bfe+and, which has the same throughput",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:28,Availability,mask,mask,28,// How many bits are in our mask?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:165,Testability,log,logic,165,"// Do not handle the case where the shift amount (can be zero if no srl; // was found) is not constant. We could handle this case, but it would; // require run-time logic that would be more expensive than just; // emitting the srl/and pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:183,Performance,throughput,throughput,183,"// Do not handle the case where the LHS of the and is not a shift. While; // it would be trivial to handle this case, it would just transform; // 'and' -> 'bfe', but 'and' has higher-throughput.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:36,Availability,mask,mask,36,// Canonicalize the AND to have the mask on the RHS,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:3,Availability,Mask,Mask,3,// Mask must be constant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:121,Availability,mask,mask,121,// The number of bits in the result bitfield will be the number of; // trailing zeros plus the number of set bits in the mask minus the; // number of bits we shift off,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:17,Availability,mask,mask,17,// This is not a mask we can handle,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:42,Testability,log,logic,42,// Handling this case would require extra logic that would make this; // transformation non-profitable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:128,Energy Efficiency,efficient,efficiently,128,"// Here, we have a pattern like:; //; // (sra (shl val, NN), MM); // or; // (srl (shl val, NN), MM); //; // If MM >= NN, we can efficiently optimize this with bfe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:140,Performance,optimiz,optimize,140,"// Here, we have a pattern like:; //; // (sra (shl val, NN), MM); // or; // (srl (shl val, NN), MM); //; // If MM >= NN, we can efficiently optimize this with bfe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:6,Safety,avoid,avoid,6,"// To avoid extra codegen and be profitable, we need Outer >= Inner",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:405,Integrability,interface,interfaces,405,"//===-- NVPTXISelLowering.cpp - NVPTX DAG Lowering Implementation ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that NVPTX uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:30,Performance,load,loads,30,"// Check whether we can merge loads/stores of some of the pieces of a; // flattened function parameter or return value into a single vector; // load/store.; //; // The flattened parameter is represented as a list of EVTs and; // offsets, and the whole structure is aligned to ParamAlignment. This; // function determines whether we can load/store pieces of the; // parameter starting at index Idx using a single vectorized op of; // size AccessSize. If so, it returns the number of param pieces; // covered by the vector op. Otherwise, it returns 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:144,Performance,load,load,144,"// Check whether we can merge loads/stores of some of the pieces of a; // flattened function parameter or return value into a single vector; // load/store.; //; // The flattened parameter is represented as a list of EVTs and; // offsets, and the whole structure is aligned to ParamAlignment. This; // function determines whether we can load/store pieces of the; // parameter starting at index Idx using a single vectorized op of; // size AccessSize. If so, it returns the number of param pieces; // covered by the vector op. Otherwise, it returns 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:336,Performance,load,load,336,"// Check whether we can merge loads/stores of some of the pieces of a; // flattened function parameter or return value into a single vector; // load/store.; //; // The flattened parameter is represented as a list of EVTs and; // offsets, and the whole structure is aligned to ParamAlignment. This; // function determines whether we can load/store pieces of the; // parameter starting at index Idx using a single vectorized op of; // size AccessSize. If so, it returns the number of param pieces; // covered by the vector op. Otherwise, it returns 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:438,Security,Access,AccessSize,438,"// Check whether we can merge loads/stores of some of the pieces of a; // flattened function parameter or return value into a single vector; // load/store.; //; // The flattened parameter is represented as a list of EVTs and; // offsets, and the whole structure is aligned to ParamAlignment. This; // function determines whether we can load/store pieces of the; // parameter starting at index Idx using a single vectorized op of; // size AccessSize. If so, it returns the number of param pieces; // covered by the vector op. Otherwise, it returns 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:22,Security,Access,AccessBytes,22,// Can't vectorize if AccessBytes if not a multiple of EltSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:57,Performance,load,loads,57,// Flags for tracking per-element vectorization state of loads/stores; // of a flattened function parameter or return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:49,Performance,load,loads,49,"// Computes whether and how we can vectorize the loads/stores of a; // flattened function parameter or return value.; //; // The flattened parameter is represented as the list of ValueVTs and; // Offsets, and is aligned to ParamAlignment bytes. We return a vector; // of the same size as ValueVTs indicating how each piece should be; // loaded/stored (i.e. as a scalar, or as part of a vector; // load/store).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:337,Performance,load,loaded,337,"// Computes whether and how we can vectorize the loads/stores of a; // flattened function parameter or return value.; //; // The flattened parameter is represented as the list of ValueVTs and; // Offsets, and is aligned to ParamAlignment bytes. We return a vector; // of the same size as ValueVTs indicating how each piece should be; // loaded/stored (i.e. as a scalar, or as part of a vector; // load/store).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:397,Performance,load,load,397,"// Computes whether and how we can vectorize the loads/stores of a; // flattened function parameter or return value.; //; // The flattened parameter is represented as the list of ValueVTs and; // Offsets, and is aligned to ParamAlignment bytes. We return a vector; // of the same size as ValueVTs indicating how each piece should be; // loaded/stored (i.e. as a scalar, or as part of a vector; // load/store).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:51,Security,access,accesses,51,// Check what we can vectorize using 128/64/32-bit accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:90,Security,Access,AccessSize,90,// Break out of the inner loop because we've already succeeded; // using largest possible AccessSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:58,Performance,load,load,58,"// always lower memset, memcpy, and memmove intrinsics to load/store; // instructions, rather; // then generating calls to memset, mempcy or memmove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:40,Energy Efficiency,reduce,reduce,40,// Wide divides are _very_ slow. Try to reduce the width of the divide if; // possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:30,Energy Efficiency,schedul,scheduling,30,"// By default, use the Source scheduling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Availability,avail,available,24,// Few instructions are available on sm_90 only,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:20,Availability,avail,available,20,// instructions are available on sm_90 only,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:8,Testability,log,logical,8,"// Only logical ops can be done on v4i8 directly, others must be done; // elementwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Performance,load,load,24,// Turn FP extload into load/fpextend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Performance,load,load,24,// PTX does not support load / store predicate registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:81,Availability,error,error,81,// Lowering of DYNAMIC_STACKALLOC is unsupported.; // Custom lower to produce an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:39,Performance,load,loads,39,// Register custom handling for vector loads/stores,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Testability,log,logic,24,// Other arithmetic and logic ops are unsupported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:50,Availability,avail,available,50,"// Promote fp16 arithmetic if fp16 hardware isn't available or the; // user passed --nvptx-no-fp16-math. The flag is useful because,; // although sm_53+ GPUs have some sort of FP16 support in; // hardware, only sm_53 and sm_60 have full implementation. Others; // only have token amount of hardware and are likely to run faster; // by using fp32 units instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:3,Deployability,update,update,3,// update the index for Outs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:35,Availability,avail,available,35,"// If alignment information is not available, fall back to the; // default function param optimized type alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:90,Performance,optimiz,optimized,90,"// If alignment information is not available, fall back to the; // default function param optimized type alignment",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:390,Deployability,patch,patched,390,"// Variadic arguments.; //; // Normally, for each argument, we declare a param scalar or a param; // byte array in the .param space, and store the argument value to that; // param scalar or array starting at offset 0.; //; // In the case of the first variadic argument, we declare a vararg byte array; // with size 0. The exact size of this array isn't known at this point, so; // it'll be patched later. All the variadic arguments will be stored to this; // array at a certain offset (which gets tracked by 'VAOffset'). The offset is; // initially set to 0, so it can be used for non-variadic arguments (which use; // 0 offset) to simplify the code.; //; // After all vararg is processed, 'VAOffset' holds the size of the; // vararg byte array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:632,Usability,simpl,simplify,632,"// Variadic arguments.; //; // Normally, for each argument, we declare a param scalar or a param; // byte array in the .param space, and store the argument value to that; // param scalar or array starting at offset 0.; //; // In the case of the first variadic argument, we declare a vararg byte array; // with size 0. The exact size of this array isn't known at this point, so; // it'll be patched later. All the variadic arguments will be stored to this; // array at a certain offset (which gets tracked by 'VAOffset'). The offset is; // initially set to 0, so it can be used for non-variadic arguments (which use; // 0 offset) to simplify the code.; //; // After all vararg is processed, 'VAOffset' holds the size of the; // vararg byte array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:79,Performance,load,loaded,79,"// PTX ABI requires integral types to be at least 32 bits in; // size. FP16 is loaded/stored using i16, so it's handled; // here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:7,Integrability,Interoperab,Interoperability,7,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:116,Integrability,depend,depending,116,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:89,Modifiability,extend,extended,89,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:106,Modifiability,extend,extended,106,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Usability,Guid,Guide,24,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:40,Modifiability,extend,extended,40,// Adjust type of the store op if we've extended the scalar; // return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:12,Performance,load,loads,12,// Generate loads from param memory/moves from registers for result,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:53,Integrability,Interoperab,Interoperability,53,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:162,Integrability,depend,depending,162,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:135,Modifiability,extend,extended,135,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:152,Modifiability,extend,extended,152,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:70,Usability,Guid,Guide,70,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:85,Performance,optimiz,optimization,85,"// set isTailCall to false for now, until we figure out how to express; // tail call optimization in PTX",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:116,Performance,load,loads,116,"// We can init constant f16x2/v2i16/v4i8 with a single .b32 move. Normally it; // would get lowered as two constant loads and vector-packing move.; // Instead we want just a constant move:; // mov.b32 %r2, 0x40003C00",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:84,Performance,optimiz,optimize,84,"// Lower non-const v4i8 vector as byte-wise constructed i32, which allows us; // to optimize calculation of constant parts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:167,Testability,log,logic,167,"// {dHi, dLo} = {aHi, aLo} >> Amt; // - if (Amt>=size) then; // dLo = aHi >> (Amt-size); // dHi = aHi >> Amt (this is either all 0 or all 1); // else; // dLo = (aLo >>logic Amt) | (aHi << (size-Amt)); // dHi = aHi >> Amt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:110,Performance,load,loads,110,// This function is almost a copy of SelectionDAG::expandVAArg().; // The only diff is that this one produces loads from local address space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:3,Performance,Load,Load,3,// Load the actual argument out of the pointer VAList,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:92,Performance,load,loads,92,"// v2f16/v2bf16/v2i16/v4i8 are legal, so we can't rely on legalizer to handle; // unaligned loads and have to handle it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:77,Performance,load,load,77,"// The legalizer (the caller) is expecting two values from the legalized; // load, so we build a MergeValues node for it. See ExpandUnalignedLoad(); // in LegalizeDAG.cpp which also uses MergeValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:227,Modifiability,variab,variable,227,// This creates target external symbol for a function parameter.; // Name of the symbol is composed from its index and the function name.; // Negative index corresponds to special parameter (unsized array) used for; // passing variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:9,Performance,load,loaded,9,// i1 is loaded/stored as i8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:115,Performance,load,load,115,"// getLoad needs a vector type, but it can't handle; // vectors which contain v2f16 or v2bf16 elements. So we must load; // using i32 here and then bitcast back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:9,Performance,load,loaded,9,// We've loaded i1 as an i8 and now must truncate it back to i1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:13,Performance,load,loaded,13,// v2f16 was loaded as an i32. Now we must bitcast it back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:48,Availability,down,down,48,"// If a promoted integer type is used, truncate down to the original",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend the element if necessary (e.g. an i8 is loaded; // into an i16 register),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:50,Performance,load,loaded,50,// Extend the element if necessary (e.g. an i8 is loaded; // into an i16 register),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:272,Integrability,depend,dependent,272,"// Param has ByVal attribute; // Return MoveParam(param symbol).; // Ideally, the param symbol can be returned directly,; // but when SDNode builder decides to use it in a CopyToReg(),; // machine instruction fails because TargetExternalSymbol; // (not lowered) is target dependent, and CopyToReg assumes; // the source is lowered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:7,Integrability,Interoperab,Interoperability,7,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:116,Integrability,depend,depending,116,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:89,Modifiability,extend,extended,89,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:106,Modifiability,extend,extended,106,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Usability,Guid,Guide,24,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:7,Performance,load,load,7,// New load/store. Record chain and offset operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:34,Performance,load,load-stores,34,// Use 16-bit registers for small load-stores as it's the; // smallest general purpose register size supported by NVPTX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:41,Modifiability,extend,extended,41,// Adjust type of load/store op if we've extended the scalar; // return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:18,Performance,load,load,18,// Adjust type of load/store op if we've extended the scalar; // return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:143,Availability,avail,available,143,"// llvm.ptx.memcpy.const and llvm.ptx.memmove.const need to be modeled as; // TgtMemIntrinsic; // because we need the information that is only available in the ""Value"" type; // of destination; // pointer. In particular, the address space information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:135,Performance,perform,perform,135,"// memVT is bogus. These intrinsics have IntrInaccessibleMemOnly attribute; // in order to model data exchange with other threads, but perform no real; // memory accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:162,Security,access,accesses,162,"// memVT is bogus. These intrinsics have IntrInaccessibleMemOnly attribute; // in order to model data exchange with other threads, but perform no real; // memory accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:14,Integrability,depend,depends,14,// Our result depends on both our and other thread's arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:203,Performance,load,loads,203,"/// getFunctionParamOptimizedAlign - since function arguments are passed via; /// .param space, we may want to increase their alignment in a way that; /// ensures that we can effectively vectorize their loads & stores. We can; /// increase alignment only if the function has internal or has private; /// linkage as for other linkage types callers may already rely on default; /// alignment. To allow using 128-bit vectorized loads/stores, this function; /// ensures that alignment is 16 or greater.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:425,Performance,load,loads,425,"/// getFunctionParamOptimizedAlign - since function arguments are passed via; /// .param space, we may want to increase their alignment in a way that; /// ensures that we can effectively vectorize their loads & stores. We can; /// increase alignment only if the function has internal or has private; /// linkage as for other linkage types callers may already rely on default; /// alignment. To allow using 128-bit vectorized loads/stores, this function; /// ensures that alignment is 16 or greater.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:32,Modifiability,enhance,enhance,32,// Try to increase alignment to enhance vectorization options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:231,Security,access,access,231,"// Old ptx versions have a bug. When PTX code takes address of; // byval parameter with alignment < 4, ptxas generates code to; // spill argument into memory. Alas on sm_50+ ptxas generates; // SASS code that fails with misaligned access. To work around; // the problem, make sure that we align byval parameters by at; // least 4. This bug seems to be fixed at least starting from; // ptxas > 9.0.; // TODO: remove this after verifying the bug is not reproduced; // on non-deprecated ptxas versions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:193,Modifiability,variab,variable,193,// Helper for getting a function parameter name. Name is composed from; // its index and the function name. Negative index corresponds to special; // parameter (unsized array) used for passing variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// Used to guide target specific optimizations, like loop strength reduction; /// (LoopStrengthReduce.cpp) and memory optimization for address mode; /// (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:187,Performance,optimiz,optimizations,187,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// Used to guide target specific optimizations, like loop strength reduction; /// (LoopStrengthReduce.cpp) and memory optimization for address mode; /// (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:272,Performance,optimiz,optimization,272,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// Used to guide target specific optimizations, like loop strength reduction; /// (LoopStrengthReduce.cpp) and memory optimization for address mode; /// (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:165,Usability,guid,guide,165,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// Used to guide target specific optimizations, like loop strength reduction; /// (LoopStrengthReduce.cpp) and memory optimization for address mode; /// (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:10,Integrability,contract,contract,10,// Do not contract if we're not optimizing the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:32,Performance,optimiz,optimizing,32,// Do not contract if we're not optimizing the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:49,Safety,unsafe,unsafe,49,// Honor TargetOptions flags that explicitly say unsafe math is okay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:9,Safety,unsafe,unsafe,9,// Allow unsafe math if unsafe-fp-math attribute explicitly says so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Safety,unsafe,unsafe-fp-math,24,// Allow unsafe math if unsafe-fp-math attribute explicitly says so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Performance,Perform,PerformADDCombineWithOperands,4,"/// PerformADDCombineWithOperands - Try DAG combinations for an ADD with; /// operands N0 and N1. This is a helper for PerformADDCombine that is; /// called with the default operands, and if that fails, with commuted; /// operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:119,Performance,Perform,PerformADDCombine,119,"/// PerformADDCombineWithOperands - Try DAG combinations for an ADD with; /// operands N0 and N1. This is a helper for PerformADDCombine that is; /// called with the default operands, and if that fails, with commuted; /// operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:79,Testability,log,logics,79,"// simple heuristics here for considering potential register; // pressure, the logics here is that the differnce are used; // to measure the distance between def and use, the longer distance; // more likely cause register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:3,Usability,simpl,simple,3,"// simple heuristics here for considering potential register; // pressure, the logics here is that the differnce are used; // to measure the distance between def and use, the longer distance; // more likely cause register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Performance,Perform,PerformADDCombine,4,/// PerformADDCombine - Target-specific dag combine xforms for ISD::ADD.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:37,Performance,load,load,37,"// The type legalizer turns a vector load of i8 values into a zextload to i16; // registers, optionally ANY_EXTENDs it (if target type is integer),; // and ANDs off the high 8 bits. Since we turn this load into a; // target-specific DAG node, the DAG combiner fails to eliminate these AND; // nodes. Do that here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:201,Performance,load,load,201,"// The type legalizer turns a vector load of i8 values into a zextload to i16; // registers, optionally ANY_EXTENDs it (if target type is integer),; // and ANDs off the high 8 bits. Since we turn this load into a; // target-specific DAG node, the DAG combiner fails to eliminate these AND; // nodes. Do that here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:26,Performance,load,load,26,"// If for some reason the load is a sextload, the and is needed to zero; // out the high 8 bits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:68,Performance,load,load,68,"// If we get here, the AND is unnecessary. Just replace it with the load",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Performance,Perform,PerformMULCombine,4,/// PerformMULCombine - Runs PTX-specific DAG combine patterns on MUL nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Performance,Perform,PerformSHLCombine,4,/// PerformSHLCombine - Runs PTX-specific DAG combine patterns on SHL nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:17,Performance,load,loads,17,"// Native vector loads already combine nicely w/; // extract_vector_elt, except for v4i8.; // Don't mess with singletons or v2*16 types, we already handle them OK.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:216,Safety,avoid,avoid,216,"// We need to split vselect into individual per-element operations Because we; // use BFE/BFI instruction for byte extraction/insertion, we do end up with; // 32-bit values, so we may as well do comparison as i32 to avoid conversions; // to/from i16 normally used for i8 values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:17,Performance,load,load,17,"// Lower a v16i8 load into a LoadV4 operation with i32 results instead of; // letting ReplaceLoadVector split it into smaller loads during legalization.; // This is done at dag-combine1 time, so that vector operations with i8; // elements can be optimised away instead of being needlessly split during; // legalization, which involves storing to the stack and loading it back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:126,Performance,load,loads,126,"// Lower a v16i8 load into a LoadV4 operation with i32 results instead of; // letting ReplaceLoadVector split it into smaller loads during legalization.; // This is done at dag-combine1 time, so that vector operations with i8; // elements can be optimised away instead of being needlessly split during; // legalization, which involves storing to the stack and loading it back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:360,Performance,load,loading,360,"// Lower a v16i8 load into a LoadV4 operation with i32 results instead of; // letting ReplaceLoadVector split it into smaller loads during legalization.; // This is done at dag-combine1 time, so that vector operations with i8; // elements can be optimised away instead of being needlessly split during; // legalization, which involves storing to the stack and loading it back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:25,Performance,load,load,25,"// Create a v4i32 vector load operation, effectively <4 x v4i8>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:61,Performance,load,load,61,// Create a vector of the same type returned by the original load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:39,Performance,load,loads,39,/// ReplaceVectorLoad - Convert vector loads into multi-output scalar loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:70,Performance,load,loads,70,/// ReplaceVectorLoad - Convert vector loads into multi-output scalar loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:123,Performance,load,loads,123,"// We only handle ""native"" vector sizes for now, e.g. <4 x double> is not; // legal. We can (and should) split that into 2 loads of <2 x double> here; // but I'm leaving that as a TODO for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:8,Performance,load,load,8,"// This load is not sufficiently aligned, so bail out and let this vector; // load be scalarized. Note that we may still be able to emit smaller; // vector loads. For example, if we are loading a <4 x float> with an; // alignment of 8, this check will fail but the legalizer will try again; // with 2 x <2 x float>, which will succeed with an alignment of 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:78,Performance,load,load,78,"// This load is not sufficiently aligned, so bail out and let this vector; // load be scalarized. Note that we may still be able to emit smaller; // vector loads. For example, if we are loading a <4 x float> with an; // alignment of 8, this check will fail but the legalizer will try again; // with 2 x <2 x float>, which will succeed with an alignment of 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:156,Performance,load,loads,156,"// This load is not sufficiently aligned, so bail out and let this vector; // load be scalarized. Note that we may still be able to emit smaller; // vector loads. For example, if we are loading a <4 x float> with an; // alignment of 8, this check will fail but the legalizer will try again; // with 2 x <2 x float>, which will succeed with an alignment of 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:186,Performance,load,loading,186,"// This load is not sufficiently aligned, so bail out and let this vector; // load be scalarized. Note that we may still be able to emit smaller; // vector loads. For example, if we are loading a <4 x float> with an; // alignment of 8, this check will fail but the legalizer will try again; // with 2 x <2 x float>, which will succeed with an alignment of 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:154,Performance,load,loaded,154,"// Since LoadV2 is a target node, we cannot rely on DAG type legalization.; // Therefore, we must ensure the type is legal. For i1 and i8, we set the; // loaded type to i16 and propagate the ""real"" type as the memory type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:127,Performance,load,load,127,"// v8f16 is a special case. PTX doesn't have ld.v8.f16; // instruction. Instead, we split the vector into v2f16 chunks and; // load them with ld.v4.b32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:14,Integrability,rout,routine,14,"// The select routine does not have access to the LoadSDNode instance, so; // pass along the extension information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:50,Performance,Load,LoadSDNode,50,"// The select routine does not have access to the LoadSDNode instance, so; // pass along the extension information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:36,Security,access,access,36,"// The select routine does not have access to the LoadSDNode instance, so; // pass along the extension information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:159,Performance,load,loaded,159,"// Since LDU/LDG are target nodes, we cannot rely on DAG type; // legalization.; // Therefore, we must ensure the type is legal. For i1 and i8, we set the; // loaded type to i16 and propagate the ""real"" type as the memory type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:49,Integrability,Interface,Interface,49,"//===-- NVPTXISelLowering.h - NVPTX DAG Lowering Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that NVPTX uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:405,Integrability,interface,interfaces,405,"//===-- NVPTXISelLowering.h - NVPTX DAG Lowering Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interfaces that NVPTX uses to lower LLVM code into a; // selection DAG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:203,Performance,load,loads,203,"/// getFunctionParamOptimizedAlign - since function arguments are passed via; /// .param space, we may want to increase their alignment in a way that; /// ensures that we can effectively vectorize their loads & stores. We can; /// increase alignment only if the function has internal or has private; /// linkage as for other linkage types callers may already rely on default; /// alignment. To allow using 128-bit vectorized loads/stores, this function; /// ensures that alignment is 16 or greater.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:425,Performance,load,loads,425,"/// getFunctionParamOptimizedAlign - since function arguments are passed via; /// .param space, we may want to increase their alignment in a way that; /// ensures that we can effectively vectorize their loads & stores. We can; /// increase alignment only if the function has internal or has private; /// linkage as for other linkage types callers may already rely on default; /// alignment. To allow using 128-bit vectorized loads/stores, this function; /// ensures that alignment is 16 or greater.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:193,Modifiability,variab,variable,193,// Helper for getting a function parameter name. Name is composed from; // its index and the function name. Negative index corresponds to special; // parameter (unsized array) used for passing variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:118,Performance,load,load,118,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type; /// Used to guide target specific optimizations, like loop strength; /// reduction (LoopStrengthReduce.cpp) and memory optimization for; /// address mode (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:186,Performance,optimiz,optimizations,186,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type; /// Used to guide target specific optimizations, like loop strength; /// reduction (LoopStrengthReduce.cpp) and memory optimization for; /// address mode (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:271,Performance,optimiz,optimization,271,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type; /// Used to guide target specific optimizations, like loop strength; /// reduction (LoopStrengthReduce.cpp) and memory optimization for; /// address mode (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:164,Usability,guid,guide,164,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type; /// Used to guide target specific optimizations, like loop strength; /// reduction (LoopStrengthReduce.cpp) and memory optimization for; /// address mode (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:238,Availability,avail,available,238,"// Get the degree of precision we want from 32-bit floating point division; // operations.; //; // 0 - Use ptx div.approx; // 1 - Use ptx.div.full (approximate, but less so than div.approx); // 2 - Use IEEE-compliant div instructions, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:166,Safety,avoid,avoids,166,"// The default is to transform llvm.ctlz(x, false) (where false indicates that; // x == 0 is not undefined behavior) into a branch that checks whether x is 0; // and avoids calling ctlz in that case. We have a dedicated ctlz; // instruction, so we say that ctlz is cheap to speculate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:3,Performance,cache,cache,3,// cache the subtarget here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp:25,Performance,load,loads,25,// Collect all aggregate loads and mem* calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp:32,Modifiability,variab,variable,32,// Convert intrinsic calls with variable size or with constant size; // larger than the MaxAggrCopySize threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp:40,Performance,load,load,40,//; // Do the transformation of an aggr load/copy/set to a loop; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:258,Availability,redundant,redundant,258,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:9,Performance,Load,Load,9,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:258,Safety,redund,redundant,258,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:119,Security,expose,expose,119,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1416,Performance,optimiz,optimizations,1416,"ctions are passed via param space,; // which imposes certain restrictions:; // http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global addre",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1573,Performance,load,load,1573,"te-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1820,Performance,load,load,1820,"o generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i3",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1914,Performance,optimiz,optimize,1914,"m.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: mer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:2045,Performance,load,load,2045,"m.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: mer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:2588,Performance,load,load,2588,"nity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't; // cancel the addrspacecast pair this pass emits.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:2787,Performance,load,load,2787,"nity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't; // cancel the addrspacecast pair this pass emits.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:612,Security,access,accessible,612,"//===-- NVPTXLowerArgs.cpp - Lower arguments ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Arguments to kernel and device functions are passed via param space,; // which imposes certain restrictions:; // http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast fl",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:811,Security,access,accessible,811,"//===-- NVPTXLowerArgs.cpp - Lower arguments ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Arguments to kernel and device functions are passed via param space,; // which imposes certain restrictions:; // http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast fl",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1470,Security,access,accessing,1470,"strictions:; // http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:212,Performance,load,loads,212,"// Knowing Ptr must point to the global address space, this function; // addrspacecasts Ptr to global and then back to generic. This allows; // NVPTXInferAddressSpaces to fold the global-to-generic cast into; // loads/stores that appear later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:520,Energy Efficiency,allocate,allocates,520,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:213,Performance,load,loads,213,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:408,Performance,load,load,408,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:722,Performance,Load,Loads,722,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:982,Performance,Load,Load,982,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:200,Security,access,accesses,200,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:792,Security,access,access,792,"// =============================================================================; // If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),; // and we can't guarantee that the only accesses are loads,; // then add the following instructions to the first basic block:; //; // %temp = alloca %struct.x, align 8; // %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*; // %tv = load %struct.x addrspace(101)* %tempd; // store %struct.x %tv, %struct.x* %temp, align 8; //; // The above code allocates some space in the stack and copies the incoming; // struct from param space to local space.; // Then replace all occurrences of %d by %temp.; //; // In case we know that all users are GEPs or Loads, replace them with the same; // ones in parameter AS, so we can access them using ld.param.; // =============================================================================; // Replaces the \p OldUser instruction with the same in parameter AS.; // Only Load and GEP are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:36,Performance,Queue,Queue,36,"// We've created a new instruction. Queue users of the old instruction to; // be converted and the instruction itself to be deleted. We can't delete; // the old instruction yet, because it's still in use by a load somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:209,Performance,load,load,209,"// We've created a new instruction. Queue users of the old instruction to; // be converted and the instruction itself to be deleted. We can't delete; // the old instruction yet, because it's still in use by a load somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:161,Energy Efficiency,schedul,scheduled,161,"// Now we know that all argument loads are using addresses in parameter space; // and we can finally remove the old instructions in generic AS. Instructions; // scheduled for removal should be processed in reverse order so the ones; // closest to the load are deleted first. Otherwise they may still be in use.; // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will; // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by; // the BitCast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:33,Performance,load,loads,33,"// Now we know that all argument loads are using addresses in parameter space; // and we can finally remove the old instructions in generic AS. Instructions; // scheduled for removal should be processed in reverse order so the ones; // closest to the load are deleted first. Otherwise they may still be in use.; // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will; // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by; // the BitCast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:251,Performance,load,load,251,"// Now we know that all argument loads are using addresses in parameter space; // and we can finally remove the old instructions in generic AS. Instructions; // scheduled for removal should be processed in reverse order so the ones; // closest to the load are deleted first. Otherwise they may still be in use.; // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will; // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by; // the BitCast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:338,Performance,Load,Load,338,"// Now we know that all argument loads are using addresses in parameter space; // and we can finally remove the old instructions in generic AS. Instructions; // scheduled for removal should be processed in reverse order so the ones; // closest to the load are deleted first. Otherwise they may still be in use.; // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will; // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by; // the BitCast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:185,Performance,load,loads,185,"// Adjust alignment of arguments passed byval in .param address space. We can; // increase alignment of such arguments in a way that ensures that we can; // effectively vectorize their loads. We should also traverse all loads from; // byval pointer and adjust their alignment, if those were using known offset.; // Such alignment changes must be conformed with parameter store and load in; // NVPTXTargetLowering::LowerCall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:220,Performance,load,loads,220,"// Adjust alignment of arguments passed byval in .param address space. We can; // increase alignment of such arguments in a way that ensures that we can; // effectively vectorize their loads. We should also traverse all loads from; // byval pointer and adjust their alignment, if those were using known offset.; // Such alignment changes must be conformed with parameter store and load in; // NVPTXTargetLowering::LowerCall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:381,Performance,load,load,381,"// Adjust alignment of arguments passed byval in .param address space. We can; // increase alignment of such arguments in a way that ensures that we can; // effectively vectorize their loads. We should also traverse all loads from; // byval pointer and adjust their alignment, if those were using known offset.; // Such alignment changes must be conformed with parameter store and load in; // NVPTXTargetLowering::LowerCall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:15,Performance,load,loads,15,// Convert all loads and intermediate operations to use parameter AS and; // skip creation of a local copy of the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:85,Performance,load,load,85,"// Set the alignment to alignment of the byval parameter. This is because,; // later load/stores assume that alignment, and we are going to replace; // the use of the byval parameter with this alloca instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:42,Performance,load,load,42,"// Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX; // addrspacecast preserves alignment. Since params are constant, this load is; // definitely not volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:148,Performance,load,load,148,"// Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX; // addrspacecast preserves alignment. Since params are constant, this load is; // definitely not volatile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:67,Performance,load,loaded,67,"// Copying of byval aggregates + SROA may result in pointers being loaded as; // integers, followed by intotoptr. We may want to mark those as global, too,; // but only if the loaded integer is used exclusively for conversion to a; // pointer with inttoptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:176,Performance,load,loaded,176,"// Copying of byval aggregates + SROA may result in pointers being loaded as; // integers, followed by intotoptr. We may want to mark those as global, too,; // but only if the loaded integer is used exclusively for conversion to a; // pointer with inttoptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:11,Performance,load,load,11,// LI is a load from a pointer within a byval kernel parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerUnreachable.cpp:178,Testability,log,logic,178,// =============================================================================; // Returns whether a `trap` intrinsic should be emitted before I.; //; // This is a copy of the logic in SelectionDAGBuilder::visitUnreachable().; // =============================================================================,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerUnreachable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerUnreachable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMachineFunctionInfo.h:458,Integrability,depend,dependent,458,"//===-- NVPTXMachineFunctionInfo.h - NVPTX-specific Function Info --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class is attached to a MachineFunction instance and tracks target-; // dependent information; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMachineFunctionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMachineFunctionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.cpp:96,Performance,load,load,96,// ptxas does not have a way to specify half-precision floats.; // Instead we have to print and load fp16 constants as .b16,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h:6,Integrability,wrap,wrapper,6,/// A wrapper for MCSymbolRefExpr that tells the assembly printer that the; /// symbol should be enclosed by generic().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h:18,Security,Access,Accessors,18,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXMCExpr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:43,Performance,Optimiz,Optimiztions,43,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:772,Performance,load,load,772,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:889,Performance,Perform,Performance,889,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:1039,Performance,optimiz,optimizes,1039,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:923,Safety,avoid,avoid,923,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:82,Usability,simpl,simply,82,// Frame indices in debug values are encoded in a target independent; // way with simply the frame index and offset rather than any; // target-specific addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:22,Availability,down,down,22,"// If the stack grows down, add the object size to find the lowest address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:108,Energy Efficiency,allocate,allocated,108,"// If there are fixed sized objects that are preallocated in the local area,; // non-fixed objects can't be allocated right at the start of local area.; // We currently don't support filling in holes in between fixed sized; // objects, so we adjust 'Offset' to point to the end of last fixed sized; // preallocated object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:118,Availability,down,down,118,"// The maximum distance from the stack pointer is at lower address of; // the object -- which is given by offset. For down growing stack; // the offset is negative, so we negate the offset to get the distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:225,Performance,optimiz,optimization,225,"// No scavenger; // FIXME: Once this is working, then enable flag will change to a target; // check for whether the frame is large enough to want to use virtual; // frame index registers. Functions which don't want/need this optimization; // will continue to use the existing code path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the local block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp:3,Deployability,Update,Update,3,// Update frame info to pretend that this is part of the stack...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPrologEpilogPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXRegisterInfo.cpp:103,Integrability,depend,depend,103,"// We use untyped (.b) integer registers here as NVCC does.; // Correctness of generated code does not depend on register type,; // but using .s/.u registers runs into ptxas bug that prevents; // assembly of otherwise valid PTX into SASS. Despite PTX ISA; // specifying only argument size for fp16 instructions, ptxas does; // not allow using .s16 or .u16 arguments for .fp16; // instructions. At the same time it allows using .s32/.u32; // arguments for .fp16v2 instructions:; //; // .reg .b16 rb16; // .reg .s16 rs16; // add.f16 rb16,rb16,rb16; // OK; // add.f16 rs16,rs16,rs16; // Arguments mismatch for instruction 'add'; // but:; // .reg .b32 rb32; // .reg .s32 rs32; // add.f16v2 rb32,rb32,rb32; // OK; // add.f16v2 rs32,rs32,rs32; // OK",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:550,Availability,reliab,reliably,550,"//===-- NVPTXReplaceImageHandles.cpp - Replace image handles for Fermi ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // On Fermi, image handles are not supported. To work around this, we traverse; // the machine code and replace image handles with concrete symbols. For this; // to work reliably, inlining of all function call must be performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:598,Performance,perform,performed,598,"//===-- NVPTXReplaceImageHandles.cpp - Replace image handles for Fermi ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // On Fermi, image handles are not supported. To work around this, we traverse; // the machine code and replace image handles with concrete symbols. For this; // to work reliably, inlining of all function call must be performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:27,Security,access,access,27,"// Now clean up any handle-access instructions; // This is needed in debug mode when code cleanup passes are not executed,; // but we need the handle access to be eliminated because they are not; // valid instructions when image handles are disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:150,Security,access,access,150,"// Now clean up any handle-access instructions; // This is needed in debug mode when code cleanup passes are not executed,; // but we need the handle access to be eliminated because they are not; // valid instructions when image handles are disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:17,Performance,load,load,17,"// For a surface load of vector size N, the Nth operand will be the surfref",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:41,Performance,load,loaded,41,"// The handle is a parameter value being loaded, replace with the; // parameter symbol",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:35,Performance,load,loads,35,"// For CUDA, we preserve the param loads coming from function arguments",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:26,Modifiability,variab,variable,26,"// The handle is a global variable, replace with the global variable name",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:60,Modifiability,variab,variable,60,"// The handle is a global variable, replace with the global variable name",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:63,Performance,optimiz,optimization,63,"// FIXME: This pass is really intended to be invoked during IR optimization,; // but it's very NVPTX-specific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:19,Performance,perform,perform,19,// Add passes that perform straight-line scalar optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:48,Performance,optimiz,optimizations,48,// Add passes that perform straight-line scalar optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:19,Security,expose,exposes,19,// ReassociateGEPs exposes more opportunites for SLSR. See; // the example in reassociate-geps-and-slsr.ll.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:177,Testability,benchmark,benchmarks,177,// SeparateConstOffsetFromGEP and SLSR creates common expressions which GVN or; // EarlyCSE can reuse. GVN generates significantly better code than EarlyCSE; // for some of our benchmarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:35,Availability,redundant,redundant,35,"// NaryReassociate on GEPs creates redundant common expressions, so run; // EarlyCSE after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:35,Safety,redund,redundant,35,"// NaryReassociate on GEPs creates redundant common expressions, so run; // EarlyCSE after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:217,Deployability,pipeline,pipeline,217,"// NVVMReflectPass is added in addEarlyAsPossiblePasses, so hopefully running; // it here does nothing. But since we need it for correctness when lowering; // to NVPTX, run it here too, in case whoever built our pass pipeline didn't; // call addEarlyAsPossiblePasses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:72,Availability,alive,alive,72,// Remove Proxy Register pseudo instructions used to keep `callseq_end` alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:21,Energy Efficiency,schedul,scheduling,21,// PreRA instruction scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:3,Performance,Optimiz,Optimize,3,// Optimize PHIs before DCE: removing dead PHI cycles may make more; // instructions dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:8,Performance,optimiz,optimization,8,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:250,Testability,test,test,250,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.h:27,Security,access,accessing,27,// Use 32-bit pointers for accessing const/local/short AS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:61,Performance,load,loaded,61,"// Without pointer analysis, we conservatively assume values loaded from; // generic or local address space are divergent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:30,Usability,simpl,simplify,30,"// Each NVVM intrinsic we can simplify can be replaced with one of:; //; // * an LLVM intrinsic,; // * an LLVM cast operation,; // * an LLVM binary operation, or; // * ad-hoc LLVM IR for the particular operation.; // Some transformations are only valid when the module's; // flush-denormals-to-zero (ftz) setting is true/false, whereas other; // transformations are valid regardless of the module's ftz setting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:155,Usability,simpl,simplify,155,"// Classes of NVVM intrinsics that can't be replaced one-to-one with a; // target-generic intrinsic, cast op, or binary op but that we can nonetheless; // simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,SimplifyAction,3,// SimplifyAction is a poor-man's variant (plus an additional flag) that; // represents how to replace an NVVM intrinsic with target-generic LLVM IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:56,Integrability,depend,depending,56,"// Denormal handling is guarded by different attributes depending on the; // type (denormal-fp-math vs denormal-fp-math-f32), take note of halfs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:21,Usability,Simpl,SimplifyAction,21,// Try to generate a SimplifyAction describing how to replace our; // IntrinsicInstr with target-generic LLVM IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:23,Usability,simpl,simplify,23,"// We do not currently simplify intrinsics that give an approximate; // answer. These include:; //; // - nvvm_cos_approx_{f,ftz_f}; // - nvvm_ex2_approx_{d,f,ftz_f}; // - nvvm_lg2_approx_{d,f,ftz_f}; // - nvvm_sin_approx_{f,ftz_f}; // - nvvm_sqrt_approx_{f,ftz_f}; // - nvvm_rsqrt_approx_{d,f,ftz_f}; // - nvvm_div_approx_{ftz_d,ftz_f,f}; // - nvvm_rcp_approx_ftz_d; //; // Ideally we'd encode them as e.g. ""fast call @llvm.cos"", where ""fast""; // means that fastmath is enabled in the intrinsic. Unfortunately only; // binary operators (currently) have a fastmath bit in SelectionDAG, so; // this information gets lost and we can't select on it.; //; // TODO: div and rcp are lowered to a binary op, so these we could in; // theory lower them to ""fast fdiv"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,Simplify,3,// Simplify to target-generic intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,Simplify,3,// Simplify to target-generic binary op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,Simplify,3,// Simplify to target-generic cast op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Usability,Simpl,Simplify,3,// Simplify reciprocal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:55,Energy Efficiency,reduce,reduce,55,"// Enable partial unrolling and runtime unrolling, but reduce the; // threshold. This partially unrolls small loops which are often; // unrolled by the PTX to SASS compiler and unrolling earlier can be; // beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h:3,Performance,Load,Loads,3,// Loads and stores can be vectorized if the alignment is at least as big as; // the load/store we want to vectorize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h:85,Performance,load,load,85,// Loads and stores can be vectorized if the alignment is at least as big as; // the load/store we want to vectorize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h:202,Availability,error,errors,202,"// We don't want to prevent inlining because of target-cpu and -features; // attributes that were added to newer versions of LLVM/Clang: There are; // no incompatible functions in PTX, ptxas will throw errors in such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h:12,Performance,load,loads,12,"// Volatile loads/stores are only supported for shared and global address; // spaces, or for generic AS that maps to them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.cpp:39,Modifiability,variab,variable,39,"// start index = 1, to skip the global variable key; // increment = 2, to skip the value for each property-value pairs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.h:80,Energy Efficiency,power,power,80,// PTX ABI requires all scalar argument/return values to have; // bit-size as a power of two of at least 32 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:721,Safety,predict,predict,721,"//===- NVVMReflect.cpp - NVVM Emulate conditional compilation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces occurrences of __nvvm_reflect(""foo"") and llvm.nvvm.reflect; // with an integer.; //; // We choose the value we use by looking at metadata in the module itself. Note; // that we intentionally only have one way to choose these values, because other; // parts of LLVM (particularly, InstCombineCall) rely on being able to predict; // the values chosen by this pass.; //; // If we see an unknown string, we replace its call with 0.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:157,Security,validat,validate,157,"// Go through the calls in this function. Each call to __nvvm_reflect or; // llvm.nvvm.reflect should be a CallInst with a ConstantArray argument.; // First validate that. If the c-string corresponding to the ConstantArray can; // be found successfully, see if it can be found in VarMap. If so, replace the; // uses of CallInst with the value found in VarMap. If not, replace the use; // with value 0.; // The IR for __nvvm_reflect calls differs between CUDA versions.; //; // CUDA 6.5 and earlier uses this sequence:; // %ptr = tail call i8* @llvm.nvvm.ptr.constant.to.gen.p0i8.p4i8; // (i8 addrspace(4)* getelementptr inbounds; // ([8 x i8], [8 x i8] addrspace(4)* @str, i32 0, i32 0)); // %reflect = tail call i32 @__nvvm_reflect(i8* %ptr); //; // The value returned by Sym->getOperand(0) is a Constant with a; // ConstantDataSequential operand which can be converted to string and used; // for lookup.; //; // CUDA 7.0 does it slightly differently:; // %reflect = call i32 @__nvvm_reflect(i8* addrspacecast; // (i8 addrspace(1)* getelementptr inbounds; // ([8 x i8], [8 x i8] addrspace(1)* @str, i32 0, i32 0) to i8*)); //; // In this case, we get a Constant with a GlobalVariable operand and we need; // to dig deeper to find its initializer with the string we'll use for lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:18,Availability,error,error,18,// FIXME: Improve error handling here and elsewhere in this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:14,Testability,assert,assertions,14,// FIXME: Add assertions about ConvCall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:53,Integrability,wrap,wrapping,53,// Pre opaque pointers we have a constant expression wrapping the constant; // string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:161,Safety,detect,detect,161,"// Try to pull __CUDA_FTZ from the nvvm-reflect-ftz module flag. Our; // choice here must be kept in sync with AutoUpgrade, which uses the same; // technique to detect whether ftz is enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid using parens for identifiers starting with $ - ptxas does; // not expect them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCTargetDesc.cpp:2,Performance,Tune,TuneCPU,2,/*TuneCPU*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCTargetDesc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCTargetDesc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXTargetStreamer.cpp:102,Deployability,patch,patch,102,// FIXME: the checks for the DWARF sections are very fragile and should be; // fixed up in a followup patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXTargetStreamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXTargetStreamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:40,Energy Efficiency,Power,PowerPC,40,"//===-- PPC.h - Top-level interface for PowerPC Target ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // PowerPC back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:464,Energy Efficiency,Power,PowerPC,464,"//===-- PPC.h - Top-level interface for PowerPC Target ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // PowerPC back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:26,Integrability,interface,interface,26,"//===-- PPC.h - Top-level interface for PowerPC Target ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the entry points for global functions defined in the LLVM; // PowerPC back-end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:92,Performance,optimiz,optimization,92,/// MO_PCREL_OPT_FLAG - If this bit is set the operand is part of a; /// PC Relative linker optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:124,Modifiability,variab,variable,124,/// MO_TLSGD_FLAG - If this bit is set the symbol reference is relative to; /// TLS General Dynamic model for Linux and the variable offset of TLS; /// General Dynamic model for AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:52,Energy Efficiency,Power,PowerPC,52,"//===-- PPCAsmPrinter.cpp - Print machine instrs to PowerPC assembly ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to PowerPC assembly language. This printer is; // the output mechanism used by `llc'.; //; // Documentation at http://developer.apple.com/documentation/DeveloperTools/; // Reference/Assembler/ASMIntroduction/chapter_1_section_1.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:497,Energy Efficiency,Power,PowerPC,497,"//===-- PPCAsmPrinter.cpp - Print machine instrs to PowerPC assembly ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to PowerPC assembly language. This printer is; // the output mechanism used by `llc'.; //; // Documentation at http://developer.apple.com/documentation/DeveloperTools/; // Reference/Assembler/ASMIntroduction/chapter_1_section_1.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:474,Integrability,depend,dependent,474,"//===-- PPCAsmPrinter.cpp - Print machine instrs to PowerPC assembly ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a printer that converts from our internal representation; // of machine-dependent LLVM code to PowerPC assembly language. This printer is; // the output mechanism used by `llc'.; //; // Documentation at http://developer.apple.com/documentation/DeveloperTools/; // Reference/Assembler/ASMIntroduction/chapter_1_section_1.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:26,Energy Efficiency,Power,PowerPC,26,// GNU attribute tags for PowerPC ABI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:28,Energy Efficiency,Power,PowerPC,28,"// GNU attribute values for PowerPC float ABI, as combination of two parts",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:25,Energy Efficiency,Power,PowerPC,25,"/// PPCLinuxAsmPrinter - PowerPC assembly printer, customized for Linux",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:108,Integrability,rout,routine,108,"// At the moment, all inline asm memory operands are a single register.; // In any case, the output of this routine should always be just one; // assembler operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:17,Deployability,update,update,17,// Print 'u' for update form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:352,Availability,toler,tolerate,352,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:138,Deployability,update,update,138,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:56,Energy Efficiency,Power,PowerPC,56,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:91,Performance,load,loaded,91,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:274,Performance,load,load,274,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:302,Performance,load,load,302,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:11,Deployability,patch,patchpoint,11,"// Lower a patchpoint of the form:; // [<def>], <id>, <numBytes>, <target>, <numArgs>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:38,Performance,load,load,38,"// If we're on ELFv1, then we need to load the actual function pointer; // from the function descriptor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:3,Performance,Load,Load,3,"// Load the new TOC pointer and the function address, but not r11; // (needing this is rare, and loading it here would prevent passing it; // via a 'nest' parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:97,Performance,load,loading,97,"// Load the new TOC pointer and the function address, but not r11; // (needing this is rare, and loading it here would prevent passing it; // via a 'nest' parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:15,Modifiability,variab,variable,15,"// On AIX, the variable offset should already be in R4 and the region handle; // should already be in R3.; // For TLSGD, which currently is the only supported access model, we only; // need to generate an absolute branch to .__tls_get_addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:159,Security,access,access,159,"// On AIX, the variable offset should already be in R4 and the region handle; // should already be in R3.; // For TLSGD, which currently is the only supported access model, we only; // need to generate an absolute branch to .__tls_get_addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:42,Energy Efficiency,Power,PowerPC,42,/// EmitInstruction -- Print out a single PowerPC MI in Darwin syntax to; /// the current output stream.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:3,Security,Validat,Validate,3,// Validate that SPE and FPU are mutually exclusive in codegen,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:107,Modifiability,variab,variable,107,"// For TLS initial-exec and local-exec accesses on AIX, we have one TOC; // entry for the symbol (with the variable offset), which is differentiated; // by MO_TPREL_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:39,Security,access,accesses,39,"// For TLS initial-exec and local-exec accesses on AIX, we have one TOC; // entry for the symbol (with the variable offset), which is differentiated; // by MO_TPREL_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:85,Modifiability,variab,variable,85,"// For GD TLS access on AIX, we have two TOC entries for the symbol (one for; // the variable offset and the other for the region handle). They are; // differentiated by MO_TLSGD_FLAG and MO_TLSGDM_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:14,Security,access,access,14,"// For GD TLS access on AIX, we have two TOC entries for the symbol (one for; // the variable offset and the other for the region handle). They are; // differentiated by MO_TLSGD_FLAG and MO_TLSGDM_FLAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:27,Energy Efficiency,efficient,efficient,27,"// FIXME: We would like an efficient form for this, so we; // don't have to do a lot of extra uniquing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:19,Deployability,Update,UpdateGBR,19,"// Transform %rd = UpdateGBR(%rt, %ri); // Into: lwz %rt, .L0$poff - .L0$pb(%ri); // add %rd, %rt, %ri; // or into (if secure plt mode is on):; // addis r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@ha; // addi r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@l; // Get the offset from the GOT Base Register to the GOT",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:119,Security,secur,secure,119,"// Transform %rd = UpdateGBR(%rt, %ri); // Into: lwz %rt, .L0$poff - .L0$pb(%ri); // add %rd, %rt, %ri; // or into (if secure plt mode is on):; // addis r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@ha; // addi r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@l; // Get the offset from the GOT Base Register to the GOT",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:83,Energy Efficiency,allocate,allocated,83,"// Otherwise, use the TOC. 'TOCEntry' is a label used to reference the; // storage allocated in the TOC which contains the address of; // 'MOSymbol'. Said TOC entry will be synthesized later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:24,Performance,load,load,24,// Change the opcode to load address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:178,Energy Efficiency,allocate,allocated,178,// Always use TOC on AIX. Map the global address operand to be a reference; // to the TOC entry we will synthesize later. 'TOCEntry' is a label used to; // reference the storage allocated in the TOC which contains the address of; // 'MOSymbol'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:178,Energy Efficiency,allocate,allocated,178,// Always use TOC on AIX. Map the global address operand to be a reference; // to the TOC entry we will synthesize later. 'TOCEntry' is a label used to; // reference the storage allocated in the TOC which contains the address of; // 'MOSymbol'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:27,Energy Efficiency,efficient,efficient,27,"// FIXME: We would like an efficient form for this, so we don't have to do; // a lot of extra uniquing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:48,Availability,mask,mask,48,"// Transform: %cr7 = MTOCRF %r3; // Into: MTCRF mask, %r3 ;; cr7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:161,Deployability,Update,Update,161,"// .begin:; // b .end # lis 0, FuncId[16..32]; // nop # li 0, FuncId[0..15]; // std 0, -8(1); // mflr 0; // bl __xray_FunctionEntry; // mtlr 0; // .end:; //; // Update compiler-rt/lib/xray/xray_powerpc64.cc accordingly when number; // of instructions change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:239,Deployability,Update,Update,239,"// Before:; // bgtlr cr0; //; // After:; // ble cr0, .end; // .p2align 3; // .begin:; // blr # lis 0, FuncId[16..32]; // nop # li 0, FuncId[0..15]; // std 0, -8(1); // mflr 0; // bl __xray_FunctionExit; // mtlr 0; // blr; // .end:; //; // Update compiler-rt/lib/xray/xray_powerpc64.cc accordingly when number; // of instructions change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:176,Deployability,Update,Update,176,"// .p2align 3; // .begin:; // b(lr)? # lis 0, FuncId[16..32]; // nop # li 0, FuncId[0..15]; // std 0, -8(1); // mflr 0; // bl __xray_FunctionExit; // mtlr 0; // b(lr)?; //; // Update compiler-rt/lib/xray/xray_powerpc64.cc accordingly when number; // of instructions change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:32,Integrability,synchroniz,synchronized,32,// Note: The logic here must be synchronized with the code in the; // branch-selection pass which sets the offset of the first block in the; // function. This matters because it affects the alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:13,Testability,log,logic,13,// Note: The logic here must be synchronized with the code in the; // branch-selection pass which sets the offset of the first block in the; // function. This matters because it affects the alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:277,Security,access,access,277,"// If ShouldEmitEHBlock returns true, then the eh info table; // will be emitted via `AIXException::endFunction`. Otherwise, we; // need to emit a dumy eh info table when VRs are saved. We could not; // consolidate these two places into one because there is no easy way; // to access register information in `AIXException` class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:167,Integrability,rout,routine,167,"// There is a lack of information in the IR to assist with determining the; // source language. AIX exception handling mechanism would only search for; // personality routine and LSDA area when such language supports exception; // handling. So to be conservatively correct and allow runtime to do its job,; // we need to set it to C++ for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:17,Modifiability,Variab,Variable,17,"// If the Global Variable has the toc-data attribute, it needs to be emitted; // when we emit the .toc section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:31,Modifiability,variab,variable,31,// Emit linkage for the global variable and its aliases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:49,Modifiability,variab,variable,49,// Emit alias label and element value for global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp:473,Energy Efficiency,allocate,allocated,473,"//===- PPCBoolRetToInt.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements converting i1 values to i32/i64 if they could be more; // profitably allocated as GPRs rather than CRs. This pass will become totally; // unnecessary if Register Bank Allocation and Global Instruction Selection ever; // go upstream.; //; // Presently, the pass converts i1 Constants, and Arguments to i32/i64 if the; // transitive closure of their uses includes only PHINodes, CallInsts, and; // ReturnInsts. The rational is that arguments are generally passed and returned; // in GPRs rather than CRs, so casting them to i32/i64 at the LLVM IR level will; // actually save casts at the Machine Instruction level.; //; // It might be useful to expand this pass to add bit-wise operations to the list; // of safe transitive closure types. Also, we miss some opportunities when LLVM; // represents logical AND and OR operations with control flow rather than data; // flow. For example by lowering the expression: return (A && B && C); //; // as: return A ? true : B && C.; //; // There's code in SimplifyCFG that code be used to turn control flow in data; // flow using SelectInsts. Selects are slow on some architectures (P7/P8), so; // this probably isn't good in general, but for the special case of i1, the; // Selects could be further lowered to bit operations that are fast everywhere.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp:1111,Safety,safe,safe,1111,"//===- PPCBoolRetToInt.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements converting i1 values to i32/i64 if they could be more; // profitably allocated as GPRs rather than CRs. This pass will become totally; // unnecessary if Register Bank Allocation and Global Instruction Selection ever; // go upstream.; //; // Presently, the pass converts i1 Constants, and Arguments to i32/i64 if the; // transitive closure of their uses includes only PHINodes, CallInsts, and; // ReturnInsts. The rational is that arguments are generally passed and returned; // in GPRs rather than CRs, so casting them to i32/i64 at the LLVM IR level will; // actually save casts at the Machine Instruction level.; //; // It might be useful to expand this pass to add bit-wise operations to the list; // of safe transitive closure types. Also, we miss some opportunities when LLVM; // represents logical AND and OR operations with control flow rather than data; // flow. For example by lowering the expression: return (A && B && C); //; // as: return A ? true : B && C.; //; // There's code in SimplifyCFG that code be used to turn control flow in data; // flow using SelectInsts. Selects are slow on some architectures (P7/P8), so; // this probably isn't good in general, but for the special case of i1, the; // Selects could be further lowered to bit operations that are fast everywhere.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp:1200,Testability,log,logical,1200,"//===- PPCBoolRetToInt.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements converting i1 values to i32/i64 if they could be more; // profitably allocated as GPRs rather than CRs. This pass will become totally; // unnecessary if Register Bank Allocation and Global Instruction Selection ever; // go upstream.; //; // Presently, the pass converts i1 Constants, and Arguments to i32/i64 if the; // transitive closure of their uses includes only PHINodes, CallInsts, and; // ReturnInsts. The rational is that arguments are generally passed and returned; // in GPRs rather than CRs, so casting them to i32/i64 at the LLVM IR level will; // actually save casts at the Machine Instruction level.; //; // It might be useful to expand this pass to add bit-wise operations to the list; // of safe transitive closure types. Also, we miss some opportunities when LLVM; // represents logical AND and OR operations with control flow rather than data; // flow. For example by lowering the expression: return (A && B && C); //; // as: return A ? true : B && C.; //; // There's code in SimplifyCFG that code be used to turn control flow in data; // flow using SelectInsts. Selects are slow on some architectures (P7/P8), so; // this probably isn't good in general, but for the special case of i1, the; // Selects could be further lowered to bit operations that are fast everywhere.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp:1398,Usability,Simpl,SimplifyCFG,1398,"//===- PPCBoolRetToInt.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements converting i1 values to i32/i64 if they could be more; // profitably allocated as GPRs rather than CRs. This pass will become totally; // unnecessary if Register Bank Allocation and Global Instruction Selection ever; // go upstream.; //; // Presently, the pass converts i1 Constants, and Arguments to i32/i64 if the; // transitive closure of their uses includes only PHINodes, CallInsts, and; // ReturnInsts. The rational is that arguments are generally passed and returned; // in GPRs rather than CRs, so casting them to i32/i64 at the LLVM IR level will; // actually save casts at the Machine Instruction level.; //; // It might be useful to expand this pass to add bit-wise operations to the list; // of safe transitive closure types. Also, we miss some opportunities when LLVM; // represents logical AND and OR operations with control flow rather than data; // flow. For example by lowering the expression: return (A && B && C); //; // as: return A ? true : B && C.; //; // There's code in SimplifyCFG that code be used to turn control flow in data; // flow using SelectInsts. Selects are slow on some architectures (P7/P8), so; // this probably isn't good in general, but for the special case of i1, the; // Selects could be further lowered to bit operations that are fast everywhere.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBoolRetToInt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3505,Availability,down,down,3505," to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// When this pattern is detected, branch coalescing will try to collapse; /// it by moving code in %bb.2 to %bb.0 and/or %bb.4 and removing %bb.3.; ///; /// If all conditions are meet, IR should collapse to:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.1(0x2aaaaaaa / 0x80000000 = 33.33%); /// %bb.4(0x55555554 / 0x80000000 = 66.67%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.4(0x40000000 / 0x80000000 = 50.00%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// %13 = PHI %12, <%bb.1>, %2, <%bb.0>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// Branch Coalescing does not split blocks, it moves everything in the same; /// direction ensuring it does not break use/definition semantics.; ///; /// PHI nodes and its corresponding use instructions are moved to its successor; /// block if there are no uses within the successor block PHI nodes. PHI; /// node ordering cannot be assumed.; ///; /// Non-PHI can be moved up to the predecessor basic block or down to the; /// successor basic block following any PHI instructions. Whether it moves; /// up or down depends on whether the register(s) defined in the instructions; /// are used in current block or in any PHI instructions at the beginning of; /// the successor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3604,Availability,down,down,3604," to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// When this pattern is detected, branch coalescing will try to collapse; /// it by moving code in %bb.2 to %bb.0 and/or %bb.4 and removing %bb.3.; ///; /// If all conditions are meet, IR should collapse to:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.1(0x2aaaaaaa / 0x80000000 = 33.33%); /// %bb.4(0x55555554 / 0x80000000 = 66.67%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.4(0x40000000 / 0x80000000 = 50.00%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// %13 = PHI %12, <%bb.1>, %2, <%bb.0>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// Branch Coalescing does not split blocks, it moves everything in the same; /// direction ensuring it does not break use/definition semantics.; ///; /// PHI nodes and its corresponding use instructions are moved to its successor; /// block if there are no uses within the successor block PHI nodes. PHI; /// node ordering cannot be assumed.; ///; /// Non-PHI can be moved up to the predecessor basic block or down to the; /// successor basic block following any PHI instructions. Whether it moves; /// up or down depends on whether the register(s) defined in the instructions; /// are used in current block or in any PHI instructions at the beginning of; /// the successor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:205,Energy Efficiency,schedul,scheduling,205,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:244,Integrability,depend,depend,244,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3609,Integrability,depend,depends,3609," to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// When this pattern is detected, branch coalescing will try to collapse; /// it by moving code in %bb.2 to %bb.0 and/or %bb.4 and removing %bb.3.; ///; /// If all conditions are meet, IR should collapse to:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.1(0x2aaaaaaa / 0x80000000 = 33.33%); /// %bb.4(0x55555554 / 0x80000000 = 66.67%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.4(0x40000000 / 0x80000000 = 50.00%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// %13 = PHI %12, <%bb.1>, %2, <%bb.0>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// Branch Coalescing does not split blocks, it moves everything in the same; /// direction ensuring it does not break use/definition semantics.; ///; /// PHI nodes and its corresponding use instructions are moved to its successor; /// block if there are no uses within the successor block PHI nodes. PHI; /// node ordering cannot be assumed.; ///; /// Non-PHI can be moved up to the predecessor basic block or down to the; /// successor basic block following any PHI instructions. Whether it moves; /// up or down depends on whether the register(s) defined in the instructions; /// are used in current block or in any PHI instructions at the beginning of; /// the successor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:2046,Safety,detect,detected,2046,"/// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// When this pattern is detected, branch coalescing will try to collapse; /// it by moving code in %bb.2 to %bb.0 and/or %bb.4 and removing %bb.3.; ///; /// If all conditions are meet, IR should collapse to:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.1(0x2aaaaaaa / 0x80000000 = 33.33%); /// %bb.4(0x55555554 / 0x80000000 = 66.67%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.4(0x40000000 / 0x80000000 = 50.00%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// %13 = PHI %12, <%bb.1>, %2, <%bb.0>;; /// F8RC:%13,%12,%2; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:745,Testability,test,test,745,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:793,Testability,test,test,793,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:854,Testability,test,test,854,"//===----------------------------------------------------------------------===//; // PPCBranchCoalescing; //===----------------------------------------------------------------------===//; ///; /// Improve scheduling by coalescing branches that depend on the same condition.; /// This pass looks for blocks that are guarded by the same branch condition; /// and attempts to merge the blocks together. Such opportunities arise from; /// the expansion of select statements in the IR.; ///; /// This pass does not handle implicit operands on branch statements. In order; /// to run on targets that use implicit operands, changes need to be made in the; /// canCoalesceBranch and canMerge methods.; ///; /// Example: the following LLVM IR; ///; /// %test = icmp eq i32 %x 0; /// %tmp1 = select i1 %test, double %a, double 2.000000e-03; /// %tmp2 = select i1 %test, double %b, double 5.000000e-03; ///; /// expands to the following machine code:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:224,Deployability,update,updated,224,"// The analyzeBranch method does not include any implicit operands.; // This is not an issue on PPC but must be handled on other targets.; // For this pass to be made target-independent, the analyzeBranch API; // need to be updated to support implicit operands and there would; // need to be a way to verify that any implicit operands would not be; // clobbered by merging blocks. This would include identifying the; // implicit operands as well as the basic block they are defined in.; // This could be done by changing the analyzeBranch API to have it also; // record and return the implicit operands and the blocks where they are; // defined. Alternatively, the BranchCoalescing code would need to be; // extended to identify the implicit operands. The analysis in canMerge; // must then be extended to prove that none of the implicit operands are; // changed in the blocks that are combined during coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:708,Modifiability,extend,extended,708,"// The analyzeBranch method does not include any implicit operands.; // This is not an issue on PPC but must be handled on other targets.; // For this pass to be made target-independent, the analyzeBranch API; // need to be updated to support implicit operands and there would; // need to be a way to verify that any implicit operands would not be; // clobbered by merging blocks. This would include identifying the; // implicit operands as well as the basic block they are defined in.; // This could be done by changing the analyzeBranch API to have it also; // record and return the implicit operands and the blocks where they are; // defined. Alternatively, the BranchCoalescing code would need to be; // extended to identify the implicit operands. The analysis in canMerge; // must then be extended to prove that none of the implicit operands are; // changed in the blocks that are combined during coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:794,Modifiability,extend,extended,794,"// The analyzeBranch method does not include any implicit operands.; // This is not an issue on PPC but must be handled on other targets.; // For this pass to be made target-independent, the analyzeBranch API; // need to be updated to support implicit operands and there would; // need to be a way to verify that any implicit operands would not be; // clobbered by merging blocks. This would include identifying the; // implicit operands as well as the basic block they are defined in.; // This could be done by changing the analyzeBranch API to have it also; // record and return the implicit operands and the blocks where they are; // defined. Alternatively, the BranchCoalescing code would need to be; // extended to identify the implicit operands. The analysis in canMerge; // must then be extended to prove that none of the implicit operands are; // changed in the blocks that are combined during coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:84,Deployability,update,update,84,///; /// Moves ALL PHI instructions in SourceMBB to beginning of TargetMBB; /// and update them to refer to the new block. PHI node ordering; /// cannot be assumed so it does not matter where the PHI instructions; /// are moved to in TargetMBB.; ///; /// \param[in] SourceMBB block to move PHI instructions from; /// \param[in] TargetMBB block to move PHI instructions to; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3,Deployability,Update,Update,3,// Update all PHI instructions in SourceMBB and move to top of TargetMBB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:385,Safety,safe,safe,385,"///; /// This function checks if MI can be moved to the beginning of the TargetMBB; /// following PHI instructions. A MI instruction can be moved to beginning of; /// the TargetMBB if there are no uses of it within the TargetMBB PHI nodes.; ///; /// \param[in] MI the machine instruction to move.; /// \param[in] TargetMBB the machine basic block to move to; /// \return true if it is safe to move MI to beginning of TargetMBB,; /// false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:395,Safety,safe,safe,395,"///; /// This function checks if MI can be moved to the end of the TargetMBB,; /// immediately before the first terminator. A MI instruction can be moved; /// to then end of the TargetMBB if no PHI node defines what MI uses within; /// it's own MBB.; ///; /// \param[in] MI the machine instruction to move.; /// \param[in] TargetMBB the machine basic block to move to; /// \return true if it is safe to move MI to end of TargetMBB,; /// false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:494,Availability,down,down,494,"///; /// This method determines whether the two coalescing candidates can be merged.; /// In order to be merged, all instructions must be able to; /// 1. Move to the beginning of the SourceRegion.BranchTargetBlock;; /// 2. Move to the end of the TargetRegion.BranchBlock.; /// Merging involves moving the instructions in the; /// TargetRegion.BranchTargetBlock (also SourceRegion.BranchBlock).; ///; /// This function first try to move instructions from the; /// TargetRegion.BranchTargetBlock down, to the beginning of the; /// SourceRegion.BranchTargetBlock. This is not possible if any register defined; /// in TargetRegion.BranchTargetBlock is used in a PHI node in the; /// SourceRegion.BranchTargetBlock. In this case, check whether the statement; /// can be moved up, to the end of the TargetRegion.BranchBlock (immediately; /// before the branch statement). If it cannot move, then these blocks cannot; /// be merged.; ///; /// Note that there is no analysis for moving instructions past the fall-through; /// blocks because they are confirmed to be empty. An assert is thrown if they; /// are not.; ///; /// \param[in] SourceRegion The candidate to move statements from; /// \param[in] TargetRegion The candidate to move statements to; /// \return true if all instructions in SourceRegion.BranchBlock can be merged; /// into a block in TargetRegion, false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:1068,Testability,assert,assert,1068,"///; /// This method determines whether the two coalescing candidates can be merged.; /// In order to be merged, all instructions must be able to; /// 1. Move to the beginning of the SourceRegion.BranchTargetBlock;; /// 2. Move to the end of the TargetRegion.BranchBlock.; /// Merging involves moving the instructions in the; /// TargetRegion.BranchTargetBlock (also SourceRegion.BranchBlock).; ///; /// This function first try to move instructions from the; /// TargetRegion.BranchTargetBlock down, to the beginning of the; /// SourceRegion.BranchTargetBlock. This is not possible if any register defined; /// in TargetRegion.BranchTargetBlock is used in a PHI node in the; /// SourceRegion.BranchTargetBlock. In this case, check whether the statement; /// can be moved up, to the end of the TargetRegion.BranchBlock (immediately; /// before the branch statement). If it cannot move, then these blocks cannot; /// be merged.; ///; /// Note that there is no analysis for moving instructions past the fall-through; /// blocks because they are confirmed to be empty. An assert is thrown if they; /// are not.; ///; /// \param[in] SourceRegion The candidate to move statements from; /// \param[in] TargetRegion The candidate to move statements to; /// \return true if all instructions in SourceRegion.BranchBlock can be merged; /// into a block in TargetRegion, false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:129,Availability,down,down,129,// Walk through the MI to see if they should be merged into; // TargetRegion.BranchBlock (up) or SourceRegion.BranchTargetBlock (down),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:309,Deployability,update,updated,309,"/// Merge the instructions from SourceRegion.BranchBlock,; /// SourceRegion.BranchTargetBlock, and SourceRegion.FallThroughBlock into; /// TargetRegion.BranchBlock, TargetRegion.BranchTargetBlock and; /// TargetRegion.FallThroughBlock respectively.; ///; /// The successors for blocks in TargetRegion will be updated to use the; /// successors from blocks in SourceRegion. Finally, the blocks in SourceRegion; /// will be removed from the function.; ///; /// A region consists of a BranchBlock, a FallThroughBlock, and a; /// BranchTargetBlock. Branch coalesce works on patterns where the; /// TargetRegion's BranchTargetBlock must also be the SourceRegions's; /// BranchBlock.; ///; /// Before mergeCandidates:; ///; /// +---------------------------+; /// | TargetRegion.BranchBlock |; /// +---------------------------+; /// / |; /// / +--------------------------------+; /// | | TargetRegion.FallThroughBlock |; /// \ +--------------------------------+; /// \ |; /// +----------------------------------+; /// | TargetRegion.BranchTargetBlock |; /// | SourceRegion.BranchBlock |; /// +----------------------------------+; /// / |; /// / +--------------------------------+; /// | | SourceRegion.FallThroughBlock |; /// \ +--------------------------------+; /// \ |; /// +----------------------------------+; /// | SourceRegion.BranchTargetBlock |; /// +----------------------------------+; ///; /// After mergeCandidates:; ///; /// +-----------------------------+; /// | TargetRegion.BranchBlock |; /// | SourceRegion.BranchBlock |; /// +-----------------------------+; /// / |; /// / +---------------------------------+; /// | | TargetRegion.FallThroughBlock |; /// | | SourceRegion.FallThroughBlock |; /// \ +---------------------------------+; /// \ |; /// +----------------------------------+; /// | SourceRegion.BranchTargetBlock |; /// +----------------------------------+; ///; /// \param[in] SourceRegion The candidate to move blocks from; /// \param[in] TargetRegion The candidate to move blo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:110,Availability,down,down,110,// Start the merging process by first handling the BranchBlock.; // Move any PHIs in SourceRegion.BranchBlock down to the branch-taken block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:3,Deployability,Update,Update,3,"// Update branch in TargetRegion.BranchBlock to jump to; // SourceRegion.BranchTargetBlock; // In this case, TargetRegion.BranchTargetBlock == SourceRegion.BranchBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:48,Availability,down,down,48,// Transfer successor information and move PHIs down to the; // branch-taken block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:323,Integrability,synchroniz,synchronized,323,"/// We need to be careful about the offset of the first block in the function; /// because it might not have the function's alignment. This happens because,; /// under the ELFv2 ABI, for functions which require a TOC pointer, we add a; /// two-instruction sequence to the start of the function.; /// Note: This needs to be synchronized with the check in; /// PPCLinuxAsmPrinter::EmitFunctionBodyStart.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:647,Safety,safe,safe,647,// All 8 byte instructions may require alignment. Each 8 byte; // instruction may be aligned by another 4 bytes.; // This means that an 8 byte instruction may require 12 bytes; // (8 for the instruction itself and 4 for the alignment nop).; // This will happen if an 8 byte instruction can be aligned to 64 bytes; // by only adding a 4 byte nop.; // We don't know the alignment at this point in the code so we have to; // adopt a more pessimistic approach. If an instruction may need; // alignment we assume that it does need alignment and add 4 bytes to; // it. As a result we may end up with more long branches than before; // but we are in the safe position where if we need a long branch we; // have one.; // The if statement checks to make sure that two 8 byte instructions; // are at least 64 bytes away from each other. It is not possible for; // two instructions that both need alignment to be within 64 bytes of; // each other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:2011,Safety,safe,safety,2011," estimate code size due to large alignment and; // inline assembly. Usually it causes larger computed branch offset.; // But sometimes it may also causes smaller computed branch offset; // than actual branch offset. If the offset is close to the limit of; // encoding, it may cause problem at run time.; // Following is a simplified example.; //; // actual estimated; // address address; // ...; // bne Far 100 10c; // .p2align 4; // Near: 110 110; // ...; // Far: 8108 8108; //; // Actual offset: 0x8108 - 0x100 = 0x8008; // Computed offset: 0x8108 - 0x10c = 0x7ffc; //; // This example also shows when we can get the largest gap between; // estimated offset and actual offset. If there is an aligned block; // ABB between branch and target, assume its alignment is <align>; // bits. Now consider the accumulated function size FSIZE till the end; // of previous block PBB. If the estimated FSIZE is multiple of; // 2^<align>, we don't need any padding for the estimated address of; // ABB. If actual FSIZE at the end of PBB is 4 bytes more than; // multiple of 2^<align>, then we need (2^<align> - 4) bytes of; // padding. It also means the actual branch offset is (2^<align> - 4); // larger than computed offset. Other actual FSIZE needs less padding; // bytes, so causes smaller gap between actual and computed offset.; //; // On the other hand, if the inline asm or large alignment occurs; // between the branch block and destination block, the estimated address; // can be <delta> larger than actual address. If padding bytes are; // needed for a later aligned block, the actual number of padding bytes; // is at most <delta> more than estimated padding bytes. So the actual; // aligned block address is less than or equal to the estimated aligned; // block address. So the actual branch offset is less than or equal to; // computed branch offset.; //; // The computed offset is at most ((1 << alignment) - 4) bytes smaller; // than actual offset. So we add this number to the offset for safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:340,Usability,simpl,simplified,340,"// We tend to over estimate code size due to large alignment and; // inline assembly. Usually it causes larger computed branch offset.; // But sometimes it may also causes smaller computed branch offset; // than actual branch offset. If the offset is close to the limit of; // encoding, it may cause problem at run time.; // Following is a simplified example.; //; // actual estimated; // address address; // ...; // bne Far 100 10c; // .p2align 4; // Near: 110 110; // ...; // Far: 8108 8108; //; // Actual offset: 0x8108 - 0x100 = 0x8008; // Computed offset: 0x8108 - 0x10c = 0x7ffc; //; // This example also shows when we can get the largest gap between; // estimated offset and actual offset. If there is an aligned block; // ABB between branch and target, assume its alignment is <align>; // bits. Now consider the accumulated function size FSIZE till the end; // of previous block PBB. If the estimated FSIZE is multiple of; // 2^<align>, we don't need any padding for the estimated address of; // ABB. If actual FSIZE at the end of PBB is 4 bytes more than; // multiple of 2^<align>, then we need (2^<align> - 4) bytes of; // padding. It also means the actual branch offset is (2^<align> - 4); // larger than computed offset. Other actual FSIZE needs less padding; // bytes, so causes smaller gap between actual and computed offset.; //; // On the other hand, if the inline asm or large alignment occurs; // between the branch block and destination block, the estimated address; // can be <delta> larger than actual address. If padding bytes are; // needed for a later aligned block, the actual number of padding bytes; // is at most <delta> more than estimated padding bytes. So the actual; // aligned block address is less than or equal to the estimated aligned; // block address. So the actual branch offset is less than or equal to; // computed branch offset.; //; // The computed offset is at most ((1 << alignment) - 4) bytes smaller; // than actual offset. So we add this number to the o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:52,Deployability,update,updated,52,"// If we're going to iterate again, make sure we've updated our; // padding-based contributions to the block sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:54,Deployability,Release,Release,54,// gracefully fallback to PPC C calling convention on Release builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:254,Energy Efficiency,allocate,allocated,254,"// For vector and __float128 (which is represents the ""vector"" section; // in 2.2.4.1), shadow two even GPRs (skipping the odd one if it is next; // in the allocation order). To check if the GPR is even, the specific; // condition checks if the register allocated is odd, because the even; // physical registers are odd values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:126,Availability,avail,available,126,"// Skip one register if the first unallocated register has an even register; // number and there are still argument registers available which have not been; // allocated yet. RegNum is actually an index into ArgRegs, which means we; // need to skip a register if RegNum is odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:160,Energy Efficiency,allocate,allocated,160,"// Skip one register if the first unallocated register has an even register; // number and there are still argument registers available which have not been; // allocated yet. RegNum is actually an index into ArgRegs, which means we; // need to skip a register if RegNum is odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:155,Energy Efficiency,allocate,allocate,155,"// Always return false here, as this function only makes sure that the first; // unallocated register has an odd register number and does not actually; // allocate a register for the current argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:205,Energy Efficiency,allocate,allocate,205,"// Always return false here, as this function only makes sure that the two f64; // values a ppc_fp128 value is split into are both passed in registers or both; // passed on the stack and does not actually allocate a register for the; // current argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:49,Energy Efficiency,allocate,allocate,49,"// Same as above, but for return values, so only allocate for R3 and R4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h:55,Integrability,Rout,Routines,55,"//=== PPCCallingConv.h - PPC Custom Calling Convention Routines -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the custom routines for the PPC Calling Convention that; // aren't done by tablegen.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h:413,Integrability,rout,routines,413,"//=== PPCCallingConv.h - PPC Custom Calling Convention Routines -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the custom routines for the PPC Calling Convention that; // aren't done by tablegen.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.cpp:40,Energy Efficiency,Power,PowerPC,40,"//===---- PPCCCState.cpp - CCState with PowerPC specific extensions ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.h:38,Energy Efficiency,Power,PowerPC,38,"//===---- PPCCCState.h - CCState with PowerPC specific extensions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCCState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp:1060,Energy Efficiency,allocate,allocate,1060,"//===-- PPCCTRLoops.cpp - Generate CTR loops ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass generates machine instructions for the CTR loops related pseudos:; // 1: MTCTRloop/DecreaseCTRloop; // 2: MTCTR8loop/DecreaseCTR8loop; //; // If a CTR loop can be generated:; // 1: MTCTRloop/MTCTR8loop will be converted to ""mtctr""; // 2: DecreaseCTRloop/DecreaseCTR8loop will be converted to ""bdnz/bdz"" and; // its user branch instruction can be deleted.; //; // If a CTR loop can not be generated due to clobber of CTR:; // 1: MTCTRloop/MTCTR8loop can be deleted.; // 2: DecreaseCTRloop/DecreaseCTR8loop will be converted to ""addi -1"" and; // a ""cmplwi/cmpldi"".; //; // This pass runs just before register allocation, because we don't want; // register allocator to allocate register for DecreaseCTRloop if a CTR can be; // generated or if a CTR loop can not be generated, we don't have any condition; // register for the new added ""cmplwi/cmpldi"".; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp:816,Deployability,Release,Release,816,"//===-- PPCCTRLoops.cpp - Verify CTR loops -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass verifies that all bdnz/bdz instructions are dominated by a loop; // mtctr before any other instructions that might clobber the ctr register.; //; //===----------------------------------------------------------------------===//; // CTR loops are produced by the HardwareLoops pass and this pass is simply a; // verification that no invalid CTR loops are produced. As such, it isn't; // something that needs to be run (or even defined) for Release builds so the; // entire file is guarded by NDEBUG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp:675,Usability,simpl,simply,675,"//===-- PPCCTRLoops.cpp - Verify CTR loops -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass verifies that all bdnz/bdz instructions are dominated by a loop; // mtctr before any other instructions that might clobber the ctr register.; //; //===----------------------------------------------------------------------===//; // CTR loops are produced by the HardwareLoops pass and this pass is simply a; // verification that no invalid CTR loops are produced. As such, it isn't; // something that needs to be run (or even defined) for Release builds so the; // entire file is guarded by NDEBUG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCTRLoopsVerify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp:125,Safety,avoid,avoid,125,"// PPCEarlyReturn pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp:29,Usability,simpl,simple,29,"// PPCEarlyReturn pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:76,Availability,redundant,redundant,76,"// Special case 1, all registers used by ISEL are the same one.; // The non-redundant isel 0, 0, 0, N would not satisfy these conditions; // as it would be ISEL %R0, %ZERO, %R0, %CRN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:76,Safety,redund,redundant,76,"// Special case 1, all registers used by ISEL are the same one.; // The non-redundant isel 0, 0, 0, N would not satisfy these conditions; // as it would be ISEL %R0, %ZERO, %R0, %CRN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:213,Safety,safe,safe,213,"// Special case 2, the two input registers used by ISEL are the same.; // Note: the non-foldable isel RX, 0, 0, N would not satisfy this; // condition as it would be ISEL %RX, %ZERO, %R0, %CRN, which makes it; // safe to fold ISEL to MR(OR) instead of ADDI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:133,Availability,redundant,redundant,133,// Collect the ISELs that can be merged together.; // This will eat up ISEL instructions without considering whether they; // may be redundant or foldable to a register copy. So we still keep; // the handleSpecialCases() downstream to handle them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:221,Availability,down,downstream,221,// Collect the ISELs that can be merged together.; // This will eat up ISEL instructions without considering whether they; // may be redundant or foldable to a register copy. So we still keep; // the handleSpecialCases() downstream to handle them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:133,Safety,redund,redundant,133,// Collect the ISELs that can be merged together.; // This will eat up ISEL instructions without considering whether they; // may be redundant or foldable to a register copy. So we still keep; // the handleSpecialCases() downstream to handle them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:248,Testability,test,test,248,"// Special case 2, the two input registers used by ISEL are the same.; // Note 1: We favor merging ISEL expansions over folding a single one. If; // the passed list has multiple merge-able ISEL's, we won't fold any.; // Note 2: There is no need to test for PPC::R0/PPC::X0 because PPC::ZERO/; // PPC::ZERO8 will be used for the first operand if the value is meant to; // be zero. In this case, the useSameRegister method will return false,; // thereby preventing this ISEL from being folded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:3,Deployability,Update,Update,3,// Update the liveins for NewSuccessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:3,Deployability,Update,Update,3,// Update the liveins for TrueBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:3,Deployability,Update,Update,3,// Update the liveins for FalseBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:26,Energy Efficiency,Power,PowerPC,26,"//===-- PPCFastISel.cpp - PowerPC FastISel implementation -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PowerPC-specific support for the FastISel class. Some; // of the target-specific code is generated by tablegen in the file; // PPCGenFastISel.inc, which is #included here.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:405,Energy Efficiency,Power,PowerPC-specific,405,"//===-- PPCFastISel.cpp - PowerPC FastISel implementation -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PowerPC-specific support for the FastISel class. Some; // of the target-specific code is generated by tablegen in the file; // PPCGenFastISel.inc, which is #included here.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:284,Performance,Optimiz,Optimize,284,//===----------------------------------------------------------------------===//; //; // TBD:; // fastLowerArguments: Handle simple cases.; // PPCMaterializeGV: Handle TLS.; // SelectCall: Handle function pointers.; // SelectCall: Handle multi-register return values.; // SelectCall: Optimize away nops for local calls.; // processCallArgs: Handle bit-converted arguments.; // finishCall: Handle multi-register return values.; // PPCComputeAddress: Handle parameter references as FrameIndex's.; // PPCEmitCmp: Handle immediate as operand 1.; // SelectCall: Handle small byval arguments.; // SelectIntrinsicCall: Implement.; // SelectSelect: Implement.; // Consider factoring isTypeLegal into the base class.; // Implement switches and jump tables.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:125,Usability,simpl,simple,125,//===----------------------------------------------------------------------===//; //; // TBD:; // fastLowerArguments: Handle simple cases.; // PPCMaterializeGV: Handle TLS.; // SelectCall: Handle function pointers.; // SelectCall: Handle multi-register return values.; // SelectCall: Optimize away nops for local calls.; // processCallArgs: Handle bit-converted arguments.; // finishCall: Handle multi-register return values.; // PPCComputeAddress: Handle parameter references as FrameIndex's.; // PPCEmitCmp: Handle immediate as operand 1.; // SelectCall: Handle small byval arguments.; // SelectIntrinsicCall: Implement.; // SelectSelect: Implement.; // Consider factoring isTypeLegal into the base class.; // Implement switches and jump tables.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:25,Integrability,rout,routines,25,// Instruction selection routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:11,Integrability,rout,routines,11,// Utility routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:17,Integrability,rout,routines,17,// Call handling routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:623,Testability,test,tested,623,"// Major concern about the following 6 cases is NaN result. The comparison; // result consists of 4 bits, indicating lt, eq, gt and un (unordered),; // only one of which will be set. The result is generated by fcmpu; // instruction. However, bc instruction only inspects one of the first 3; // bits, so when un is set, bc instruction may jump to an undesired; // place.; //; // More specifically, if we expect an unordered comparison and un is set, we; // expect to always go to true branch; in such case UEQ, UGT and ULT still; // give false, which are undesired; but UNE, UGE, ULE happen to give true,; // since they are tested by inspecting !eq, !lt, !gt, respectively.; //; // Similarly, for ordered comparison, when un is set, we always expect the; // result to be false. In such case OGT, OLT and OEQ is good, since they are; // actually testing GT, LT, and EQ respectively, which are false. OGE, OLE; // and ONE are tested through !lt, !gt and !eq, and these are true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:844,Testability,test,testing,844,"// Major concern about the following 6 cases is NaN result. The comparison; // result consists of 4 bits, indicating lt, eq, gt and un (unordered),; // only one of which will be set. The result is generated by fcmpu; // instruction. However, bc instruction only inspects one of the first 3; // bits, so when un is set, bc instruction may jump to an undesired; // place.; //; // More specifically, if we expect an unordered comparison and un is set, we; // expect to always go to true branch; in such case UEQ, UGT and ULT still; // give false, which are undesired; but UNE, UGE, ULE happen to give true,; // since they are tested by inspecting !eq, !lt, !gt, respectively.; //; // Similarly, for ordered comparison, when un is set, we always expect the; // result to be false. In such case OGT, OLT and OEQ is good, since they are; // actually testing GT, LT, and EQ respectively, which are false. OGE, OLE; // and ONE are tested through !lt, !gt and !eq, and these are true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:923,Testability,test,tested,923,"// Major concern about the following 6 cases is NaN result. The comparison; // result consists of 4 bits, indicating lt, eq, gt and un (unordered),; // only one of which will be set. The result is generated by fcmpu; // instruction. However, bc instruction only inspects one of the first 3; // bits, so when un is set, bc instruction may jump to an undesired; // place.; //; // More specifically, if we expect an unordered comparison and un is set, we; // expect to always go to true branch; in such case UEQ, UGT and ULT still; // give false, which are undesired; but UNE, UGE, ULE happen to give true,; // since they are tested by inspecting !eq, !lt, !gt, respectively.; //; // Similarly, for ordered comparison, when un is set, we always expect the; // result to be false. In such case OGT, OLT and OEQ is good, since they are; // actually testing GT, LT, and EQ respectively, which are false. OGE, OLE; // and ONE are tested through !lt, !gt and !eq, and these are true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:36,Usability,simpl,simple,36,"// Determine whether the type Ty is simple enough to be handled by; // fast-isel, and return its equivalent machine type in VT.; // FIXME: Copied directly from ARM -- factor into base class?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:86,Performance,load,load,86,"// Determine whether the type Ty is simple enough to be handled by; // fast-isel as a load target, and return its equivalent machine type in VT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:36,Usability,simpl,simple,36,"// Determine whether the type Ty is simple enough to be handled by; // fast-isel as a load target, and return its equivalent machine type in VT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:46,Modifiability,extend,extended,46,// If this is a type than can be sign or zero-extended to a basic operation; // go ahead and accept it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:77,Performance,load,loads,77,"// Prevent assignment of base register to X0, which is inappropriate; // for loads and stores alike.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:57,Usability,simpl,simplified,57,"// If this is a stack pointer and the offset needs to be simplified then; // put the alloca address into a register, set the base type back to; // register and continue. This should almost never happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:10,Performance,load,load,10,"// Emit a load instruction if possible, returning true if we succeeded,; // otherwise false. See commentary below for how the register class of; // the load is determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:152,Performance,load,load,152,"// Emit a load instruction if possible, returning true if we succeeded,; // otherwise false. See commentary below for how the register class of; // the load is determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:66,Performance,load,load,66,"// If ResultReg is given, it determines the register class of the load.; // Otherwise, RC is the register class to use. If the result of the; // load isn't anticipated in this block, both may be zero, in which; // case we must make a conservative guess. In particular, don't assign; // R0 or X0 to the result register, as the result may be used in a load,; // store, add-immediate, or isel that won't permit this. (Though; // perhaps the spill and reload of live-exit values would handle this?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:145,Performance,load,load,145,"// If ResultReg is given, it determines the register class of the load.; // Otherwise, RC is the register class to use. If the result of the; // load isn't anticipated in this block, both may be zero, in which; // case we must make a conservative guess. In particular, don't assign; // R0 or X0 to the result register, as the result may be used in a load,; // store, add-immediate, or isel that won't permit this. (Though; // perhaps the spill and reload of live-exit values would handle this?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:350,Performance,load,load,350,"// If ResultReg is given, it determines the register class of the load.; // Otherwise, RC is the register class to use. If the result of the; // load isn't anticipated in this block, both may be zero, in which; // case we must make a conservative guess. In particular, don't assign; // R0 or X0 to the result register, as the result may be used in a load,; // store, add-immediate, or isel that won't permit this. (Though; // perhaps the spill and reload of live-exit values would handle this?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:30,Performance,load,load,30,"// If this is a potential VSX load with an offset of 0, a VSX indexed load can; // be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:70,Performance,load,load,70,"// If this is a potential VSX load with an offset of 0, a VSX indexed load can; // be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:32,Performance,load,load,32,// VSX only provides an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:32,Performance,load,load,32,// VSX only provides an indexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:28,Performance,load,load,28,// Attempt to fast-select a load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:20,Performance,load,loads,20,// FIXME: No atomic loads are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:21,Performance,load,loads,21,// FIXME: No atomics loads are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:25,Usability,simpl,simplest,25,"// For now, just try the simplest case where it's fed by a compare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:164,Availability,avail,available,164,"// FIXME: ARM looks for a case where the block containing the compare; // has been split from the block containing the branch. If this happens,; // there is a vreg available containing the result of the compare. I'm; // not sure we can do much, as we've lost the predicate information with; // the compare instruction -- we have a 4-bit CR but don't know which bit; // to test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:372,Testability,test,test,372,"// FIXME: ARM looks for a case where the block containing the compare; // has been split from the block containing the branch. If this happens,; // there is a vreg available containing the result of the compare. I'm; // not sure we can do much, as we've lost the predicate information with; // the compare instruction -- we have a 4-bit CR but don't know which bit; // to test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:72,Energy Efficiency,Power,PowerPC,72,// Only 16-bit integer constants can be represented in compares for; // PowerPC. Others will be materialized into a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:43,Modifiability,extend,extend,43,// Attempt to fast-select a floating-point extend instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:33,Modifiability,extend,extend,33,// No code is generated for a FP extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:123,Energy Efficiency,Power,PowerISA,123,"// Move an i32 or i64 value in a GPR to an f64 value in an FPR.; // FIXME: When direct register moves are implemented (see PowerISA 2.07),; // those should be used instead of moving via a stack slot when the; // subtarget permits.; // FIXME: The code here is sloppy for the 4-byte case. Can use a 4-byte; // stack slot and 4-byte store/load sequence. Or just sext the 4-byte; // case to 8 bytes which produces tighter code but wastes stack space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:336,Performance,load,load,336,"// Move an i32 or i64 value in a GPR to an f64 value in an FPR.; // FIXME: When direct register moves are implemented (see PowerISA 2.07),; // those should be used instead of moving via a stack slot when the; // subtarget permits.; // FIXME: The code here is sloppy for the 4-byte case. Can use a 4-byte; // stack slot and 4-byte store/load sequence. Or just sext the 4-byte; // case to 8 bytes which produces tighter code but wastes stack space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:17,Modifiability,extend,extend,17,"// If necessary, extend 32-bit int to 64-bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:61,Integrability,depend,depends,61,// Load the integer value into an FPR. The kind of load used depends; // on a number of conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:3,Performance,Load,Load,3,// Load the integer value into an FPR. The kind of load used depends; // on a number of conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:51,Performance,load,load,51,// Load the integer value into an FPR. The kind of load used depends; // on a number of conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:43,Performance,load,load,43,"// Shortcut for SPE. Doesn't need to store/load, since it's all in the GPRs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:237,Safety,avoid,avoid,237,"// FIXME: For now we require the newer floating-point conversion operations; // (which are present only on P7 and A2 server models) when converting; // to single-precision float. Otherwise we have to generate a lot of; // fiddly code to avoid double rounding. If necessary, the fiddly code; // can be found in PPCTargetLowering::LowerINT_TO_FP().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:3,Modifiability,Extend,Extend,3,// Extend the input if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:201,Energy Efficiency,Power,PowerISA,201,"// Move the floating-point value in SrcReg into an integer destination; // register, and return the register (or zero if we can't handle it).; // FIXME: When direct register moves are implemented (see PowerISA 2.07),; // those should be used instead of moving via a stack slot when the; // subtarget permits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:94,Availability,avail,available,94,"// Get a stack slot 8 bytes wide, aligned on an 8-byte boundary.; // Note that if have STFIWX available, we could use a 4-byte stack; // slot for i32, but this being fast-isel we'll just go with the; // easiest code gen possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:111,Performance,load,load,111,"// Reload it into a GPR. If we want an i32 on big endian, modify the; // address to have a 4-byte offset so we load from the right place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:417,Energy Efficiency,allocate,allocate,417,"// The prolog code of the callee may store up to 8 GPR argument registers to; // the stack, allowing va_start to index over them in memory if its varargs.; // Because we cannot tell if this is needed on the caller side, we have to; // conservatively assume that it is needed. As such, make sure we have at; // least enough stack space for the caller to store the 8 GPRs.; // FIXME: On ELFv2, it may be unnecessary to allocate the parameter area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:74,Integrability,protocol,protocol,74,// Prepare to assign register arguments. Every argument uses up a; // GPR protocol register even if it's passed in a floating-point; // register (unless we're using the fast calling convention).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:184,Availability,down,downstream,184,"// If only the low half of a general register is needed, generate; // a GPRC copy instead of a G8RC copy. (EXTRACT_SUBREG can't be; // used along the fast-isel path (not lowered), and downstream logic; // also doesn't like a direct subreg copy on a physical reg.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:195,Testability,log,logic,195,"// If only the low half of a general register is needed, generate; // a GPRC copy instead of a G8RC copy. (EXTRACT_SUBREG can't be; // used along the fast-isel path (not lowered), and downstream logic; // also doesn't like a direct subreg copy on a physical reg.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:82,Modifiability,extend,extended,82,"// Handle simple calls for now, with legal return types and; // those that can be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:10,Usability,simpl,simple,10,"// Handle simple calls for now, with legal return types and; // those that can be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:37,Usability,simpl,simple,37,"// FIXME: FastISel cannot handle non-simple types yet, including 128-bit FP; // types, which is passed through vector register. Skip these types and; // fallback to default SelectionDAG based selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:3,Deployability,patch,patchpoints,3,"// patchpoints are a special case; they always dispatch to a pointer value.; // However, we don't actually want to generate the indirect call sequence; // here (that will be generated, as necessary, during asm printing), and; // the call we generate here will be erased by FastISel::selectPatchpoint,; // so don't try very hard...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:76,Performance,optimiz,optimize,76,// Build direct call with NOP for TOC restore.; // FIXME: We can and should optimize away the NOP for local calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:18,Availability,mask,mask,18,// Add a register mask with the call-preserved registers. Proper; // defs for return values will be added by setPhysRegsDeadExcept().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:41,Modifiability,extend,extending,41,"// We still need to worry about properly extending the sign. For example,; // we could have only a single bit or a constant that needs zero; // extension rather than sign extension. Make sure we pass the return; // value extension property to integer materialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:30,Modifiability,extend,extend,30,// Attempt to emit an integer extend of SrcReg into DestReg. Both; // signed and zero extensions are supported. Return false if we; // can't handle it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:37,Modifiability,extend,extend,37,// Attempt to fast-select an integer extend instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:207,Availability,down,downstream,207,"// If we know the register class needed for the result of this; // instruction, use it. Otherwise pick the register class of the; // correct size that does not contain X0/R0, since we don't know; // whether downstream uses permit that assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:24,Performance,load,loaded,24,// All FP constants are loaded from the constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:156,Integrability,depend,depend,156,"// Global values may be plain old object addresses, TLS object; // addresses, constant pool entries, or jump tables. How we generate; // code for these may depend on small, medium, or large code model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:47,Performance,load,load,47,"// For small code model, generate a simple TOC load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:36,Usability,simpl,simple,36,"// For small code model, generate a simple TOC load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:90,Availability,avail,available,90,"// If the address is an externally defined symbol, a symbol with common; // or externally available linkage, a non-local function address, or a; // jump table address (not yet needed), or if we are generating code; // for large code model, we generate:; // LDtocL(GV, ADDIStocHA8(%x2, GV)); // Otherwise we generate:; // ADDItocL(ADDIStocHA8(%x2, GV), GV); // Either way, start with the ADDIStocHA8:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:77,Modifiability,extend,extend,77,"// If the constant is in range, use a load-immediate.; // Since LI will sign extend the constant we need to make sure that for; // our zeroext constants that the sign extended constant fits into 16-bits -; // a range of 0..0x7fff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:167,Modifiability,extend,extended,167,"// If the constant is in range, use a load-immediate.; // Since LI will sign extend the constant we need to make sure that for; // our zeroext constants that the sign extended constant fits into 16-bits -; // a range of 0..0x7fff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:38,Performance,load,load-immediate,38,"// If the constant is in range, use a load-immediate.; // Since LI will sign extend the constant we need to make sure that for; // our zeroext constants that the sign extended constant fits into 16-bits -; // a range of 0..0x7fff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:15,Usability,simpl,simple,15,// Only handle simple types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:138,Availability,failure,failure,138,"// Note that the code in FunctionLoweringInfo::ComputePHILiveOutRegInfo; // assumes that constant PHI operands will be zero extended, and failure to; // match that assumption will cause problems if we sign extend here but; // some user of a PHI is in a block for which we fall back to full SDAG; // instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:124,Modifiability,extend,extended,124,"// Note that the code in FunctionLoweringInfo::ComputePHILiveOutRegInfo; // assumes that constant PHI operands will be zero extended, and failure to; // match that assumption will cause problems if we sign extend here but; // some user of a PHI is in a block for which we fall back to full SDAG; // instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:206,Modifiability,extend,extend,206,"// Note that the code in FunctionLoweringInfo::ComputePHILiveOutRegInfo; // assumes that constant PHI operands will be zero extended, and failure to; // match that assumption will cause problems if we sign extend here but; // some user of a PHI is in a block for which we fall back to full SDAG; // instruction selection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:74,Availability,redundant,redundant,74,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:304,Availability,redundant,redundant,304,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:427,Energy Efficiency,Power,PowerPC,427,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:19,Modifiability,extend,extends,19,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:84,Modifiability,extend,extend,84,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:163,Modifiability,Extend,Extend,163,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:8,Performance,load,loads,8,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:126,Performance,load,load,126,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:74,Safety,redund,redundant,74,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:304,Safety,redund,redundant,304,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:414,Testability,test,test,414,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:501,Testability,test,tests,501,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:42,Modifiability,extend,extend,42,// Combine load followed by zero- or sign-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:11,Performance,load,load,11,// Combine load followed by zero- or sign-extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:20,Modifiability,extend,extending,20,/* There is no sign-extending load-byte instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:30,Performance,load,load-byte,30,/* There is no sign-extending load-byte instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:66,Energy Efficiency,efficient,efficient,66,"// Defer to normal argument lowering for now. It's reasonably; // efficient. Consider doing something like ARM to handle the; // case where all args fit in registers, no varargs, no float; // or vector args.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:103,Energy Efficiency,Power,PowerPC,103,"// Handle materializing integer constants into a register. This is not; // automatically generated for PowerPC, so must be explicitly created here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:466,Safety,Avoid,Avoid,466,"// Override for ADDI and ADDI8 to set the correct register class; // on RHS operand 0. The automatic infrastructure naively assumes; // GPRC for i32 and G8RC for i64; the concept of ""no R0"" is lost; // for these cases. At the moment, none of the other automatically; // generated RI instructions require special treatment. However, once; // SelectSelect is implemented, ""isel"" requires similar handling.; //; // Also be conservative about the output register class. Avoid; // assigning R0 or X0 to the output register for GPRC and G8RC; // register classes, as any such result could be used in ADDI, etc.,; // where those regs have another meaning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:58,Safety,avoid,avoid,58,// Override for instructions with one register operand to avoid use of; // R0/X0. The automatic infrastructure isn't aware of the context so; // we must be conservative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:59,Safety,avoid,avoid,59,// Override for instructions with two register operands to avoid use; // of R0/X0. The automatic infrastructure isn't aware of the context; // so we must be conservative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:8,Availability,avail,available,8,// Only available on 64-bit for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:174,Energy Efficiency,allocate,allocate,174,"// CR save area offset. We map each of the nonvolatile CR fields; // to the slot for CR2, which is the first of the nonvolatile CR; // fields to be assigned, so that we only allocate one save slot.; // See PPCRegisterInfo::hasReservedSpillSlot() for more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:102,Deployability,Update,Update,102,/// determineFrameLayoutAndUpdate - Determine the size of the frame and maximum; /// call frame size. Update the MachineFunction object with the stack size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:30,Energy Efficiency,allocate,allocate,30,// Get the number of bytes to allocate from the FrameInfo,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:121,Energy Efficiency,allocate,allocated,121,"// No special alignment.; // Note: for PPC32 SVR4ABI, we can still generate stackless; // code if all local vars are reg-allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Deployability,Update,Update,3,// Update the new max call frame size if the caller passes in a valid pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:182,Integrability,depend,depending,182,"// FIXME: This is pretty much broken by design: hasFP() might be called really; // early, before the stack layout was calculated and thus hasFP() might return; // true or false here depending on the time of call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:136,Modifiability,variab,variable,136,// needsFP - Return true if the specified function should have a dedicated frame; // pointer register. This is true if the function has variable sized allocas or; // if frame pointer elimination is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:252,Availability,avail,available,252,"/* This function will do the following:; - If MBB is an entry or exit block, set SR1 and SR2 to R0 and R12; respectively (defaults recommended by the ABI) and return true; - If MBB is not an entry block, initialize the register scavenger and look; for available registers.; - If the defaults (R0/R12) are available, return true; - If TwoUniqueRegsRequired is set to true, it looks for two unique; registers. Otherwise, look for a single available register.; - If the required registers are found, set SR1 and SR2 and return true.; - If the required registers are not found, set SR2 or both SR1 and SR2 to; PPC::NoRegister and return false. Note that if both SR1 and SR2 are valid parameters and TwoUniqueRegsRequired; is not set, this function will attempt to find two different registers, but; still return true if only one register is available (and set SR1 == SR2).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:305,Availability,avail,available,305,"/* This function will do the following:; - If MBB is an entry or exit block, set SR1 and SR2 to R0 and R12; respectively (defaults recommended by the ABI) and return true; - If MBB is not an entry block, initialize the register scavenger and look; for available registers.; - If the defaults (R0/R12) are available, return true; - If TwoUniqueRegsRequired is set to true, it looks for two unique; registers. Otherwise, look for a single available register.; - If the required registers are found, set SR1 and SR2 and return true.; - If the required registers are not found, set SR2 or both SR1 and SR2 to; PPC::NoRegister and return false. Note that if both SR1 and SR2 are valid parameters and TwoUniqueRegsRequired; is not set, this function will attempt to find two different registers, but; still return true if only one register is available (and set SR1 == SR2).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:437,Availability,avail,available,437,"/* This function will do the following:; - If MBB is an entry or exit block, set SR1 and SR2 to R0 and R12; respectively (defaults recommended by the ABI) and return true; - If MBB is not an entry block, initialize the register scavenger and look; for available registers.; - If the defaults (R0/R12) are available, return true; - If TwoUniqueRegsRequired is set to true, it looks for two unique; registers. Otherwise, look for a single available register.; - If the required registers are found, set SR1 and SR2 and return true.; - If the required registers are not found, set SR2 or both SR1 and SR2 to; PPC::NoRegister and return false. Note that if both SR1 and SR2 are valid parameters and TwoUniqueRegsRequired; is not set, this function will attempt to find two different registers, but; still return true if only one register is available (and set SR1 == SR2).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:837,Availability,avail,available,837,"/* This function will do the following:; - If MBB is an entry or exit block, set SR1 and SR2 to R0 and R12; respectively (defaults recommended by the ABI) and return true; - If MBB is not an entry block, initialize the register scavenger and look; for available registers.; - If the defaults (R0/R12) are available, return true; - If TwoUniqueRegsRequired is set to true, it looks for two unique; registers. Otherwise, look for a single available register.; - If the required registers are found, set SR1 and SR2 and return true.; - If the required registers are not found, set SR2 or both SR1 and SR2 to; PPC::NoRegister and return false. Note that if both SR1 and SR2 are valid parameters and TwoUniqueRegsRequired; is not set, this function will attempt to find two different registers, but; still return true if only one register is available (and set SR1 == SR2).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:28,Availability,avail,available,28,"// If the two registers are available, we're all good.; // Note that we only return here if both R0 and R12 are available because; // although the function may not require two unique registers, it may benefit; // from having two so we should try to provide them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:112,Availability,avail,available,112,"// If the two registers are available, we're all good.; // Note that we only return here if both R0 and R12 are available because; // although the function may not require two unique registers, it may benefit; // from having two so we should try to provide them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:15,Availability,avail,available,15,// Get all the available registers in the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:83,Availability,avail,available,83,// We shouldn't use callee-saved registers as scratch registers as they may be; // available when looking for a candidate block for shrink wrapping but not; // available when the actual prologue/epilogue is being emitted because they; // were added as live-in to the prologue block by PrologueEpilogueInserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:160,Availability,avail,available,160,// We shouldn't use callee-saved registers as scratch registers as they may be; // available when looking for a candidate block for shrink wrapping but not; // available when the actual prologue/epilogue is being emitted because they; // were added as live-in to the prologue block by PrologueEpilogueInserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:139,Integrability,wrap,wrapping,139,// We shouldn't use callee-saved registers as scratch registers as they may be; // available when looking for a candidate block for shrink wrapping but not; // available when the actual prologue/epilogue is being emitted because they; // were added as live-in to the prologue block by PrologueEpilogueInserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Availability,avail,available,47,// Set the first scratch register to the first available one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:27,Availability,avail,available,27,"// If there is another one available, set the second scratch register to that.; // Otherwise, set it to either PPC::NoRegister if this function requires two; // or to whatever SR1 is set to if this function doesn't require two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:174,Availability,avail,available,174,"// We need a scratch register for spilling LR and for spilling CR. By default,; // we use two scratch registers to hide latency. However, if only one scratch; // register is available, we can adjust for that by not overlapping the spill; // code. However, if we need to realign the stack (i.e. have a base pointer); // and the stack frame is large, we need two scratch registers.; // Also, stack probe requires two scratch registers, one for old sp, one for; // large frame and large probe size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:120,Performance,latency,latency,120,"// We need a scratch register for spilling LR and for spilling CR. By default,; // we use two scratch registers to hide latency. However, if only one scratch; // register is available, we can adjust for that by not overlapping the spill; // code. However, if we need to realign the stack (i.e. have a base pointer); // and the stack frame is large, we need two scratch registers.; // Also, stack probe requires two scratch registers, one for old sp, one for; // large frame and large probe size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Safety,Abort,Abort,3,// Abort if there is no register info or function info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:23,Deployability,update,update,23,// Only move the stack update on ELFv2 ABI and PPC64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:220,Deployability,update,update,220,// Check the frame size first and return false if it does not fit the; // requirements.; // We need a non-zero frame size as well as a frame that will fit in the red; // zone. This is because by moving the stack pointer update we are now storing; // to the red zone until the stack pointer is updated. If we get an interrupt; // inside the prologue but before the stack update we now have a number of; // stores to the red zone and those stores must all fit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:293,Deployability,update,updated,293,// Check the frame size first and return false if it does not fit the; // requirements.; // We need a non-zero frame size as well as a frame that will fit in the red; // zone. This is because by moving the stack pointer update we are now storing; // to the red zone until the stack pointer is updated. If we get an interrupt; // inside the prologue but before the stack update we now have a number of; // stores to the red zone and those stores must all fit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:370,Deployability,update,update,370,// Check the frame size first and return false if it does not fit the; // requirements.; // We need a non-zero frame size as well as a frame that will fit in the red; // zone. This is because by moving the stack pointer update we are now storing; // to the red zone until the stack pointer is updated. If we get an interrupt; // inside the prologue but before the stack update we now have a number of; // stores to the red zone and those stores must all fit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:213,Deployability,update,updates,213,// Frame pointers and base pointers complicate matters so don't do anything; // if we have them. For example having a frame pointer will sometimes require; // a copy of r1 into r31 and that makes keeping track of updates to r1 more; // difficult. Similar situation exists with setjmp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:253,Deployability,update,update,253,// Calls to fast_cc functions use different rules for passing parameters on; // the stack from the ABI and using PIC base in the function imposes; // similar restrictions to using the base pointer. It is not generally safe; // to move the stack pointer update in these situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:218,Safety,safe,safe,218,// Calls to fast_cc functions use different rules for passing parameters on; // the stack from the ABI and using PIC base in the function imposes; // similar restrictions to using the base pointer. It is not generally safe; // to move the stack pointer update in these situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:33,Deployability,update,update,33,// Finally we can move the stack update if we do not require register; // scavenging. Register scavenging can introduce more spills and so; // may make the frame size larger than we have computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:18,Testability,assert,assert,18,"// Regarding this assert: Even though LR is saved in the caller's frame (i.e.,; // LROffset is positive), that slot is callee-owned. Because PPC32 SVR4 has no; // Red Zone, an asynchronous event (a form of ""callee"") could claim a frame &; // overwrite it, so PPC32 SVR4 must claim at least a minimal frame to save LR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:23,Modifiability,variab,variable,23,// Using the same bool variable as below to suppress compiler warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:99,Usability,simpl,simple,99,// Frames of 32KB & larger require special handling because they cannot be; // indexed into with a simple STDU/STWU/STD/STW immediate offset operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:60,Availability,down,down,60,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:34,Deployability,update,update,34,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:185,Deployability,update,update,185,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:210,Deployability,update,update,210,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:125,Safety,avoid,avoid,125,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:34,Deployability,update,update,34,// Check if we can move the stack update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:198,Deployability,update,update,198,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:342,Deployability,update,update,342,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:480,Deployability,update,update,480,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:569,Deployability,update,update,569,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:546,Safety,abort,abort,546,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:194,Deployability,update,update,194,// If the frame index is not negative the callee saved info belongs to a; // stack object that is not a fixed stack object. We ignore non-fixed; // stack objects because we won't move the stack update pointer past them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:82,Safety,abort,abort,82,"// We need all of the Frame Indices to meet these conditions.; // If they do not, abort the whole operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:41,Deployability,update,update,41,// If the operation was not aborted then update the object offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:28,Safety,abort,aborted,28,// If the operation was not aborted then update the object offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Integrability,depend,depends,47,"// Where in the prologue we move the CR fields depends on how many scratch; // registers we have, and if we need to save the link register or not. This; // lambda is to avoid duplicating the logic in 2 places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:169,Safety,avoid,avoid,169,"// Where in the prologue we move the CR fields depends on how many scratch; // registers we have, and if we need to save the link register or not. This; // lambda is to avoid duplicating the logic in 2 places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:191,Testability,log,logic,191,"// Where in the prologue we move the CR fields depends on how many scratch; // registers we have, and if we need to save the link register or not. This; // lambda is to avoid duplicating the logic in 2 places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:114,Energy Efficiency,efficient,efficient,114,"// In the ELFv2 ABI, we are not required to save all CR fields.; // If only one CR field is clobbered, it is more efficient to use; // mfocrf to selectively save just that field, because mfocrf has short; // latency compares to mfcr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:208,Performance,latency,latency,208,"// In the ELFv2 ABI, we are not required to save all CR fields.; // If only one CR field is clobbered, it is more efficient to use; // mfocrf to selectively save just that field, because mfocrf has short; // latency compares to mfcr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:86,Availability,avail,available,86,"// If we need to spill the CR and the LR but we don't have two separate; // registers available, we must spill them one at a time",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:173,Security,hash,hash,173,// Generate the instruction to store the LR. In the case where ROP protection; // is required the register holding the LR should not be killed as it will be; // used by the hash store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:26,Security,Hash,Hash,26,"// Add the ROP protection Hash Store instruction.; // NOTE: This is technically a violation of the ABI. The hash can be saved; // up to 512 bytes into the Protected Zone. This can be outside of the; // initial 288 byte volatile program storage region in the Protected Zone.; // However, this restriction will be removed in an upcoming revision of the; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:108,Security,hash,hash,108,"// Add the ROP protection Hash Store instruction.; // NOTE: This is technically a violation of the ABI. The hash can be saved; // up to 512 bytes into the Protected Zone. This can be outside of the; // initial 288 byte volatile program storage region in the Protected Zone.; // However, this restriction will be removed in an upcoming revision of the; // ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:21,Deployability,update,update,21,"// If we use STUX to update the stack pointer, we need the two scratch; // registers TempReg and ScratchReg, we have to save LR here which is stored; // in ScratchReg.; // If the offset can not be encoded into the store instruction, we also have; // to save LR here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:49,Energy Efficiency,POWER,POWER,49,"// If FrameSize <= TLI.getStackProbeSize(MF), as POWER ABI requires backchain; // pointer is always stored at SP, we will get a free probe due to an essential; // STU(X) instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:78,Deployability,update,update,78,"// FIXME: HasSTUX is only read if HasRedZone is not set, in such case, we; // update the ScratchReg to meet the assumption that ScratchReg contains; // the NegFrameSize. This solution is rather tricky.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:49,Deployability,update,update,49,// Save the TOC register after the stack pointer update if a prologue TOC; // save is required for the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:367,Availability,avail,available,367,"// The negated frame size is in ScratchReg, and the SPReg has been; // decremented by the frame size: SPReg = old SPReg + ScratchReg.; // Since FPOffset, PBPOffset, etc. are relative to the beginning of; // the stack frame (i.e. the old SP), ideally, we would put the old; // SP into a register and use it as the base for the stores. The; // problem is that the only available register may be ScratchReg,; // which could be R0, and R0 cannot be used as a base address.; // First, set ScratchReg to the old SP. This may need to be modified; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:168,Energy Efficiency,allocate,allocated,168,"// ScratchReg is not R0, so use it as the base register. It is; // already set to the old SP, so we can use the offsets directly.; // Now that the stack frame has been allocated, save all the necessary; // registers using ScratchReg as the base address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:132,Usability,undo,undo,132,// We have changed the object offset above but we do not want to change; // the actual offsets in the CFI instruction so we have to undo the; // offset change here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:192,Deployability,update,update,192,"// Used to probe stack when realignment is required.; // Note that, according to ABI's requirement, *sp must always equals the; // value of back-chain pointer, only st(w|d)u(x) can be used to update sp.; // Following is pseudo code:; // final_sp = (sp & align) + negframesize;; // neg_gap = final_sp - sp;; // while (neg_gap < negprobesize) {; // stdu fp, negprobesize(sp);; // neg_gap -= negprobesize;; // }; // stdux fp, sp, neg_gap; //; // When HasBP & HasRedzone, back-chain pointer is already saved in BPReg; // before probe code, we don't need to save it, so we get one additional reg; // that can be used to materialize the probeside if needed to use xform.; // Otherwise, we can NOT materialize probeside, so we can only use Dform for; // now.; //; // The allocations are:; // if (HasBP && HasRedzone) {; // r0: materialize the probesize if needed so that we can use xform.; // r12: `neg_gap`; // } else {; // r0: back-chain pointer; // r12: `neg_gap`.; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Deployability,Update,Update,3,// Update liveins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:64,Performance,perform,performing,64,"// For case HasBP && MaxAlign > 1, we have to realign the SP by performing; // SP = SP - SP % MaxAlign, thus make the probe more like dynamic probe since; // the offset subtracted from SP is determined by SP's runtime value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:131,Safety,safe,safe,131,"// Since CTR is a volatile register and current shrinkwrap implementation; // won't choose an MBB in a loop as the PrologMBB, it's safe to synthesize a; // CTR loop to probe.; // Calculate trip count and stores it in CTRReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Deployability,Update,Update,3,// Update liveins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:27,Energy Efficiency,allocate,allocated,27,// Get the number of bytes allocated from the FrameInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:23,Modifiability,variab,variable,23,// Using the same bool variable as below to suppress compiler warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:99,Usability,simpl,simple,99,// Frames of 32KB & larger require special handling because they cannot be; // indexed into with a simple LD/LWZ immediate offset operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:555,Deployability,update,update,555,"// On targets without red zone, the SP needs to be restored last, so that; // all live contents of the stack frame are upwards of the SP. This means; // that we cannot restore SP just now, since there may be more registers; // to restore from the stack frame (e.g. R31). If the frame size is not; // a simple immediate value, we will need a spare register to hold the; // restored SP. If the frame size is known and small, we can simply adjust; // the offsets of the registers to be restored, and still use SP to restore; // them. In such case, the final update of SP will be to add the frame; // size to it.; // To simplify the code, set RBReg to the base register used to restore; // values from the stack, and set SPAdd to the value that needs to be added; // to the SP at the end. The default values are as if red zone was present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:302,Usability,simpl,simple,302,"// On targets without red zone, the SP needs to be restored last, so that; // all live contents of the stack frame are upwards of the SP. This means; // that we cannot restore SP just now, since there may be more registers; // to restore from the stack frame (e.g. R31). If the frame size is not; // a simple immediate value, we will need a spare register to hold the; // restored SP. If the frame size is known and small, we can simply adjust; // the offsets of the registers to be restored, and still use SP to restore; // them. In such case, the final update of SP will be to add the frame; // size to it.; // To simplify the code, set RBReg to the base register used to restore; // values from the stack, and set SPAdd to the value that needs to be added; // to the SP at the end. The default values are as if red zone was present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:430,Usability,simpl,simply,430,"// On targets without red zone, the SP needs to be restored last, so that; // all live contents of the stack frame are upwards of the SP. This means; // that we cannot restore SP just now, since there may be more registers; // to restore from the stack frame (e.g. R31). If the frame size is not; // a simple immediate value, we will need a spare register to hold the; // restored SP. If the frame size is known and small, we can simply adjust; // the offsets of the registers to be restored, and still use SP to restore; // them. In such case, the final update of SP will be to add the frame; // size to it.; // To simplify the code, set RBReg to the base register used to restore; // values from the stack, and set SPAdd to the value that needs to be added; // to the SP at the end. The default values are as if red zone was present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:616,Usability,simpl,simplify,616,"// On targets without red zone, the SP needs to be restored last, so that; // all live contents of the stack frame are upwards of the SP. This means; // that we cannot restore SP just now, since there may be more registers; // to restore from the stack frame (e.g. R31). If the frame size is not; // a simple immediate value, we will need a spare register to hold the; // restored SP. If the frame size is known and small, we can simply adjust; // the offsets of the registers to be restored, and still use SP to restore; // them. In such case, the final update of SP will be to add the frame; // size to it.; // To simplify the code, set RBReg to the base register used to restore; // values from the stack, and set SPAdd to the value that needs to be added; // to the SP at the end. The default values are as if red zone was present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:34,Deployability,update,update,34,// Check if we can move the stack update instruction up the epilogue; // past the callee saves. This will allow the move to LR instruction; // to be executed before the restores of the callee saves which means; // that the callee saves can hide the latency from the MTLR instrcution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:249,Performance,latency,latency,249,// Check if we can move the stack update instruction up the epilogue; // past the callee saves. This will allow the move to LR instruction; // to be executed before the restores of the callee saves which means; // that the callee saves can hide the latency from the MTLR instrcution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:83,Deployability,update,update,83,// If the callee saved register is spilled to another register abort the; // stack update movement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:63,Safety,abort,abort,63,// If the callee saved register is spilled to another register abort the; // stack update movement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:188,Deployability,update,update,188,// If the frame index is not negative the callee saved info belongs to a; // stack object that is not a fixed stack object. We ignore non-fixed; // stack objects because we won't move the update of the stack pointer; // past them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:35,Deployability,update,update,35,// Abort the operation as we can't update all CSR restores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Safety,Abort,Abort,3,// Abort the operation as we can't update all CSR restores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:24,Performance,load,loaded,24,"// In the prologue, the loaded (or persistent) stack pointer value is; // offset by the STDU/STDUX/STWU/STWUX instruction. For targets with red; // zone add this offset back now.; // If the function has a base pointer, the stack pointer has been copied; // to it so we can restore it by copying in the other direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:239,Availability,avail,available,239,"// If there is no red zone, ScratchReg may be needed for holding a useful; // value (although not the base register). Make sure it is not overwritten; // too early.; // If we need to restore both the LR and the CR and we only have one; // available scratch register, we must do them one at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:31,Performance,load,loaded,31,"// There is nothing more to be loaded from the stack, so now we can; // restore SP: SP = RBReg + SPAdd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:7,Performance,load,load,7,// Now load the LR from the caller's stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:81,Security,hash,hash,81,"// If ROP protection is required, an extra instruction is added to compute a; // hash and then compare it to the hash stored in the prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:113,Security,hash,hash,113,"// If ROP protection is required, an extra instruction is added to compute a; // hash and then compare it to the hash stored in the prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:85,Performance,optimiz,optimization,85,// Callee pop calling convention. Pop parameter/linkage area. Used for tail; // call optimization,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:12,Usability,clear,clear,12,// Save and clear the LR state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the frame index for frame pointer save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the frame index for the base pointer save area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate the nonvolatile CR spill slot iff the function uses CR 2, 3, or 4.; // For 64-bit SVR4, and all flavors of AIX we create a FixedStack; // object at the offset of the CR-save slot in the linkage area. The actual; // save and restore of the condition register will be created as part of the; // prologue and epilogue insertion, but the FixedStack object is needed to; // keep the CalleSavedInfo valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:29,Integrability,wrap,wrapped,29,"// If the function is shrink-wrapped, and if the function has a tail call, the; // tail call might not be in the new RestoreBlock, so real branch instruction; // won't be generated by emitEpilogue(), because shrink-wrap has chosen new; // RestoreBlock. So we handle this case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:215,Integrability,wrap,wrap,215,"// If the function is shrink-wrapped, and if the function has a tail call, the; // tail call might not be in the new RestoreBlock, so real branch instruction; // won't be generated by emitEpilogue(), because shrink-wrap has chosen new; // RestoreBlock. So we handle this case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Energy Efficiency,allocate,allocated,47,"// Check whether the frame pointer register is allocated. If so, make sure it; // is spilled to the correct offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:32,Deployability,update,update,32,"// FP is R31/X31, so no need to update MinGPR/MinG8R.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Availability,down,down,47,"// Move general register save area spill slots down, taking into account; // the size of the Floating-point register save area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:47,Availability,down,down,47,"// Move general register save area spill slots down, taking into account; // the size of the Floating-point register save area.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:206,Availability,down,downward,206,"// Insert alignment padding, we need 16-byte alignment. Note: for positive; // number the alignment formula is : y = (x + (n-1)) & (~(n-1)). But since; // we are using negative number here (the stack grows downward). We should; // use formula : y = x & (~(n-1)). Where x is the size before aligning, n; // is the alignment size ( n = 16 here) and y is the size after aligning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:257,Availability,error,error,257,// Add the callee-saved register as live-in; it's killed at the spill.; // Do not do this for callee-saved registers that are live-in to the; // function because they will already be marked live-in and this will be; // adding it for a second time. It is an error to add the same register; // to the set more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Usability,Simpl,Simply,3,"// Simply discard ADJCALLSTACKDOWN, ADJCALLSTACKUP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:30,Testability,log,logic,30,// Initialize insertion-point logic; we will be restoring in reverse; // order of spill.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:109,Deployability,release,release,109,"// On PPC64, we use `stux r1, r1, <scratch_reg>` to extend the stack;; // use `add r1, r1, <scratch_reg>` to release the stack frame.; // Scratch register contains a signed 64-bit number, which is negative; // when extending the stack and is positive when releasing the stack frame.; // To make `stux` and `add` paired, the absolute value of the number contained; // in the scratch register should be the same. Thus the maximum stack size; // is (2^63)-1, i.e., LONG_MAX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:52,Modifiability,extend,extend,52,"// On PPC64, we use `stux r1, r1, <scratch_reg>` to extend the stack;; // use `add r1, r1, <scratch_reg>` to release the stack frame.; // Scratch register contains a signed 64-bit number, which is negative; // when extending the stack and is positive when releasing the stack frame.; // To make `stux` and `add` paired, the absolute value of the number contained; // in the scratch register should be the same. Thus the maximum stack size; // is (2^63)-1, i.e., LONG_MAX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:215,Modifiability,extend,extending,215,"// On PPC64, we use `stux r1, r1, <scratch_reg>` to extend the stack;; // use `add r1, r1, <scratch_reg>` to release the stack frame.; // Scratch register contains a signed 64-bit number, which is negative; // when extending the stack and is positive when releasing the stack frame.; // To make `stux` and `add` paired, the absolute value of the number contained; // in the scratch register should be the same. Thus the maximum stack size; // is (2^63)-1, i.e., LONG_MAX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:55,Energy Efficiency,Power,PowerPC,55,"//===-- PPCFrameLowering.h - Define frame lowering for PowerPC --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:112,Safety,avoid,avoid,112,// Map each group of one or two GPRs to corresponding VSR for spilling.; // TODO: Use local table in methods to avoid this mutable member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:258,Availability,avail,available,258,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:314,Availability,avail,available,314,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:490,Availability,avail,available,490,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:710,Availability,avail,available,710,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:1202,Availability,avail,available,1202,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:1434,Availability,avail,available,1434,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:1527,Availability,avail,available,1527,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:425,Integrability,depend,depending,425,"/**; * Find register[s] that can be used in function prologue and epilogue; *; * Find register[s] that can be use as scratch register[s] in function; * prologue and epilogue to save various registers (Link Register, Base; * Pointer, etc.). Prefer R0/R12, if available. Otherwise choose whatever; * register[s] are available.; *; * This method will return true if it is able to find enough unique scratch; * registers (1 or 2 depending on the requirement). If it is unable to find; * enough available registers in the block, it will return false and set; * any passed output parameter that corresponds to a required unique register; * to PPC::NoRegister.; *; * \param[in] MBB The machine basic block to find an available register for; * \param[in] UseAtEnd Specify whether the scratch register will be used at; * the end of the basic block (i.e., will the scratch; * register kill a register defined in the basic block); * \param[in] TwoUniqueRegsRequired Specify whether this basic block will; * require two unique scratch registers.; * \param[out] SR1 The scratch register to use; * \param[out] SR2 The second scratch register. If this pointer is not null; * the function will attempt to set it to an available; * register regardless of whether there is a hard requirement; * for two unique scratch registers.; * \return true if the required number of registers was found.; * false if the required number of scratch register weren't available.; * If either output parameter refers to a required scratch register; * that isn't available, it will be set to an invalid value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:66,Deployability,update,update,66,/**; * Check if the conditions are correct to allow for the stack update; * to be moved past the CSR save/restore code.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:38,Deployability,update,update,38,/**; * Determine the frame layout and update the machine function.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:45,Deployability,update,update,45,/**; * Determine the frame layout but do not update the machine function.; * The MachineFunction object can be const in this case as it is not; * modified.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:44,Energy Efficiency,Power,PowerPC,44,/// getLinkageSize - Return the size of the PowerPC ABI linkage area.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:27,Integrability,wrap,wrapping,27,/// Methods used by shrink wrapping to determine if MBB can be used for the; /// function prologue/epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp:491,Energy Efficiency,Power,PowerPC,491,"//===-- PPCGenScalarMASSEntries.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation converts standard math functions into their; // corresponding MASS (scalar) entries for PowerPC targets.; // Following are examples of such conversion:; // tanh ---> __xl_tanh_finite; // Such lowering is legal under the fast-math option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp:158,Deployability,update,updated,158,/// Lowers scalar math functions to scalar MASS functions.; /// e.g.: tanh --> __xl_tanh_finite or __xl_tanh; /// Both function prototype and its callsite is updated during lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCGenScalarMASSEntries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:35,Energy Efficiency,Power,PowerPC,35,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:427,Energy Efficiency,schedul,scheduling,427,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:441,Energy Efficiency,Power,PowerPC,441,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:43,Safety,Hazard,Hazard,43,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:404,Safety,hazard,hazard,404,"//===-- PPCHazardRecognizers.cpp - PowerPC Hazard Recognizer Impls --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:118,Integrability,depend,dependency,118,"// SU is a load; for any predecessors in this dispatch group, that are stores,; // and with which we have an ordering dependency, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:11,Performance,load,load,11,"// SU is a load; for any predecessors in this dispatch group, that are stores,; // and with which we have an ordering dependency, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:94,Integrability,depend,dependence,94,"// SU is a branch; for any predecessors in this dispatch group, with which we; // have a data dependence and set the counter register, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:6,Testability,log,logicals,6,// cr logicals,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:130,Energy Efficiency,schedul,scheduling,130,"// If we're using a special group-terminating nop, then we need only one.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:183,Energy Efficiency,schedul,scheduling,183,"// If the group has now filled all of its slots, or if we're using a special; // group-terminating nop, the group is complete.; // FIXME: the same for P9 as previous gen until POWER9 scheduling is ready",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:814,Availability,recover,recovery,814,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:85,Energy Efficiency,Power,PowerPC,85,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:770,Performance,perform,performance,770,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:992,Performance,load,loading,992,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:97,Safety,Hazard,Hazard,97,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:714,Safety,hazard,hazards,714,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:814,Safety,recover,recovery,814,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:1050,Safety,avoid,avoid,1050,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:839,Testability,log,logic,839,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:14,Safety,hazard,hazard,14,// Structural hazard info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:41,Performance,load,load,41,"/// isLoadOfStoredAddress - If we have a load from the previously stored pointer; /// as indicated by StorePtr1/StorePtr2/StoreSize, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:86,Performance,load,load,86,"// Okay the base pointers match, so we have [c1+r] vs [c2+r]. Check; // to see if the load and store actually overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:226,Deployability,pipeline,pipeline,226,/// getHazardType - We return hazard for any non-branch instruction that would; /// terminate the dispatch group. We turn NoopHazard for any; /// instructions that wouldn't terminate the dispatch group that would cause a; /// pipeline flush.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:30,Safety,hazard,hazard,30,/// getHazardType - We return hazard for any non-branch instruction that would; /// terminate the dispatch group. We turn NoopHazard for any; /// instructions that wouldn't terminate the dispatch group that would cause a; /// pipeline flush.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:16,Performance,load,load,16,"// If this is a load following a store, make sure it's not to the same or; // overlapping address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:3,Deployability,Update,Update,3,// Update structural hazard information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:21,Safety,hazard,hazard,21,// Update structural hazard information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:33,Energy Efficiency,Power,PowerPC,33,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:424,Energy Efficiency,schedul,scheduling,424,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:438,Energy Efficiency,Power,PowerPC,438,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:41,Safety,Hazard,Hazard,41,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:401,Safety,hazard,hazard,401,"//===-- PPCHazardRecognizers.h - PowerPC Hazard Recognizers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines hazard recognizers for scheduling on PowerPC processors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:87,Safety,hazard,hazard,87,/// PPCDispatchGroupSBHazardRecognizer - This class implements a scoreboard-based; /// hazard recognizer for PPC ooo processors with dispatch-group hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:148,Safety,hazard,hazards,148,/// PPCDispatchGroupSBHazardRecognizer - This class implements a scoreboard-based; /// hazard recognizer for PPC ooo processors with dispatch-group hazards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:115,Energy Efficiency,Power,PowerPC,115,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:282,Performance,perform,performance,282,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:413,Performance,load,loading,413,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:234,Safety,avoid,avoid,234,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:251,Safety,hazard,hazards,251,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:102,Testability,log,logic,102,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:101,Safety,hazard,hazard,101,"// Number of insts issued, including advanced cycles.; // Various things that can cause a structural hazard.; // HasCTRSet - If the CTR register is set in this group, disallow BCTRL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:67,Performance,load,load,67,"// StoredPtr - Keep track of the address of any store. If we see a load from; // the same address (or one that aliases it), disallow the store. We can have; // up to four stores in one dispatch group, hence we track up to 4.; //; // This is null if we haven't seen a store yet. We keep track of both; // operands of the store here, since we support [r+r] and [r+i] addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:79,Deployability,pipeline,pipeline,79,/// GetInstrType - Classify the specified powerpc opcode according to its; /// pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:42,Energy Efficiency,power,powerpc,42,/// GetInstrType - Classify the specified powerpc opcode according to its; /// pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h:393,Security,expose,exposes,393,"//===-- PPCInstrBuilder.h - Aides for building PPC insts --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to simplify generating frame and constant pool; // references.; //; // For reference, the order of operands for memory references is:; // (Operand), Dest Reg, Base Reg, and either Reg Index or Immediate; // Displacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h:484,Usability,simpl,simplify,484,"//===-- PPCInstrBuilder.h - Aides for building PPC insts --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes functions that may be used with BuildMI from the; // MachineInstrBuilder.h file to simplify generating frame and constant pool; // references.; //; // For reference, the order of operands for memory references is:; // (Operand), Dest Reg, Base Reg, and either Reg Index or Immediate; // Displacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:27,Energy Efficiency,Power,PowerPC,27,"//===-- PPCInstrInfo.cpp - PowerPC Instruction Information ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetInstrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCInstrInfo.cpp - PowerPC Instruction Information ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetInstrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:97,Energy Efficiency,schedul,scheduling,97,/// CreateTargetHazardRecognizer - Return the hazard recognizer to use for; /// this target when scheduling the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:46,Safety,hazard,hazard,46,/// CreateTargetHazardRecognizer - Return the hazard recognizer to use for; /// this target when scheduling the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:110,Energy Efficiency,schedul,scheduling,110,/// CreateTargetPostRAHazardRecognizer - Return the postRA hazard recognizer; /// to use for this target when scheduling the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:59,Safety,hazard,hazard,59,/// CreateTargetPostRAHazardRecognizer - Return the postRA hazard recognizer; /// to use for this target when scheduling the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:50,Energy Efficiency,schedul,scheduling,50,// FIXME: Leaving this as-is until we have POWER9 scheduling info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:182,Deployability,pipeline,pipelined,182,"// The default implementation of getInstrLatency calls getStageLatency, but; // getStageLatency does not do the right thing for us. While we have; // itinerary, most cores are fully pipelined, and so the itineraries only; // express the first part of the pipeline, not every stage. Instead, we need; // to use the listed output operand cycle number (using operand 0 here, which; // is an output).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:255,Deployability,pipeline,pipeline,255,"// The default implementation of getInstrLatency calls getStageLatency, but; // getStageLatency does not do the right thing for us. While we have; // itinerary, most cores are fully pipelined, and so the itineraries only; // express the first part of the pipeline, not every stage. Instead, we need; // to use the listed output operand cycle number (using operand 0 here, which; // is an output).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:158,Energy Efficiency,reduce,reduce,158,"// This function does not list all associative and commutative operations, but; // only those worth feeding through the machine combiner in an attempt to; // reduce the critical path. Mostly, this means floating-point operations,; // because they have high latencies(>=5) (compared to other operations, such as; // and/or, which are also associative and commutative, but have low latencies).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:637,Deployability,pipeline,pipeline,637,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:6,Energy Efficiency,Power,PowerPC,6,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:694,Energy Efficiency,Reduce,Reduce,694,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:543,Integrability,depend,dependency,543,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:658,Integrability,depend,depending,658,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:68,Energy Efficiency,reduce,reduce,68,// For now we only need to fix up placeholder for register pressure reduce; // patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Energy Efficiency,reduce,reduce,25,// Not register pressure reduce patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:28,Performance,load,load,28,// Generate instructions to load the const fp from constant pool.; // We only support PPC64 and medium code model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Performance,load,load,37,// Fill the placeholder with the new load from constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:399,Performance,load,load,399,"// Currently, we only enable register pressure reducing in machine combiner; // for: 1: PPC64; 2: Code Model is Medium; 3: Power9 which also has vector; // support.; //; // So we need following instructions to access a TOC entry:; //; // %6:g8rc_and_g8rc_nox0 = ADDIStocHA8 $x2, %const.0; // %7:vssrc = DFLOADf32 target-flags(ppc-toc-lo) %const.0,; // killed %6:g8rc_and_g8rc_nox0, implicit $x2 :: (load 4 from constant-pool); //; // FIXME: add more supported targets, like Small and Large code model, PPC32,; // AIX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:210,Security,access,access,210,"// Currently, we only enable register pressure reducing in machine combiner; // for: 1: PPC64; 2: Code Model is Medium; 3: Power9 which also has vector; // support.; //; // So we need following instructions to access a TOC entry:; //; // %6:g8rc_and_g8rc_nox0 = ADDIStocHA8 $x2, %const.0; // %7:vssrc = DFLOADf32 target-flags(ppc-toc-lo) %const.0,; // killed %6:g8rc_and_g8rc_nox0, implicit $x2 :: (load 4 from constant-pool); //; // FIXME: add more supported targets, like Small and Large code model, PPC32,; // AIX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:8,Energy Efficiency,reduce,reduce,8,// Only reduce register pressure when pressure is high.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:42,Performance,load,load,42,// I has only one memory operand which is load from constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:101,Security,access,access,101,"// Now we only support PPC64, Medium code model and P9 with vector.; // We have immutable pattern to access const pool. See function; // shouldReduceRegisterPressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,Performance,Load,Load,12,// Generate Load from constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:18,Performance,load,load,18,// Insert the toc load instructions into InsInstrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:75,Performance,load,load,75,// This function returns the const value in constant pool if the \p I is a load; // from constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:103,Performance,optimiz,optimizations,103,"// Using the machine combiner in this way is potentially expensive, so; // restrict to when aggressive optimizations are desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update flags for newly created instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update flags for newly created instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:395,Performance,load,load,395,"// We don't want to get negative const from memory pool too early, as the; // created entry will not be deleted even if it has no users. Since all; // operand of Leaf and Root are virtual register, we use zero register; // here as a placeholder. When the InsInstrs is selected in; // MachineCombiner, we call finalizeInsInstrs to replace the zero register; // with a virtual register which is a load from constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Safety,Detect,Detect,3,// Detect 32 -> 64-bit extensions where we may reuse the low sub-register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:184,Availability,mask,mask,184,"// Note that RLWIMI can be commuted as a 32-bit instruction, but not as a; // 64-bit instruction (so we don't handle PPC::RLWIMI8 here), because; // changing the relative order of the mask operands might change what happens; // to the high-bits of the mask (and, thus, the result).; // Cannot commute if it has a non-zero rotate count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:252,Availability,mask,mask,252,"// Note that RLWIMI can be commuted as a 32-bit instruction, but not as a; // 64-bit instruction (so we don't handle PPC::RLWIMI8 here), because; // changing the relative order of the mask operands might change what happens; // to the high-bits of the mask (and, thus, the result).; // Cannot commute if it has a non-zero rotate count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:52,Availability,mask,mask,52,"// If we have a zero rotate count, we have:; // M = mask(MB,ME); // Op0 = (Op1 & ~M) | (Op2 & M); // Change this to:; // M = mask((ME+1)&31, (MB-1)&31); // Op0 = (Op2 & ~M) | (Op1 & M); // Swap op1/op2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:125,Availability,mask,mask,125,"// If we have a zero rotate count, we have:; // M = mask(MB,ME); // Op0 = (Op1 & ~M) | (Op2 & M); // Change this to:; // M = mask((ME+1)&31, (MB-1)&31); // Op0 = (Op2 & ~M) | (Op1 & M); // Swap op1/op2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:57,Deployability,update,update,57,"// If machine instrs are no longer in two-address forms, update; // destination register as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Availability,Mask,Masks,3,// Masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:30,Availability,mask,mask,30,// We can't commute a trivial mask (there is no way to represent an all-zero; // mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:81,Availability,mask,mask,81,// We can't commute a trivial mask (there is no way to represent an all-zero; // mask).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,Availability,mask,mask,12,// Swap the mask around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:29,Energy Efficiency,schedul,scheduling,29,"// This function is used for scheduling, and the nop wanted here is the type; // that terminates dispatch groups on the POWER cores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:120,Energy Efficiency,POWER,POWER,120,"// This function is used for scheduling, and the nop wanted here is the type; // that terminates dispatch groups on the POWER cores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Deployability,Update,Update,10,/* FIXME: Update when P8 InstrScheduling model is ready */; // FIXME: Update when POWER9 scheduling model is ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:70,Deployability,Update,Update,70,/* FIXME: Update when P8 InstrScheduling model is ready */; // FIXME: Update when POWER9 scheduling model is ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:89,Energy Efficiency,schedul,scheduling,89,/* FIXME: Update when P8 InstrScheduling model is ready */; // FIXME: Update when POWER9 scheduling model is ready.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:6,Deployability,update,update,6,// We update iterator after deleting the last branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:146,Performance,latency,latency,146,"// FIXME: These numbers are for the A2, how well they work for other cores is; // an open question. On the A2, the isel instruction has a 2-cycle latency; // but single-cycle throughput. These numbers are used in combination with; // the MispredictPenalty setting from the active SchedMachineModel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:175,Performance,throughput,throughput,175,"// FIXME: These numbers are for the A2, how well they work for other cores is; // an open question. On the A2, the isel instruction has a 2-cycle latency; // but single-cycle throughput. These numbers are used in combination with; // the MispredictPenalty setting from the active SchedMachineModel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:83,Availability,mask,mask,83,// Rotate the CR bit in the CR fields to be the least significant bit and; // then mask with 0x1 (MB = ME = 31).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:141,Deployability,pipeline,pipeline,141,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:247,Deployability,pipeline,pipeline,247,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:80,Performance,latency,latency,80,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:191,Performance,latency,latency,191,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:408,Performance,latency,latency,408,"// There are two different ways this can be done:; // 1. xxlor : This has lower latency (on the P7), 2 cycles, but can only; // issue in VSU pipeline 0.; // 2. xmovdp/xmovsp: This has higher latency (on the P7), 6 cycles, but; // can go to either pipeline.; // We'll always use xxlor here, because in practically all cases where; // copies are generated, they are close enough to some use that the; // lower-latency form is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:219,Performance,load,load,219,// We need to avoid a situation in which the value from a VRRC register is; // spilled using an Altivec instruction and reloaded into a VSRC register; // using a VSX instruction. The issue with this is that the VSX; // load/store instructions swap the doublewords in the vector and the Altivec; // ones don't. The register classes on the spill/reload may be different if; // the register is defined using an Altivec instruction and is then used by a; // VSX instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:14,Safety,avoid,avoid,14,// We need to avoid a situation in which the value from a VRRC register is; // spilled using an Altivec instruction and reloaded into a VSRC register; // using a VSX instruction. The issue with this is that the VSX; // load/store instructions swap the doublewords in the vector and the Altivec; // ones don't. The register classes on the spill/reload may be different if; // the register is defined using an Altivec instruction and is then used by a; // VSX instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:219,Performance,load,load,219,// We need to avoid a situation in which the value from a VRRC register is; // spilled using an Altivec instruction and reloaded into a VSRC register; // using a VSX instruction. The issue with this is that the VSX; // load/store instructions swap the doublewords in the vector and the Altivec; // ones don't. The register classes on the spill/reload may be different if; // the register is defined using an Altivec instruction and is then used by a; // VSX instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:14,Safety,avoid,avoid,14,// We need to avoid a situation in which the value from a VRRC register is; // spilled using an Altivec instruction and reloaded into a VSRC register; // using a VSX instruction. The issue with this is that the VSX; // load/store instructions swap the doublewords in the vector and the Altivec; // ones don't. The register classes on the spill/reload may be different if; // the register is defined using an Altivec instruction and is then used by a; // VSX instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:97,Performance,perform,performs,97,"// For some instructions, it is legal to fold ZERO into the RA register field.; // This function performs that fold by replacing the operand with PPC::ZERO,; // it does not consider whether the load immediate zero is no longer in use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:194,Performance,load,load,194,"// For some instructions, it is legal to fold ZERO into the RA register field.; // This function performs that fold by replacing the operand with PPC::ZERO,; // it does not consider whether the load immediate zero is no longer in use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Performance,load,loaded,37,// A zero immediate should always be loaded with a single li.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:208,Testability,log,logical,208,"// Note that we cannot here invert the arguments of an isel in order to fold; // a ZERO into what is presented as the second argument. All we have here; // is the condition bit, and that might come from a CR-logical bit operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:104,Usability,UX,UX,104,"// Make sure this is not tied to an output register (or otherwise; // constrained). This is true for ST?UX registers, for example, which; // are tied to their output registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:45,Performance,load,load,45,// Folds zero into instructions which have a load immediate zero as an operand; // but also recognize zero as immediate zero. If the definition of the load; // has no more users it is deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:151,Performance,load,load,151,// Folds zero into instructions which have a load immediate zero as an operand; // but also recognize zero as immediate zero. If the definition of the load; // has no more users it is deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Energy Efficiency,schedul,scheduling,25,"// Set MFFS and MTFSF as scheduling boundary to avoid unexpected code motion; // across them, since some FP operations may change content of FPSCR.; // TODO: Model FPSCR in PPC instruction definitions and remove the workaround",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:48,Safety,avoid,avoid,48,"// Set MFFS and MTFSF as scheduling boundary to avoid unexpected code motion; // across them, since some FP operations may change content of FPSCR.; // TODO: Model FPSCR in PPC instruction definitions and remove the workaround",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:34,Testability,test,test,34,// P1 can only subsume P2 if they test the same condition register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:419,Integrability,depend,depend,419,"// The record forms set the condition register based on a signed comparison; // with zero (so says the ISA manual). This is not as straightforward as it; // seems, however, because this is always a 64-bit comparison on PPC64, even; // for instructions that are 32-bit in nature (like slw for example).; // So, on PPC32, for unsigned comparisons, we can use the record forms only; // for equality checks (as those don't depend on the sign). On PPC64,; // we are restricted to equality for unsigned 64-bit comparisons and for; // signed 32-bit comparisons the applicability is more restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:59,Modifiability,extend,extending,59,// We can perform this optimization only if SrcReg is sign-extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Performance,perform,perform,10,// We can perform this optimization only if SrcReg is sign-extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:23,Performance,optimiz,optimization,23,// We can perform this optimization only if SrcReg is sign-extending.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:74,Modifiability,extend,extending,74,"// We can perform this optimization, equality only, if SrcReg is; // zero-extending.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Performance,perform,perform,10,"// We can perform this optimization, equality only, if SrcReg is; // zero-extending.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:23,Performance,optimiz,optimization,23,"// We can perform this optimization, equality only, if SrcReg is; // zero-extending.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:144,Safety,avoid,avoid,144,// FIXME: Conservatively refuse to convert an instruction which isn't in the; // same BB as the comparison. This is to allow the check below to avoid calls; // (and other explicit clobbers); instead we should really check for these; // more explicitly (in at least a few predecessors).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:355,Performance,optimiz,optimize,355,"// The record-form instructions set CR bit based on signed comparison; // against 0. We try to convert a compare against 1 or -1 into a compare; // against 0 to exploit record-form instructions. For example, we change; // the condition ""greater than -1"" into ""greater than or equal to 0""; // and ""less than 1"" into ""less than or equal to 0"".; // Since we optimize comparison based on a specific branch condition,; // we don't optimize if condition code is used by more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:426,Performance,optimiz,optimize,426,"// The record-form instructions set CR bit based on signed comparison; // against 0. We try to convert a compare against 1 or -1 into a compare; // against 0 to exploit record-form instructions. For example, we change; // the condition ""greater than -1"" into ""greater than or equal to 0""; // and ""less than 1"" into ""less than or equal to 0"".; // Since we optimize comparison based on a specific branch condition,; // we don't optimize if condition code is used by more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:149,Performance,optimiz,optimization,149,// Convert the comparison and its user to a compare against zero with the; // appropriate predicate on the branch. Zero comparison might provide; // optimization opportunities post-RA (see optimization in; // PPCPreEmitPeephole.cpp).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:189,Performance,optimiz,optimization,189,// Convert the comparison and its user to a compare against zero with the; // appropriate predicate on the branch. Zero comparison might provide; // optimization opportunities post-RA (see optimization in; // PPCPreEmitPeephole.cpp).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Availability,redundant,redundant,38,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Safety,redund,redundant,38,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:30,Energy Efficiency,POWER,POWER,30,"// FIXME: On the non-embedded POWER architectures, only some of the record; // forms are fast, and we should use only the fast ones.; // The defining instruction has a record form (or is already a record; // form). It is possible, however, that we'll need to reverse the condition; // code of the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Performance,perform,performed,37,"// This transformation should not be performed if `nsw` is missing and is not; // `equalityOnly` comparison. Since if there is overflow, sub_lt, sub_gt in; // CRReg do not reflect correct order. If `equalityOnly` is true, sub_eq in; // CRReg can reflect if compared values are equal, this optz is still valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:91,Deployability,update,updated,91,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on CMP; // needs to be updated to be based on SUB. Push the condition code; // operands to OperandsToUpdate. If it is safe to remove CmpInstr, the; // condition code of these operands will be modified.; // Here, Value == 0 means we haven't converted comparison against 1 or -1 to; // comparison against 0, which may modify predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:186,Safety,safe,safe,186,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on CMP; // needs to be updated to be based on SUB. Push the condition code; // operands to OperandsToUpdate. If it is safe to remove CmpInstr, the; // condition code of these operands will be modified.; // Here, Value == 0 means we haven't converted comparison against 1 or -1 to; // comparison against 0, which may modify predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:26,Deployability,release,release,26,// To suppress warning in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:14,Safety,abort,abort,14,// We need to abort on a user we don't understand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:48,Availability,alive,alive,48,"// Even if CR0 register were dead before, it is alive now since the; // instruction we just built uses it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:56,Availability,mask,mask,56,// We can only do this if both the start and end of the mask are in the; // same halfword.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:7,Availability,mask,mask,7,// The mask value needs to shift right 16 if we're emitting andis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:64,Availability,mask,mask,64,"// If we are rotating by the exact number of bits as are in the mask; // and the mask is in the least significant bits of the register,; // that's just an andis. (as long as the GPR result has no uses).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:81,Availability,mask,mask,81,"// If we are rotating by the exact number of bits as are in the mask; // and the mask is in the least significant bits of the register,; // that's just an andis. (as long as the GPR result has no uses).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:20,Availability,mask,mask,20,"// If we've set the mask, we can transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Performance,optimiz,optimize,10,// Try to optimize the comparison against 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:107,Performance,optimiz,optimizeCompareInstr,107,"// The record forms set the condition register based on a signed comparison; // with zero (see comments in optimizeCompareInstr). Since we can't do the; // equality checks in post-RA, we are more restricted on a unsigned; // comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Performance,load,load,25,"// If this is a volatile load/store, don't mess with it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:76,Deployability,update,update,76,"// Can't cluster if the instruction modifies the base register; // or it is update form. e.g. ld r2,3(r2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:102,Energy Efficiency,Power,PowerPC,102,"// Only cluster instruction pair that have the same opcode, and they are; // clusterable according to PowerPC specification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC backend has opcode STW/STW8 for instruction ""stw"" to deal with; // 32bit and 64bit instruction selection. They are clusterable pair though; // they are different opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,load,15,// Cluster the load/store only when they have the same base; // register or FI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:60,Energy Efficiency,Power,PowerPC,60,// Check if the load/store are clusterable according to the PowerPC; // specification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:16,Performance,load,load,16,// Check if the load/store are clusterable according to the PowerPC; // specification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:112,Energy Efficiency,Power,PowerPC,112,"// Cluster the load/store only when they have the same opcode, and they are; // clusterable opcode according to PowerPC specification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,load,15,"// Cluster the load/store only when they have the same opcode, and they are; // clusterable opcode according to PowerPC specification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:17,Performance,load,load,17,// Can't cluster load/store that have ordered or volatile memory reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:28,Availability,mask,mask,28,// PPC always uses a direct mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:198,Performance,latency,latency,198,// Expand VSX Memory Pseudo instruction to either a VSX or a FP instruction.; // The VSX versions have the advantage of a full 64-register target whereas; // the FP ones have the advantage of lower latency and higher throughput. So; // what we are after is using the faster instructions in low register pressure; // situations and using the larger register file in high register pressure; // situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:217,Performance,throughput,throughput,217,// Expand VSX Memory Pseudo instruction to either a VSX or a FP instruction.; // The VSX versions have the advantage of a full 64-register target whereas; // the FP ones have the advantage of lower latency and higher throughput. So; // what we are after is using the faster instructions in low register pressure; // situations and using the larger register file in high register pressure; // situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Energy Efficiency,Power,PowerPC,37,// FIXME: Maybe we can expand it in 'PowerPC Expand Atomic' pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:254,Integrability,depend,depending,254,"// Essentially a compile-time implementation of a compare->isel sequence.; // It takes two constants to compare, along with the true/false registers; // and the comparison type (as a subreg to a CR field) and returns one; // of the true/false registers, depending on the comparison results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:61,Modifiability,extend,extended,61,// Signed comparisons. The immediates are assumed to be sign-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:73,Performance,load,load-immediate,73,// Is this register defined by some form of add-immediate (including; // load-immediate) within this basic block?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:98,Modifiability,variab,variables,98,"// This opt tries to convert the following imm form to an index form to save an; // add for stack variables.; // Return false if no such pattern found.; //; // ADDI instr: ToBeChangedReg = ADDI FrameBaseReg, OffsetAddi; // ADD instr: ToBeDeletedReg = ADD ToBeChangedReg(killed), ScaleReg; // Imm instr: Reg = op OffsetImm, ToBeDeletedReg(killed); //; // can be converted to:; //; // new ADDI instr: ToBeChangedReg = ADDI FrameBaseReg, (OffsetAddi + OffsetImm); // Index instr: Reg = opx ScaleReg, ToBeChangedReg(killed); //; // In order to eliminate ADD instr, make sure that:; // 1: (OffsetAddi + OffsetImm) must be int16 since this offset will be used in; // new ADDI instr and ADDI can only take int16 Imm.; // 2: ToBeChangedReg must be killed in ADD instr and there is no other use; // between ADDI and ADD instr since its original def in ADDI will be changed; // in new ADDI instr. And also there should be no new def for it between; // ADD and Imm instr as ToBeChangedReg will be used in Index instr.; // 3: ToBeDeletedReg must be killed in Imm instr and there is no other use; // between ADD and Imm instr since ADD instr will be eliminated.; // 4: ScaleReg must not be redefined between ADD and Imm instr since it will be; // moved to Index instr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:94,Security,expose,expose,94,"// Do this opt after PEI which is after RA. The reason is stack slot expansion; // in PEI may expose such opportunities since in PEI, stack slot offsets to; // frame base(OffsetAddi) are determined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update ADDI instr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update Imm instr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,load,15,// Only handle load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:18,Testability,log,logic,18,// TODO: sync the logic between instrHasImmForm() and ImmToIdxMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:90,Performance,load,load-immediate,90,"// If this instruction has an immediate form and one of its operands is a; // result of a load-immediate or an add-immediate, convert it to; // the immediate form if the constant is in range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:115,Deployability,update,updated,115,// Conservatively add defs from DefMI and defs/uses from MI to the set of; // registers that need their kill flags updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:161,Availability,Mask,MaskMI,161,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:333,Availability,Mask,MaskMI,333,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:470,Availability,mask,mask,470,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:579,Availability,Mask,MaskMI,579,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:90,Integrability,wrap,wrap,90,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:254,Integrability,wrap,wrap,254,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:89,Availability,mask,mask,89,"// In MI, we only need low 32 bits of SrcMI, just consider about low 32; // bit of SrcMI mask. Note that in APInt, lowerest bit is at index 0,; // while in PowerPC ISA, lowerest bit is at index 63.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:156,Energy Efficiency,Power,PowerPC,156,"// In MI, we only need low 32 bits of SrcMI, just consider about low 32; // bit of SrcMI mask. Note that in APInt, lowerest bit is at index 0,; // while in PowerPC ISA, lowerest bit is at index 63.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,Availability,mask,mask,12,"// If final mask is 0, MI result should be 0 too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Usability,clear,clear,38,"// About to replace MI.getOperand(1), clear its kill flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:12,Availability,mask,mask,12,"// If SrcMI mask is full, no need to update MBMI and MEMI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:37,Deployability,update,update,37,"// If SrcMI mask is full, no need to update MBMI and MEMI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Usability,clear,clear,38,"// About to replace MI.getOperand(1), clear its kill flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:107,Safety,safe,safe,107,"// If FoldingReg has no non-debug use and it has no implicit def (it; // is not RLWINMO or RLWINM8o), it's safe to delete its def SrcMI.; // Otherwise keep it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:166,Deployability,update,update,166,// The vast majority of the instructions would need their operand 2 replaced; // with an immediate when switching to the reg+imm form. A marked exception; // are the update form loads/stores for which a constant operand 2 would need; // to turn into a displacement and move operand 1 to the operand 2 position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:178,Performance,load,loads,178,// The vast majority of the instructions would need their operand 2 replaced; // with an immediate when switching to the reg+imm form. A marked exception; // are the update form loads/stores for which a constant operand 2 would need; // to turn into a displacement and move operand 1 to the operand 2 position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:101,Performance,load,loaded,101,"// This isn't actually true, but the instructions ignore any of the; // upper bits, so any immediate loaded with an LI is acceptable.; // This does not apply to shift right algebraic because a value; // out of range will produce a -1/0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:101,Performance,load,loaded,101,"// This isn't actually true, but the instructions ignore any of the; // upper bits, so any immediate loaded with an LI is acceptable.; // This does not apply to shift right algebraic because a value; // out of range will produce a -1/0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Performance,Load,Loads,3,// Loads and stores:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:228,Performance,load,loaded,228,"// Power9 and up only. For some of these, the X-Form version has access to all; // 64 VSR's whereas the D-Form only has access to the VR's. We replace those; // with pseudo-ops pre-ra and for post-ra, we check that the register loaded; // into or stored from is one of the VR registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:65,Security,access,access,65,"// Power9 and up only. For some of these, the X-Form version has access to all; // 64 VSR's whereas the D-Form only has access to the VR's. We replace those; // with pseudo-ops pre-ra and for post-ra, we check that the register loaded; // into or stored from is one of the VR registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:120,Security,access,access,120,"// Power9 and up only. For some of these, the X-Form version has access to all; // 64 VSR's whereas the D-Form only has access to the VR's. We replace those; // with pseudo-ops pre-ra and for post-ra, we check that the register loaded; // into or stored from is one of the VR registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:133,Integrability,depend,depending,133,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:29,Performance,load,loads,29,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:154,Performance,load,load,154,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:168,Performance,load,load,168,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:235,Performance,load,loads,235,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:66,Modifiability,extend,extend,66,"// It is Imm, we need to check if the Imm fit the range.; // Sign-extend to 64-bits.; // DefMI may be folded with another imm form instruction, the result Imm is; // the sum of Imm of DefMI and BaseImm which is from imm form instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:8,Modifiability,extend,extend,8,// Sign-extend to 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:57,Availability,reliab,reliably,57,// Doing this post-RA would require dataflow analysis to reliably find uses; // of the CR register set by the compare.; // No need to fixup killed/dead flag since this transformation is only valid; // before RA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Usability,simpl,simply,25,// Immediate forms - may simply be convertable to an LI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:62,Modifiability,extend,extend,62,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:173,Modifiability,extend,extend,173,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:191,Safety,safe,safe,191,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:81,Usability,clear,clear,81,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:62,Modifiability,extend,extend,62,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:173,Modifiability,extend,extend,173,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:191,Safety,safe,safe,191,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:81,Usability,clear,clear,81,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:19,Performance,load,load-immediate,19,"// If the defining load-immediate has no other uses, we can just replace; // the immediate with the new immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:111,Integrability,depend,depending,111,"// If we're not using the GPR result of the CR-setting instruction, we; // just need to and with zero/non-zero depending on the new immediate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:41,Performance,load,load-immediate,41,"// If we're setting the CR, the original load-immediate must be kept (as an; // operand to ANDI_rec/ANDI8_rec).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:10,Modifiability,extend,extend,10,// FIXME: extend this to post-ra. Need to do some change in getForwardingDefMI; // for post-ra.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,load,15,// Only handle load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:132,Safety,safe,safe,132,"// We know that, the MI and DefMI both meet the pattern, and; // the Imm also meet the requirement with the new Imm-form.; // It is safe to do the transformation now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update the base reg first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:9,Deployability,update,update,9,"// Then, update the imm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:22,Integrability,interface,interface,22,"// MI didn't have the interface such as MI.setOperand(i) though; // it has MI.getOperand(i). To repalce the ZERO MachineOperand with; // ImmMO, we need to remove ZERO operand and all the operands behind it,; // and, add the ImmMO, then, move back all the operands behind ZERO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Deployability,Update,Update,3,// Update the opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:28,Modifiability,extend,extend,28,// Get Imm operand and Sign-extend to 64-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:84,Safety,unsafe,unsafe,84,"// If R0 is in the operand where zero is special for the new instruction,; // it is unsafe to transform if the constant operand isn't that operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:38,Modifiability,extend,extended,38,// The first def of LBZU/LHZU is sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,Modifiability,extend,extended,25,// RLDICL generates sign-extended output if it clears at least; // 33 bits from the left (MSB).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:47,Usability,clear,clears,47,// RLDICL generates sign-extended output if it clears at least; // 33 bits from the left (MSB).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:52,Availability,mask,masked,52,"// If at least one bit from left in a lower word is masked out,; // all of 0 to 32-th bits of the output are cleared.; // Hence the output is already sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:155,Modifiability,extend,extended,155,"// If at least one bit from left in a lower word is masked out,; // all of 0 to 32-th bits of the output are cleared.; // Hence the output is already sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:109,Usability,clear,cleared,109,"// If at least one bit from left in a lower word is masked out,; // all of 0 to 32-th bits of the output are cleared.; // Hence the output is already sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:93,Usability,clear,cleared,93,"// If the most significant bit of immediate in ANDIS is zero,; // all of 0 to 32-th bits are cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:44,Modifiability,extend,extended,44,// The first def of LBZU/LHZU/LWZU are zero extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:32,Modifiability,extend,extended,32,"// The 16-bit immediate is sign-extended in li/lis.; // If the most significant bit is zero, all higher bits are zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:41,Availability,mask,mask,41,// We have some variations of rotate-and-mask instructions; // that clear higher 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:68,Usability,clear,clear,68,// We have some variations of rotate-and-mask instructions; // that clear higher 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:91,Safety,avoid,avoid,91,// We limit the max depth to track incoming values of PHIs or binary ops; // (e.g. AND) to avoid excessive cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:60,Modifiability,extend,extended,60,"// If we know the instruction always returns sign- and zero-extended result,; // return here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:90,Modifiability,extend,extended,90,"// In both ELFv1 and v2 ABI, method parameters and the return value; // are sign- or zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:41,Modifiability,extend,extended,41,"// If all incoming values are sign-/zero-extended,; // the output of OR, ISEL or PHI is also sign-/zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:104,Modifiability,extend,extended,104,"// If all incoming values are sign-/zero-extended,; // the output of OR, ISEL or PHI is also sign-/zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:60,Modifiability,extend,extended,60,// If at least one of the incoming values of an AND is zero extended; // then the output is also zero-extended. If both of the incoming values; // are sign-extended then the output is also sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:102,Modifiability,extend,extended,102,// If at least one of the incoming values of an AND is zero extended; // then the output is also zero-extended. If both of the incoming values; // are sign-extended then the output is also sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:156,Modifiability,extend,extended,156,// If at least one of the incoming values of an AND is zero extended; // then the output is also zero-extended. If both of the incoming values; // are sign-extended then the output is also sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:194,Modifiability,extend,extended,194,// If at least one of the incoming values of an AND is zero extended; // then the output is also zero-extended. If both of the incoming values; // are sign-extended then the output is also sign extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:122,Energy Efficiency,adapt,adapt,122,"// Do nothing. We want the LOOP setup instruction to stay in the *old*; // preheader, so we can use BDZ in the prologs to adapt the loop trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:122,Modifiability,adapt,adapt,122,"// Do nothing. We want the LOOP setup instruction to stay in the *old*; // preheader, so we can use BDZ in the prologs to adapt the loop trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:138,Performance,load,loaded,138,"// Return true if get the base operand, byte offset of an instruction and the; // memory width. Width is the size of memory that is being loaded/stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:15,Performance,load,loads,15,// Handle only loads/stores with base register followed by immediate offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:118,Performance,load,loaded,118,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:218,Security,access,access,218,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:287,Security,access,access,287,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:315,Security,access,accesses,315,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:25,Energy Efficiency,Power,PowerPC,25,"//===-- PPCInstrInfo.h - PowerPC Instruction Information --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetInstrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:406,Energy Efficiency,Power,PowerPC,406,"//===-- PPCInstrInfo.h - PowerPC Instruction Information --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the PowerPC implementation of the TargetInstrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:120,Performance,load,load,120,"// Instructions that have an immediate form might be convertible to that; // form if the correct input is a result of a load immediate. In order to; // know whether the transformation is special, we might need to know some; // of the details of the two forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:18,Performance,load,load,18,// Define list of load and store spill opcodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:25,Performance,load,load,25,// Initialize arrays for load and store spill opcodes on supported subtargets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:7,Energy Efficiency,Power,PowerPC,7,"/// On PowerPC, we leverage machine combiner pass to reduce register pressure; /// when the register pressure is high for one BB.; /// Return true if register pressure for \p MBB is high and ABI is supported; /// to reduce register pressure. Otherwise return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:53,Energy Efficiency,reduce,reduce,53,"/// On PowerPC, we leverage machine combiner pass to reduce register pressure; /// when the register pressure is high for one BB.; /// Return true if register pressure for \p MBB is high and ABI is supported; /// to reduce register pressure. Otherwise return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:216,Energy Efficiency,reduce,reduce,216,"/// On PowerPC, we leverage machine combiner pass to reduce register pressure; /// when the register pressure is high for one BB.; /// Return true if register pressure for \p MBB is high and ABI is supported; /// to reduce register pressure. Otherwise return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:7,Energy Efficiency,Power,PowerPC,7,"/// On PowerPC, we try to reassociate FMA chain which will increase; /// instruction size. Set extension resource length limit to 1 for edge case.; /// Resource Length is calculated by scaled resource usage in getCycles().; /// Because of the division in getCycles(), it returns different cycles due to; /// legacy scaled resource usage. So new resource length may be same with; /// legacy or 1 bigger than legacy.; /// We need to execlude the 1 bigger case even the resource length is not; /// perserved for more FMA chain reassociations on PowerPC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:542,Energy Efficiency,Power,PowerPC,542,"/// On PowerPC, we try to reassociate FMA chain which will increase; /// instruction size. Set extension resource length limit to 1 for edge case.; /// Resource Length is calculated by scaled resource usage in getCycles().; /// Because of the division in getCycles(), it returns different cycles due to; /// legacy scaled resource usage. So new resource length may be same with; /// legacy or 1 bigger than legacy.; /// We need to execlude the 1 bigger case even the resource length is not; /// perserved for more FMA chain reassociations on PowerPC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:3,Energy Efficiency,Power,PowerPC,3,"// PowerPC specific version of setSpecialOperandAttr that copies Flags to MI; // and clears nuw, nsw, and exact flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:85,Usability,clear,clears,85,"// PowerPC specific version of setSpecialOperandAttr that copies Flags to MI; // and clears nuw, nsw, and exact flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:14,Performance,optimiz,optimization,14,// Comparison optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:145,Performance,load,loaded,145,"/// Return true if get the base operand, byte offset of an instruction and; /// the memory width. Width is the size of memory that is being; /// loaded/stored (e.g. 1, 2, 4, 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:62,Energy Efficiency,schedul,scheduled,62,/// Returns true if the two given memory operations should be scheduled; /// adjacent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:27,Security,access,access,27,/// Return true if two MIs access different memory addresses and false; /// otherwise,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:39,Modifiability,extend,extended,39,// Return true if the register is sign-extended from 32 to 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:39,Modifiability,extend,extended,39,// Return true if the register is zero-extended from 32 to 64 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:123,Deployability,Pipeline,PipelinerLoopInfo,123,"/// Analyze loop L, which must be a single-basic-block loop, and if the; /// conditions can be understood enough produce a PipelinerLoopInfo object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:445,Energy Efficiency,Power,PowerPC,445,"//===-- PPCISelDAGToDAG.cpp - PPC --pattern matching inst selector --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pattern matching instruction selector for PowerPC,; // converting from a legalized dag to a PPC dag.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:54,Security,Hash,Hash,54,// Create a place on the stack for the ROP Protection Hash.; // The ROP Protection Hash will always be 8 bytes and aligned to 8; // bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:83,Security,Hash,Hash,83,// Create a place on the stack for the ROP Protection Hash.; // The ROP Protection Hash will always be 8 bytes and aligned to 8; // bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:38,Availability,Mask,Mask,38,/// isRotateAndMask - Returns true if Mask and Shift can be folded into a; /// rotate and mask opcode and mask operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:90,Availability,mask,mask,90,/// isRotateAndMask - Returns true if Mask and Shift can be folded into a; /// rotate and mask opcode and mask operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:106,Availability,mask,mask,106,/// isRotateAndMask - Returns true if Mask and Shift can be folded into a; /// rotate and mask opcode and mask operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:37,Performance,LOAD,LOAD,37,// tryTLSXFormLoad - Convert an ISD::LOAD fed by a PPCISD::ADD_TLS into; // an X-Form load instruction with the offset being a relocation coming from; // the PPCISD::ADD_TLS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:86,Performance,load,load,86,// tryTLSXFormLoad - Convert an ISD::LOAD fed by a PPCISD::ADD_TLS into; // an X-Form load instruction with the offset being a relocation coming from; // the PPCISD::ADD_TLS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:331,Performance,load,load,331,"/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for; /// inline asm expressions. It is always correct to compute the value into; /// a register. The case of adding a (possibly relocatable) constant to a; /// register can be improved, but it is wrong to substitute Reg+Reg for; /// Reg in an asm, because the load or store opcode would have to change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:96,Security,access,accessing,96,/// getGlobalBaseReg - Output the instructions required to put the; /// base address to use for accessing globals into a register.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:154,Integrability,wrap,wrapping,154,"// We must ensure that this sequence is dominated by the prologue.; // FIXME: This is a bit of a big hammer since we don't get the benefits; // of shrink-wrapping whenever we emit this instruction. Considering; // this is used in any function where we emit a jump table, this may be; // a significant limitation. We should consider inserting this in the; // block where it is used and then commoning this sequence up if it; // appears in multiple places.; // Note: on ISA 3.0 cores, we can use lnia (addpcis) instead of; // MovePCtoLR8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:33,Deployability,update,updated,33,"// TODO: These asserts should be updated as more support for the toc data; // transformation is added (struct support, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Testability,assert,asserts,15,"// TODO: These asserts should be updated as more support for the toc data; // transformation is added (struct support, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Testability,test,tests,35,/// isInt32Immediate - This method tests to see if the node is a 32-bit constant; /// operand. If so Imm will receive the 32-bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Testability,test,tests,35,/// isInt64Immediate - This method tests to see if the node is a 64-bit constant; /// operand. If so Imm will receive the 64-bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:34,Testability,test,tests,34,// isInt32Immediate - This method tests to see if a constant operand.; // If so Imm will receive the 32 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:35,Testability,test,tests,35,/// isInt64Immediate - This method tests to see if the value is a 64-bit; /// constant operand. If so Imm will receive the 64-bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:50,Safety,predict,predict,50,"// We only want to handle cases which are easy to predict at static time, e.g.; // C++ throw statement, that is very likely not taken, or calling never; // returned function, e.g. stdlib exit(). So we set Threshold to filter; // unwanted cases.; //; // Below is LLVM branch weight table, we only want to handle case 1, 2; //; // Case Taken:Nontaken Example; // 1. Unreachable 1048575:1 C++ throw, stdlib exit(),; // 2. Invoke-terminating 1:1048575; // 3. Coldblock 4:64 __builtin_expect; // 4. Loop Branch 124:4 For loop; // 5. PH/ZH/FPH 20:12",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:39,Testability,test,tests,39,// isOpcWithIntImmediate - This method tests to see if the node is a specific; // opcode and that it has a immediate integer right operand.; // If so Imm will receive the 32 bit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,Availability,down,down,17,"// Don't even go down this path for i64, since different logic will be; // necessary for rldicl/rldicr/rldimi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:57,Testability,log,logic,57,"// Don't even go down this path for i64, since different logic will be; // necessary for rldicl/rldicr/rldimi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:7,Availability,mask,mask,7,// bit mask marking indeterminant results,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:23,Availability,mask,mask,23,// apply shift left to mask if it comes first,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:24,Availability,mask,mask,24,// apply shift right to mask if it comes first,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:10,Availability,mask,mask,10,// if the mask doesn't intersect any Indeterminant bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:17,Availability,mask,mask,17,// make sure the mask is still a mask (wrap arounds may not be),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:33,Availability,mask,mask,33,// make sure the mask is still a mask (wrap arounds may not be),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:39,Integrability,wrap,wrap,39,// make sure the mask is still a mask (wrap arounds may not be),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:401,Modifiability,variab,variable,401,"// Account for when ADD_TLS is used for the initial-exec TLS model on Linux.; //; // Although ADD_TLS does not explicitly use the thread pointer; // register when LD_GOT_TPREL_L is one of it's operands, the LD_GOT_TPREL_L; // instruction will have a relocation specifier, @got@tprel, that is used to; // generate a GOT entry. The linker replaces this entry with an offset for a; // for a thread local variable, which will be relative to the thread pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:32,Performance,Optimiz,Optimize,32,"// canOptimizeTLSDFormToXForm - Optimize TLS accesses when an ADD_TLS; // instruction is present. An ADD_TLS instruction, followed by a D-Form memory; // operation, can be optimized to use an X-Form load or store, allowing the; // ADD_TLS node to be removed completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:172,Performance,optimiz,optimized,172,"// canOptimizeTLSDFormToXForm - Optimize TLS accesses when an ADD_TLS; // instruction is present. An ADD_TLS instruction, followed by a D-Form memory; // operation, can be optimized to use an X-Form load or store, allowing the; // ADD_TLS node to be removed completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:199,Performance,load,load,199,"// canOptimizeTLSDFormToXForm - Optimize TLS accesses when an ADD_TLS; // instruction is present. An ADD_TLS instruction, followed by a D-Form memory; // operation, can be optimized to use an X-Form load or store, allowing the; // ADD_TLS node to be removed completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,Security,access,accesses,45,"// canOptimizeTLSDFormToXForm - Optimize TLS accesses when an ADD_TLS; // instruction is present. An ADD_TLS instruction, followed by a D-Form memory; // operation, can be optimized to use an X-Form load or store, allowing the; // ADD_TLS node to be removed completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:15,Performance,perform,perform,15,"// In order to perform this optimization inside tryTLSXForm[Load|Store],; // Base is expected to be an ADD_TLS node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:28,Performance,optimiz,optimization,28,"// In order to perform this optimization inside tryTLSXForm[Load|Store],; // Base is expected to be an ADD_TLS node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:60,Performance,Load,Load,60,"// In order to perform this optimization inside tryTLSXForm[Load|Store],; // Base is expected to be an ADD_TLS node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:7,Performance,optimiz,optimization,7,// The optimization to convert the D-Form load/store into its X-Form; // counterpart should only occur if the source value offset of the load/; // store is 0. This also means that The offset should always be undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:42,Performance,load,load,42,// The optimization to convert the D-Form load/store into its X-Form; // counterpart should only occur if the source value offset of the load/; // store is 0. This also means that The offset should always be undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:137,Performance,load,load,137,// The optimization to convert the D-Form load/store into its X-Form; // counterpart should only occur if the source value offset of the load/; // store is 0. This also means that The offset should always be undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:9,Performance,optimiz,optimize,9,// Don't optimize if there are ADD_TLS users that aren't load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:57,Performance,load,load,57,// Don't optimize if there are ADD_TLS users that aren't load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:32,Performance,load,load,32,"// Does the ADD_TLS node of the load/store use the thread pointer?; // If the thread pointer is not used as one of the operands of ADD_TLS,; // then this optimization is not valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:154,Performance,optimiz,optimization,154,"// Does the ADD_TLS node of the load/store use the thread pointer?; // If the thread pointer is not used as one of the operands of ADD_TLS,; // then this optimization is not valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,Availability,mask,masked,22,/// Turn an or of two masked values into the rotate left word immediate then; /// mask insert (rlwimi) instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:82,Availability,mask,mask,82,/// Turn an or of two masked values into the rotate left word immediate then; /// mask insert (rlwimi) instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:11,Availability,mask,mask,11,"// The AND mask might not be a constant, and we need to make sure that; // if we're going to fold the masking with the insert, all bits not; // know to be zero in the mask are known to be one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:102,Availability,mask,masking,102,"// The AND mask might not be a constant, and we need to make sure that; // if we're going to fold the masking with the insert, all bits not; // know to be zero in the mask are known to be one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:167,Availability,mask,mask,167,"// The AND mask might not be a constant, and we need to make sure that; // if we're going to fold the masking with the insert, all bits not; // know to be zero in the mask are known to be one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:262,Availability,mask,mask,262,"// 2-2) Patterns : {zeros}{ones}{15-bit value}{zeros}; // {zeros}{15-bit value}{zeros}; // {zeros}{ones}{15-bit value}; // {ones}{15-bit value}{zeros}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDIC to mask off the ones in both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:209,Availability,mask,mask,209,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:502,Usability,clear,clear,502,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:725,Usability,clear,clear,725,"// 2-3) Pattern : {zeros}{15-bit value}{ones}; // Shift right the Imm by (48 - LZ) bits to construct a negtive 16 bits value,; // therefore we can take advantage of LI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> (48 - LZ) & 0xffff); // +----sext-----|--16-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left (48 - LZ), clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:196,Availability,mask,mask,196,"// 2-4) Patterns : {zeros}{ones}{15-bit value}{ones}; // {ones}{15-bit value}{ones}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDICL to mask off the ones in left sides (if required); // after rotation.; //; // +-LZ-FO||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00011110bbbbbbbbb1111111| -> |000000000011110bbbbbbbbb|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> TO) & 0xffff; // +----sext-----|--16-bit--+ +LZ|---------------------+; // |111111111111110bbbbbbbbb| -> |00011110bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left TO, clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:734,Usability,clear,clear,734,"// 2-4) Patterns : {zeros}{ones}{15-bit value}{ones}; // {ones}{15-bit value}{ones}; // We can take advantage of LI's sign-extension semantics to generate leading; // ones, and then use RLDICL to mask off the ones in left sides (if required); // after rotation.; //; // +-LZ-FO||-15-bit-||--TO--+ +-------------|--16-bit--+; // |00011110bbbbbbbbb1111111| -> |000000000011110bbbbbbbbb|; // +------------------------+ +------------------------+; // 63 0 63 0; // Imm (Imm >> TO) & 0xffff; // +----sext-----|--16-bit--+ +LZ|---------------------+; // |111111111111110bbbbbbbbb| -> |00011110bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0; // LI8: sext many leading zeros RLDICL: rotate left TO, clear left LZ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:295,Availability,mask,mask,295,"// 2-6) Patterns : {******}{49 zeros}{******}; // {******}{49 ones}{******}; // If the Imm contains 49 consecutive zeros/ones, it means that a total of 15; // bits remain on both sides. Rotate right the Imm to construct an int<16>; // value, use LI for int<16> value and then use RLDICL without mask to rotate; // it back.; //; // 1) findContiguousZerosAtLeast(Imm, 49); // +------|--zeros-|------+ +---ones--||---15 bit--+; // |bbbbbb0000000000aaaaaa| -> |0000000000aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0; //; // 2) findContiguousZerosAtLeast(~Imm, 49); // +------|--ones--|------+ +---ones--||---15 bit--+; // |bbbbbb1111111111aaaaaa| -> |1111111111aaaaaabbbbbb|; // +----------------------+ +----------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:83,Integrability,depend,depending,83,"// 2-7) Patterns : High word == Low word; // This may require 2 to 3 instructions, depending on whether Lo32 can be; // materialized in 1 instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:296,Availability,mask,mask,296,"// 3-1) Patterns : {zeros}{ones}{31-bit value}{zeros}; // {zeros}{31-bit value}{zeros}; // {zeros}{ones}{31-bit value}; // {ones}{31-bit value}{zeros}; // We can take advantage of LIS's sign-extension semantics to generate leading; // ones, add the remaining bits with ORI, and then use RLDIC to mask off the; // ones in both sides after rotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:244,Availability,mask,mask,244,"// 3-2) Pattern : {zeros}{31-bit value}{ones}; // Shift right the Imm by (32 - LZ) bits to construct a negative 32 bits; // value, therefore we can take advantage of LIS's sign-extension semantics,; // add the remaining bits with ORI, and then mask them off after rotation.; // This is similar to Pattern 2-3, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:230,Availability,mask,mask,230,"// 3-3) Patterns : {zeros}{ones}{31-bit value}{ones}; // {ones}{31-bit value}{ones}; // We can take advantage of LIS's sign-extension semantics to generate leading; // ones, add the remaining bits with ORI, and then use RLDICL to mask off the; // ones in left sides (if required) after rotation.; // This is similar to Pattern 2-4, please refer to the diagram there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
