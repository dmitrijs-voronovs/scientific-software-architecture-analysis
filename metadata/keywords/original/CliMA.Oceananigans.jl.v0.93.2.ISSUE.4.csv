id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/issues/3036:2514,Energy Efficiency,energy,energy,2514,"ime = 3days). wizard = TimeStepWizard(max_change=1.01, cfl=0.2, diffusive_cfl=0.1, max_Δt=0.2/√N²∞); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2)). KE = Average((u^2 + w^2) / 2); PE = Average(b^2/(2*N²∞)); outputs = (; u, w, b, KE, PE). simulation.output_writers[:writer] = NetCDFOutputWriter(model, outputs;; filename = ""mwe.nc"",; schedule = TimeInterval(1hour),; with_halos = false,; overwrite_existing = true); run!(simulation). using Rasters, Plots; fpath_xz1 = simulation.output_writers[:writer].filepath; ds_xz1 = RasterStack(fpath_xz1); u_lims = (-amp, +amp). times = dims(ds_xz1, :Ti); anim = @animate for frame in 1:length(times); p1 = heatmap(ds_xz1[:u][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""u""); p2 = heatmap(ds_xz1[:w][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""w""); p3 = heatmap(ds_xz1[:b][Ti=frame, yC=1]', title=""b""); p4 = plot(ds_xz1[:KE]); plot!(p4, ds_xz1[:PE]); vline!(p4, [times[frame]], label=""time"", linestyle=:dash). fullplot = plot(p1, p2, p3, p4, layout = Plots.grid(2, 2), size=(1000, 600)); end. mp4(anim, ""mwe.mp4"", fps=16). ```. I expected this simulation to slowly lose or approximately conserve total energy. Instead I get these grid-scale noises popping up and a build up of kinetic and potential energy seemingly out of nowhere:. https://user-images.githubusercontent.com/13205162/228424859-905f3dd6-b167-440b-b073-af09008f4f04.mp4. Notes: . - Even if I add a background diffusivity with a reasonable value, the energy buildup still happens; - The energy buildup does not happen without a background buoyancy; - When `gravity_unit_vector == NegativeZDirection()` the KE stays approximately the same, but the PE increases. Although that might be due to the boundary conditions, I'm not sure at this point.; - When I start this with a larger velocity amplitude the small scale noise becomes less evident, but there's still an increase in the total energy (KE and PE) of the flow. Any guesses as to what might be causing this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036
https://github.com/CliMA/Oceananigans.jl/issues/3036:2611,Energy Efficiency,energy,energy,2611,"ime = 3days). wizard = TimeStepWizard(max_change=1.01, cfl=0.2, diffusive_cfl=0.1, max_Δt=0.2/√N²∞); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2)). KE = Average((u^2 + w^2) / 2); PE = Average(b^2/(2*N²∞)); outputs = (; u, w, b, KE, PE). simulation.output_writers[:writer] = NetCDFOutputWriter(model, outputs;; filename = ""mwe.nc"",; schedule = TimeInterval(1hour),; with_halos = false,; overwrite_existing = true); run!(simulation). using Rasters, Plots; fpath_xz1 = simulation.output_writers[:writer].filepath; ds_xz1 = RasterStack(fpath_xz1); u_lims = (-amp, +amp). times = dims(ds_xz1, :Ti); anim = @animate for frame in 1:length(times); p1 = heatmap(ds_xz1[:u][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""u""); p2 = heatmap(ds_xz1[:w][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""w""); p3 = heatmap(ds_xz1[:b][Ti=frame, yC=1]', title=""b""); p4 = plot(ds_xz1[:KE]); plot!(p4, ds_xz1[:PE]); vline!(p4, [times[frame]], label=""time"", linestyle=:dash). fullplot = plot(p1, p2, p3, p4, layout = Plots.grid(2, 2), size=(1000, 600)); end. mp4(anim, ""mwe.mp4"", fps=16). ```. I expected this simulation to slowly lose or approximately conserve total energy. Instead I get these grid-scale noises popping up and a build up of kinetic and potential energy seemingly out of nowhere:. https://user-images.githubusercontent.com/13205162/228424859-905f3dd6-b167-440b-b073-af09008f4f04.mp4. Notes: . - Even if I add a background diffusivity with a reasonable value, the energy buildup still happens; - The energy buildup does not happen without a background buoyancy; - When `gravity_unit_vector == NegativeZDirection()` the KE stays approximately the same, but the PE increases. Although that might be due to the boundary conditions, I'm not sure at this point.; - When I start this with a larger velocity amplitude the small scale noise becomes less evident, but there's still an increase in the total energy (KE and PE) of the flow. Any guesses as to what might be causing this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036
https://github.com/CliMA/Oceananigans.jl/issues/3036:2827,Energy Efficiency,energy,energy,2827,"ime = 3days). wizard = TimeStepWizard(max_change=1.01, cfl=0.2, diffusive_cfl=0.1, max_Δt=0.2/√N²∞); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2)). KE = Average((u^2 + w^2) / 2); PE = Average(b^2/(2*N²∞)); outputs = (; u, w, b, KE, PE). simulation.output_writers[:writer] = NetCDFOutputWriter(model, outputs;; filename = ""mwe.nc"",; schedule = TimeInterval(1hour),; with_halos = false,; overwrite_existing = true); run!(simulation). using Rasters, Plots; fpath_xz1 = simulation.output_writers[:writer].filepath; ds_xz1 = RasterStack(fpath_xz1); u_lims = (-amp, +amp). times = dims(ds_xz1, :Ti); anim = @animate for frame in 1:length(times); p1 = heatmap(ds_xz1[:u][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""u""); p2 = heatmap(ds_xz1[:w][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""w""); p3 = heatmap(ds_xz1[:b][Ti=frame, yC=1]', title=""b""); p4 = plot(ds_xz1[:KE]); plot!(p4, ds_xz1[:PE]); vline!(p4, [times[frame]], label=""time"", linestyle=:dash). fullplot = plot(p1, p2, p3, p4, layout = Plots.grid(2, 2), size=(1000, 600)); end. mp4(anim, ""mwe.mp4"", fps=16). ```. I expected this simulation to slowly lose or approximately conserve total energy. Instead I get these grid-scale noises popping up and a build up of kinetic and potential energy seemingly out of nowhere:. https://user-images.githubusercontent.com/13205162/228424859-905f3dd6-b167-440b-b073-af09008f4f04.mp4. Notes: . - Even if I add a background diffusivity with a reasonable value, the energy buildup still happens; - The energy buildup does not happen without a background buoyancy; - When `gravity_unit_vector == NegativeZDirection()` the KE stays approximately the same, but the PE increases. Although that might be due to the boundary conditions, I'm not sure at this point.; - When I start this with a larger velocity amplitude the small scale noise becomes less evident, but there's still an increase in the total energy (KE and PE) of the flow. Any guesses as to what might be causing this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036
https://github.com/CliMA/Oceananigans.jl/issues/3036:2863,Energy Efficiency,energy,energy,2863,"ime = 3days). wizard = TimeStepWizard(max_change=1.01, cfl=0.2, diffusive_cfl=0.1, max_Δt=0.2/√N²∞); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2)). KE = Average((u^2 + w^2) / 2); PE = Average(b^2/(2*N²∞)); outputs = (; u, w, b, KE, PE). simulation.output_writers[:writer] = NetCDFOutputWriter(model, outputs;; filename = ""mwe.nc"",; schedule = TimeInterval(1hour),; with_halos = false,; overwrite_existing = true); run!(simulation). using Rasters, Plots; fpath_xz1 = simulation.output_writers[:writer].filepath; ds_xz1 = RasterStack(fpath_xz1); u_lims = (-amp, +amp). times = dims(ds_xz1, :Ti); anim = @animate for frame in 1:length(times); p1 = heatmap(ds_xz1[:u][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""u""); p2 = heatmap(ds_xz1[:w][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""w""); p3 = heatmap(ds_xz1[:b][Ti=frame, yC=1]', title=""b""); p4 = plot(ds_xz1[:KE]); plot!(p4, ds_xz1[:PE]); vline!(p4, [times[frame]], label=""time"", linestyle=:dash). fullplot = plot(p1, p2, p3, p4, layout = Plots.grid(2, 2), size=(1000, 600)); end. mp4(anim, ""mwe.mp4"", fps=16). ```. I expected this simulation to slowly lose or approximately conserve total energy. Instead I get these grid-scale noises popping up and a build up of kinetic and potential energy seemingly out of nowhere:. https://user-images.githubusercontent.com/13205162/228424859-905f3dd6-b167-440b-b073-af09008f4f04.mp4. Notes: . - Even if I add a background diffusivity with a reasonable value, the energy buildup still happens; - The energy buildup does not happen without a background buoyancy; - When `gravity_unit_vector == NegativeZDirection()` the KE stays approximately the same, but the PE increases. Although that might be due to the boundary conditions, I'm not sure at this point.; - When I start this with a larger velocity amplitude the small scale noise becomes less evident, but there's still an increase in the total energy (KE and PE) of the flow. Any guesses as to what might be causing this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036
https://github.com/CliMA/Oceananigans.jl/issues/3036:3261,Energy Efficiency,energy,energy,3261,"ime = 3days). wizard = TimeStepWizard(max_change=1.01, cfl=0.2, diffusive_cfl=0.1, max_Δt=0.2/√N²∞); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2)). KE = Average((u^2 + w^2) / 2); PE = Average(b^2/(2*N²∞)); outputs = (; u, w, b, KE, PE). simulation.output_writers[:writer] = NetCDFOutputWriter(model, outputs;; filename = ""mwe.nc"",; schedule = TimeInterval(1hour),; with_halos = false,; overwrite_existing = true); run!(simulation). using Rasters, Plots; fpath_xz1 = simulation.output_writers[:writer].filepath; ds_xz1 = RasterStack(fpath_xz1); u_lims = (-amp, +amp). times = dims(ds_xz1, :Ti); anim = @animate for frame in 1:length(times); p1 = heatmap(ds_xz1[:u][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""u""); p2 = heatmap(ds_xz1[:w][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""w""); p3 = heatmap(ds_xz1[:b][Ti=frame, yC=1]', title=""b""); p4 = plot(ds_xz1[:KE]); plot!(p4, ds_xz1[:PE]); vline!(p4, [times[frame]], label=""time"", linestyle=:dash). fullplot = plot(p1, p2, p3, p4, layout = Plots.grid(2, 2), size=(1000, 600)); end. mp4(anim, ""mwe.mp4"", fps=16). ```. I expected this simulation to slowly lose or approximately conserve total energy. Instead I get these grid-scale noises popping up and a build up of kinetic and potential energy seemingly out of nowhere:. https://user-images.githubusercontent.com/13205162/228424859-905f3dd6-b167-440b-b073-af09008f4f04.mp4. Notes: . - Even if I add a background diffusivity with a reasonable value, the energy buildup still happens; - The energy buildup does not happen without a background buoyancy; - When `gravity_unit_vector == NegativeZDirection()` the KE stays approximately the same, but the PE increases. Although that might be due to the boundary conditions, I'm not sure at this point.; - When I start this with a larger velocity amplitude the small scale noise becomes less evident, but there's still an increase in the total energy (KE and PE) of the flow. Any guesses as to what might be causing this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036
https://github.com/CliMA/Oceananigans.jl/issues/3038:78,Availability,ERROR,ERROR,78,"I report here some issues connected to updating to Oceananigans 0.80.0 . ```; ERROR: LoadError: MethodError: no method matching min_Δx(::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:1484,Availability,ERROR,ERROR,1484,"4, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:1929,Availability,error,error,1929,"erImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:1956,Availability,error,error,1956,"ing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:3484,Availability,ERROR,ERROR,3484,"}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:2606,Energy Efficiency,reduce,reduce,2606," typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{K",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:2848,Energy Efficiency,reduce,reduce,2848,"to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:2887,Energy Efficiency,reduce,reducedim,2887," with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:2939,Energy Efficiency,reduce,reducedim,2939,"g); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:2987,Energy Efficiency,reduce,reducedim,2987,"tring); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:3039,Energy Efficiency,reduce,reducedim,3039,"a_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:3086,Energy Efficiency,reduce,reducedim,3086,"sCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:3138,Energy Efficiency,reduce,reducedim,3138,"t/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:3185,Energy Efficiency,reduce,reducedim,3185,"ndexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:3236,Energy Efficiency,reduce,reducedim,3236,"001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:3282,Energy Efficiency,reduce,reducedim,3282,"cCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:6944,Energy Efficiency,adapt,adapted,6944,"lenceClosures.HyperbolicTangentRiDependentTapering}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, NamedTuple{(:b,), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:\u03bb, :initial_buoyancy), Tuple{Float64, typeof(WenoNeverworld.initial_buoyancy_parabola)}}, typeof(WenoNeverworld.buoyancy_top_relaxation)}}}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to xnode); Stacktrace:; [1] node; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/grid_utils.jl:230; [2] buoyancy_top_relaxation; @ /nobackup1c/users/ssilvest/WenoNeverworld.jl/src/weno_neverworld.jl:47; [3] getbc; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BoundaryConditions/discrete_boundary_function.jl:41; [4] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy_tracer.jl:18; [5] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy.jl:76; [6] macro expansion; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl:190; [7] gpu_compute_ri_based_diffusivities!; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/KernelAbstractions/C8flJ/src/macros.jl:81; [8] gpu_compute_ri_based_diffusivities!; ```. Instances of `xnode` (and I would have to guess also `ynode` and `znode`) are not adapted to fit the new syntax",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:6944,Modifiability,adapt,adapted,6944,"lenceClosures.HyperbolicTangentRiDependentTapering}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, NamedTuple{(:b,), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:\u03bb, :initial_buoyancy), Tuple{Float64, typeof(WenoNeverworld.initial_buoyancy_parabola)}}, typeof(WenoNeverworld.buoyancy_top_relaxation)}}}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to xnode); Stacktrace:; [1] node; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/grid_utils.jl:230; [2] buoyancy_top_relaxation; @ /nobackup1c/users/ssilvest/WenoNeverworld.jl/src/weno_neverworld.jl:47; [3] getbc; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BoundaryConditions/discrete_boundary_function.jl:41; [4] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy_tracer.jl:18; [5] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy.jl:76; [6] macro expansion; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl:190; [7] gpu_compute_ri_based_diffusivities!; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/KernelAbstractions/C8flJ/src/macros.jl:81; [8] gpu_compute_ri_based_diffusivities!; ```. Instances of `xnode` (and I would have to guess also `ynode` and `znode`) are not adapted to fit the new syntax",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:85,Performance,Load,LoadError,85,"I report here some issues connected to updating to Oceananigans 0.80.0 . ```; ERROR: LoadError: MethodError: no method matching min_Δx(::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:1491,Performance,Load,LoadError,1491,"4, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:3491,Performance,Load,LoadError,3491,"}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3038:1973,Testability,assert,assertscalar,1973,"cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038
https://github.com/CliMA/Oceananigans.jl/issues/3039:87,Testability,test,test,87,https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/test/runtests.jl#L3. We should remove this,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3039
https://github.com/CliMA/Oceananigans.jl/issues/3040:197,Availability,ERROR,ERROR,197,"I haven't had the the time to investigate this for now, but `min_Δz()` (and supposedly the x and y version as well) complains about scalar indexing on the GPU when using irregular z spacing:. ```; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::Recti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:631,Availability,error,error,631,"I haven't had the the time to investigate this for now, but `min_Δz()` (and supposedly the x and y version as well) complains about scalar indexing on the GPU when using irregular z spacing:. ```; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::Recti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:658,Availability,error,error,658,"I haven't had the the time to investigate this for now, but `min_Δz()` (and supposedly the x and y version as well) complains about scalar indexing on the GPU when using irregular z spacing:. ```; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::Recti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1279,Energy Efficiency,reduce,reduce,1279,"xing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1516,Energy Efficiency,reduce,reduce,1516,"ping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1555,Energy Efficiency,reduce,reducedim,1555,"ex this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1607,Energy Efficiency,reduce,reducedim,1607,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1655,Energy Efficiency,reduce,reducedim,1655,"rror.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /gla",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1707,Energy Efficiency,reduce,reducedim,1707,"sCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/initia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1754,Energy Efficiency,reduce,reducedim,1754,"masc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1806,Energy Efficiency,reduce,reducedim,1806,"masc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1853,Energy Efficiency,reduce,reducedim,1853,"masc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1904,Energy Efficiency,reduce,reducedim,1904,"masc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:1950,Energy Efficiency,reduce,reducedim,1950,"masc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}); @ Oceananigans.Grids /glade/work/tomasc/.julia/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:465; [18] top-level scope; @ REPL[2]:1; [19] top-level scope; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/issues/3040:675,Testability,assert,assertscalar,675,"I haven't had the the time to investigate this for now, but `min_Δz()` (and supposedly the x and y version as well) complains about scalar indexing on the GPU when using irregular z spacing:. ```; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::Recti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040
https://github.com/CliMA/Oceananigans.jl/pull/3045:116,Performance,load,loaded,116,Prior of these PR constants (like Earth's radius) were multiply defined. Now all constants are gathered in a module loaded just after units. Closes #2981,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045
https://github.com/CliMA/Oceananigans.jl/issues/3047:292,Performance,perform,performance,292,"Currently `BatchedTridiagonalSolver` supports `Callable` tridiagonal coefficients via. https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Solvers/batched_tridiagonal_solver.jl#L58-L59. However, as noted on #3030 this can produce a catastrophic loss of performance. Therefore, this support should be discontinued. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3047
https://github.com/CliMA/Oceananigans.jl/issues/3048:1646,Availability,down,down,1646,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:533,Energy Efficiency,reduce,reduce,533,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:259,Integrability,depend,dependency,259,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:309,Integrability,interface,interface,309,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:360,Integrability,interface,interface,360,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:1133,Integrability,depend,dependencies,1133,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:1419,Integrability,interface,interface,1419,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:1153,Modifiability,coupling,coupling,1153,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:1118,Safety,avoid,avoid,1118,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:1703,Safety,avoid,avoid,1703,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:700,Testability,log,logical,700,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3048:753,Usability,clear,clear,753,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048
https://github.com/CliMA/Oceananigans.jl/issues/3049:66,Integrability,depend,depend,66,Should we move `ShallowWaterModel` to its own package which would depend on Oceananigans?. There is an outstanding issue https://github.com/CliMA/Oceananigans.jl/issues/2922; We'd either need to sort it out. I believe to figure it out we need to plot/print out the tendencies from the first iteration for a version that worked and the first version that it didn't and trace back the issue. . Perhaps it would make sense if this was a different model?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3049
https://github.com/CliMA/Oceananigans.jl/issues/3051:474,Integrability,interface,interface,474,"These lines multiply `h` (a field at ccc) with objects at `fcc` and `cfc` respectively. https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L16-L17. This doesn't look correct, but if there is some logic that makes it correct, it should be documented with a comment at least. I think if the bathymetric height is defined at cell centers, then the bathymetric height at a cell interface might need to be defined as the maximum of the height of the adjacent cells.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3051
https://github.com/CliMA/Oceananigans.jl/issues/3051:296,Testability,log,logic,296,"These lines multiply `h` (a field at ccc) with objects at `fcc` and `cfc` respectively. https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L16-L17. This doesn't look correct, but if there is some logic that makes it correct, it should be documented with a comment at least. I think if the bathymetric height is defined at cell centers, then the bathymetric height at a cell interface might need to be defined as the maximum of the height of the adjacent cells.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3051
https://github.com/CliMA/Oceananigans.jl/pull/3054:55,Testability,test,tests,55,In response to #3040 I make sure that some of the grid tests also happen on GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054
https://github.com/CliMA/Oceananigans.jl/pull/3057:842,Availability,down,downside,842,"In this PR I'm exploring the possibility of adding methods for `diffusive_flux_x`, and `viscous_flux_ux` (along with other directions) for tuples. This is needed when reconstructing tracer variance and kinetic energy dissipation rates for tuples in a conservative formulation and, specifically, it's used in Oceanostics for that end (see https://github.com/tomchor/Oceanostics.jl/pull/112). At the moment these are [defined in Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/1264b4d61e00ab2fb2fd648d489e5fcd329a135c/src/FlowDiagnostics.jl#L347-L355), but as @glwagner mentioned [here](https://github.com/tomchor/Oceanostics.jl/pull/112#issuecomment-1479761310), this isn't ideal since in the future the behavior of the relevant functions may change in Oceananigans and subsequently this calculation will break in Oceanostics. The downside of defining these methods here is that it adds to the testing infrastructure, but I think the way I currently implemented the tests it doesn't contribute too negatively to this. I'm also proposing removing the fallback method here: https://github.com/CliMA/Oceananigans.jl/blob/200f0622278fcfa583da0119e9696048b334146f/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L154-L169. The reason is that I think these general fallback methods cause for hassle than they solve for less experienced Oceananigans developers (myself very much included) by silently returning something physically reasonable (zero in this case) for virtually any combination of arguments, which can be misleading in a debugging process. But I'm curious to get other people's opinion on this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057
https://github.com/CliMA/Oceananigans.jl/pull/3057:210,Energy Efficiency,energy,energy,210,"In this PR I'm exploring the possibility of adding methods for `diffusive_flux_x`, and `viscous_flux_ux` (along with other directions) for tuples. This is needed when reconstructing tracer variance and kinetic energy dissipation rates for tuples in a conservative formulation and, specifically, it's used in Oceanostics for that end (see https://github.com/tomchor/Oceanostics.jl/pull/112). At the moment these are [defined in Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/1264b4d61e00ab2fb2fd648d489e5fcd329a135c/src/FlowDiagnostics.jl#L347-L355), but as @glwagner mentioned [here](https://github.com/tomchor/Oceanostics.jl/pull/112#issuecomment-1479761310), this isn't ideal since in the future the behavior of the relevant functions may change in Oceananigans and subsequently this calculation will break in Oceanostics. The downside of defining these methods here is that it adds to the testing infrastructure, but I think the way I currently implemented the tests it doesn't contribute too negatively to this. I'm also proposing removing the fallback method here: https://github.com/CliMA/Oceananigans.jl/blob/200f0622278fcfa583da0119e9696048b334146f/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L154-L169. The reason is that I think these general fallback methods cause for hassle than they solve for less experienced Oceananigans developers (myself very much included) by silently returning something physically reasonable (zero in this case) for virtually any combination of arguments, which can be misleading in a debugging process. But I'm curious to get other people's opinion on this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057
https://github.com/CliMA/Oceananigans.jl/pull/3057:905,Testability,test,testing,905,"In this PR I'm exploring the possibility of adding methods for `diffusive_flux_x`, and `viscous_flux_ux` (along with other directions) for tuples. This is needed when reconstructing tracer variance and kinetic energy dissipation rates for tuples in a conservative formulation and, specifically, it's used in Oceanostics for that end (see https://github.com/tomchor/Oceanostics.jl/pull/112). At the moment these are [defined in Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/1264b4d61e00ab2fb2fd648d489e5fcd329a135c/src/FlowDiagnostics.jl#L347-L355), but as @glwagner mentioned [here](https://github.com/tomchor/Oceanostics.jl/pull/112#issuecomment-1479761310), this isn't ideal since in the future the behavior of the relevant functions may change in Oceananigans and subsequently this calculation will break in Oceanostics. The downside of defining these methods here is that it adds to the testing infrastructure, but I think the way I currently implemented the tests it doesn't contribute too negatively to this. I'm also proposing removing the fallback method here: https://github.com/CliMA/Oceananigans.jl/blob/200f0622278fcfa583da0119e9696048b334146f/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L154-L169. The reason is that I think these general fallback methods cause for hassle than they solve for less experienced Oceananigans developers (myself very much included) by silently returning something physically reasonable (zero in this case) for virtually any combination of arguments, which can be misleading in a debugging process. But I'm curious to get other people's opinion on this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057
https://github.com/CliMA/Oceananigans.jl/pull/3057:977,Testability,test,tests,977,"In this PR I'm exploring the possibility of adding methods for `diffusive_flux_x`, and `viscous_flux_ux` (along with other directions) for tuples. This is needed when reconstructing tracer variance and kinetic energy dissipation rates for tuples in a conservative formulation and, specifically, it's used in Oceanostics for that end (see https://github.com/tomchor/Oceanostics.jl/pull/112). At the moment these are [defined in Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/1264b4d61e00ab2fb2fd648d489e5fcd329a135c/src/FlowDiagnostics.jl#L347-L355), but as @glwagner mentioned [here](https://github.com/tomchor/Oceanostics.jl/pull/112#issuecomment-1479761310), this isn't ideal since in the future the behavior of the relevant functions may change in Oceananigans and subsequently this calculation will break in Oceanostics. The downside of defining these methods here is that it adds to the testing infrastructure, but I think the way I currently implemented the tests it doesn't contribute too negatively to this. I'm also proposing removing the fallback method here: https://github.com/CliMA/Oceananigans.jl/blob/200f0622278fcfa583da0119e9696048b334146f/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L154-L169. The reason is that I think these general fallback methods cause for hassle than they solve for less experienced Oceananigans developers (myself very much included) by silently returning something physically reasonable (zero in this case) for virtually any combination of arguments, which can be misleading in a debugging process. But I'm curious to get other people's opinion on this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057
https://github.com/CliMA/Oceananigans.jl/pull/3060:257,Modifiability,Extend,Extend,257,"This PR readies `PartialCellBottom` for prime time. Mostly we reorganize code; the substantial changes are:. * Use `Field{Center, Center, Nothing}` for bottom_height. This is convenient mostly for `show` / `summary` but may also prove helpful for users.; * Extend implicit vertical diffusion functionality for partial cells. I'm not sure we did this right... Closes #3064",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3060
https://github.com/CliMA/Oceananigans.jl/issues/3061:44,Availability,mask,masked,44,"I have found it inconvenient that output is masked to `0`. For most purposes, I'd prefer `NaN`. I'm opening this issue to discuss a user interface that would implement such a feature. My first idea is to add a property / kwarg to output writers called `immersed_values`. Then we might write something like. ```julia; output_writer = JLD2OutputWriter(model, output, immersed_values=NaN, other_kwargs...); ```. The default will be `immersed_values=nothing`. Then `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/OutputWriters/fetch_output.jl#L12-L15. would become something like. ```julia. function fetch_output(field::AbstractField, model, immersed_value) ; compute_at!(field, time(model)); !isnothing(immersed_value) && mask_immersed_field!(field, immersed_value); return parent(field) ; end ; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061
https://github.com/CliMA/Oceananigans.jl/issues/3061:137,Integrability,interface,interface,137,"I have found it inconvenient that output is masked to `0`. For most purposes, I'd prefer `NaN`. I'm opening this issue to discuss a user interface that would implement such a feature. My first idea is to add a property / kwarg to output writers called `immersed_values`. Then we might write something like. ```julia; output_writer = JLD2OutputWriter(model, output, immersed_values=NaN, other_kwargs...); ```. The default will be `immersed_values=nothing`. Then `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/OutputWriters/fetch_output.jl#L12-L15. would become something like. ```julia. function fetch_output(field::AbstractField, model, immersed_value) ; compute_at!(field, time(model)); !isnothing(immersed_value) && mask_immersed_field!(field, immersed_value); return parent(field) ; end ; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061
https://github.com/CliMA/Oceananigans.jl/issues/3062:783,Availability,mask,mask,783,"It's currently defined _after_ these:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/Oceananigans.jl#L194-L215. in addition, `ImmersedBoundaries` extends a bunch of functions that were defined in `Advection` and `TurbulenceClosures`. But this is backwards: `ImmersedBoundaries` should be regarded as a fundamental extension of `Grids`. Then `Advection` and `TurbulenceClosures` should provide functionality that is valid on regular and immersed grids. This is a necessary change to split the repo in the future: we want to regard ""advection"" and ""turbulence closures"" as part of the model/physics, and as immersed boundaries as ""physics-agnostic"", ie, more fundamental. More practically it's the cause of some pain. For example, we can't mask immersed fields within `TurbulenceClosures` without changing how we currently define `mask_immersed_field!`. And so on. Things are tangled. I think maybe immersed boundaries belong right after grids, then `Fields` should define `mask_immersed_field!`. So making this change would distribute a lot of the immersed boundary functionality throughout the code. This is probably a natural evolution, since we used to think that immersed boundaries were an experimental add-on. Now its not. @simone-silvestri curious about your opinion since you've worked on a lot of this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3062
https://github.com/CliMA/Oceananigans.jl/issues/3062:191,Modifiability,extend,extends,191,"It's currently defined _after_ these:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/Oceananigans.jl#L194-L215. in addition, `ImmersedBoundaries` extends a bunch of functions that were defined in `Advection` and `TurbulenceClosures`. But this is backwards: `ImmersedBoundaries` should be regarded as a fundamental extension of `Grids`. Then `Advection` and `TurbulenceClosures` should provide functionality that is valid on regular and immersed grids. This is a necessary change to split the repo in the future: we want to regard ""advection"" and ""turbulence closures"" as part of the model/physics, and as immersed boundaries as ""physics-agnostic"", ie, more fundamental. More practically it's the cause of some pain. For example, we can't mask immersed fields within `TurbulenceClosures` without changing how we currently define `mask_immersed_field!`. And so on. Things are tangled. I think maybe immersed boundaries belong right after grids, then `Fields` should define `mask_immersed_field!`. So making this change would distribute a lot of the immersed boundary functionality throughout the code. This is probably a natural evolution, since we used to think that immersed boundaries were an experimental add-on. Now its not. @simone-silvestri curious about your opinion since you've worked on a lot of this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3062
https://github.com/CliMA/Oceananigans.jl/issues/3064:697,Energy Efficiency,reduce,reduced,697,"Right now reductions only exclude _immersed_ peripheral nodes:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/ImmersedBoundaries/immersed_reductions.jl#L27. It recently caused me a lot of pain and confusion and time that ""ordinary"" peripheral nodes are included in the reduction, but immersed peripheral nodes are not. What is the logic for treating immersed boundaries differently from ordinary boundaries? I think we should either exclude only inactive nodes or peripheral nodes, but this behavior should be consistent between immersed and not immersed grids. This change would mean we don't need special reductions (at least for fields that are not reduced) on immersed vs not-immersed grids. @simone-silvestri may have the answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3064
https://github.com/CliMA/Oceananigans.jl/issues/3064:376,Testability,log,logic,376,"Right now reductions only exclude _immersed_ peripheral nodes:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/ImmersedBoundaries/immersed_reductions.jl#L27. It recently caused me a lot of pain and confusion and time that ""ordinary"" peripheral nodes are included in the reduction, but immersed peripheral nodes are not. What is the logic for treating immersed boundaries differently from ordinary boundaries? I think we should either exclude only inactive nodes or peripheral nodes, but this behavior should be consistent between immersed and not immersed grids. This change would mean we don't need special reductions (at least for fields that are not reduced) on immersed vs not-immersed grids. @simone-silvestri may have the answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3064
https://github.com/CliMA/Oceananigans.jl/pull/3066:86,Integrability,depend,dependency,86,"Main motivation here is to make it possible to move CUDA with Julia 1.9 to a optional dependency,; making loading faster for non GPU workloads as well as making it easier for other GPU backends to be added. Package extensions is a backwards compatible 1.9 feature, in 1.8 and prior we still have to load CUDA.jl by default; but on 1.9 this is no longer required.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3066
https://github.com/CliMA/Oceananigans.jl/pull/3066:106,Performance,load,loading,106,"Main motivation here is to make it possible to move CUDA with Julia 1.9 to a optional dependency,; making loading faster for non GPU workloads as well as making it easier for other GPU backends to be added. Package extensions is a backwards compatible 1.9 feature, in 1.8 and prior we still have to load CUDA.jl by default; but on 1.9 this is no longer required.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3066
https://github.com/CliMA/Oceananigans.jl/pull/3066:299,Performance,load,load,299,"Main motivation here is to make it possible to move CUDA with Julia 1.9 to a optional dependency,; making loading faster for non GPU workloads as well as making it easier for other GPU backends to be added. Package extensions is a backwards compatible 1.9 feature, in 1.8 and prior we still have to load CUDA.jl by default; but on 1.9 this is no longer required.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3066
https://github.com/CliMA/Oceananigans.jl/issues/3067:217,Energy Efficiency,Reduce,Reduce,217,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3067:905,Energy Efficiency,reduce,reduced,905,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3067:800,Integrability,depend,depends,800,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3067:291,Modifiability,variab,variables,291,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3067:600,Modifiability,variab,variables,600,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3067:697,Modifiability,variab,variable,697,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3067:728,Modifiability,variab,variables,728,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3067:35,Performance,scalab,scalable,35,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3067:44,Performance,perform,performance,44,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3067:831,Security,access,accessed,831,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067
https://github.com/CliMA/Oceananigans.jl/issues/3068:62,Performance,perform,perform,62,"Increasingly we have the need to offset kernel indices; ie to perform computations over ""windows"" for incomplete `Field` `indices`:. https://github.com/CliMA/Oceananigans.jl/blob/be00e364f9dcd712b3d0c3d48e32b94b181a02fc/src/AbstractOperations/computed_field.jl#L84-L92. or for @simone-silvestri's work to overlap communication and computation, eg #3067. Possibly, such a feature can be supported by `KernelAbstractions` eg https://github.com/JuliaGPU/KernelAbstractions.jl/issues/384 which would simplify our code a lot (since we won't have to pass the offsets into the kernel explicitly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3068
https://github.com/CliMA/Oceananigans.jl/issues/3068:496,Usability,simpl,simplify,496,"Increasingly we have the need to offset kernel indices; ie to perform computations over ""windows"" for incomplete `Field` `indices`:. https://github.com/CliMA/Oceananigans.jl/blob/be00e364f9dcd712b3d0c3d48e32b94b181a02fc/src/AbstractOperations/computed_field.jl#L84-L92. or for @simone-silvestri's work to overlap communication and computation, eg #3067. Possibly, such a feature can be supported by `KernelAbstractions` eg https://github.com/JuliaGPU/KernelAbstractions.jl/issues/384 which would simplify our code a lot (since we won't have to pass the offsets into the kernel explicitly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3068
https://github.com/CliMA/Oceananigans.jl/issues/3069:1032,Energy Efficiency,schedul,schedule,1032,"These lines do not work for `ImmersedBoundaryGrid`. https://github.com/CliMA/Oceananigans.jl/blob/be00e364f9dcd712b3d0c3d48e32b94b181a02fc/src/OutputWriters/netcdf_output_writer.jl#L391-L395. Changing the first line to; ```Julia; if model.grid isa AbstractRectilinearGrid || model.grid isa ImmersedBoundaryGrid{<:Any,<:Any,<:Any,<:Any,<:AbstractRectilinearGrid}; ```; temporarily fixed my problem. Here is the script that I use for testing this issue:; ```Julia; using Oceananigans. underlying_grid = RectilinearGrid(; size=(32, 32, 16),; x=(-3.0, 3.0), y=(-3.0, 3.0), z=(0.0, 1.0),; topology=(Periodic, Periodic, Bounded),; halo=(4, 4, 4),; ). hill(x::Real, y::Real) = 0.1 + 0.1 * exp(-x^2 - y^2). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill)). model = NonhydrostaticModel(;; grid,; advection = WENO(),; ). simulation = Oceananigans.Simulation(model; Δt = 1.0, stop_time = 100.0). fields = model.velocities. simulation.output_writers[:fields] = NetCDFOutputWriter(; model,; fields,; filename = ""output.nc"",; schedule = Oceananigans.TimeInterval(10.0),; ). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3069
https://github.com/CliMA/Oceananigans.jl/issues/3069:432,Testability,test,testing,432,"These lines do not work for `ImmersedBoundaryGrid`. https://github.com/CliMA/Oceananigans.jl/blob/be00e364f9dcd712b3d0c3d48e32b94b181a02fc/src/OutputWriters/netcdf_output_writer.jl#L391-L395. Changing the first line to; ```Julia; if model.grid isa AbstractRectilinearGrid || model.grid isa ImmersedBoundaryGrid{<:Any,<:Any,<:Any,<:Any,<:AbstractRectilinearGrid}; ```; temporarily fixed my problem. Here is the script that I use for testing this issue:; ```Julia; using Oceananigans. underlying_grid = RectilinearGrid(; size=(32, 32, 16),; x=(-3.0, 3.0), y=(-3.0, 3.0), z=(0.0, 1.0),; topology=(Periodic, Periodic, Bounded),; halo=(4, 4, 4),; ). hill(x::Real, y::Real) = 0.1 + 0.1 * exp(-x^2 - y^2). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill)). model = NonhydrostaticModel(;; grid,; advection = WENO(),; ). simulation = Oceananigans.Simulation(model; Δt = 1.0, stop_time = 100.0). fields = model.velocities. simulation.output_writers[:fields] = NetCDFOutputWriter(; model,; fields,; filename = ""output.nc"",; schedule = Oceananigans.TimeInterval(10.0),; ). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3069
https://github.com/CliMA/Oceananigans.jl/pull/3070:390,Availability,down,downstream,390,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070
https://github.com/CliMA/Oceananigans.jl/pull/3070:328,Deployability,release,release,328,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070
https://github.com/CliMA/Oceananigans.jl/pull/3070:414,Integrability,depend,depend,414,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070
https://github.com/CliMA/Oceananigans.jl/pull/3070:141,Testability,test,tested,141,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070
https://github.com/CliMA/Oceananigans.jl/pull/3070:247,Testability,test,tests,247,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070
https://github.com/CliMA/Oceananigans.jl/pull/3070:433,Testability,test,tests,433,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070
https://github.com/CliMA/Oceananigans.jl/pull/3075:15,Usability,simpl,simply,15,First thing is simply to use more threads. But if we can uses parallelism at a little higher level we might do better.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3075
https://github.com/CliMA/Oceananigans.jl/issues/3076:120,Deployability,integrat,integration,120,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:434,Deployability,update,updated,434,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:851,Deployability,upgrade,upgrade,851,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:120,Integrability,integrat,integration,120,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:5,Security,validat,validation,5,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:342,Security,validat,validation,342,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:676,Security,validat,validation,676,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:944,Security,validat,validation,944,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:132,Testability,test,tests,132,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:370,Testability,test,tested,370,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/issues/3076:932,Testability,test,testing,932,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076
https://github.com/CliMA/Oceananigans.jl/pull/3080:1158,Energy Efficiency,reduce,reduces,1158,"nd a ""non-hydrostatic"" component. The vertical momentum equation in `NonhydrostaticModel` is. $$ \partial_t w = - \partial_z p + b + G_w' $$. where $G_w'$ collects the contributions to the vertical momentum tendency other than pressure gradient and buoyancy. Prior to this PR, the kinematic pressure $p$ is decomposed into (note that in this Boussinesq formulation, a hydrostatic component has already been removed from $p$) . $$ p = p_h' + p_n $$. with the hydrostatic anomaly $p_h'$ defined by. $$ p_h' = - \int^0_z b \mathrm{d} z $$. Using the hydrostatic pressure anomaly eliminates buoyancy from the vertical momentum equation, such that. $$ \partial_t w = - \partial_z p_n + G_w' $$. Buoyancy forces enter the dynamics via horizontal gradients of the hydrostatic pressure anomaly. For example, x-gradient of the kinematic pressure becomes. $$ \partial_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:1903,Energy Efficiency,reduce,reduces,1903,"_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:3432,Energy Efficiency,reduce,reduced,3432,"plifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:4284,Energy Efficiency,reduce,reduced,4284,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:3567,Integrability,interface,interface,3567,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:63,Modifiability,variab,variable,63,"This PR changes `NonhydrostaticModel` to use a single pressure variable. Prior to this PR, pressure is decomposed into a ""hydrostatic anomaly"" and a ""non-hydrostatic"" component. The vertical momentum equation in `NonhydrostaticModel` is. $$ \partial_t w = - \partial_z p + b + G_w' $$. where $G_w'$ collects the contributions to the vertical momentum tendency other than pressure gradient and buoyancy. Prior to this PR, the kinematic pressure $p$ is decomposed into (note that in this Boussinesq formulation, a hydrostatic component has already been removed from $p$) . $$ p = p_h' + p_n $$. with the hydrostatic anomaly $p_h'$ defined by. $$ p_h' = - \int^0_z b \mathrm{d} z $$. Using the hydrostatic pressure anomaly eliminates buoyancy from the vertical momentum equation, such that. $$ \partial_t w = - \partial_z p_n + G_w' $$. Buoyancy forces enter the dynamics via horizontal gradients of the hydrostatic pressure anomaly. For example, x-gradient of the kinematic pressure becomes. $$ \partial_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:2705,Modifiability,variab,variables,2705,"is PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:2992,Modifiability,variab,variables,2992," domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:1932,Performance,load,loads,1932,"_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:2432,Safety,avoid,avoid,2432,"o that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:3158,Safety,risk,risks,3158,"in decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen i",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:3183,Safety,Risk,Risk,3183,"again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:4056,Testability,test,tests,4056,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:4186,Testability,test,tested,4186,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:4222,Testability,test,test,4222,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:1280,Usability,simpl,simple,1280,"w = - \partial_z p + b + G_w' $$. where $G_w'$ collects the contributions to the vertical momentum tendency other than pressure gradient and buoyancy. Prior to this PR, the kinematic pressure $p$ is decomposed into (note that in this Boussinesq formulation, a hydrostatic component has already been removed from $p$) . $$ p = p_h' + p_n $$. with the hydrostatic anomaly $p_h'$ defined by. $$ p_h' = - \int^0_z b \mathrm{d} z $$. Using the hydrostatic pressure anomaly eliminates buoyancy from the vertical momentum equation, such that. $$ \partial_t w = - \partial_z p_n + G_w' $$. Buoyancy forces enter the dynamics via horizontal gradients of the hydrostatic pressure anomaly. For example, x-gradient of the kinematic pressure becomes. $$ \partial_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used bec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:2362,Usability,simpl,simplifies,2362,"s possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/pull/3080:4115,Usability,clear,clear,4115,"cs. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to test because the feature does not exist yet (such as accurate reduced precision algorithm or nonlinear free surface). Thus we should consider this PR carefully.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080
https://github.com/CliMA/Oceananigans.jl/issues/3082:1077,Deployability,update,update,1077,"We need a user interface for building `Field` from boundary conditions. Such a utility is model-specific. Right now, users have to do something like this (to get the bottom boundary condition, for example):. ```julia; using Oceananigans.BoundaryConditions: getbc; using Oceananigans: fields. # Boundary condition extractor in ""kernel function form""; @inline kernel_getbc(i, j, k, grid, boundary_condition, clock, fields) =; getbc(boundary_condition, i, j, grid, clock, fields). # Kernel arguments; grid = model.grid; clock = model.clock; model_fields = merge(fields(model), model.auxiliary_fields); u, v, w = model.velocities; u_bc = u.boundary_conditions.bottom; v_bc = v.boundary_conditions.bottom. # Build operations; u_bc_op = KernelFunctionOperation{Face, Center, Nothing}(kernel_getbc, grid, u_bc, clock, model_fields); v_bc_op = KernelFunctionOperation{Center, Face, Nothing}(kernel_getbc, grid, v_bc, clock, model_fields); ```. A few observations:. * It's annoying to have to define the wrapper `kernel_getbc`. I don't know if there's a clean way around this. We could update `getbc` to be closer to ""kernel form"", but I'm not sure we want to add the third index when its unused. We could make two-index kernel functions work with `KernelFunctionOperation`, leveraging `Nothing` location --- that might be clean.; * This is model specific because we have to keep track of the arguments passed to `getbc`. Maybe we want to codify that better, ie by using a function `boundary_condition_fields`. I think a user API could look like. ```julia; u_bottom_bc_op = boundary_condition_operation(u, :bottom, model); ```. This came up on #3081",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3082
https://github.com/CliMA/Oceananigans.jl/issues/3082:15,Integrability,interface,interface,15,"We need a user interface for building `Field` from boundary conditions. Such a utility is model-specific. Right now, users have to do something like this (to get the bottom boundary condition, for example):. ```julia; using Oceananigans.BoundaryConditions: getbc; using Oceananigans: fields. # Boundary condition extractor in ""kernel function form""; @inline kernel_getbc(i, j, k, grid, boundary_condition, clock, fields) =; getbc(boundary_condition, i, j, grid, clock, fields). # Kernel arguments; grid = model.grid; clock = model.clock; model_fields = merge(fields(model), model.auxiliary_fields); u, v, w = model.velocities; u_bc = u.boundary_conditions.bottom; v_bc = v.boundary_conditions.bottom. # Build operations; u_bc_op = KernelFunctionOperation{Face, Center, Nothing}(kernel_getbc, grid, u_bc, clock, model_fields); v_bc_op = KernelFunctionOperation{Center, Face, Nothing}(kernel_getbc, grid, v_bc, clock, model_fields); ```. A few observations:. * It's annoying to have to define the wrapper `kernel_getbc`. I don't know if there's a clean way around this. We could update `getbc` to be closer to ""kernel form"", but I'm not sure we want to add the third index when its unused. We could make two-index kernel functions work with `KernelFunctionOperation`, leveraging `Nothing` location --- that might be clean.; * This is model specific because we have to keep track of the arguments passed to `getbc`. Maybe we want to codify that better, ie by using a function `boundary_condition_fields`. I think a user API could look like. ```julia; u_bottom_bc_op = boundary_condition_operation(u, :bottom, model); ```. This came up on #3081",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3082
https://github.com/CliMA/Oceananigans.jl/issues/3082:995,Integrability,wrap,wrapper,995,"We need a user interface for building `Field` from boundary conditions. Such a utility is model-specific. Right now, users have to do something like this (to get the bottom boundary condition, for example):. ```julia; using Oceananigans.BoundaryConditions: getbc; using Oceananigans: fields. # Boundary condition extractor in ""kernel function form""; @inline kernel_getbc(i, j, k, grid, boundary_condition, clock, fields) =; getbc(boundary_condition, i, j, grid, clock, fields). # Kernel arguments; grid = model.grid; clock = model.clock; model_fields = merge(fields(model), model.auxiliary_fields); u, v, w = model.velocities; u_bc = u.boundary_conditions.bottom; v_bc = v.boundary_conditions.bottom. # Build operations; u_bc_op = KernelFunctionOperation{Face, Center, Nothing}(kernel_getbc, grid, u_bc, clock, model_fields); v_bc_op = KernelFunctionOperation{Center, Face, Nothing}(kernel_getbc, grid, v_bc, clock, model_fields); ```. A few observations:. * It's annoying to have to define the wrapper `kernel_getbc`. I don't know if there's a clean way around this. We could update `getbc` to be closer to ""kernel form"", but I'm not sure we want to add the third index when its unused. We could make two-index kernel functions work with `KernelFunctionOperation`, leveraging `Nothing` location --- that might be clean.; * This is model specific because we have to keep track of the arguments passed to `getbc`. Maybe we want to codify that better, ie by using a function `boundary_condition_fields`. I think a user API could look like. ```julia; u_bottom_bc_op = boundary_condition_operation(u, :bottom, model); ```. This came up on #3081",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3082
https://github.com/CliMA/Oceananigans.jl/issues/3083:231,Availability,error,error,231,"Hello. Thank you for this contribution. I am really interested in using it. . I tried to run the example here: https://clima.github.io/OceananigansDocumentation/v0.22.0/generated/ocean_wind_mixing_and_convection/. I am getting the error: RegularCartesianGrid not defined; Is there something I need to import? Thank you! Sorry, I am a novice with Julia.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3083
https://github.com/CliMA/Oceananigans.jl/pull/3087:448,Availability,checkpoint,checkpoint,448,"This PR continues #1085 the work that started on a fork long ago. @siddharthabishnu feel free to continue working on this Oceananigans branch now ;). Some of the things we discussed to do:. - [ ] convert to lat-lon grid; - [ ] add some bathymetry, e.g., bathtub-type of domain prescribed by some analytical function; - [ ] use Ri-based diffusivity for BL closure; - [ ] remove horizontal viscosities/diffusivities; - [ ] potentially run long, save checkpoint, and then resume to run for 6-12 months in the docs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087
https://github.com/CliMA/Oceananigans.jl/pull/3087:469,Usability,resume,resume,469,"This PR continues #1085 the work that started on a fork long ago. @siddharthabishnu feel free to continue working on this Oceananigans branch now ;). Some of the things we discussed to do:. - [ ] convert to lat-lon grid; - [ ] add some bathymetry, e.g., bathtub-type of domain prescribed by some analytical function; - [ ] use Ri-based diffusivity for BL closure; - [ ] remove horizontal viscosities/diffusivities; - [ ] potentially run long, save checkpoint, and then resume to run for 6-12 months in the docs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087
https://github.com/CliMA/Oceananigans.jl/issues/3088:156,Modifiability,refactor,refactor,156,"As a first step towards porting the Simulations infrastructure out of Oceananigans and into (ClimaEarth)[https://github.com/CliMA/ClimaEarth.jl], we should refactor the Simulations implementation so that it gets loaded _first_. Currently, it is loaded last:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Oceananigans.jl#L195-L229. This reorganization will help disentangle the current implementation from Oceananigans.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3088
https://github.com/CliMA/Oceananigans.jl/issues/3088:212,Performance,load,loaded,212,"As a first step towards porting the Simulations infrastructure out of Oceananigans and into (ClimaEarth)[https://github.com/CliMA/ClimaEarth.jl], we should refactor the Simulations implementation so that it gets loaded _first_. Currently, it is loaded last:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Oceananigans.jl#L195-L229. This reorganization will help disentangle the current implementation from Oceananigans.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3088
https://github.com/CliMA/Oceananigans.jl/issues/3088:245,Performance,load,loaded,245,"As a first step towards porting the Simulations infrastructure out of Oceananigans and into (ClimaEarth)[https://github.com/CliMA/ClimaEarth.jl], we should refactor the Simulations implementation so that it gets loaded _first_. Currently, it is loaded last:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Oceananigans.jl#L195-L229. This reorganization will help disentangle the current implementation from Oceananigans.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3088
https://github.com/CliMA/Oceananigans.jl/pull/3092:50,Availability,mask,mask,50,Resolves #3061. Questions:. Does it make sense to mask when`with_halos = true`? With `with_halos = true` implies that the users can use the output to compute derivative fields etc; will masking obscure this?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3092
https://github.com/CliMA/Oceananigans.jl/pull/3092:186,Availability,mask,masking,186,Resolves #3061. Questions:. Does it make sense to mask when`with_halos = true`? With `with_halos = true` implies that the users can use the output to compute derivative fields etc; will masking obscure this?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3092
https://github.com/CliMA/Oceananigans.jl/issues/3093:87,Availability,error,error,87,"I tried to construct a PGC free surface solver with an FFT preconditioned and I get an error. ```Julia; ArgumentError: The dimensions of the immersed boundary (408, 1) do not match the grid size (406, 1). Stacktrace:; [1] validate_ib_size(grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries /g/data/v45/nc3020/.julia/packages/Oceananigans/KZUtL/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries /g/data/v45/nc3020/.julia/packages/Oceananigans/KZUtL/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3093
https://github.com/CliMA/Oceananigans.jl/issues/3099:1585,Deployability,update,updated,1585,"The discussion on https://github.com/CliMA/Oceananigans.jl/discussions/3098 had me thinking about how we might allow users to access more model data within forcing or boundary condition functions. The problem we encountered in the past (especially for diffusivity fields) is that dumping _everything_ into the forcing function often caused GPU compilation to fail. That's why forcing functions only have access (for example) to velocities, tracers, and auxiliary fields:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L62. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L74. A possible solution to this is a utility `with_auxiliary_fields` for ""rebuilding"" a model with new auxiliary fields. I think this would be relatively simple to implement, because the `auxiliary_fields` don't have any role within a model constructor. Thus we can develop something like. ```julia; model = with_auxiliary_fields(model, new_auxiliary_fields); ```. which is quite easy I think, something like... ```julia; function with_auxiliary_fields(model::NonhydrostaticModel, new_auxiliary_fields); model_properties = OrderedDict{Any, Any}(name => getproperty(model, name) for name in propertynames(model)); model_properties[:auxiliary_fields] = new_auxiliiary_fields; return NonhydrostaticModel(model_properties.values...); end; ```. Then users can run simulations with the ""updated"" model, putting any fields they like from the ""old"" model into `auxiliary_fields`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3099
https://github.com/CliMA/Oceananigans.jl/issues/3099:126,Security,access,access,126,"The discussion on https://github.com/CliMA/Oceananigans.jl/discussions/3098 had me thinking about how we might allow users to access more model data within forcing or boundary condition functions. The problem we encountered in the past (especially for diffusivity fields) is that dumping _everything_ into the forcing function often caused GPU compilation to fail. That's why forcing functions only have access (for example) to velocities, tracers, and auxiliary fields:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L62. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L74. A possible solution to this is a utility `with_auxiliary_fields` for ""rebuilding"" a model with new auxiliary fields. I think this would be relatively simple to implement, because the `auxiliary_fields` don't have any role within a model constructor. Thus we can develop something like. ```julia; model = with_auxiliary_fields(model, new_auxiliary_fields); ```. which is quite easy I think, something like... ```julia; function with_auxiliary_fields(model::NonhydrostaticModel, new_auxiliary_fields); model_properties = OrderedDict{Any, Any}(name => getproperty(model, name) for name in propertynames(model)); model_properties[:auxiliary_fields] = new_auxiliiary_fields; return NonhydrostaticModel(model_properties.values...); end; ```. Then users can run simulations with the ""updated"" model, putting any fields they like from the ""old"" model into `auxiliary_fields`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3099
https://github.com/CliMA/Oceananigans.jl/issues/3099:404,Security,access,access,404,"The discussion on https://github.com/CliMA/Oceananigans.jl/discussions/3098 had me thinking about how we might allow users to access more model data within forcing or boundary condition functions. The problem we encountered in the past (especially for diffusivity fields) is that dumping _everything_ into the forcing function often caused GPU compilation to fail. That's why forcing functions only have access (for example) to velocities, tracers, and auxiliary fields:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L62. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L74. A possible solution to this is a utility `with_auxiliary_fields` for ""rebuilding"" a model with new auxiliary fields. I think this would be relatively simple to implement, because the `auxiliary_fields` don't have any role within a model constructor. Thus we can develop something like. ```julia; model = with_auxiliary_fields(model, new_auxiliary_fields); ```. which is quite easy I think, something like... ```julia; function with_auxiliary_fields(model::NonhydrostaticModel, new_auxiliary_fields); model_properties = OrderedDict{Any, Any}(name => getproperty(model, name) for name in propertynames(model)); model_properties[:auxiliary_fields] = new_auxiliiary_fields; return NonhydrostaticModel(model_properties.values...); end; ```. Then users can run simulations with the ""updated"" model, putting any fields they like from the ""old"" model into `auxiliary_fields`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3099
https://github.com/CliMA/Oceananigans.jl/issues/3099:958,Usability,simpl,simple,958,"The discussion on https://github.com/CliMA/Oceananigans.jl/discussions/3098 had me thinking about how we might allow users to access more model data within forcing or boundary condition functions. The problem we encountered in the past (especially for diffusivity fields) is that dumping _everything_ into the forcing function often caused GPU compilation to fail. That's why forcing functions only have access (for example) to velocities, tracers, and auxiliary fields:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L62. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L74. A possible solution to this is a utility `with_auxiliary_fields` for ""rebuilding"" a model with new auxiliary fields. I think this would be relatively simple to implement, because the `auxiliary_fields` don't have any role within a model constructor. Thus we can develop something like. ```julia; model = with_auxiliary_fields(model, new_auxiliary_fields); ```. which is quite easy I think, something like... ```julia; function with_auxiliary_fields(model::NonhydrostaticModel, new_auxiliary_fields); model_properties = OrderedDict{Any, Any}(name => getproperty(model, name) for name in propertynames(model)); model_properties[:auxiliary_fields] = new_auxiliiary_fields; return NonhydrostaticModel(model_properties.values...); end; ```. Then users can run simulations with the ""updated"" model, putting any fields they like from the ""old"" model into `auxiliary_fields`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3099
https://github.com/CliMA/Oceananigans.jl/pull/3100:14,Testability,test,tests,14,This PR moves tests on Julia v1.9.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100
https://github.com/CliMA/Oceananigans.jl/pull/3101:14,Deployability,update,updates,14,amongst other updates it also bumps CUDA 4.1.2->4.2.0 and KA 0.9.1->0.9.4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3101
https://github.com/CliMA/Oceananigans.jl/pull/3102:37,Modifiability,refactor,refactored,37,I noticed it was a bit convoluted. I refactored the viscosity computation to hopefully be a bit more readable and understandable.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3102
https://github.com/CliMA/Oceananigans.jl/pull/3109:2139,Energy Efficiency,schedul,schedules,2139," |__/ |. julia> using Glob. julia> glob(""src/*.jl""); 6-element Vector{String}:; ""src/Architectures.jl""; ""src/Biogeochemistry.jl""; ""src/Logger.jl""; ""src/Oceananigans.jl""; ""src/StokesDrift.jl""; ""src/Units.jl"". julia> glob(""src/**/*.jl""); 213-element Vector{String}:; ""src/AbstractOperations/AbstractOperations.jl""; ""src/AbstractOperations/at.jl""; ""src/AbstractOperations/binary_operations.jl""; ""src/AbstractOperations/broadcasting_abstract_operations.jl""; ""src/AbstractOperations/computed_field.jl""; ""src/AbstractOperations/conditional_operations.jl""; ""src/AbstractOperations/constant_field_abstract_operations.jl""; ""src/AbstractOperations/derivatives.jl""; ""src/AbstractOperations/grid_metrics.jl""; ""src/AbstractOperations/grid_validation.jl""; ""src/AbstractOperations/kernel_function_operation.jl""; ""src/AbstractOperations/metric_field_reductions.jl""; ""src/AbstractOperations/multiary_operations.jl""; ""src/AbstractOperations/show_abstract_operations.jl""; ""src/AbstractOperations/unary_operations.jl""; ""src/Advection/Advection.jl""; ""src/Advection/cell_advection_timescale.jl""; ""src/Advection/centered_advective_fluxes.jl""; ""src/Advection/centered_reconstruction.jl""; ""src/Advection/flat_advective_fluxes.jl""; ⋮; ""src/TurbulenceClosures/implicit_explicit_time_discretization.jl""; ""src/TurbulenceClosures/isopycnal_rotation_tensor_components.jl""; ""src/TurbulenceClosures/turbulence_closure_diagnostics.jl""; ""src/TurbulenceClosures/turbulence_closure_utils.jl""; ""src/TurbulenceClosures/velocity_tracer_gradients.jl""; ""src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl""; ""src/Utils/Utils.jl""; ""src/Utils/kernel_launching.jl""; ""src/Utils/multi_region_transformation.jl""; ""src/Utils/ordered_dict_show.jl""; ""src/Utils/output_writer_diagnostic_utils.jl""; ""src/Utils/pretty_filesize.jl""; ""src/Utils/prettysummary.jl""; ""src/Utils/prettytime.jl""; ""src/Utils/schedules.jl""; ""src/Utils/tuple_utils.jl""; ""src/Utils/user_function_arguments.jl""; ""src/Utils/versioninfo.jl""; ""src/Utils/with_tracers.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3109
https://github.com/CliMA/Oceananigans.jl/pull/3109:417,Testability,Log,Logger,417,"See below for a MWE. ```Julia; $ julia --project=docs; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.9.0 (2023-05-07); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Glob. julia> glob(""src/*.jl""); 6-element Vector{String}:; ""src/Architectures.jl""; ""src/Biogeochemistry.jl""; ""src/Logger.jl""; ""src/Oceananigans.jl""; ""src/StokesDrift.jl""; ""src/Units.jl"". julia> glob(""src/**/*.jl""); 213-element Vector{String}:; ""src/AbstractOperations/AbstractOperations.jl""; ""src/AbstractOperations/at.jl""; ""src/AbstractOperations/binary_operations.jl""; ""src/AbstractOperations/broadcasting_abstract_operations.jl""; ""src/AbstractOperations/computed_field.jl""; ""src/AbstractOperations/conditional_operations.jl""; ""src/AbstractOperations/constant_field_abstract_operations.jl""; ""src/AbstractOperations/derivatives.jl""; ""src/AbstractOperations/grid_metrics.jl""; ""src/AbstractOperations/grid_validation.jl""; ""src/AbstractOperations/kernel_function_operation.jl""; ""src/AbstractOperations/metric_field_reductions.jl""; ""src/AbstractOperations/multiary_operations.jl""; ""src/AbstractOperations/show_abstract_operations.jl""; ""src/AbstractOperations/unary_operations.jl""; ""src/Advection/Advection.jl""; ""src/Advection/cell_advection_timescale.jl""; ""src/Advection/centered_advective_fluxes.jl""; ""src/Advection/centered_reconstruction.jl""; ""src/Advection/flat_advective_fluxes.jl""; ⋮; ""src/TurbulenceClosures/implicit_explicit_time_discretization.jl""; ""src/TurbulenceClosures/isopycnal_rotation_tensor_components.jl""; ""src/TurbulenceClosures/turbulence_closure_diagnostics.jl""; ""src/TurbulenceClosures/turbulence_closure_utils.jl""; ""src/TurbulenceClosures/velocity_tracer_gradients.jl""; ""src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl""; ""src/Utils/Utils.jl""; ""src/Utils/kernel_launching.jl""; ""src/Utils/multi_region_transformation.jl""; ""src/Utils/ordered_dict_show.jl""; ""src/Util",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3109
https://github.com/CliMA/Oceananigans.jl/issues/3112:107,Deployability,deploy,deploying,107,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112
https://github.com/CliMA/Oceananigans.jl/issues/3112:365,Deployability,deploy,deploying,365,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112
https://github.com/CliMA/Oceananigans.jl/issues/3112:792,Modifiability,config,config,792,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112
https://github.com/CliMA/Oceananigans.jl/issues/3112:1006,Testability,test,test,1006,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112
https://github.com/CliMA/Oceananigans.jl/issues/3112:1011,Testability,test,testhelpers,1011,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112
https://github.com/CliMA/Oceananigans.jl/issues/3112:1075,Testability,test,test,1075,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112
https://github.com/CliMA/Oceananigans.jl/issues/3112:1080,Testability,test,testhelpers,1080,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112
https://github.com/CliMA/Oceananigans.jl/issues/3112:1145,Testability,test,test,1145,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112
https://github.com/CliMA/Oceananigans.jl/pull/3115:138,Safety,redund,redundancy,138,"This PR does two things:. - Changes `docs/make.jl` to only define the example names once. They were being defined twice before, with some redundancy. Now it'll be easier to comment a given example out when building the docs locally, for example.; - Speeds up the tilted BBL example. I'm doing that by starting it with some noise, which makes turbulence appear much sooner, which allows us to run it for only one day (half the previous time).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3115
https://github.com/CliMA/Oceananigans.jl/issues/3116:12,Modifiability,extend,extend,12,"I wanted to extend the code to allow `NonhydrostaticModel`s with irregular grids in all directions, not just the `z` direction. As @glwagner mentioned, it would be good to discuss the approach here, although I started the draft PR https://github.com/CliMA/Oceananigans.jl/pull/3111 already extending `FourierTridiagonalPoissonSolver` to all directions. Apparently `BatchedTridiagonalSolver` needs to be generalized first, which I didn't anticipate/notice.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116
https://github.com/CliMA/Oceananigans.jl/issues/3116:290,Modifiability,extend,extending,290,"I wanted to extend the code to allow `NonhydrostaticModel`s with irregular grids in all directions, not just the `z` direction. As @glwagner mentioned, it would be good to discuss the approach here, although I started the draft PR https://github.com/CliMA/Oceananigans.jl/pull/3111 already extending `FourierTridiagonalPoissonSolver` to all directions. Apparently `BatchedTridiagonalSolver` needs to be generalized first, which I didn't anticipate/notice.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116
https://github.com/CliMA/Oceananigans.jl/pull/3117:8,Modifiability,extend,extends,8,"This PR extends `BatchedTridiagonalSolver` to also work when the tridiagonal direction is `x` and `y`, in addition to `z`. This is one necessary step to getting the `NonhydrostaticModel` to work with grids that are irregularly-spacing in the `x` and `y` directions. Related to https://github.com/CliMA/Oceananigans.jl/issues/3116",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117
https://github.com/CliMA/Oceananigans.jl/pull/3119:185,Testability,test,tested,185,"This pull request changes the compat entry for the `PencilArrays` package from `0.16, 0.17` to `0.16, 0.17, 0.18`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3119
https://github.com/CliMA/Oceananigans.jl/pull/3119:291,Testability,test,tests,291,"This pull request changes the compat entry for the `PencilArrays` package from `0.16, 0.17` to `0.16, 0.17, 0.18`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3119
https://github.com/CliMA/Oceananigans.jl/pull/3120:187,Testability,test,tested,187,"This pull request changes the compat entry for the `PencilFFTs` package from `0.13.5, 0.14` to `0.13.5, 0.14, 0.15`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3120
https://github.com/CliMA/Oceananigans.jl/pull/3120:293,Testability,test,tests,293,"This pull request changes the compat entry for the `PencilFFTs` package from `0.13.5, 0.14` to `0.13.5, 0.14, 0.15`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3120
https://github.com/CliMA/Oceananigans.jl/pull/3122:51,Modifiability,refactor,refactoring,51,"Supercedes #3090, introducing a more comprehensive refactoring of the CATKE formulation. Closes https://github.com/CliMA/Oceananigans.jl/issues/3064; Closes https://github.com/CliMA/Oceananigans.jl/issues/3047",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122
https://github.com/CliMA/Oceananigans.jl/issues/3123:504,Deployability,configurat,configuration,504,"Cut cells use piecewise linear representations of bathymetry (as opposed to full or partial cells which use piecewise constant ones). Here’s a tentative work plan for implementing cut cells:. 1. Develop the following test cases: . (a) Tracer advection with no momentum on a seamount ([Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) or [Schär](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml) configuration); ; (b) Internal wave or overflow with momentum;; ; Run these test cases for full and partial cells. As suggested by @jm-c, compare a simulation using low vertical resolution (~10 vertical layers) and partial cells with one using high vertical resolution (~500 vertical layers) and full cells at the same horizontal resolution (to verify the effectiveness of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Cons",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:2132,Deployability,integrat,integration,2132,"partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Constant Slope](https://journals.ametsoc.org/view/journals/mwre/145/5/mwr-d-16-0308.1.xml?tab_body=abstract-display); [A finite-volume integration method for computing pressure gradient force in general vertical coordinates](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-d-15-0226.1.xml); [Large-eddy simulations with ClimateMachine v0.2.0: a new open-source code for atmospheric simulations on GPUs and CPUs](https://gmd.copernicus.org/articles/15/6259/2022/); [Medium range forecasts using cut-cells: a sensitivity study](https://link.springer.com/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:2132,Integrability,integrat,integration,2132,"partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Constant Slope](https://journals.ametsoc.org/view/journals/mwre/145/5/mwr-d-16-0308.1.xml?tab_body=abstract-display); [A finite-volume integration method for computing pressure gradient force in general vertical coordinates](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-d-15-0226.1.xml); [Large-eddy simulations with ClimateMachine v0.2.0: a new open-source code for atmospheric simulations on GPUs and CPUs](https://gmd.copernicus.org/articles/15/6259/2022/); [Medium range forecasts using cut-cells: a sensitivity study](https://link.springer.com/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:504,Modifiability,config,configuration,504,"Cut cells use piecewise linear representations of bathymetry (as opposed to full or partial cells which use piecewise constant ones). Here’s a tentative work plan for implementing cut cells:. 1. Develop the following test cases: . (a) Tracer advection with no momentum on a seamount ([Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) or [Schär](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml) configuration); ; (b) Internal wave or overflow with momentum;; ; Run these test cases for full and partial cells. As suggested by @jm-c, compare a simulation using low vertical resolution (~10 vertical layers) and partial cells with one using high vertical resolution (~500 vertical layers) and full cells at the same horizontal resolution (to verify the effectiveness of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Cons",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:707,Modifiability,layers,layers,707,"Cut cells use piecewise linear representations of bathymetry (as opposed to full or partial cells which use piecewise constant ones). Here’s a tentative work plan for implementing cut cells:. 1. Develop the following test cases: . (a) Tracer advection with no momentum on a seamount ([Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) or [Schär](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml) configuration); ; (b) Internal wave or overflow with momentum;; ; Run these test cases for full and partial cells. As suggested by @jm-c, compare a simulation using low vertical resolution (~10 vertical layers) and partial cells with one using high vertical resolution (~500 vertical layers) and full cells at the same horizontal resolution (to verify the effectiveness of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Cons",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:788,Modifiability,layers,layers,788,"Cut cells use piecewise linear representations of bathymetry (as opposed to full or partial cells which use piecewise constant ones). Here’s a tentative work plan for implementing cut cells:. 1. Develop the following test cases: . (a) Tracer advection with no momentum on a seamount ([Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) or [Schär](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml) configuration); ; (b) Internal wave or overflow with momentum;; ; Run these test cases for full and partial cells. As suggested by @jm-c, compare a simulation using low vertical resolution (~10 vertical layers) and partial cells with one using high vertical resolution (~500 vertical layers) and full cells at the same horizontal resolution (to verify the effectiveness of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Cons",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:1824,Modifiability,Extend,Extend,1824,"s of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Constant Slope](https://journals.ametsoc.org/view/journals/mwre/145/5/mwr-d-16-0308.1.xml?tab_body=abstract-display); [A finite-volume integration method for computing pressure gradient force in general vertical coordinates](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:2613,Safety,Predict,Prediction,2613,or partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Constant Slope](https://journals.ametsoc.org/view/journals/mwre/145/5/mwr-d-16-0308.1.xml?tab_body=abstract-display); [A finite-volume integration method for computing pressure gradient force in general vertical coordinates](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-d-15-0226.1.xml); [Large-eddy simulations with ClimateMachine v0.2.0: a new open-source code for atmospheric simulations on GPUs and CPUs](https://gmd.copernicus.org/articles/15/6259/2022/); [Medium range forecasts using cut-cells: a sensitivity study](https://link.springer.com/article/10.1007/s00703-019-00681-w); [On methods for solving the oceanic equations of motion in generalized vertical coordinates](https://www.sciencedirect.com/science/article/abs/pii/S1463500305000090); [Representation of topography by porous barriers and objective interpolation of topographic data](https://www.sciencedirect.com/science/article/pii/S1463500313000425); [Representation of Topography by Shaved Cells in a Height Coordinate,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:217,Testability,test,test,217,"Cut cells use piecewise linear representations of bathymetry (as opposed to full or partial cells which use piecewise constant ones). Here’s a tentative work plan for implementing cut cells:. 1. Develop the following test cases: . (a) Tracer advection with no momentum on a seamount ([Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) or [Schär](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml) configuration); ; (b) Internal wave or overflow with momentum;; ; Run these test cases for full and partial cells. As suggested by @jm-c, compare a simulation using low vertical resolution (~10 vertical layers) and partial cells with one using high vertical resolution (~500 vertical layers) and full cells at the same horizontal resolution (to verify the effectiveness of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Cons",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:580,Testability,test,test,580,"Cut cells use piecewise linear representations of bathymetry (as opposed to full or partial cells which use piecewise constant ones). Here’s a tentative work plan for implementing cut cells:. 1. Develop the following test cases: . (a) Tracer advection with no momentum on a seamount ([Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) or [Schär](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml) configuration); ; (b) Internal wave or overflow with momentum;; ; Run these test cases for full and partial cells. As suggested by @jm-c, compare a simulation using low vertical resolution (~10 vertical layers) and partial cells with one using high vertical resolution (~500 vertical layers) and full cells at the same horizontal resolution (to verify the effectiveness of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Cons",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/issues/3123:4130,Testability,test,test,4130,MepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-d-15-0226.1.xml); [Large-eddy simulations with ClimateMachine v0.2.0: a new open-source code for atmospheric simulations on GPUs and CPUs](https://gmd.copernicus.org/articles/15/6259/2022/); [Medium range forecasts using cut-cells: a sensitivity study](https://link.springer.com/article/10.1007/s00703-019-00681-w); [On methods for solving the oceanic equations of motion in generalized vertical coordinates](https://www.sciencedirect.com/science/article/abs/pii/S1463500305000090); [Representation of topography by porous barriers and objective interpolation of topographic data](https://www.sciencedirect.com/science/article/pii/S1463500313000425); [Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml); [Rescaled height coordinates for accurate representation of free-surface flows in ocean circulation models](https://www.sciencedirect.com/science/article/abs/pii/S1463500303000544); [Sliding or stumbling on the staircase: numerics of ocean circulation along piecewise-constant coastlines](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2022MS003594); ```[tasklist]; ### Tasks; - [ ] Tracer advection over seamount test case; - [ ] Two-dimensional implementation of `CutCellBottom`; - [ ] Three-dimensional implementation of `CutCellBottom`; - [ ] Merging of cells with small area (2D) or volume (3D) for cut cells; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123
https://github.com/CliMA/Oceananigans.jl/pull/3125:2071,Energy Efficiency,Adapt,Adapt,2071,"ncies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passing. #### API changes; - When calling `RectilinearGrid(arch::DistributedArch, size = (Nx, Ny, Nz), ....)`, `(Nx, Ny, Nz)` are the _per-rank_ local sizes, not the global size to be divided (easy way to specify non-uniform partitioning, see `validation/distributed/mpi_geostrophic_adjustment.jl`); - added the `enable_overlapped_communication` keyword to `DistributedArch` (defaults to true); - removed the `use_buffers` keyword to `DistributedArch` (_always_ use buffers, as views did not give significant speedup to justify maintaining two implementations); - added the keyword argument `active_cells_map::Bool = false` to `ImmersedBoundaryGrid` (ex: `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125
https://github.com/CliMA/Oceananigans.jl/pull/3125:848,Modifiability,variab,variables,848,"Overlapping MPI communication and computation in the HydrostaticFreeSurfaceModel and the NonhydrostaticModel. In particular, this PR introduces two keyword arguments for the `fill_halo_regions!` function, active **only** in case of distributed halo passing boundary conditions:; - the`async::Bool` keyword argument that allows launching MPI operations without waiting for the communication to complete.; - the `only_local_halos::Bool` keyword argument, which fills only the halo in case of a local (i.e., Flux, Value, Gradient, Periodic, and, temporarily, MultiRegionCommunication) boundary condition. This is required for having explicit boundary conditions (like Value or Flux) for turbulent diffusivities (we directly calculate diffusivities in the halos in the case of distributed BC). This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., `i = Hx` and `i = Nx - Hx`, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/ke",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125
https://github.com/CliMA/Oceananigans.jl/pull/3125:909,Modifiability,variab,variables,909,"Overlapping MPI communication and computation in the HydrostaticFreeSurfaceModel and the NonhydrostaticModel. In particular, this PR introduces two keyword arguments for the `fill_halo_regions!` function, active **only** in case of distributed halo passing boundary conditions:; - the`async::Bool` keyword argument that allows launching MPI operations without waiting for the communication to complete.; - the `only_local_halos::Bool` keyword argument, which fills only the halo in case of a local (i.e., Flux, Value, Gradient, Periodic, and, temporarily, MultiRegionCommunication) boundary condition. This is required for having explicit boundary conditions (like Value or Flux) for turbulent diffusivities (we directly calculate diffusivities in the halos in the case of distributed BC). This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., `i = Hx` and `i = Nx - Hx`, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/ke",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125
https://github.com/CliMA/Oceananigans.jl/pull/3125:1304,Modifiability,variab,variables,1304,"s without waiting for the communication to complete.; - the `only_local_halos::Bool` keyword argument, which fills only the halo in case of a local (i.e., Flux, Value, Gradient, Periodic, and, temporarily, MultiRegionCommunication) boundary condition. This is required for having explicit boundary conditions (like Value or Flux) for turbulent diffusivities (we directly calculate diffusivities in the halos in the case of distributed BC). This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., `i = Hx` and `i = Nx - Hx`, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125
https://github.com/CliMA/Oceananigans.jl/pull/3125:2071,Modifiability,Adapt,Adapt,2071,"ncies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passing. #### API changes; - When calling `RectilinearGrid(arch::DistributedArch, size = (Nx, Ny, Nz), ....)`, `(Nx, Ny, Nz)` are the _per-rank_ local sizes, not the global size to be divided (easy way to specify non-uniform partitioning, see `validation/distributed/mpi_geostrophic_adjustment.jl`); - added the `enable_overlapped_communication` keyword to `DistributedArch` (defaults to true); - removed the `use_buffers` keyword to `DistributedArch` (_always_ use buffers, as views did not give significant speedup to justify maintaining two implementations); - added the keyword argument `active_cells_map::Bool = false` to `ImmersedBoundaryGrid` (ex: `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125
https://github.com/CliMA/Oceananigans.jl/pull/3125:4263,Modifiability,parameteriz,parameterization,4263,"nicDiffusivity` (defaults to 2) to be specified by the user which sets the required halo for the specific `ν` or `κ` function (closures have now an explicitly required number of halos); #### **Major** internals change; 1) The tendencies are calculated at the **end** of a time step. Therefore at the end of a simulation `model.timestepper` will hold tendencies for the last time step completed . 2) Removed `fill_halo_regions!` for hydrostatic pressure in both the non-hydrostatic and the hydrostatic model and for w-velocity in the hydrostatic model. The halos are filled by enlarging the size of the kernels in `update_hydrostatic_pressure!` and `compute_w_from_continuity!` to incorporate the needed ghost points. 2) Removed `fill_halo_regions!` for diffusivities **only for halo-passing BC**; the halo calculation is now performed by launching the `calculate_diffusivity!` kernel inside the ghost nodes before recomputing the tendencies. This requires knowing how many halos each closure requires. 3) Added a _required_halo_ parameter to `AbstractTurbulenceClosure`. This means that each parameterization will have to specify explicitly the number of halos required to calculate the diffusivity: ; e.g ; ```julia; abstract type AbstractTurbulenceClosure{TimeDiscretization, BoundaryBuffer} end; abstract type AbstractScalarDiffusivity{TD, F, N} <: AbstractTurbulenceClosure{TD, N} end; struct TwoDimensionalLeith{FT, CR, GM, M} <: AbstractScalarDiffusivity{ExplicitTimeDiscretization, ThreeDimensionalFormulation, 2}; ``` ; Where Leith closure requires 2 halos (one for the vorticity calculation and an additional one for the vorticity derivative). #### **Minor** internals change; removed the general `calculate_nonlinear_viscosity!` and `calculate_nonlinear_diffusivity!` kernels (to each turbulence closure their own kernel). ~Requires https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399 # On hold at the moment~; Closes #615; Closes #1882; Closes #3067; Closes #3068 ; Supersedes #2953",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125
https://github.com/CliMA/Oceananigans.jl/pull/3125:3996,Performance,perform,performed,3996,": `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity` (defaults to 2) to be specified by the user which sets the required halo for the specific `ν` or `κ` function (closures have now an explicitly required number of halos); #### **Major** internals change; 1) The tendencies are calculated at the **end** of a time step. Therefore at the end of a simulation `model.timestepper` will hold tendencies for the last time step completed . 2) Removed `fill_halo_regions!` for hydrostatic pressure in both the non-hydrostatic and the hydrostatic model and for w-velocity in the hydrostatic model. The halos are filled by enlarging the size of the kernels in `update_hydrostatic_pressure!` and `compute_w_from_continuity!` to incorporate the needed ghost points. 2) Removed `fill_halo_regions!` for diffusivities **only for halo-passing BC**; the halo calculation is now performed by launching the `calculate_diffusivity!` kernel inside the ghost nodes before recomputing the tendencies. This requires knowing how many halos each closure requires. 3) Added a _required_halo_ parameter to `AbstractTurbulenceClosure`. This means that each parameterization will have to specify explicitly the number of halos required to calculate the diffusivity: ; e.g ; ```julia; abstract type AbstractTurbulenceClosure{TimeDiscretization, BoundaryBuffer} end; abstract type AbstractScalarDiffusivity{TD, F, N} <: AbstractTurbulenceClosure{TD, N} end; struct TwoDimensionalLeith{FT, CR, GM, M} <: AbstractScalarDiffusivity{ExplicitTimeDiscretization, ThreeDimensionalFormulation, 2}; ``` ; Where Leith closure requires 2 halos (one for the vorticity calculation and an additional one for the vorticity derivative). #### **Minor** internals change; removed the general `calculate_nonlinear_viscosity!` and `calculate_nonlinear_diffusivity!` kernels (to each turbulence closure their own kerne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125
https://github.com/CliMA/Oceananigans.jl/pull/3125:2590,Security,validat,validation,2590,"buted grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passing. #### API changes; - When calling `RectilinearGrid(arch::DistributedArch, size = (Nx, Ny, Nz), ....)`, `(Nx, Ny, Nz)` are the _per-rank_ local sizes, not the global size to be divided (easy way to specify non-uniform partitioning, see `validation/distributed/mpi_geostrophic_adjustment.jl`); - added the `enable_overlapped_communication` keyword to `DistributedArch` (defaults to true); - removed the `use_buffers` keyword to `DistributedArch` (_always_ use buffers, as views did not give significant speedup to justify maintaining two implementations); - added the keyword argument `active_cells_map::Bool = false` to `ImmersedBoundaryGrid` (ex: `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity` (defaults to 2) to be specified by the user which sets the required halo for the specific `ν` or `κ` function (closures have now an explicitly required number of halos); #### **Major** internals change; 1) The tendencies are calculated at the **end** of a time step. Therefore at the end of a simulation `model.timestepper` will hold tendencies for the last ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125
https://github.com/CliMA/Oceananigans.jl/issues/3126:39,Deployability,release,release,39,"thank you for the incredible effort to release and maintain this repo! I hope this is a fair request:. I have extensive background in Numerical solutions to PDEs, but am just beginning to get familiar with ocean circulation models. it'd be very helpful if someone could help me compare the features and capability (current and planned) of **Oceananigans** (cool name btw!) vs **Veros** - https://github.com/team-ocean/veros, which is based on pyOM2 (https://wiki.cen.uni-hamburg.de/ifm/TO/pyOM2). this will greatly help in understanding the 2 libraries and also which repo to focus on for different use cases. thank you so much!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3126
https://github.com/CliMA/Oceananigans.jl/pull/3132:10,Usability,simpl,simple,10,This is a simple example with immersed boundary. https://github.com/CliMA/Oceananigans.jl/assets/7112768/b225a647-7f21-4dcc-8b12-1ae9d662d106,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132
https://github.com/CliMA/Oceananigans.jl/issues/3137:258,Availability,error,error,258,"The following snippet fails:. ```julia; using Oceananigans; grid_base = RectilinearGrid(size=(8, 8, 8), extent = (1,1,1), halo=(4,4,4)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); WENO(grid=grid); ```. The error is. ```; julia> WENO(grid=grid); ERROR: ArgumentError: The dimensions of the immersed boundary (16, 16) do not match the grid size (18, 18); Stacktrace:; [1] validate_ib_size(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/9znTg/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/9znTg/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3137
https://github.com/CliMA/Oceananigans.jl/issues/3137:297,Availability,ERROR,ERROR,297,"The following snippet fails:. ```julia; using Oceananigans; grid_base = RectilinearGrid(size=(8, 8, 8), extent = (1,1,1), halo=(4,4,4)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); WENO(grid=grid); ```. The error is. ```; julia> WENO(grid=grid); ERROR: ArgumentError: The dimensions of the immersed boundary (16, 16) do not match the grid size (18, 18); Stacktrace:; [1] validate_ib_size(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/9znTg/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/9znTg/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3137
https://github.com/CliMA/Oceananigans.jl/issues/3140:1133,Availability,ERROR,ERROR,1133,"alculation that reproduces the issue:. ```julia; using Oceananigans; using CUDA: has_cuda_gpu. arch = has_cuda_gpu() ? GPU() : CPU(); grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; extent = (1, 1, 1),; halo=(4, 4, 4)). bathymetry(x, y) = 1; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(; grid). @inline function vector_projection_aaa(i, j, k, grid, ϕˣ, ϕᶻ, params); return @inbounds ϕˣ[i,j,k]*params.xdirection + ϕᶻ[i,j,k]*params.zdirection; end. using Oceananigans.AbstractOperations: ∂x, ∂y, ∂z; u, v, w = model.velocities; dudx_tilt = ∂x(u) + 1e-7; dudz_tilt = ∂z(u). using Oceananigans.Grids: Center, Face; dudz_op = KernelFunctionOperation{Center, Center, Face}(vector_projection_aaa, model.grid,; dudx_tilt, dudz_tilt,; (xdirection=0.9,; zdirection=0.1)); dudz = Field(Average(dudz_op, dims=(1,2))); compute!(dudz); ```. This gives me:. ```; ERROR: LoadError: Failed to compile PTX code (ptxas exited with code 255); Invocation arguments: --generate-line-info --verbose --gpu-name sm_70 --output-file /glade/scratch/tomasc/jl_6zqZEpG5Yv.cubin /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; ptxas /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx, line 3031; error : Entry function '_Z22partial_mapreduce_grid8identity7add_sumv16CartesianIndicesILi3E5TupleI5OneToI5Int64ES3_IS4_ES3_IS4_EEES1_ILi3ES2_IS3_IS4_ES3_IS4_ES3_IS4_EEE3ValILitrueEE13ReshapedArrayI7Float64Li4E8SubArrayIS7_Li3E13CuDeviceArrayIS7_Li3ELi1EES2_I9UnitRangeIS4_ES10_IS4_ES10_IS4_EELinfalseEES2_I27SignedMultiplicativeInverseIS4_ES11_IS4_EEE20ConditionalOperationI6CenterS13_4Face15BinaryOperationIS13_S13_S14_1_S15_IS13_S13_S14_S16_23KernelFunctionOperationIS13_S13_S14_20ImmersedBoundaryGridIS7_8PeriodicS19_7Bounded15RectilinearGridIS7_S19_S19_S20_S7_S7_S7_11OffsetArrayIS7_Li1E12StepRangeLenIS7_14TwicePrecisionIS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvE16GridFittedBottomIS22_IS7_Li2ES9_IS7_Li2ELi1EEE23CenterImmerse",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140
https://github.com/CliMA/Oceananigans.jl/issues/3140:1433,Availability,error,error,1433,"ptx, line 3031; error : Entry function '_Z22partial_mapreduce_grid8identity7add_sumv16CartesianIndicesILi3E5TupleI5OneToI5Int64ES3_IS4_ES3_IS4_EEES1_ILi3ES2_IS3_IS4_ES3_IS4_ES3_IS4_EEE3ValILitrueEE13ReshapedArrayI7Float64Li4E8SubArrayIS7_Li3E13CuDeviceArrayIS7_Li3ELi1EES2_I9UnitRangeIS4_ES10_IS4_ES10_IS4_EELinfalseEES2_I27SignedMultiplicativeInverseIS4_ES11_IS4_EEE20ConditionalOperationI6CenterS13_4Face15BinaryOperationIS13_S13_S14_1_S15_IS13_S13_S14_S16_23KernelFunctionOperationIS13_S13_S14_20ImmersedBoundaryGridIS7_8PeriodicS19_7Bounded15RectilinearGridIS7_S19_S19_S20_S7_S7_S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140
https://github.com/CliMA/Oceananigans.jl/issues/3140:4333,Availability,error,errors,4333,"ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_5Az___E9identity1S30_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLG",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140
https://github.com/CliMA/Oceananigans.jl/issues/3140:4459,Availability,error,error,4459,"0_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:125; [7] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140
https://github.com/CliMA/Oceananigans.jl/issues/3140:4486,Availability,error,error,4486,"S7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:125; [7] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140
https://github.com/CliMA/Oceananigans.jl/issues/3140:1140,Performance,Load,LoadError,1140,"alculation that reproduces the issue:. ```julia; using Oceananigans; using CUDA: has_cuda_gpu. arch = has_cuda_gpu() ? GPU() : CPU(); grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; extent = (1, 1, 1),; halo=(4, 4, 4)). bathymetry(x, y) = 1; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(; grid). @inline function vector_projection_aaa(i, j, k, grid, ϕˣ, ϕᶻ, params); return @inbounds ϕˣ[i,j,k]*params.xdirection + ϕᶻ[i,j,k]*params.zdirection; end. using Oceananigans.AbstractOperations: ∂x, ∂y, ∂z; u, v, w = model.velocities; dudx_tilt = ∂x(u) + 1e-7; dudz_tilt = ∂z(u). using Oceananigans.Grids: Center, Face; dudz_op = KernelFunctionOperation{Center, Center, Face}(vector_projection_aaa, model.grid,; dudx_tilt, dudz_tilt,; (xdirection=0.9,; zdirection=0.1)); dudz = Field(Average(dudz_op, dims=(1,2))); compute!(dudz); ```. This gives me:. ```; ERROR: LoadError: Failed to compile PTX code (ptxas exited with code 255); Invocation arguments: --generate-line-info --verbose --gpu-name sm_70 --output-file /glade/scratch/tomasc/jl_6zqZEpG5Yv.cubin /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; ptxas /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx, line 3031; error : Entry function '_Z22partial_mapreduce_grid8identity7add_sumv16CartesianIndicesILi3E5TupleI5OneToI5Int64ES3_IS4_ES3_IS4_EEES1_ILi3ES2_IS3_IS4_ES3_IS4_ES3_IS4_EEE3ValILitrueEE13ReshapedArrayI7Float64Li4E8SubArrayIS7_Li3E13CuDeviceArrayIS7_Li3ELi1EES2_I9UnitRangeIS4_ES10_IS4_ES10_IS4_EELinfalseEES2_I27SignedMultiplicativeInverseIS4_ES11_IS4_EEE20ConditionalOperationI6CenterS13_4Face15BinaryOperationIS13_S13_S14_1_S15_IS13_S13_S14_S16_23KernelFunctionOperationIS13_S13_S14_20ImmersedBoundaryGridIS7_8PeriodicS19_7Bounded15RectilinearGridIS7_S19_S19_S20_S7_S7_S7_11OffsetArrayIS7_Li1E12StepRangeLenIS7_14TwicePrecisionIS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvE16GridFittedBottomIS22_IS7_Li2ES9_IS7_Li2ELi1EEE23CenterImmerse",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140
https://github.com/CliMA/Oceananigans.jl/issues/3140:5085,Performance,cache,cache,5085,"S23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:125; [7] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:103; [8] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/execution.jl:318 [inlined]; [9] macro expansion; @ ./lock.jl:223 [inlined]; [10] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140
https://github.com/CliMA/Oceananigans.jl/issues/3140:5410,Performance,cache,cache,5410,"atch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:125; [7] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:103; [8] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/execution.jl:318 [inlined]; [9] macro expansion; @ ./lock.jl:223 [inlined]; [10] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeIn",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140
https://github.com/CliMA/Oceananigans.jl/issues/3140:4318,Safety,abort,aborted,4318,"ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_5Az___E9identity1S30_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLG",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140
https://github.com/CliMA/Oceananigans.jl/pull/3142:45,Security,validat,validation,45,see #3141 ; closes #3141 . The results from `validation/immersed_boundaries/immersed_couette_flow.jl` from this branch. https://github.com/CliMA/Oceananigans.jl/assets/33547697/e50beac1-4d22-4581-9715-5f541e8dcf01,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142
https://github.com/CliMA/Oceananigans.jl/pull/3143:775,Availability,ERROR,ERROR,775,"The spacings functions aren't working for `ImmersedBoundaryGrid`s on `main`. This PR fixes that. On main:. ```julia; julia> using Oceananigans. julia> grid_base = RectilinearGrid(size=(4, 5, 6), extent=(1, 1, 1));. julia> ibg = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1)); 4×5×6 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=1.00e+00, max(h)=1.00e+00); ├── underlying_grid: 4×5×6 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.2; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.166667. julia> xspacings(ibg, Center()); ERROR: MethodError: no method matching xspacings(::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::Center); Closest candidates are:; xspacings(::Any, ::Any, ::Any, ::Any; with_halos) at ~/repos/Oceananigans.jl/src/Grids/grid_utils.jl:363; xspacings(::Any, ::ImmersedBoundaryGrid) at ~/repos/Oceananigans.jl/src/ImmersedBoundaries/immersed_grid_metrics.jl:37; xspacings(::Oceananigans.Grids.XRegRectilinearGrid, ::Center; with_halos) at ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:473; ...; Stacktrace:; [1] top-level scope; @ REPL[18]:1; ```. On this branch:. ```julia; julia> xspacings(ibg, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143
https://github.com/CliMA/Oceananigans.jl/issues/3144:864,Availability,error,error,864,"I've been using `FieldTimeSeries` a lot over the last few weeks and have noticed a couple of issues calculating means and constructing operations on them. First, `mean` with `dims` only calculates it on the first time index (I think). For example, if I do `mean(f, dims = (1, 2, 3))` it returns a size `[1, 1, 1]` array vs calculating `mean(interior(f), dims = (1, 2, 3))` which returns a `[1, 1, 1, Nt]` array. I suspect it is also calculating means with no dimensions specified incorrectly. Second, constructing operators on field time series fails and returns operators with dimensions `[Nx, Ny, Nz]` which if you then try and index into fails as it tries to index into the underlying fields which have a time dimension. For example, `speed = √(u^2 + v^2 + w^2)` gives `speed` with size `[Nx, Ny, Nz]`, if I then try and index at `[1, 1, 1]` it throws a bounds error trying to access `Nx x Ny x Nz x Nt` array at `1, 1, 1`. Neither of these is particularly important but thought I would document in case anyone else has issues, and because I will try and fix them at some point. For reference, I am currently getting around this by calculating means on the interior (which I think would produce the wrong results with immersed boundaries because it wouldn't have the masking step), and by just calculating arrays like `speed = √(interior(u)^2 + interior(v)^2 + interior(w)^2)` which doesn't lose me too much performance since I end up indexing into the whole array anyway.; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144
https://github.com/CliMA/Oceananigans.jl/issues/3144:1270,Availability,mask,masking,1270,"I've been using `FieldTimeSeries` a lot over the last few weeks and have noticed a couple of issues calculating means and constructing operations on them. First, `mean` with `dims` only calculates it on the first time index (I think). For example, if I do `mean(f, dims = (1, 2, 3))` it returns a size `[1, 1, 1]` array vs calculating `mean(interior(f), dims = (1, 2, 3))` which returns a `[1, 1, 1, Nt]` array. I suspect it is also calculating means with no dimensions specified incorrectly. Second, constructing operators on field time series fails and returns operators with dimensions `[Nx, Ny, Nz]` which if you then try and index into fails as it tries to index into the underlying fields which have a time dimension. For example, `speed = √(u^2 + v^2 + w^2)` gives `speed` with size `[Nx, Ny, Nz]`, if I then try and index at `[1, 1, 1]` it throws a bounds error trying to access `Nx x Ny x Nz x Nt` array at `1, 1, 1`. Neither of these is particularly important but thought I would document in case anyone else has issues, and because I will try and fix them at some point. For reference, I am currently getting around this by calculating means on the interior (which I think would produce the wrong results with immersed boundaries because it wouldn't have the masking step), and by just calculating arrays like `speed = √(interior(u)^2 + interior(v)^2 + interior(w)^2)` which doesn't lose me too much performance since I end up indexing into the whole array anyway.; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144
https://github.com/CliMA/Oceananigans.jl/issues/3144:1411,Performance,perform,performance,1411,"I've been using `FieldTimeSeries` a lot over the last few weeks and have noticed a couple of issues calculating means and constructing operations on them. First, `mean` with `dims` only calculates it on the first time index (I think). For example, if I do `mean(f, dims = (1, 2, 3))` it returns a size `[1, 1, 1]` array vs calculating `mean(interior(f), dims = (1, 2, 3))` which returns a `[1, 1, 1, Nt]` array. I suspect it is also calculating means with no dimensions specified incorrectly. Second, constructing operators on field time series fails and returns operators with dimensions `[Nx, Ny, Nz]` which if you then try and index into fails as it tries to index into the underlying fields which have a time dimension. For example, `speed = √(u^2 + v^2 + w^2)` gives `speed` with size `[Nx, Ny, Nz]`, if I then try and index at `[1, 1, 1]` it throws a bounds error trying to access `Nx x Ny x Nz x Nt` array at `1, 1, 1`. Neither of these is particularly important but thought I would document in case anyone else has issues, and because I will try and fix them at some point. For reference, I am currently getting around this by calculating means on the interior (which I think would produce the wrong results with immersed boundaries because it wouldn't have the masking step), and by just calculating arrays like `speed = √(interior(u)^2 + interior(v)^2 + interior(w)^2)` which doesn't lose me too much performance since I end up indexing into the whole array anyway.; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144
https://github.com/CliMA/Oceananigans.jl/issues/3144:880,Security,access,access,880,"I've been using `FieldTimeSeries` a lot over the last few weeks and have noticed a couple of issues calculating means and constructing operations on them. First, `mean` with `dims` only calculates it on the first time index (I think). For example, if I do `mean(f, dims = (1, 2, 3))` it returns a size `[1, 1, 1]` array vs calculating `mean(interior(f), dims = (1, 2, 3))` which returns a `[1, 1, 1, Nt]` array. I suspect it is also calculating means with no dimensions specified incorrectly. Second, constructing operators on field time series fails and returns operators with dimensions `[Nx, Ny, Nz]` which if you then try and index into fails as it tries to index into the underlying fields which have a time dimension. For example, `speed = √(u^2 + v^2 + w^2)` gives `speed` with size `[Nx, Ny, Nz]`, if I then try and index at `[1, 1, 1]` it throws a bounds error trying to access `Nx x Ny x Nz x Nt` array at `1, 1, 1`. Neither of these is particularly important but thought I would document in case anyone else has issues, and because I will try and fix them at some point. For reference, I am currently getting around this by calculating means on the interior (which I think would produce the wrong results with immersed boundaries because it wouldn't have the masking step), and by just calculating arrays like `speed = √(interior(u)^2 + interior(v)^2 + interior(w)^2)` which doesn't lose me too much performance since I end up indexing into the whole array anyway.; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144
https://github.com/CliMA/Oceananigans.jl/issues/3147:806,Availability,error,errors,806,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147
https://github.com/CliMA/Oceananigans.jl/issues/3147:963,Availability,error,error-by-error,963,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147
https://github.com/CliMA/Oceananigans.jl/issues/3147:984,Availability,down,downside,984,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147
https://github.com/CliMA/Oceananigans.jl/issues/3147:120,Deployability,release,release,120,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147
https://github.com/CliMA/Oceananigans.jl/issues/3147:134,Deployability,release,release,134,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147
https://github.com/CliMA/Oceananigans.jl/issues/3147:231,Deployability,release,release,231,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147
https://github.com/CliMA/Oceananigans.jl/issues/3147:623,Deployability,update,update,623,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147
https://github.com/CliMA/Oceananigans.jl/issues/3147:683,Deployability,update,update,683,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147
https://github.com/CliMA/Oceananigans.jl/issues/3147:1057,Deployability,release,releases,1057,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147
https://github.com/CliMA/Oceananigans.jl/issues/3148:529,Usability,intuit,intuitive,529,"Given that the doc examples are gonna run much faster due to https://github.com/CliMA/Oceananigans.jl/pull/3135 (I'm assuming it's gonna get merged soon) should we create an example with an immersed boundary with drag forces?. My main reasons for suggesting this are:. 1. Probably there's a lot of user interest in this application, but no example showing this capability (https://github.com/CliMA/Oceananigans.jl/pull/3132 will add an `ImmersedBoundaryGrid` example, but with default boundary conditions);; 2. Coming up with an intuitive way to impose flux boundary conditions on immersed boundaries is hard (see for example https://github.com/CliMA/Oceananigans.jl/pull/3142 and discussion in https://github.com/CliMA/Oceananigans.jl/pull/2437), so I think it'd be good to give users a guaranteed-to-work easy-to-find example to base themselves off of.; 3. I also think having such examples probably makes counter-intuitive definitions and bugs more likely to be caught (and therefore fixed) early, since it makes the `ImmersedBoundaryGrid` API more visible to users, who will be more likely to use it for explorations. So my opinion is that including an example will increase our confidence in the IBG implementation (although, again, this is already being done with https://github.com/CliMA/Oceananigans.jl/pull/3132, albeit with default BCs). If there's interest we can discuss what this example should look like. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148
https://github.com/CliMA/Oceananigans.jl/issues/3148:916,Usability,intuit,intuitive,916,"Given that the doc examples are gonna run much faster due to https://github.com/CliMA/Oceananigans.jl/pull/3135 (I'm assuming it's gonna get merged soon) should we create an example with an immersed boundary with drag forces?. My main reasons for suggesting this are:. 1. Probably there's a lot of user interest in this application, but no example showing this capability (https://github.com/CliMA/Oceananigans.jl/pull/3132 will add an `ImmersedBoundaryGrid` example, but with default boundary conditions);; 2. Coming up with an intuitive way to impose flux boundary conditions on immersed boundaries is hard (see for example https://github.com/CliMA/Oceananigans.jl/pull/3142 and discussion in https://github.com/CliMA/Oceananigans.jl/pull/2437), so I think it'd be good to give users a guaranteed-to-work easy-to-find example to base themselves off of.; 3. I also think having such examples probably makes counter-intuitive definitions and bugs more likely to be caught (and therefore fixed) early, since it makes the `ImmersedBoundaryGrid` API more visible to users, who will be more likely to use it for explorations. So my opinion is that including an example will increase our confidence in the IBG implementation (although, again, this is already being done with https://github.com/CliMA/Oceananigans.jl/pull/3132, albeit with default BCs). If there's interest we can discuss what this example should look like. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148
https://github.com/CliMA/Oceananigans.jl/pull/3149:32,Deployability,update,updates,32,This bot automatically suggests updates of GitHub action workflows.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3149
https://github.com/CliMA/Oceananigans.jl/pull/3150:107,Deployability,integrat,integrating,107,"- `Docs/Physics/HydrostaticFreeSurfaceModel`; At the moment docs mention that we obtain $w(x, y, z, t)$ by integrating the mass conservation equation from bottom to top but we need to integrate from bottom to depth $z$. This PR fixes this. - `Docs/Physics/NonHydrostaticModel`; The rotation rate term due to surface waves was missing a sign.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3150
https://github.com/CliMA/Oceananigans.jl/pull/3150:184,Deployability,integrat,integrate,184,"- `Docs/Physics/HydrostaticFreeSurfaceModel`; At the moment docs mention that we obtain $w(x, y, z, t)$ by integrating the mass conservation equation from bottom to top but we need to integrate from bottom to depth $z$. This PR fixes this. - `Docs/Physics/NonHydrostaticModel`; The rotation rate term due to surface waves was missing a sign.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3150
https://github.com/CliMA/Oceananigans.jl/pull/3150:107,Integrability,integrat,integrating,107,"- `Docs/Physics/HydrostaticFreeSurfaceModel`; At the moment docs mention that we obtain $w(x, y, z, t)$ by integrating the mass conservation equation from bottom to top but we need to integrate from bottom to depth $z$. This PR fixes this. - `Docs/Physics/NonHydrostaticModel`; The rotation rate term due to surface waves was missing a sign.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3150
https://github.com/CliMA/Oceananigans.jl/pull/3150:184,Integrability,integrat,integrate,184,"- `Docs/Physics/HydrostaticFreeSurfaceModel`; At the moment docs mention that we obtain $w(x, y, z, t)$ by integrating the mass conservation equation from bottom to top but we need to integrate from bottom to depth $z$. This PR fixes this. - `Docs/Physics/NonHydrostaticModel`; The rotation rate term due to surface waves was missing a sign.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3150
https://github.com/CliMA/Oceananigans.jl/issues/3152:470,Energy Efficiency,schedul,schedule,470,"To reproduce this bug:; ```Julia; using Oceananigans. grid = RectilinearGrid(; CPU(),; size=(128, 128, 128),; x=(0.0, 1.0), y=(0.0, 1.0), z=(0.0, 1.0),; topology=(Bounded, Bounded, Bounded),; ). model = NonhydrostaticModel(;; grid,; ). simulation = Oceananigans.Simulation(model; Δt = 1.0, stop_iteration = 8). fields = model.velocities. simulation.output_writers[:compression_0] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_0.nc"",; compression = 0,; schedule = IterationInterval(1),; overwrite_existing = true,; ). simulation.output_writers[:compression_4] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_4.nc"",; compression = 4,; schedule = IterationInterval(1),; overwrite_existing = true,; ). run!(simulation). @info filesize(""compression_0.nc""); @info filesize(""compression_4.nc""); ```. Output:; ```; Info: Initializing simulation...; Info: ... simulation initialization complete (915.221 ms); Info: Executing initial time step...; Info: ... initial time step complete (5.500 seconds).; Info: Simulation is stopping after running for 8.465 seconds.; Info: Model iteration 8 equals or exceeds stop iteration 8.; Info: 460126123; Info: 460126123; ```. Expected behavior: the size of `compression_4.nc` should be much smaller than that of `compression_0.nc`, since the data are all zeros. Test enviroment:; - Julia: 1.9.1; - Oceananigans: v0.83.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3152
https://github.com/CliMA/Oceananigans.jl/issues/3152:667,Energy Efficiency,schedul,schedule,667,"To reproduce this bug:; ```Julia; using Oceananigans. grid = RectilinearGrid(; CPU(),; size=(128, 128, 128),; x=(0.0, 1.0), y=(0.0, 1.0), z=(0.0, 1.0),; topology=(Bounded, Bounded, Bounded),; ). model = NonhydrostaticModel(;; grid,; ). simulation = Oceananigans.Simulation(model; Δt = 1.0, stop_iteration = 8). fields = model.velocities. simulation.output_writers[:compression_0] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_0.nc"",; compression = 0,; schedule = IterationInterval(1),; overwrite_existing = true,; ). simulation.output_writers[:compression_4] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_4.nc"",; compression = 4,; schedule = IterationInterval(1),; overwrite_existing = true,; ). run!(simulation). @info filesize(""compression_0.nc""); @info filesize(""compression_4.nc""); ```. Output:; ```; Info: Initializing simulation...; Info: ... simulation initialization complete (915.221 ms); Info: Executing initial time step...; Info: ... initial time step complete (5.500 seconds).; Info: Simulation is stopping after running for 8.465 seconds.; Info: Model iteration 8 equals or exceeds stop iteration 8.; Info: 460126123; Info: 460126123; ```. Expected behavior: the size of `compression_4.nc` should be much smaller than that of `compression_0.nc`, since the data are all zeros. Test enviroment:; - Julia: 1.9.1; - Oceananigans: v0.83.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3152
https://github.com/CliMA/Oceananigans.jl/issues/3152:1326,Testability,Test,Test,1326,"To reproduce this bug:; ```Julia; using Oceananigans. grid = RectilinearGrid(; CPU(),; size=(128, 128, 128),; x=(0.0, 1.0), y=(0.0, 1.0), z=(0.0, 1.0),; topology=(Bounded, Bounded, Bounded),; ). model = NonhydrostaticModel(;; grid,; ). simulation = Oceananigans.Simulation(model; Δt = 1.0, stop_iteration = 8). fields = model.velocities. simulation.output_writers[:compression_0] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_0.nc"",; compression = 0,; schedule = IterationInterval(1),; overwrite_existing = true,; ). simulation.output_writers[:compression_4] = NetCDFOutputWriter(; model,; fields,; filename = ""compression_4.nc"",; compression = 4,; schedule = IterationInterval(1),; overwrite_existing = true,; ). run!(simulation). @info filesize(""compression_0.nc""); @info filesize(""compression_4.nc""); ```. Output:; ```; Info: Initializing simulation...; Info: ... simulation initialization complete (915.221 ms); Info: Executing initial time step...; Info: ... initial time step complete (5.500 seconds).; Info: Simulation is stopping after running for 8.465 seconds.; Info: Model iteration 8 equals or exceeds stop iteration 8.; Info: 460126123; Info: 460126123; ```. Expected behavior: the size of `compression_4.nc` should be much smaller than that of `compression_0.nc`, since the data are all zeros. Test enviroment:; - Julia: 1.9.1; - Oceananigans: v0.83.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3152
https://github.com/CliMA/Oceananigans.jl/pull/3153:148,Integrability,message,message,148,"To use compression in `NCDatasets` , the keyword for `defVar` should be `deflatelevel` instead of `compression`. `defVar` does not show any warning message for unrecognized keywords. **Breaking change**: This PR induces a breaking change in the `NetCDFOutputWriter` constructor since the `compression` kwarg is now renamed to `deflatelevel`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153
https://github.com/CliMA/Oceananigans.jl/issues/3154:254,Availability,checkpoint,checkpoint,254,"Sometimes it's useful to run a simulation with tracers and have the tracers start evolving _only_ after a certain spin-up period. Since https://github.com/CliMA/Oceananigans.jl/pull/2938 this is possible by running a simulation without tracers, saving a checkpoint file from it, building a new model that is identical to the previous one but with extra tracers, manually `set!()` the prognostic fields from the checkpoint file, and then run that model. This works as intended, but as I've realized since then it's got a few downsides. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154
https://github.com/CliMA/Oceananigans.jl/issues/3154:411,Availability,checkpoint,checkpoint,411,"Sometimes it's useful to run a simulation with tracers and have the tracers start evolving _only_ after a certain spin-up period. Since https://github.com/CliMA/Oceananigans.jl/pull/2938 this is possible by running a simulation without tracers, saving a checkpoint file from it, building a new model that is identical to the previous one but with extra tracers, manually `set!()` the prognostic fields from the checkpoint file, and then run that model. This works as intended, but as I've realized since then it's got a few downsides. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154
https://github.com/CliMA/Oceananigans.jl/issues/3154:524,Availability,down,downsides,524,"Sometimes it's useful to run a simulation with tracers and have the tracers start evolving _only_ after a certain spin-up period. Since https://github.com/CliMA/Oceananigans.jl/pull/2938 this is possible by running a simulation without tracers, saving a checkpoint file from it, building a new model that is identical to the previous one but with extra tracers, manually `set!()` the prognostic fields from the checkpoint file, and then run that model. This works as intended, but as I've realized since then it's got a few downsides. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154
https://github.com/CliMA/Oceananigans.jl/issues/3154:1334,Availability,down,downside,1334,"w model that is identical to the previous one but with extra tracers, manually `set!()` the prognostic fields from the checkpoint file, and then run that model. This works as intended, but as I've realized since then it's got a few downsides. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest i",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154
https://github.com/CliMA/Oceananigans.jl/issues/3154:2048,Availability,down,downsides,2048,"es. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thing for my research, and I know @whitleyv does this too, but maybe we're the exception?. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154
https://github.com/CliMA/Oceananigans.jl/issues/3154:1981,Modifiability,evolve,evolved,1981,"es. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thing for my research, and I know @whitleyv does this too, but maybe we're the exception?. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154
https://github.com/CliMA/Oceananigans.jl/issues/3154:1435,Safety,safe,safe,1435,"then run that model. This works as intended, but as I've realized since then it's got a few downsides. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154
https://github.com/CliMA/Oceananigans.jl/issues/3154:2254,Testability,test,test,2254,"es. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thing for my research, and I know @whitleyv does this too, but maybe we're the exception?. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154
https://github.com/CliMA/Oceananigans.jl/issues/3158:3450,Usability,clear,clear,3450,"ions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}; ├── underlying_grid: 4×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Flat y; └── Flat z. julia> c = CenterField(ibg); 4×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 4×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×1×1 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, 1:1) with eltype Float64 with indices -2:7×1:1×1:1; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, 1.0); 4×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 4×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×1×1 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, 1:1) with eltype Float64 with indices -2:7×1:1×1:1; └── max=1.0, min=1.0, mean=1.0. julia> mask_immersed_field!(c). julia> ℑxᶠᵃᵃ(3, 1, 1, ibg, c) # Non boundary-aware x-interpolation operator; 0.5. julia> ℑxᶠᶜᶜ(3, 1, 1, ibg, c) # Boundary-aware x-interpolation operator; 1.0. ```. At the moment there is no clear use for the internals of the code as nothing really requires an interpolation across immersed boundary, except for along-isopycnal diffusion and GM, but I find it useful mostly for postprocessing, where interpolation to combine fields in `AbstractOperations` is extensively used. What do people think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3158
https://github.com/CliMA/Oceananigans.jl/pull/3161:349,Availability,error,errors,349,"The current Manifest conflicts with FFMPEG v0.4 and thus enforces it to fallback to FFMPEG v0.2.; This, in principle, is not a problem since we don't depend on FFMPEG. But as soon as we try to use Makie/GLMakie which has FFMPEG as a dependency then it is forced to use FFMPEG v0.2. FFMPEG v0.2 cannot compile on Apple’s M1/M2 chips and this creates errors and inconvenience. . I tried to enforce installing `FFMPEG@v0.4` on the current environment and this resulted in downgrade of some `jll`s. ```; ⌅ [0234f1f7] ↓ HDF5_jll v1.14.0+0 ⇒ v1.12.2+2; ⌃ [7243133f] ↓ NetCDF_jll v400.902.208+0 ⇒ v400.902.5+1; ⌅ [458c3c95] ↓ OpenSSL_jll v3.0.9+0 ⇒ v1.1.21+0; ```. Informed by that, this PR ensures that those `jll`s satisfy `FFMPEG`s dep requirements so that people with Apple M1/2 chips (like myself) can still use Oceananigans + Makie for plotting. I've been troubling with this all morning along with @glwagner and @siddharthabishnu. Not sure if this is the best solution possible, but it does work. Hopefully this is something that it will be fixed from other packages moving forward.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161
https://github.com/CliMA/Oceananigans.jl/pull/3161:469,Availability,down,downgrade,469,"The current Manifest conflicts with FFMPEG v0.4 and thus enforces it to fallback to FFMPEG v0.2.; This, in principle, is not a problem since we don't depend on FFMPEG. But as soon as we try to use Makie/GLMakie which has FFMPEG as a dependency then it is forced to use FFMPEG v0.2. FFMPEG v0.2 cannot compile on Apple’s M1/M2 chips and this creates errors and inconvenience. . I tried to enforce installing `FFMPEG@v0.4` on the current environment and this resulted in downgrade of some `jll`s. ```; ⌅ [0234f1f7] ↓ HDF5_jll v1.14.0+0 ⇒ v1.12.2+2; ⌃ [7243133f] ↓ NetCDF_jll v400.902.208+0 ⇒ v400.902.5+1; ⌅ [458c3c95] ↓ OpenSSL_jll v3.0.9+0 ⇒ v1.1.21+0; ```. Informed by that, this PR ensures that those `jll`s satisfy `FFMPEG`s dep requirements so that people with Apple M1/2 chips (like myself) can still use Oceananigans + Makie for plotting. I've been troubling with this all morning along with @glwagner and @siddharthabishnu. Not sure if this is the best solution possible, but it does work. Hopefully this is something that it will be fixed from other packages moving forward.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161
https://github.com/CliMA/Oceananigans.jl/pull/3161:396,Deployability,install,installing,396,"The current Manifest conflicts with FFMPEG v0.4 and thus enforces it to fallback to FFMPEG v0.2.; This, in principle, is not a problem since we don't depend on FFMPEG. But as soon as we try to use Makie/GLMakie which has FFMPEG as a dependency then it is forced to use FFMPEG v0.2. FFMPEG v0.2 cannot compile on Apple’s M1/M2 chips and this creates errors and inconvenience. . I tried to enforce installing `FFMPEG@v0.4` on the current environment and this resulted in downgrade of some `jll`s. ```; ⌅ [0234f1f7] ↓ HDF5_jll v1.14.0+0 ⇒ v1.12.2+2; ⌃ [7243133f] ↓ NetCDF_jll v400.902.208+0 ⇒ v400.902.5+1; ⌅ [458c3c95] ↓ OpenSSL_jll v3.0.9+0 ⇒ v1.1.21+0; ```. Informed by that, this PR ensures that those `jll`s satisfy `FFMPEG`s dep requirements so that people with Apple M1/2 chips (like myself) can still use Oceananigans + Makie for plotting. I've been troubling with this all morning along with @glwagner and @siddharthabishnu. Not sure if this is the best solution possible, but it does work. Hopefully this is something that it will be fixed from other packages moving forward.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161
https://github.com/CliMA/Oceananigans.jl/pull/3161:150,Integrability,depend,depend,150,"The current Manifest conflicts with FFMPEG v0.4 and thus enforces it to fallback to FFMPEG v0.2.; This, in principle, is not a problem since we don't depend on FFMPEG. But as soon as we try to use Makie/GLMakie which has FFMPEG as a dependency then it is forced to use FFMPEG v0.2. FFMPEG v0.2 cannot compile on Apple’s M1/M2 chips and this creates errors and inconvenience. . I tried to enforce installing `FFMPEG@v0.4` on the current environment and this resulted in downgrade of some `jll`s. ```; ⌅ [0234f1f7] ↓ HDF5_jll v1.14.0+0 ⇒ v1.12.2+2; ⌃ [7243133f] ↓ NetCDF_jll v400.902.208+0 ⇒ v400.902.5+1; ⌅ [458c3c95] ↓ OpenSSL_jll v3.0.9+0 ⇒ v1.1.21+0; ```. Informed by that, this PR ensures that those `jll`s satisfy `FFMPEG`s dep requirements so that people with Apple M1/2 chips (like myself) can still use Oceananigans + Makie for plotting. I've been troubling with this all morning along with @glwagner and @siddharthabishnu. Not sure if this is the best solution possible, but it does work. Hopefully this is something that it will be fixed from other packages moving forward.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161
https://github.com/CliMA/Oceananigans.jl/pull/3161:233,Integrability,depend,dependency,233,"The current Manifest conflicts with FFMPEG v0.4 and thus enforces it to fallback to FFMPEG v0.2.; This, in principle, is not a problem since we don't depend on FFMPEG. But as soon as we try to use Makie/GLMakie which has FFMPEG as a dependency then it is forced to use FFMPEG v0.2. FFMPEG v0.2 cannot compile on Apple’s M1/M2 chips and this creates errors and inconvenience. . I tried to enforce installing `FFMPEG@v0.4` on the current environment and this resulted in downgrade of some `jll`s. ```; ⌅ [0234f1f7] ↓ HDF5_jll v1.14.0+0 ⇒ v1.12.2+2; ⌃ [7243133f] ↓ NetCDF_jll v400.902.208+0 ⇒ v400.902.5+1; ⌅ [458c3c95] ↓ OpenSSL_jll v3.0.9+0 ⇒ v1.1.21+0; ```. Informed by that, this PR ensures that those `jll`s satisfy `FFMPEG`s dep requirements so that people with Apple M1/2 chips (like myself) can still use Oceananigans + Makie for plotting. I've been troubling with this all morning along with @glwagner and @siddharthabishnu. Not sure if this is the best solution possible, but it does work. Hopefully this is something that it will be fixed from other packages moving forward.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161
https://github.com/CliMA/Oceananigans.jl/issues/3163:138,Energy Efficiency,schedul,schedules,138,Why here we drop the last two elements?. https://github.com/CliMA/Oceananigans.jl/blob/d7d146bc59f966d65eb66a875c16679bef365130/src/Utils/schedules.jl#L177,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3163
https://github.com/CliMA/Oceananigans.jl/issues/3166:445,Deployability,update,update,445,At some point we'd need to revisit the benchmarks. (https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/). We might wanna discuss what to include there and how we could perhaps automate the procedure? It doesn't need to be completely automated but perhaps we should have a workflow that we could run every now and again that produces a set of figures that are stored in OceananigansArtifacts.jl or somewhere so the docs update automatically?. (Feel free to convert this to a Discussion if it's more appropriate.),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3166
https://github.com/CliMA/Oceananigans.jl/issues/3166:39,Testability,benchmark,benchmarks,39,At some point we'd need to revisit the benchmarks. (https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/). We might wanna discuss what to include there and how we could perhaps automate the procedure? It doesn't need to be completely automated but perhaps we should have a workflow that we could run every now and again that produces a set of figures that are stored in OceananigansArtifacts.jl or somewhere so the docs update automatically?. (Feel free to convert this to a Discussion if it's more appropriate.),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3166
https://github.com/CliMA/Oceananigans.jl/issues/3166:118,Testability,benchmark,benchmarks,118,At some point we'd need to revisit the benchmarks. (https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/). We might wanna discuss what to include there and how we could perhaps automate the procedure? It doesn't need to be completely automated but perhaps we should have a workflow that we could run every now and again that produces a set of figures that are stored in OceananigansArtifacts.jl or somewhere so the docs update automatically?. (Feel free to convert this to a Discussion if it's more appropriate.),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3166
https://github.com/CliMA/Oceananigans.jl/pull/3167:22,Testability,test,test,22,"This PR restores some test on netCDF output. (The tests were removed, if I recall correctly, because at some point netCDF was creating issues on unix machines. Things seems fine now!). Closes #2956",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3167
https://github.com/CliMA/Oceananigans.jl/pull/3167:50,Testability,test,tests,50,"This PR restores some test on netCDF output. (The tests were removed, if I recall correctly, because at some point netCDF was creating issues on unix machines. Things seems fine now!). Closes #2956",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3167
https://github.com/CliMA/Oceananigans.jl/issues/3169:239,Performance,perform,performance,239,In #3151 it was discovered that the shallow water example in the docs needs ~25 min to run while all other examples need from ~1min (2D) or up to ~7min (Baroclinic instability). Was this always the case? Did something happen to impede the performance of the SWE model?. #3168 is relevant; it does not resolve the issue but nevertheless minimizes the toll that this issue has on the overall building time for the docs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3169
https://github.com/CliMA/Oceananigans.jl/issues/3171:177,Availability,error,error,177,"hello - I'm able to run the basic example in the docs under Quick start, but when I try to run the same code in VSCode by setting breakpoints in debug mode, I get the following error:. the line: `model = NonhydrostaticModel(; grid, advection=WENO())`. leads to the function `update_state!()` in the script `update_nonhydrostatic_model_state.jl`. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl. where it gets to Line 21 - `foreach(mask_immersed_field!, model.tracers)` after which I get the following error:. the debugger opens up this file:. ![jl_err_1](https://github.com/CliMA/Oceananigans.jl/assets/16384103/b957fdae-ab7f-490f-9179-ece64d7293e2). which then throws this error:. ```; @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:21; [20] NonhydrostaticModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, clock::Clock{Float64}, advection::WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{}, timestepper::Symbol, background",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171
https://github.com/CliMA/Oceananigans.jl/issues/3171:573,Availability,error,error,573,"hello - I'm able to run the basic example in the docs under Quick start, but when I try to run the same code in VSCode by setting breakpoints in debug mode, I get the following error:. the line: `model = NonhydrostaticModel(; grid, advection=WENO())`. leads to the function `update_state!()` in the script `update_nonhydrostatic_model_state.jl`. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl. where it gets to Line 21 - `foreach(mask_immersed_field!, model.tracers)` after which I get the following error:. the debugger opens up this file:. ![jl_err_1](https://github.com/CliMA/Oceananigans.jl/assets/16384103/b957fdae-ab7f-490f-9179-ece64d7293e2). which then throws this error:. ```; @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:21; [20] NonhydrostaticModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, clock::Clock{Float64}, advection::WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{}, timestepper::Symbol, background",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171
https://github.com/CliMA/Oceananigans.jl/issues/3171:746,Availability,error,error,746,"hello - I'm able to run the basic example in the docs under Quick start, but when I try to run the same code in VSCode by setting breakpoints in debug mode, I get the following error:. the line: `model = NonhydrostaticModel(; grid, advection=WENO())`. leads to the function `update_state!()` in the script `update_nonhydrostatic_model_state.jl`. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl. where it gets to Line 21 - `foreach(mask_immersed_field!, model.tracers)` after which I get the following error:. the debugger opens up this file:. ![jl_err_1](https://github.com/CliMA/Oceananigans.jl/assets/16384103/b957fdae-ab7f-490f-9179-ece64d7293e2). which then throws this error:. ```; @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:21; [20] NonhydrostaticModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, clock::Clock{Float64}, advection::WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{}, timestepper::Symbol, background",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171
https://github.com/CliMA/Oceananigans.jl/issues/3171:3596,Availability,error,error,3596,"Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:198. [21] (::Core.var""#Type##kw"")(::NamedTuple{(:grid, :advection), Tuple{RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}}, ::Type{NonhydrostaticModel}); @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:107; [22] top-level scope; @ ~/ocean_ex_1.jl:10; ```. I'm trying to step through the code to understand the code better, but I'm not able to figure out why I only get this error when I insert breakpoints. I'd greatly appreciate any help understanding this better, thank you",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171
https://github.com/CliMA/Oceananigans.jl/pull/3172:52,Availability,checkpoint,checkpointer,52,`run!` does not need `Glob` + fix the docstring of `checkpointer`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3172
https://github.com/CliMA/Oceananigans.jl/issues/3178:631,Availability,mainten,maintenance,631,I was reading about the extension feature in Julia v1.9. https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions). and it reads to me that it's ideal to add for plotting methods that step onto Makie functionality. This way the code won't load unless one loads GLMakie/CairoMakie in the environment. What do others think?. I have put together a few methods for plotting Oceananigans fields at https://github.com/navidcy/Imaginocean.jl. I could move those into an extension in Oceananigans. Ideally I would like these things to live outside Oceananigans repo to minimise the burden of maintenance. But from what I understand for how extensions work they have to live in this repo? Or in the Makie repo which makes even less sense? Am I right?. x-ref: https://github.com/navidcy/Imaginocean.jl/issues/2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178
https://github.com/CliMA/Oceananigans.jl/issues/3178:121,Performance,load,loading-of-code-in-packages,121,I was reading about the extension feature in Julia v1.9. https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions). and it reads to me that it's ideal to add for plotting methods that step onto Makie functionality. This way the code won't load unless one loads GLMakie/CairoMakie in the environment. What do others think?. I have put together a few methods for plotting Oceananigans fields at https://github.com/navidcy/Imaginocean.jl. I could move those into an extension in Oceananigans. Ideally I would like these things to live outside Oceananigans repo to minimise the burden of maintenance. But from what I understand for how extensions work they have to live in this repo? Or in the Makie repo which makes even less sense? Am I right?. x-ref: https://github.com/navidcy/Imaginocean.jl/issues/2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178
https://github.com/CliMA/Oceananigans.jl/issues/3178:286,Performance,load,load,286,I was reading about the extension feature in Julia v1.9. https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions). and it reads to me that it's ideal to add for plotting methods that step onto Makie functionality. This way the code won't load unless one loads GLMakie/CairoMakie in the environment. What do others think?. I have put together a few methods for plotting Oceananigans fields at https://github.com/navidcy/Imaginocean.jl. I could move those into an extension in Oceananigans. Ideally I would like these things to live outside Oceananigans repo to minimise the burden of maintenance. But from what I understand for how extensions work they have to live in this repo? Or in the Makie repo which makes even less sense? Am I right?. x-ref: https://github.com/navidcy/Imaginocean.jl/issues/2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178
https://github.com/CliMA/Oceananigans.jl/issues/3178:302,Performance,load,loads,302,I was reading about the extension feature in Julia v1.9. https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions). and it reads to me that it's ideal to add for plotting methods that step onto Makie functionality. This way the code won't load unless one loads GLMakie/CairoMakie in the environment. What do others think?. I have put together a few methods for plotting Oceananigans fields at https://github.com/navidcy/Imaginocean.jl. I could move those into an extension in Oceananigans. Ideally I would like these things to live outside Oceananigans repo to minimise the burden of maintenance. But from what I understand for how extensions work they have to live in this repo? Or in the Makie repo which makes even less sense? Am I right?. x-ref: https://github.com/navidcy/Imaginocean.jl/issues/2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178
https://github.com/CliMA/Oceananigans.jl/pull/3179:108,Testability,test,tested,108,Follow up from https://github.com/CliMA/Oceananigans.jl/pull/3173. `update_biogeochemical_state!` was being tested but only failing on a grid type that previously wasn't being tested so added tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179
https://github.com/CliMA/Oceananigans.jl/pull/3179:176,Testability,test,tested,176,Follow up from https://github.com/CliMA/Oceananigans.jl/pull/3173. `update_biogeochemical_state!` was being tested but only failing on a grid type that previously wasn't being tested so added tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179
https://github.com/CliMA/Oceananigans.jl/pull/3179:192,Testability,test,tests,192,Follow up from https://github.com/CliMA/Oceananigans.jl/pull/3173. `update_biogeochemical_state!` was being tested but only failing on a grid type that previously wasn't being tested so added tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179
https://github.com/CliMA/Oceananigans.jl/issues/3181:70,Availability,Error,Errors,70,"PR #3179 identified a few bugs with Flat dimensions in lat-lon grids. Errors appear when one tries to run a HydrostaticFreeSurface model with such grids. 1) for a lat-lon grid with Flat-Flat-Bounded the problem comes from . https://github.com/CliMA/Oceananigans.jl/blob/8c1f2fb7f51a459fcf8c472a92d10c3cad455793/src/Advection/momentum_advection_operators.jl#L54. which requires `Vᶠᶜᶜ` and in turn hits:. https://github.com/CliMA/Oceananigans.jl/blob/8c1f2fb7f51a459fcf8c472a92d10c3cad455793/src/Operators/spacings_and_areas_and_volumes.jl#L206. 2) for lat-lon grids with **either** lon **or** lat being Flat, the problem comes from the Matrix implicit free surface solver which assumes that there is no flat horizontal dimension. _Originally posted by @navidcy in https://github.com/CliMA/Oceananigans.jl/issues/3179#issuecomment-1630670511_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3181
https://github.com/CliMA/Oceananigans.jl/pull/3182:250,Availability,redundant,redundant,250,"After discussion in #3177 I noticed that the warning only warns for Julia v1.7 and earlier... But it should warn for Julia v1.8 as well. (Although, if we decide to add a compat entry for Julia v1.9 as a response to #3184 then the warning is rendered redundant.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182
https://github.com/CliMA/Oceananigans.jl/pull/3182:250,Safety,redund,redundant,250,"After discussion in #3177 I noticed that the warning only warns for Julia v1.7 and earlier... But it should warn for Julia v1.8 as well. (Although, if we decide to add a compat entry for Julia v1.9 as a response to #3184 then the warning is rendered redundant.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182
https://github.com/CliMA/Oceananigans.jl/issues/3184:191,Availability,error,error,191,"As discussed in #3177 , there is a version bug with `fkeep` and Julia 1.8.3 (1.9.2 works fine).; Trying to use `ImmersedBoundaryGrid` with `HydrostaticFreeSurfaceModel` returns the following error:. ```julia; MethodError: no method matching fkeep!(::Oceananigans.Solvers.var""#60#61"", ::SparseArrays.SparseMatrixCSC{Float64, Int64}); ```. Minimal reproducible example:. ```julia; using Oceananigans. underlying_grid = RectilinearGrid(; size=(100, 100, 10),; x=(-2pi, 2pi),; y=(-2pi, 2pi),; z=(-2, 0),; topology=(Bounded, Bounded, Bounded),; halo=(4, 4, 4); ). @inline bathymetry(x,y) = sin(x)*sin(y)-1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)). model = HydrostaticFreeSurfaceModel(; grid); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184
https://github.com/CliMA/Oceananigans.jl/pull/3185:197,Testability,test,tested,197,"This pull request changes the compat entry for the `PencilArrays` package from `0.16, 0.17, 0.18` to `0.16, 0.17, 0.18, 0.19`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3185
https://github.com/CliMA/Oceananigans.jl/pull/3185:303,Testability,test,tests,303,"This pull request changes the compat entry for the `PencilArrays` package from `0.16, 0.17, 0.18` to `0.16, 0.17, 0.18, 0.19`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3185
https://github.com/CliMA/Oceananigans.jl/pull/3186:8,Deployability,update,updates,8,This PR updates the citation style reference according to changes by [DocumenterCitations.jl v1](https://github.com/JuliaDocs/DocumenterCitations.jl/blob/master/NEWS.md#breaking). Now we can use `(@citet)` and `(@cite)`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3186
https://github.com/CliMA/Oceananigans.jl/pull/3188:793,Security,validat,validation,793,"Using the `FFTBasedPoissonSolver` in complex domains on the `ImmersedBoundaryGrid` leads to resulting solution that either. 1. Does not conserve tracers in the flow; or; 2. Leads to divergent flow along the immersed boundary. On the other hand, using the `PreconditionedConjugateGradientSolver` on complex domains leads to exact solution at a much slower speed on the GPU. This PR implements an `ImmersedPressureSolver` that uses the `FFTBasedPoissonSolver` as a preconditioner, then iterates `PreconditionedConjugateGradientSolver` to arrive at the correct solution. This approach is much faster than using a vanilla `PreconditionedConjugateGradientSolver` as the number of iterations scale much more slowly with grid size on the GPU. This PR will include the `ImmersedPressureSolver`, a few validation examples for benchmarking purposes and a number of example use cases where this solver would be useful. @glwagner @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188
https://github.com/CliMA/Oceananigans.jl/pull/3188:817,Testability,benchmark,benchmarking,817,"Using the `FFTBasedPoissonSolver` in complex domains on the `ImmersedBoundaryGrid` leads to resulting solution that either. 1. Does not conserve tracers in the flow; or; 2. Leads to divergent flow along the immersed boundary. On the other hand, using the `PreconditionedConjugateGradientSolver` on complex domains leads to exact solution at a much slower speed on the GPU. This PR implements an `ImmersedPressureSolver` that uses the `FFTBasedPoissonSolver` as a preconditioner, then iterates `PreconditionedConjugateGradientSolver` to arrive at the correct solution. This approach is much faster than using a vanilla `PreconditionedConjugateGradientSolver` as the number of iterations scale much more slowly with grid size on the GPU. This PR will include the `ImmersedPressureSolver`, a few validation examples for benchmarking purposes and a number of example use cases where this solver would be useful. @glwagner @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188
https://github.com/CliMA/Oceananigans.jl/issues/3189:46,Availability,error,errors,46,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:184,Availability,error,errors,184,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:374,Availability,error,error,374,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:387,Availability,ERROR,ERROR,387,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:435,Availability,error,error,435,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:4309,Availability,Down,Downgrading,4309,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:4541,Availability,error,errors,4541,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:4629,Availability,down,down,4629,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:263,Deployability,configurat,configurations,263,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:4461,Deployability,configurat,configuration,4461,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:1134,Integrability,wrap,wrappers,1134," GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:209 [inlined]; [15] solve!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, so",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:1213,Integrability,wrap,wrappers,1213,"A but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:209 [inlined]; [15] solve!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, solver::Oceananigans.Solvers.HeptadiagonalIterativeSolver{ImmersedBoundaryGrid{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:4812,Integrability,depend,dependency,4812,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:263,Modifiability,config,configurations,263,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:4461,Modifiability,config,configuration,4461,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/issues/3189:394,Performance,Load,LoadError,394,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189
https://github.com/CliMA/Oceananigans.jl/pull/3190:48,Deployability,update,update,48,Removes all support for <1.9 Julia versions and update `Project.toml`. Closes #3184,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3190
https://github.com/CliMA/Oceananigans.jl/issues/3195:111,Testability,log,log-low,111,"Hi all,; I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference?; ![u_profile (2)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/14e2c865-ec3b-4065-a13a-213a99257d31); ![uw_flux (1)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/1cd16836-6f59-465b-8d02-0577052b52ba). ```julia; const H=15 #/m; grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); const u★=0.01 #friction velocity; Fx(x,y,z,t)=u★^2/H #forcing. const z₀ = H*1e-4 # m (roughness length); const κ = 0.4 # von Karman constant; const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient. @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v). drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)). u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); v_bcs = FieldBoundaryConditions(bottom = drag_bc_v). model = NonhydrostaticModel(; grid, coriolis,; advection = WENO(),; timestepper = :RungeKutta3,; tracers =(:T,:S),; buoyancy = SeawaterBuoyancy(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; forcing=(u=Fx,)); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195
https://github.com/CliMA/Oceananigans.jl/issues/3195:892,Testability,log,log,892,"Hi all,; I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference?; ![u_profile (2)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/14e2c865-ec3b-4065-a13a-213a99257d31); ![uw_flux (1)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/1cd16836-6f59-465b-8d02-0577052b52ba). ```julia; const H=15 #/m; grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); const u★=0.01 #friction velocity; Fx(x,y,z,t)=u★^2/H #forcing. const z₀ = H*1e-4 # m (roughness length); const κ = 0.4 # von Karman constant; const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient. @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v). drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)). u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); v_bcs = FieldBoundaryConditions(bottom = drag_bc_v). model = NonhydrostaticModel(; grid, coriolis,; advection = WENO(),; timestepper = :RungeKutta3,; tracers =(:T,:S),; buoyancy = SeawaterBuoyancy(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; forcing=(u=Fx,)); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195
https://github.com/CliMA/Oceananigans.jl/issues/3195:45,Usability,simpl,simple,45,"Hi all,; I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference?; ![u_profile (2)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/14e2c865-ec3b-4065-a13a-213a99257d31); ![uw_flux (1)](https://github.com/CliMA/Oceananigans.jl/assets/117068415/1cd16836-6f59-465b-8d02-0577052b52ba). ```julia; const H=15 #/m; grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); const u★=0.01 #friction velocity; Fx(x,y,z,t)=u★^2/H #forcing. const z₀ = H*1e-4 # m (roughness length); const κ = 0.4 # von Karman constant; const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient. @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v). drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)). u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); v_bcs = FieldBoundaryConditions(bottom = drag_bc_v). model = NonhydrostaticModel(; grid, coriolis,; advection = WENO(),; timestepper = :RungeKutta3,; tracers =(:T,:S),; buoyancy = SeawaterBuoyancy(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; forcing=(u=Fx,)); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195
https://github.com/CliMA/Oceananigans.jl/issues/3201:370,Performance,perform,performance,370,"At the moment we fill the velocity halos with multiple passes, e.g., . https://github.com/CliMA/Oceananigans.jl/blob/2447ea7c15d552fb6a50d3fd347d6534af0018c7/validation/multi_region/multi_region_cubed_sphere.jl#L115-L119. We should utilize the grid's connectivity and develop a method to fill the velocity halos that only requires _one_ pass. This is very important for performance and scaling on distributed systems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201
https://github.com/CliMA/Oceananigans.jl/issues/3201:158,Security,validat,validation,158,"At the moment we fill the velocity halos with multiple passes, e.g., . https://github.com/CliMA/Oceananigans.jl/blob/2447ea7c15d552fb6a50d3fd347d6534af0018c7/validation/multi_region/multi_region_cubed_sphere.jl#L115-L119. We should utilize the grid's connectivity and develop a method to fill the velocity halos that only requires _one_ pass. This is very important for performance and scaling on distributed systems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201
https://github.com/CliMA/Oceananigans.jl/issues/3202:35,Testability,test,tested,35,At the moment only `XPartition` is tested:. https://github.com/CliMA/Oceananigans.jl/blob/2447ea7c15d552fb6a50d3fd347d6534af0018c7/test/test_multi_region_unit.jl#L14-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3202
https://github.com/CliMA/Oceananigans.jl/issues/3202:131,Testability,test,test,131,At the moment only `XPartition` is tested:. https://github.com/CliMA/Oceananigans.jl/blob/2447ea7c15d552fb6a50d3fd347d6534af0018c7/test/test_multi_region_unit.jl#L14-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3202
https://github.com/CliMA/Oceananigans.jl/issues/3204:6,Security,validat,validation,6,Add a validation script and/or tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204
https://github.com/CliMA/Oceananigans.jl/issues/3204:31,Testability,test,tests,31,Add a validation script and/or tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204
https://github.com/CliMA/Oceananigans.jl/issues/3205:173,Integrability,depend,depend,173,The `OrthogonalSphericalShellGrid` is more general than the `LatitudeLongitudeGrid`. We should add functionality so that _any_ grid with horizontal coordinates/metrics that depend in both horizontal dimensions can be constructed using the `OrthogonalSphericalShellGrid`. When we do that and when we ensure that we can replicate any `LatitudeLongitudeGrid` using the `OrthogonalSphericalShellGrid` we will be able to eliminate the `LatitudeLongitudeGrid`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3205
https://github.com/CliMA/Oceananigans.jl/issues/3206:31,Availability,checkpoint,checkpoints,31,"At the moment, restarting from checkpoints does not allow to restart from data with different halo size.; In particular, I encountered this issue when I wanted to restart a simulation with a different advection order from already evolved data. We might want to support this feature since, when dealing with large complex simulations, a lot of trial and error has to be done in order to find the optimal parameters, which include order of advection (and sub-stepping size for the free surface, which involves halo size for distributed simulations). If there is interest in this feature, I can start implementing it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206
https://github.com/CliMA/Oceananigans.jl/issues/3206:353,Availability,error,error,353,"At the moment, restarting from checkpoints does not allow to restart from data with different halo size.; In particular, I encountered this issue when I wanted to restart a simulation with a different advection order from already evolved data. We might want to support this feature since, when dealing with large complex simulations, a lot of trial and error has to be done in order to find the optimal parameters, which include order of advection (and sub-stepping size for the free surface, which involves halo size for distributed simulations). If there is interest in this feature, I can start implementing it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206
https://github.com/CliMA/Oceananigans.jl/issues/3206:230,Modifiability,evolve,evolved,230,"At the moment, restarting from checkpoints does not allow to restart from data with different halo size.; In particular, I encountered this issue when I wanted to restart a simulation with a different advection order from already evolved data. We might want to support this feature since, when dealing with large complex simulations, a lot of trial and error has to be done in order to find the optimal parameters, which include order of advection (and sub-stepping size for the free surface, which involves halo size for distributed simulations). If there is interest in this feature, I can start implementing it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206
https://github.com/CliMA/Oceananigans.jl/issues/3208:61,Security,validat,validation,61,"I've been playing around with the `immersed_couette_flow.jl` validation experiment and think I discovered a bug in the immersed boundaries implementation which causes non-immersed boundary conditions to be ignored. The BCs specified are here:; https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/validation/immersed_boundaries/immersed_couette_flow.jl#L16-L23. It is clear from the movie produced by the script that the flow adjusts to the immersed value BCs of u(0.1)=1 and c(0.1)=1 but does not adjust to meet the top BCs of u(1)=-1 and c(1)=-1. https://github.com/CliMA/Oceananigans.jl/assets/12971166/fb6ac2a8-7081-4edf-b363-87850b47fc6a. I ran into the same problem when adding an immersed boundary to the `horizontal_convection.jl` experiment. Adding an immersed boundary invalidated the surface buoyancy forcing, even when no `immersed` boundary condition was explicitly specified. Has anyone run into this issue or know what might be going on?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208
https://github.com/CliMA/Oceananigans.jl/issues/3208:331,Security,validat,validation,331,"I've been playing around with the `immersed_couette_flow.jl` validation experiment and think I discovered a bug in the immersed boundaries implementation which causes non-immersed boundary conditions to be ignored. The BCs specified are here:; https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/validation/immersed_boundaries/immersed_couette_flow.jl#L16-L23. It is clear from the movie produced by the script that the flow adjusts to the immersed value BCs of u(0.1)=1 and c(0.1)=1 but does not adjust to meet the top BCs of u(1)=-1 and c(1)=-1. https://github.com/CliMA/Oceananigans.jl/assets/12971166/fb6ac2a8-7081-4edf-b363-87850b47fc6a. I ran into the same problem when adding an immersed boundary to the `horizontal_convection.jl` experiment. Adding an immersed boundary invalidated the surface buoyancy forcing, even when no `immersed` boundary condition was explicitly specified. Has anyone run into this issue or know what might be going on?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208
https://github.com/CliMA/Oceananigans.jl/issues/3208:402,Usability,clear,clear,402,"I've been playing around with the `immersed_couette_flow.jl` validation experiment and think I discovered a bug in the immersed boundaries implementation which causes non-immersed boundary conditions to be ignored. The BCs specified are here:; https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/validation/immersed_boundaries/immersed_couette_flow.jl#L16-L23. It is clear from the movie produced by the script that the flow adjusts to the immersed value BCs of u(0.1)=1 and c(0.1)=1 but does not adjust to meet the top BCs of u(1)=-1 and c(1)=-1. https://github.com/CliMA/Oceananigans.jl/assets/12971166/fb6ac2a8-7081-4edf-b363-87850b47fc6a. I ran into the same problem when adding an immersed boundary to the `horizontal_convection.jl` experiment. Adding an immersed boundary invalidated the surface buoyancy forcing, even when no `immersed` boundary condition was explicitly specified. Has anyone run into this issue or know what might be going on?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208
https://github.com/CliMA/Oceananigans.jl/pull/3209:8,Deployability,toggle,toggles,8,"This PR toggles conditional differences with `immersed_inactive_node`, rather than `inactive_node`. The difference is that `inactive_node` returns `true` if the node is outside the domain (either immersed _or_ outside the domain in a `Bounded` direction). `immersed_inactive_node` only returns true if the node is within the immersed boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/ImmersedBoundaries/ImmersedBoundaries.jl#L220-L221. This matters for applying `ValueBoundaryCondition` or `GradientBoundaryCondition` across non-immersed boundaries, on `ImmersedBoundaryGrid`, because both of these are enforced by filling the halo regions on the other side of a `Bounded` direction. Thus we have to be able to correctly evaluate differences / interpolate across non-immersed `Bounded` boundaries. Closes #3208 . We might want to add a test so this doesn't break in the future. It'd also be great to make this code more understandable (suggestions welcome...). @hdrake",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3209
https://github.com/CliMA/Oceananigans.jl/pull/3209:888,Testability,test,test,888,"This PR toggles conditional differences with `immersed_inactive_node`, rather than `inactive_node`. The difference is that `inactive_node` returns `true` if the node is outside the domain (either immersed _or_ outside the domain in a `Bounded` direction). `immersed_inactive_node` only returns true if the node is within the immersed boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/ImmersedBoundaries/ImmersedBoundaries.jl#L220-L221. This matters for applying `ValueBoundaryCondition` or `GradientBoundaryCondition` across non-immersed boundaries, on `ImmersedBoundaryGrid`, because both of these are enforced by filling the halo regions on the other side of a `Bounded` direction. Thus we have to be able to correctly evaluate differences / interpolate across non-immersed `Bounded` boundaries. Closes #3208 . We might want to add a test so this doesn't break in the future. It'd also be great to make this code more understandable (suggestions welcome...). @hdrake",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3209
https://github.com/CliMA/Oceananigans.jl/pull/3212:593,Energy Efficiency,energy,energy,593,"@simone-silvestri and I replaced a hardcoded `0.5` with `/2` as the former caused a type instability which eventually crashed the baroclinic adjustment setup after 13 days. How exactly that happened we don't know, but it definitely caused a cascade to Float64 - we believe even into the whole tendency - we shouldn't happen. With this little change Float32 runs stable even with 9th order WENO V-scheme (velocities used for smoothness estimation when reconstructing vorticity) which is Simone's preferred scheme also for global simulations. . Simone can you throw in the video and the kinetic energy comparison to Float64?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212
https://github.com/CliMA/Oceananigans.jl/pull/3213:150,Deployability,integrat,integrator,150,"I don't know how relevant these changes are, but I found some more type instabilities in the split explicit free surface model's adams bashforth time integrator. Removing them similar to #3212 . Alternatively we could also hardcode the constants. https://github.com/CliMA/Oceananigans.jl/blob/9140a74536784396d368cf8205432433a9deea3d/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L11-L19. as Float32. ```julia; const β = 0.281105f0; const α = 1.5f0 + β; ```; etc. as this will directly upcast to Float64 if that's used, but not cause a type instability with Float32. But this will again cause problems if we ever want to use something else than Float32/64... Now just the `U★, η★` get a bit lengthier!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3213
https://github.com/CliMA/Oceananigans.jl/pull/3213:150,Integrability,integrat,integrator,150,"I don't know how relevant these changes are, but I found some more type instabilities in the split explicit free surface model's adams bashforth time integrator. Removing them similar to #3212 . Alternatively we could also hardcode the constants. https://github.com/CliMA/Oceananigans.jl/blob/9140a74536784396d368cf8205432433a9deea3d/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L11-L19. as Float32. ```julia; const β = 0.281105f0; const α = 1.5f0 + β; ```; etc. as this will directly upcast to Float64 if that's used, but not cause a type instability with Float32. But this will again cause problems if we ever want to use something else than Float32/64... Now just the `U★, η★` get a bit lengthier!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3213
https://github.com/CliMA/Oceananigans.jl/issues/3217:410,Security,validat,validation,410,"Longitude values are not defined correctly at locations fca and cfa of (some particular orientations of) the orthogonal spherical shell grid (OSSG). Recall that the OSSGs constitute the individual panels of the conformal cubed sphere. The attached plots can be generated by running the script [multiregion_cubed_sphere.jl](https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) of the commit [60dde17](https://github.com/CliMA/Oceananigans.jl/commit/60dde179a1851bcc47a55987478d825709e3e7c6) of the Oceananigans branch [jmc-ss/cubed-sphere](https://github.com/CliMA/Oceananigans.jl/tree/jmc-ss/cubed_sphere) with the specification test_multi_region_cubed_sphere_plots = true. ![longitude_heatsphere_c](https://github.com/CliMA/Oceananigans.jl/assets/12926768/250e2ad9-530b-4e00-94da-ebfff9c8d0c6); ![longitude_panel_wise_visualization_c_k_2](https://github.com/CliMA/Oceananigans.jl/assets/12926768/6a3aec42-476d-4575-906b-f04ecd88ea82). ![longitude_heatsphere_u](https://github.com/CliMA/Oceananigans.jl/assets/12926768/fabf2caf-dfaf-4342-a713-1799e592e307); ![longitude_panel_wise_visualization_u_k_2](https://github.com/CliMA/Oceananigans.jl/assets/12926768/2a83e72e-8527-45bd-bb0d-0bd120544848). ![longitude_heatsphere_v](https://github.com/CliMA/Oceananigans.jl/assets/12926768/79f91dec-0f48-4a11-9f6f-2e7f16bce000); ![longitude_panel_wise_visualization_v_k_2](https://github.com/CliMA/Oceananigans.jl/assets/12926768/68605b8c-34be-4d7c-9d9e-d5a84efefb56). The first, second and third pair of plots depict the longitude at locations cca, fca, and cfa respectively. The first pair of plots appear to be reasonable. That is not the case with the second and third pairs of plots, where the longitudes appear to be oriented along the latitudes (while ignoring the plotting issue resulting in a small gap).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217
https://github.com/CliMA/Oceananigans.jl/issues/3224:972,Deployability,integrat,integrate,972,"Presently, applying differential operators to fields offline (as opposed to using diagnosing them online using using an `OutputWriter`) yields erroneous results because derivatives seem to be naively using output halo region values (which seem to be filled with zeroes by default) and not overwriting them to satisfy boundary conditions. One example impact of this is that the [Nusselt number calculation in the `horizontal_convection.jl` example script](https://clima.github.io/OceananigansDocumentation/stable/generated/horizontal_convection/#The-Nusselt-number) is totally meaningless because it is dominated by spuriously large buoyancy gradients in the boundary-adjacent cells. @ikeshwani and I demonstrate this bug in [this `horizontal_diffusion.jl` script](https://github.com/hdrake/HorizontalConvection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224
https://github.com/CliMA/Oceananigans.jl/issues/3224:1047,Deployability,integrat,integrated,1047,"ing them online using using an `OutputWriter`) yields erroneous results because derivatives seem to be naively using output halo region values (which seem to be filled with zeroes by default) and not overwriting them to satisfy boundary conditions. One example impact of this is that the [Nusselt number calculation in the `horizontal_convection.jl` example script](https://clima.github.io/OceananigansDocumentation/stable/generated/horizontal_convection/#The-Nusselt-number) is totally meaningless because it is dominated by spuriously large buoyancy gradients in the boundary-adjacent cells. @ikeshwani and I demonstrate this bug in [this `horizontal_diffusion.jl` script](https://github.com/hdrake/HorizontalConvection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`), as is evident from the movie of the buoyancy dissipation rate field in the [`horizontal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224
https://github.com/CliMA/Oceananigans.jl/issues/3224:972,Integrability,integrat,integrate,972,"Presently, applying differential operators to fields offline (as opposed to using diagnosing them online using using an `OutputWriter`) yields erroneous results because derivatives seem to be naively using output halo region values (which seem to be filled with zeroes by default) and not overwriting them to satisfy boundary conditions. One example impact of this is that the [Nusselt number calculation in the `horizontal_convection.jl` example script](https://clima.github.io/OceananigansDocumentation/stable/generated/horizontal_convection/#The-Nusselt-number) is totally meaningless because it is dominated by spuriously large buoyancy gradients in the boundary-adjacent cells. @ikeshwani and I demonstrate this bug in [this `horizontal_diffusion.jl` script](https://github.com/hdrake/HorizontalConvection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224
https://github.com/CliMA/Oceananigans.jl/issues/3224:1047,Integrability,integrat,integrated,1047,"ing them online using using an `OutputWriter`) yields erroneous results because derivatives seem to be naively using output halo region values (which seem to be filled with zeroes by default) and not overwriting them to satisfy boundary conditions. One example impact of this is that the [Nusselt number calculation in the `horizontal_convection.jl` example script](https://clima.github.io/OceananigansDocumentation/stable/generated/horizontal_convection/#The-Nusselt-number) is totally meaningless because it is dominated by spuriously large buoyancy gradients in the boundary-adjacent cells. @ikeshwani and I demonstrate this bug in [this `horizontal_diffusion.jl` script](https://github.com/hdrake/HorizontalConvection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`), as is evident from the movie of the buoyancy dissipation rate field in the [`horizontal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224
https://github.com/CliMA/Oceananigans.jl/issues/3224:2220,Performance,Load,Load-saved-output,2220,"Convection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`), as is evident from the movie of the buoyancy dissipation rate field in the [`horizontal_convection.jl` example documentation](https://clima.github.io/OceananigansDocumentation/v0.84.1/generated/horizontal_convection/#Load-saved-output,-process,-visualize) and verified locally. <img width=""519"" alt=""Screenshot 2023-08-22 at 1 13 30 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/c61b002c-5fd5-453d-8809-623e577e54f3"">. I am referring to this as a bug because it is contrary to the expected behavior of halos containing the necessary information for satisfying boundary conditions, as discussed in the horizontal convection documentation example:; https://github.com/CliMA/Oceananigans.jl/blob/a226b3efa7db7426ccee03884d610035314955e4/examples/horizontal_convection.jl#L143-L147",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224
https://github.com/CliMA/Oceananigans.jl/issues/3224:1686,Usability,clear,clearly,1686,"monstrate this bug in [this `horizontal_diffusion.jl` script](https://github.com/hdrake/HorizontalConvection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`), as is evident from the movie of the buoyancy dissipation rate field in the [`horizontal_convection.jl` example documentation](https://clima.github.io/OceananigansDocumentation/v0.84.1/generated/horizontal_convection/#Load-saved-output,-process,-visualize) and verified locally. <img width=""519"" alt=""Screenshot 2023-08-22 at 1 13 30 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/c61b002c-5fd5-453d-8809-623e577e54f3"">. I am referring to this as a bug because it is contrary to the expected behavior of halos containing the necessary information for satisfying boundary conditions, as discussed in the horizontal convection documentation example:; https://github.com/CliMA/Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224
https://github.com/CliMA/Oceananigans.jl/pull/3225:321,Testability,test,test,321,"It was not copying halo regions, which are needed for correct offline diagnostics since `FieldTimeSeries` uses `set!`. Closes #3224 . Thanks very much to @hdrake and @ikeshwani for finding this offline-diagnostics-ruining bug!. I think the implementation of `set!` between `Field`s has waffled over time. We should add a test if we want to ensure this behavior.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3225
https://github.com/CliMA/Oceananigans.jl/issues/3226:699,Availability,error,error,699,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226
https://github.com/CliMA/Oceananigans.jl/issues/3226:712,Availability,ERROR,ERROR,712,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226
https://github.com/CliMA/Oceananigans.jl/issues/3226:590,Energy Efficiency,schedul,schedule,590,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226
https://github.com/CliMA/Oceananigans.jl/issues/3226:719,Performance,Load,LoadError,719,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226
https://github.com/CliMA/Oceananigans.jl/issues/3226:109,Security,access,access,109,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226
https://github.com/CliMA/Oceananigans.jl/pull/3227:66,Deployability,update,update,66,getregion was not working on `KernelFunctionOperation`s after the update from `computed_dependecies` to `arguments` because of the splatting in the constructor. This PR fixes it. @siddharthabishnu,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227
https://github.com/CliMA/Oceananigans.jl/pull/3228:34,Testability,test,test,34,"Closes #3226 . It'd make sense to test this, let's see first if it does the trick.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228
https://github.com/CliMA/Oceananigans.jl/pull/3230:187,Integrability,depend,depend,187,This PR removes any conformal mapping-related properties from the `OrthogonalSphericalShellGrid` and thus now `OrthogonalSphericalShellGrid` is any grid with coordinates and metrics that depend on both horizontal dimensions. The PR also adds a `conformal_cubed_sphere_panel` constructor that returns the grid that corresponds to each panel of a conformal cubed sphere grid. Closes #3200,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3230
https://github.com/CliMA/Oceananigans.jl/issues/3232:477,Availability,ERROR,ERROR,477,"This is what's keeping tests in https://github.com/tomchor/Oceanostics.jl/pull/151 from passing. Here's the simplest MWE I could come up with:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid,);. julia> test(i, j, k, grid, auxiliary_fields,) = 1.0;. julia> a = KernelFunctionOperation{Center, Center, Center}(test, model.grid, model.auxiliary_fields);. julia> compute!(Field(a)); ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 2 times); @ ./tuple.jl:414 [inlined]; [4] findfirst(f::Function, t::Tuple{Tuple{DataType, DataType, DataType}, NamedTuple{(), Tuple{}}}); @ Base ./tuple.jl:421; [5] #construct_regionally#52; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:146 [inlined]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232
https://github.com/CliMA/Oceananigans.jl/issues/3232:23,Testability,test,tests,23,"This is what's keeping tests in https://github.com/tomchor/Oceanostics.jl/pull/151 from passing. Here's the simplest MWE I could come up with:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid,);. julia> test(i, j, k, grid, auxiliary_fields,) = 1.0;. julia> a = KernelFunctionOperation{Center, Center, Center}(test, model.grid, model.auxiliary_fields);. julia> compute!(Field(a)); ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 2 times); @ ./tuple.jl:414 [inlined]; [4] findfirst(f::Function, t::Tuple{Tuple{DataType, DataType, DataType}, NamedTuple{(), Tuple{}}}); @ Base ./tuple.jl:421; [5] #construct_regionally#52; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:146 [inlined]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232
https://github.com/CliMA/Oceananigans.jl/issues/3232:300,Testability,test,test,300,"This is what's keeping tests in https://github.com/tomchor/Oceanostics.jl/pull/151 from passing. Here's the simplest MWE I could come up with:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid,);. julia> test(i, j, k, grid, auxiliary_fields,) = 1.0;. julia> a = KernelFunctionOperation{Center, Center, Center}(test, model.grid, model.auxiliary_fields);. julia> compute!(Field(a)); ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 2 times); @ ./tuple.jl:414 [inlined]; [4] findfirst(f::Function, t::Tuple{Tuple{DataType, DataType, DataType}, NamedTuple{(), Tuple{}}}); @ Base ./tuple.jl:421; [5] #construct_regionally#52; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:146 [inlined]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232
https://github.com/CliMA/Oceananigans.jl/issues/3232:406,Testability,test,test,406,"This is what's keeping tests in https://github.com/tomchor/Oceanostics.jl/pull/151 from passing. Here's the simplest MWE I could come up with:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid,);. julia> test(i, j, k, grid, auxiliary_fields,) = 1.0;. julia> a = KernelFunctionOperation{Center, Center, Center}(test, model.grid, model.auxiliary_fields);. julia> compute!(Field(a)); ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 2 times); @ ./tuple.jl:414 [inlined]; [4] findfirst(f::Function, t::Tuple{Tuple{DataType, DataType, DataType}, NamedTuple{(), Tuple{}}}); @ Base ./tuple.jl:421; [5] #construct_regionally#52; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:146 [inlined]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232
https://github.com/CliMA/Oceananigans.jl/issues/3232:2074,Testability,test,test,2074,"ed]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(test), Tuple{NamedTuple{(), Tuple{}}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/pbNSE/src/AbstractOperations/kernel_function_operation.jl:74; [10] Field(operand::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(test), Tuple{NamedTuple{(), Tuple{}}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/pbNSE/src/AbstractOperations/computed_field.jl:37; [11] top-level scope; @ REPL[12]:1; ```. For some reason it seems this only happens when passing `auxiliary_fields` to KFO.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232
https://github.com/CliMA/Oceananigans.jl/issues/3232:2791,Testability,test,test,2791,"ed]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(test), Tuple{NamedTuple{(), Tuple{}}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/pbNSE/src/AbstractOperations/kernel_function_operation.jl:74; [10] Field(operand::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(test), Tuple{NamedTuple{(), Tuple{}}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/pbNSE/src/AbstractOperations/computed_field.jl:37; [11] top-level scope; @ REPL[12]:1; ```. For some reason it seems this only happens when passing `auxiliary_fields` to KFO.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232
https://github.com/CliMA/Oceananigans.jl/issues/3232:108,Usability,simpl,simplest,108,"This is what's keeping tests in https://github.com/tomchor/Oceanostics.jl/pull/151 from passing. Here's the simplest MWE I could come up with:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid,);. julia> test(i, j, k, grid, auxiliary_fields,) = 1.0;. julia> a = KernelFunctionOperation{Center, Center, Center}(test, model.grid, model.auxiliary_fields);. julia> compute!(Field(a)); ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 2 times); @ ./tuple.jl:414 [inlined]; [4] findfirst(f::Function, t::Tuple{Tuple{DataType, DataType, DataType}, NamedTuple{(), Tuple{}}}); @ Base ./tuple.jl:421; [5] #construct_regionally#52; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:146 [inlined]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232
https://github.com/CliMA/Oceananigans.jl/pull/3233:268,Availability,down,down,268,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233
https://github.com/CliMA/Oceananigans.jl/pull/3233:1766,Deployability,update,update,1766," LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u"", backend = Chunked(chunk_size = 4)); 17×16×10×100 FieldTimeSeries{Chunked} located at (Face, Center, Center) on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── indices: (Colon(), Colon(), Colon()); └── data: 23×22×16×4 OffsetArray(::Array{Float64, 4}, -2:20, -2:19, -2:13, 1:4) with eltype Float64 with indices -2:20×-2:19×-2:13×1:4; └── max=8.0, min=0.0, mean=1.67984; ```. This is not final and all open to suggestions/changes/improvement. maybe interesting for @yuchenma23",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233
https://github.com/CliMA/Oceananigans.jl/pull/3233:108,Integrability,depend,dependent,108,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233
https://github.com/CliMA/Oceananigans.jl/pull/3233:31,Modifiability,extend,extend,31,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233
https://github.com/CliMA/Oceananigans.jl/pull/3233:773,Testability,test,testfile,773,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233
https://github.com/CliMA/Oceananigans.jl/pull/3233:906,Testability,test,testfile,906,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233
https://github.com/CliMA/Oceananigans.jl/pull/3233:976,Testability,test,testfile,976,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233
https://github.com/CliMA/Oceananigans.jl/pull/3233:1052,Testability,test,testfile,1052," `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u"", backend = Chunked(chunk_size = 4)); 17×16×10×100 Fi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233
https://github.com/CliMA/Oceananigans.jl/pull/3233:1983,Testability,test,testfile,1983," LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u"", backend = Chunked(chunk_size = 4)); 17×16×10×100 FieldTimeSeries{Chunked} located at (Face, Center, Center) on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── indices: (Colon(), Colon(), Colon()); └── data: 23×22×16×4 OffsetArray(::Array{Float64, 4}, -2:20, -2:19, -2:13, 1:4) with eltype Float64 with indices -2:20×-2:19×-2:13×1:4; └── max=8.0, min=0.0, mean=1.67984; ```. This is not final and all open to suggestions/changes/improvement. maybe interesting for @yuchenma23",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233
https://github.com/CliMA/Oceananigans.jl/pull/3236:199,Testability,test,testfile,199,"Allow linear time interpolation between different indices of the field time series triggered by a Float64 (AbstractTime not supported at the moment) index. ; ```julia; julia> fts2 = FieldTimeSeries(""testfile.jld2"", ""u"");. julia> fts2[1]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.0, min=2.0, mean=2.0. julia> fts2[2]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 2), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=4.0, min=4.0, mean=4.0. julia> fts2[1.35]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ├── operand: BinaryOperation at (Face, Center, Center); ├── status: time=0.0; └── data: 23×22×16 OffsetArray(::Array{Float64, 3}, -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.7, min=2.7, mean=2.7. julia> fts2[1, 1, 1, 13]; 26.0. julia> fts2[1, 1, 1, 14]; 28.0. julia> fts2[1, 1, 1, 13.67]; 27.34; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236
https://github.com/CliMA/Oceananigans.jl/pull/3237:513,Availability,error,error,513,"Here I've removed the over-specification that `DiscreteForcing` must have a `Function` in the second parameter so that an object can be put there instead, and a method on that object be the forcing function (don't think I'm describing this very well). This is useful if you want to pass information to a forcing by defining a struct like:; ```julia; struct StructForcing{D}; data :: D; end. (forcing::StructForcing)(i, j, k, grid, clock, model_fields) = forcing.data[i, j, k]; ```. Then this would fail with this error:; <details>; <summary>; MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; </summary>; Struct method forcing [CPU]: Error During Test at /Users/jago/Documents/Projects/Oceananigans.jl/test/test_forcings.jl:204; Test threw exception; Expression: struct_method_forcing(arch); MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; Stacktrace:; [1] u_velocity_tendency; @ ~/Documents/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; [2] cpu_calculate_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [3] cpu_calculate_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, Gu::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237
https://github.com/CliMA/Oceananigans.jl/pull/3237:690,Availability,Error,Error,690,"Here I've removed the over-specification that `DiscreteForcing` must have a `Function` in the second parameter so that an object can be put there instead, and a method on that object be the forcing function (don't think I'm describing this very well). This is useful if you want to pass information to a forcing by defining a struct like:; ```julia; struct StructForcing{D}; data :: D; end. (forcing::StructForcing)(i, j, k, grid, clock, model_fields) = forcing.data[i, j, k]; ```. Then this would fail with this error:; <details>; <summary>; MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; </summary>; Struct method forcing [CPU]: Error During Test at /Users/jago/Documents/Projects/Oceananigans.jl/test/test_forcings.jl:204; Test threw exception; Expression: struct_method_forcing(arch); MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; Stacktrace:; [1] u_velocity_tendency; @ ~/Documents/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; [2] cpu_calculate_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [3] cpu_calculate_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, Gu::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237
https://github.com/CliMA/Oceananigans.jl/pull/3237:53085,Performance,load,loads,53085,"se.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{FFTW.r2rFFTWPlan{ComplexF64, Vector{Int32}, true, 3, Vector{Int64}}, Oceananigans.Solvers.Backward, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Int64, Bounded, Float64, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, Nothing, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Int64; callbacks::Vector{Any}, euler::Bool); @ Oceananigans.TimeSteppers ~/Documents/Projects/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:91; </details>. In this example, you could achieve it by just using a normal array forcing, but there are more complicated cases where I would find this useful. I would like to do this for boundary conditions too but removing the `Forcing` from here:https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/BoundaryConditions/boundary_condition.jl#L52. and changing ; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/BoundaryConditions/boundary_condition.jl#L20. to dispatch on numbers or arrays does not work and loads of the tests fail.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237
https://github.com/CliMA/Oceananigans.jl/pull/3237:703,Testability,Test,Test,703,"Here I've removed the over-specification that `DiscreteForcing` must have a `Function` in the second parameter so that an object can be put there instead, and a method on that object be the forcing function (don't think I'm describing this very well). This is useful if you want to pass information to a forcing by defining a struct like:; ```julia; struct StructForcing{D}; data :: D; end. (forcing::StructForcing)(i, j, k, grid, clock, model_fields) = forcing.data[i, j, k]; ```. Then this would fail with this error:; <details>; <summary>; MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; </summary>; Struct method forcing [CPU]: Error During Test at /Users/jago/Documents/Projects/Oceananigans.jl/test/test_forcings.jl:204; Test threw exception; Expression: struct_method_forcing(arch); MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; Stacktrace:; [1] u_velocity_tendency; @ ~/Documents/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; [2] cpu_calculate_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [3] cpu_calculate_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, Gu::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237
https://github.com/CliMA/Oceananigans.jl/pull/3237:758,Testability,test,test,758,"Here I've removed the over-specification that `DiscreteForcing` must have a `Function` in the second parameter so that an object can be put there instead, and a method on that object be the forcing function (don't think I'm describing this very well). This is useful if you want to pass information to a forcing by defining a struct like:; ```julia; struct StructForcing{D}; data :: D; end. (forcing::StructForcing)(i, j, k, grid, clock, model_fields) = forcing.data[i, j, k]; ```. Then this would fail with this error:; <details>; <summary>; MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; </summary>; Struct method forcing [CPU]: Error During Test at /Users/jago/Documents/Projects/Oceananigans.jl/test/test_forcings.jl:204; Test threw exception; Expression: struct_method_forcing(arch); MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; Stacktrace:; [1] u_velocity_tendency; @ ~/Documents/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; [2] cpu_calculate_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [3] cpu_calculate_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, Gu::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237
https://github.com/CliMA/Oceananigans.jl/pull/3237:785,Testability,Test,Test,785,"Here I've removed the over-specification that `DiscreteForcing` must have a `Function` in the second parameter so that an object can be put there instead, and a method on that object be the forcing function (don't think I'm describing this very well). This is useful if you want to pass information to a forcing by defining a struct like:; ```julia; struct StructForcing{D}; data :: D; end. (forcing::StructForcing)(i, j, k, grid, clock, model_fields) = forcing.data[i, j, k]; ```. Then this would fail with this error:; <details>; <summary>; MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; </summary>; Struct method forcing [CPU]: Error During Test at /Users/jago/Documents/Projects/Oceananigans.jl/test/test_forcings.jl:204; Test threw exception; Expression: struct_method_forcing(arch); MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; Stacktrace:; [1] u_velocity_tendency; @ ~/Documents/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; [2] cpu_calculate_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [3] cpu_calculate_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, Gu::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237
https://github.com/CliMA/Oceananigans.jl/pull/3237:53098,Testability,test,tests,53098,"se.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{FFTW.r2rFFTWPlan{ComplexF64, Vector{Int32}, true, 3, Vector{Int64}}, Oceananigans.Solvers.Backward, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Int64, Bounded, Float64, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, Nothing, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Int64; callbacks::Vector{Any}, euler::Bool); @ Oceananigans.TimeSteppers ~/Documents/Projects/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:91; </details>. In this example, you could achieve it by just using a normal array forcing, but there are more complicated cases where I would find this useful. I would like to do this for boundary conditions too but removing the `Forcing` from here:https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/BoundaryConditions/boundary_condition.jl#L52. and changing ; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/BoundaryConditions/boundary_condition.jl#L20. to dispatch on numbers or arrays does not work and loads of the tests fail.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237
https://github.com/CliMA/Oceananigans.jl/issues/3238:343,Availability,error,errors,343,"So initially me and @djlikesdjs were trying to use the `SplitExplicitFreeSurface` with the adaptive barotropic step based on CFL. This:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)). free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); ```. errors. ```Julia; ERROR: ArgumentError: either specify a cfl or a number of substeps; Stacktrace:; [1] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings(FT::DataType; substeps::Int64, cfl::Float64, grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, fixed_Δt::Nothing, gravitational_acceleration::Float64, averaging_kernel::Function, timestepper::Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:361,Availability,ERROR,ERROR,361,"So initially me and @djlikesdjs were trying to use the `SplitExplicitFreeSurface` with the adaptive barotropic step based on CFL. This:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)). free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); ```. errors. ```Julia; ERROR: ArgumentError: either specify a cfl or a number of substeps; Stacktrace:; [1] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings(FT::DataType; substeps::Int64, cfl::Float64, grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, fixed_Δt::Nothing, gravitational_acceleration::Float64, averaging_kernel::Function, timestepper::Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:2236,Availability,error,error,2236,"eSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:74; [3] top-level scope; @ REPL[10]:1; ```. This seems counter-intuitive to me because we _had_ actually prescribed a `cfl`. We figured that the error was because `substeps` has a default value of 200 so when we also prescribe a `cfl` kwarg then . https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation);",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:2775,Availability,error,error,2775,"oat64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:74; [3] top-level scope; @ REPL[10]:1; ```. This seems counter-intuitive to me because we _had_ actually prescribed a `cfl`. We figured that the error was because `substeps` has a default value of 200 so when we also prescribe a `cfl` kwarg then . https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation); ```. spits out . ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; Stacktrace:; [1] calculate_substeps; @ ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl:324 [inlined]; [2] iterate_split_explicit!(free_surface::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Ba",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:2781,Availability,down,down,2781,"oat64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:74; [3] top-level scope; @ REPL[10]:1; ```. This seems counter-intuitive to me because we _had_ actually prescribed a `cfl`. We figured that the error was because `substeps` has a default value of 200 so when we also prescribe a `cfl` kwarg then . https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation); ```. spits out . ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; Stacktrace:; [1] calculate_substeps; @ ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl:324 [inlined]; [2] iterate_split_explicit!(free_surface::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Ba",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:3305,Availability,ERROR,ERROR,3305,"thub.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation); ```. spits out . ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; Stacktrace:; [1] calculate_substeps; @ ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl:324 [inlined]; [2] iterate_split_explicit!(free_surface::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:91,Energy Efficiency,adapt,adaptive,91,"So initially me and @djlikesdjs were trying to use the `SplitExplicitFreeSurface` with the adaptive barotropic step based on CFL. This:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)). free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); ```. errors. ```Julia; ERROR: ArgumentError: either specify a cfl or a number of substeps; Stacktrace:; [1] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings(FT::DataType; substeps::Int64, cfl::Float64, grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, fixed_Δt::Nothing, gravitational_acceleration::Float64, averaging_kernel::Function, timestepper::Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:91,Modifiability,adapt,adaptive,91,"So initially me and @djlikesdjs were trying to use the `SplitExplicitFreeSurface` with the adaptive barotropic step based on CFL. This:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)). free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); ```. errors. ```Julia; ERROR: ArgumentError: either specify a cfl or a number of substeps; Stacktrace:; [1] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings(FT::DataType; substeps::Int64, cfl::Float64, grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, fixed_Δt::Nothing, gravitational_acceleration::Float64, averaging_kernel::Function, timestepper::Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:3312,Performance,Load,LoadError,3312,"thub.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation); ```. spits out . ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; Stacktrace:; [1] calculate_substeps; @ ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl:324 [inlined]; [2] iterate_split_explicit!(free_surface::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:2154,Usability,intuit,intuitive,2154,"ans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:74; [3] top-level scope; @ REPL[10]:1; ```. This seems counter-intuitive to me because we _had_ actually prescribed a `cfl`. We figured that the error was because `substeps` has a default value of 200 so when we also prescribe a `cfl` kwarg then . https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/issues/3238:2590,Usability,intuit,intuitive,2590,"setVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:74; [3] top-level scope; @ REPL[10]:1; ```. This seems counter-intuitive to me because we _had_ actually prescribed a `cfl`. We figured that the error was because `substeps` has a default value of 200 so when we also prescribe a `cfl` kwarg then . https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation); ```. spits out . ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; Stacktrace:; [1] calculate_substeps; @ ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl:324 [inlined]; [2] iterate_split_explicit!(free_surface::SplitExplicit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238
https://github.com/CliMA/Oceananigans.jl/pull/3239:97,Security,validat,validation,97,"This PR fills the metrics for the halo regions for a `OrthogonalSphericalShellGrid`. Also adds a validation example for a splash on an `OrthogonalSphericalShellGrid`, i.e., a `HydrostaticFreeSurface` model starting from rest + its free surface lifted up in the form of a Gaussian. Partially resolves #3198.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3239
https://github.com/CliMA/Oceananigans.jl/issues/3241:265,Availability,error,error,265,"Why the lat-lon validation _only_ happens if `isnothing(topology)`? See here:. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Grids/latitude_longitude_grid.jl#L240-L262. This way, if I prescribe latitudes beyond +/-90 no error is given...... ```Julia; julia> using Oceananigans. julia> grid = LatitudeLongitudeGrid(topology=(Bounded, Bounded, Bounded), size = (5, 5, 2), longitude = [0, 1, 3, 6, 12, 20], latitude = [10, 12, 20, 40, 100, 170], z = (-1, 0)); 5×5×2 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── longitude: Bounded λ ∈ [0.0, 20.0] variably spaced with min(Δλ)=1.0, max(Δλ)=8.0; ├── latitude: Bounded φ ∈ [10.0, 170.0] variably spaced with min(Δφ)=2.0, max(Δφ)=70.0; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241
https://github.com/CliMA/Oceananigans.jl/issues/3241:658,Modifiability,variab,variably,658,"Why the lat-lon validation _only_ happens if `isnothing(topology)`? See here:. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Grids/latitude_longitude_grid.jl#L240-L262. This way, if I prescribe latitudes beyond +/-90 no error is given...... ```Julia; julia> using Oceananigans. julia> grid = LatitudeLongitudeGrid(topology=(Bounded, Bounded, Bounded), size = (5, 5, 2), longitude = [0, 1, 3, 6, 12, 20], latitude = [10, 12, 20, 40, 100, 170], z = (-1, 0)); 5×5×2 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── longitude: Bounded λ ∈ [0.0, 20.0] variably spaced with min(Δλ)=1.0, max(Δλ)=8.0; ├── latitude: Bounded φ ∈ [10.0, 170.0] variably spaced with min(Δφ)=2.0, max(Δφ)=70.0; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241
https://github.com/CliMA/Oceananigans.jl/issues/3241:745,Modifiability,variab,variably,745,"Why the lat-lon validation _only_ happens if `isnothing(topology)`? See here:. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Grids/latitude_longitude_grid.jl#L240-L262. This way, if I prescribe latitudes beyond +/-90 no error is given...... ```Julia; julia> using Oceananigans. julia> grid = LatitudeLongitudeGrid(topology=(Bounded, Bounded, Bounded), size = (5, 5, 2), longitude = [0, 1, 3, 6, 12, 20], latitude = [10, 12, 20, 40, 100, 170], z = (-1, 0)); 5×5×2 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── longitude: Bounded λ ∈ [0.0, 20.0] variably spaced with min(Δλ)=1.0, max(Δλ)=8.0; ├── latitude: Bounded φ ∈ [10.0, 170.0] variably spaced with min(Δφ)=2.0, max(Δφ)=70.0; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241
https://github.com/CliMA/Oceananigans.jl/issues/3241:16,Security,validat,validation,16,"Why the lat-lon validation _only_ happens if `isnothing(topology)`? See here:. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Grids/latitude_longitude_grid.jl#L240-L262. This way, if I prescribe latitudes beyond +/-90 no error is given...... ```Julia; julia> using Oceananigans. julia> grid = LatitudeLongitudeGrid(topology=(Bounded, Bounded, Bounded), size = (5, 5, 2), longitude = [0, 1, 3, 6, 12, 20], latitude = [10, 12, 20, 40, 100, 170], z = (-1, 0)); 5×5×2 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── longitude: Bounded λ ∈ [0.0, 20.0] variably spaced with min(Δλ)=1.0, max(Δλ)=8.0; ├── latitude: Bounded φ ∈ [10.0, 170.0] variably spaced with min(Δφ)=2.0, max(Δφ)=70.0; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241
https://github.com/CliMA/Oceananigans.jl/issues/3242:149,Testability,test,test,149,We should add some annotations/docstrings on these functions. https://github.com/CliMA/Oceananigans.jl/blob/f8b4936d9553d53b399b43d5f27678867b9bcee6/test/test_multi_region_cubed_sphere.jl#L9-L65,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3242
https://github.com/CliMA/Oceananigans.jl/issues/3244:131,Safety,avoid,avoid,131,"Hi,. I have been confused about what the `max_change` and `min_change` means.; I understand from the documentation that this is to avoid the time step to change too quickly, but how is it used?. Is it in time units? e.g., taking the default `max_change` of 1.1, that means that for dated simulation it will change the time step at max in 1.1 seconds? . Is it a multiplication? e.g., `new_time_step = 1.1*time_step` ?. I think we can try to be more clear about that in the docs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3244
https://github.com/CliMA/Oceananigans.jl/issues/3244:448,Usability,clear,clear,448,"Hi,. I have been confused about what the `max_change` and `min_change` means.; I understand from the documentation that this is to avoid the time step to change too quickly, but how is it used?. Is it in time units? e.g., taking the default `max_change` of 1.1, that means that for dated simulation it will change the time step at max in 1.1 seconds? . Is it a multiplication? e.g., `new_time_step = 1.1*time_step` ?. I think we can try to be more clear about that in the docs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3244
https://github.com/CliMA/Oceananigans.jl/issues/3250:908,Integrability,interface,interfaces,908,"The argument `grid` is required --- of course --- in model constructors. Our current API makes `grid` a keyword argument. Originally (and it was a long time ago now) it was argued that keyword arguments are just better and that's why we should keep it. Also, we don't dispatch on it. However, we violate that concept in `Simulation`, where the `model` is a positional argument. I think it's more natural to input `grid` as a positional argument in the models. It's a relatively minor thing, but it avoids anti-patterns like `grid=grid`, which appeared in many scripts before `; grid` was possible. It looks better. This has come up because we are adding more Oceananigans-based `AbstractModel`s over in [`ClimaSeaIce`](https://github.com/CliMA/ClimaSeaIce.jl), and my first intuition there was to make `grid` a required positional argument. Ultimately though, we should strive for all models to have uniform interfaces, so either we change `Oceananigans` or we change `ClimaSeaIce`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250
https://github.com/CliMA/Oceananigans.jl/issues/3250:498,Safety,avoid,avoids,498,"The argument `grid` is required --- of course --- in model constructors. Our current API makes `grid` a keyword argument. Originally (and it was a long time ago now) it was argued that keyword arguments are just better and that's why we should keep it. Also, we don't dispatch on it. However, we violate that concept in `Simulation`, where the `model` is a positional argument. I think it's more natural to input `grid` as a positional argument in the models. It's a relatively minor thing, but it avoids anti-patterns like `grid=grid`, which appeared in many scripts before `; grid` was possible. It looks better. This has come up because we are adding more Oceananigans-based `AbstractModel`s over in [`ClimaSeaIce`](https://github.com/CliMA/ClimaSeaIce.jl), and my first intuition there was to make `grid` a required positional argument. Ultimately though, we should strive for all models to have uniform interfaces, so either we change `Oceananigans` or we change `ClimaSeaIce`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250
https://github.com/CliMA/Oceananigans.jl/issues/3250:774,Usability,intuit,intuition,774,"The argument `grid` is required --- of course --- in model constructors. Our current API makes `grid` a keyword argument. Originally (and it was a long time ago now) it was argued that keyword arguments are just better and that's why we should keep it. Also, we don't dispatch on it. However, we violate that concept in `Simulation`, where the `model` is a positional argument. I think it's more natural to input `grid` as a positional argument in the models. It's a relatively minor thing, but it avoids anti-patterns like `grid=grid`, which appeared in many scripts before `; grid` was possible. It looks better. This has come up because we are adding more Oceananigans-based `AbstractModel`s over in [`ClimaSeaIce`](https://github.com/CliMA/ClimaSeaIce.jl), and my first intuition there was to make `grid` a required positional argument. Ultimately though, we should strive for all models to have uniform interfaces, so either we change `Oceananigans` or we change `ClimaSeaIce`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250
https://github.com/CliMA/Oceananigans.jl/issues/3251:813,Availability,error,errors,813,"@m3azevedo and me are doing a simulation of an unstable baroclinic jet in the context of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = U",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:3056,Energy Efficiency,schedul,schedule,3056,"(z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = 0.0; bᵢ(x, y, z) = 0e-6*rand(). model = NonhydrostaticModel(; grid,; background_fields = (u=U, b=B),; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν); ); set!(model, u = uᵢ, b = bᵢ). x, y, z = nodes((Center, Center, Center), grid). function progress(sim); umax = maximum(abs, sim.model.velocities.u); bmax = maximum(abs, sim.model.tracers.b); @info @sprintf(""Iter: %d, time: %.2e, max|u|: %.2e, max|b|: %.2e"",; iteration(sim), time(sim), umax, bmax). return nothing; end; simulation = Simulation(model; Δt=30, stop_time=6hours); simulation.callbacks[:p] = Callback(progress, TimeInterval(1minutes)). u, v, w = model.velocities; b = model.tracers.b; outputs = (; v, u, w, b). simulation.output_writers[:fields] = NetCDFOutputWriter(; model, outputs;; filename = ""NH_BC_jet_pert_fields.nc"",; schedule = TimeInterval(1minutes),; array_type = Array{Float32},; 	 overwrite_existing = true). perturbation_norm(args...) = norm(u). simulation.output_writers[:growth] = NetCDFOutputWriter(; model, (; perturbation_norm),; filename = ""NH_BC_jet_pert_norm.nc"",; schedule = TimeInterval(1minutes),; dimensions = (; perturbation_norm = ()),; overwrite_existing = true). run!(simulation); ```. Method 2: evolve total field. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = U(x, y, z); b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:3317,Energy Efficiency,schedul,schedule,3317,"),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν); ); set!(model, u = uᵢ, b = bᵢ). x, y, z = nodes((Center, Center, Center), grid). function progress(sim); umax = maximum(abs, sim.model.velocities.u); bmax = maximum(abs, sim.model.tracers.b); @info @sprintf(""Iter: %d, time: %.2e, max|u|: %.2e, max|b|: %.2e"",; iteration(sim), time(sim), umax, bmax). return nothing; end; simulation = Simulation(model; Δt=30, stop_time=6hours); simulation.callbacks[:p] = Callback(progress, TimeInterval(1minutes)). u, v, w = model.velocities; b = model.tracers.b; outputs = (; v, u, w, b). simulation.output_writers[:fields] = NetCDFOutputWriter(; model, outputs;; filename = ""NH_BC_jet_pert_fields.nc"",; schedule = TimeInterval(1minutes),; array_type = Array{Float32},; 	 overwrite_existing = true). perturbation_norm(args...) = norm(u). simulation.output_writers[:growth] = NetCDFOutputWriter(; model, (; perturbation_norm),; filename = ""NH_BC_jet_pert_norm.nc"",; schedule = TimeInterval(1minutes),; dimensions = (; perturbation_norm = ()),; overwrite_existing = true). run!(simulation); ```. Method 2: evolve total field. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = U(x, y, z); bᵢ(x, y, z) = B(x, y, z) + 0e-6*rand(). b_bc = FieldBoundaryConditions(top = GradientBoundaryCondition(N²), bottom = GradientBoundaryCondition(N²)). model = NonhydrostaticModel(; grid,; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advect",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:5109,Energy Efficiency,schedul,schedule,5109,"Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = U(x, y, z); bᵢ(x, y, z) = B(x, y, z) + 0e-6*rand(). b_bc = FieldBoundaryConditions(top = GradientBoundaryCondition(N²), bottom = GradientBoundaryCondition(N²)). model = NonhydrostaticModel(; grid,; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν),; boundary_conditions = (b = b_bc, ); ); set!(model, u = uᵢ, b = bᵢ). x, y, z = nodes((Center, Center, Center), grid). function progress(sim); umax = maximum(abs, sim.model.velocities.u); bmax = maximum(abs, sim.model.tracers.b); @info @sprintf(""Iter: %d, time: %.2e, max|u|: %.2e, max|b|: %.2e"",; iteration(sim), time(sim), umax, bmax). return nothing; end; simulation = Simulation(model; Δt=30, stop_time=1hours); simulation.callbacks[:p] = Callback(progress, TimeInterval(1minutes)). u, v, w = model.velocities; b = model.tracers.b; outputs = (; v, u, w, b). simulation.output_writers[:fields] = NetCDFOutputWriter(; model, outputs;; filename = ""NH_BC_jet_fields.nc"",; schedule = TimeInterval(1minutes),; array_type = Array{Float32},; 	 overwrite_existing = true). perturbation_norm(args...) = norm(u). simulation.output_writers[:growth] = NetCDFOutputWriter(; model, (; perturbation_norm),; filename = ""NH_BC_jet_norm.nc"",; schedule = TimeInterval(1minutes),; dimensions = (; perturbation_norm = ()),; overwrite_existing = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:5365,Energy Efficiency,schedul,schedule,5365,"Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = U(x, y, z); bᵢ(x, y, z) = B(x, y, z) + 0e-6*rand(). b_bc = FieldBoundaryConditions(top = GradientBoundaryCondition(N²), bottom = GradientBoundaryCondition(N²)). model = NonhydrostaticModel(; grid,; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν),; boundary_conditions = (b = b_bc, ); ); set!(model, u = uᵢ, b = bᵢ). x, y, z = nodes((Center, Center, Center), grid). function progress(sim); umax = maximum(abs, sim.model.velocities.u); bmax = maximum(abs, sim.model.tracers.b); @info @sprintf(""Iter: %d, time: %.2e, max|u|: %.2e, max|b|: %.2e"",; iteration(sim), time(sim), umax, bmax). return nothing; end; simulation = Simulation(model; Δt=30, stop_time=1hours); simulation.callbacks[:p] = Callback(progress, TimeInterval(1minutes)). u, v, w = model.velocities; b = model.tracers.b; outputs = (; v, u, w, b). simulation.output_writers[:fields] = NetCDFOutputWriter(; model, outputs;; filename = ""NH_BC_jet_fields.nc"",; schedule = TimeInterval(1minutes),; array_type = Array{Float32},; 	 overwrite_existing = true). perturbation_norm(args...) = norm(u). simulation.output_writers[:growth] = NetCDFOutputWriter(; model, (; perturbation_norm),; filename = ""NH_BC_jet_norm.nc"",; schedule = TimeInterval(1minutes),; dimensions = (; perturbation_norm = ()),; overwrite_existing = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:294,Modifiability,evolve,evolve,294,"@m3azevedo and me are doing a simulation of an unstable baroclinic jet in the context of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = U",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:401,Modifiability,evolve,evolve,401,"@m3azevedo and me are doing a simulation of an unstable baroclinic jet in the context of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = U",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:865,Modifiability,evolve,evolve,865,"@m3azevedo and me are doing a simulation of an unstable baroclinic jet in the context of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = U",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:1020,Modifiability,evolve,evolve,1020,"ntext of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z, t) = N² * z + 2*f*Umax*Lⱼ/D^",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:1523,Modifiability,Evolve,Evolve,1523,"ence and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z, t) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = 0.0; bᵢ(x, y, z) = 0e-6*rand(). model = NonhydrostaticModel(; grid,; background_fields = (u=U, b=B),; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν); ); set!(model, u = uᵢ, b = bᵢ). x, y, z = nodes((Center, Center, Center), grid). function progress(sim); umax =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3251:3456,Modifiability,evolve,evolve,3456,"odes((Center, Center, Center), grid). function progress(sim); umax = maximum(abs, sim.model.velocities.u); bmax = maximum(abs, sim.model.tracers.b); @info @sprintf(""Iter: %d, time: %.2e, max|u|: %.2e, max|b|: %.2e"",; iteration(sim), time(sim), umax, bmax). return nothing; end; simulation = Simulation(model; Δt=30, stop_time=6hours); simulation.callbacks[:p] = Callback(progress, TimeInterval(1minutes)). u, v, w = model.velocities; b = model.tracers.b; outputs = (; v, u, w, b). simulation.output_writers[:fields] = NetCDFOutputWriter(; model, outputs;; filename = ""NH_BC_jet_pert_fields.nc"",; schedule = TimeInterval(1minutes),; array_type = Array{Float32},; 	 overwrite_existing = true). perturbation_norm(args...) = norm(u). simulation.output_writers[:growth] = NetCDFOutputWriter(; model, (; perturbation_norm),; filename = ""NH_BC_jet_pert_norm.nc"",; schedule = TimeInterval(1minutes),; dimensions = (; perturbation_norm = ()),; overwrite_existing = true). run!(simulation); ```. Method 2: evolve total field. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = U(x, y, z); bᵢ(x, y, z) = B(x, y, z) + 0e-6*rand(). b_bc = FieldBoundaryConditions(top = GradientBoundaryCondition(N²), bottom = GradientBoundaryCondition(N²)). model = NonhydrostaticModel(; grid,; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν),; boundary_conditions =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251
https://github.com/CliMA/Oceananigans.jl/issues/3252:811,Modifiability,variab,variably-spaced,811,"There is a mismatch between what the docstring of the `RectilinearGrid` claims for what the metrics (e.g., `Δxᶜᵃᵃ` or `Δxᶠᵃᵃ`) are and what the metrics actually correspond to. The docstring says that, e.g., `Δxᶜᵃᵃ` is the distances between cell centers. I think this is wrong. First of all, this is not uniquely defined as, e.g., the distance between a cell center and the adjacent cell centers may be different on each side of the cell. I believe that `Δxᶜᵃᵃ` is, instead, the length of the corresponding cell that is centered at `caa`, _or equivalently_, is the distances between the adjacent faces of each cell's center. Note that for a regularly-spaced grid what I claim to be correct and what the docstring mentions are equivalent (and possibly this is what lead to the current docstring?). However, for a variably-spaced grid they are not equivalent. Here's an example:. ```julia; julia> Nx = 3; grid = RectilinearGrid(size = Nx, topology = (Bounded, Flat, Flat), x = [0, 1, 2, 10]); 3×1×1 RectilinearGrid{Float64, Bounded, Flat, Flat} on CPU with 3×0×0 halo; ├── Bounded x ∈ [0.0, 10.0] variably spaced with min(Δx)=1.0, max(Δx)=8.0; ├── Flat y; └── Flat z. julia> grid.xᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 0.5; 1.5; 6.0. julia> grid.xᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 0.0; 1.0; 2.0; 10.0. julia> grid.Δxᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 1.0; 1.0; 8.0. julia> grid.Δxᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 1.0; 1.0; 4.5; 8.0; ```. A schematic of the cell faces and centers together with the corresponding values for `Δx` is below:. ```julia; F C F C F C F. xᶠᵃᵃ 0 1 2 10; xᶜᵃᵃ 0.5 1.5 6.0. Δxᶠᵃᵃ 1 1 4.5 8; Δxᶜᵃᵃ 1 1 8; ```. I am pretty sure that what we want is what the code actually does. In this case, what's left to be done is simply to fix the docstring. Am I right?. (P.S.: I stumbled upon this while trying to fill the halos properly for #3239.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3252
https://github.com/CliMA/Oceananigans.jl/issues/3252:1094,Modifiability,variab,variably,1094,"There is a mismatch between what the docstring of the `RectilinearGrid` claims for what the metrics (e.g., `Δxᶜᵃᵃ` or `Δxᶠᵃᵃ`) are and what the metrics actually correspond to. The docstring says that, e.g., `Δxᶜᵃᵃ` is the distances between cell centers. I think this is wrong. First of all, this is not uniquely defined as, e.g., the distance between a cell center and the adjacent cell centers may be different on each side of the cell. I believe that `Δxᶜᵃᵃ` is, instead, the length of the corresponding cell that is centered at `caa`, _or equivalently_, is the distances between the adjacent faces of each cell's center. Note that for a regularly-spaced grid what I claim to be correct and what the docstring mentions are equivalent (and possibly this is what lead to the current docstring?). However, for a variably-spaced grid they are not equivalent. Here's an example:. ```julia; julia> Nx = 3; grid = RectilinearGrid(size = Nx, topology = (Bounded, Flat, Flat), x = [0, 1, 2, 10]); 3×1×1 RectilinearGrid{Float64, Bounded, Flat, Flat} on CPU with 3×0×0 halo; ├── Bounded x ∈ [0.0, 10.0] variably spaced with min(Δx)=1.0, max(Δx)=8.0; ├── Flat y; └── Flat z. julia> grid.xᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 0.5; 1.5; 6.0. julia> grid.xᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 0.0; 1.0; 2.0; 10.0. julia> grid.Δxᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 1.0; 1.0; 8.0. julia> grid.Δxᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 1.0; 1.0; 4.5; 8.0; ```. A schematic of the cell faces and centers together with the corresponding values for `Δx` is below:. ```julia; F C F C F C F. xᶠᵃᵃ 0 1 2 10; xᶜᵃᵃ 0.5 1.5 6.0. Δxᶠᵃᵃ 1 1 4.5 8; Δxᶜᵃᵃ 1 1 8; ```. I am pretty sure that what we want is what the code actually does. In this case, what's left to be done is simply to fix the docstring. Am I right?. (P.S.: I stumbled upon this while trying to fill the halos properly for #3239.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3252
https://github.com/CliMA/Oceananigans.jl/issues/3252:1756,Usability,simpl,simply,1756,"There is a mismatch between what the docstring of the `RectilinearGrid` claims for what the metrics (e.g., `Δxᶜᵃᵃ` or `Δxᶠᵃᵃ`) are and what the metrics actually correspond to. The docstring says that, e.g., `Δxᶜᵃᵃ` is the distances between cell centers. I think this is wrong. First of all, this is not uniquely defined as, e.g., the distance between a cell center and the adjacent cell centers may be different on each side of the cell. I believe that `Δxᶜᵃᵃ` is, instead, the length of the corresponding cell that is centered at `caa`, _or equivalently_, is the distances between the adjacent faces of each cell's center. Note that for a regularly-spaced grid what I claim to be correct and what the docstring mentions are equivalent (and possibly this is what lead to the current docstring?). However, for a variably-spaced grid they are not equivalent. Here's an example:. ```julia; julia> Nx = 3; grid = RectilinearGrid(size = Nx, topology = (Bounded, Flat, Flat), x = [0, 1, 2, 10]); 3×1×1 RectilinearGrid{Float64, Bounded, Flat, Flat} on CPU with 3×0×0 halo; ├── Bounded x ∈ [0.0, 10.0] variably spaced with min(Δx)=1.0, max(Δx)=8.0; ├── Flat y; └── Flat z. julia> grid.xᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 0.5; 1.5; 6.0. julia> grid.xᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 0.0; 1.0; 2.0; 10.0. julia> grid.Δxᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 1.0; 1.0; 8.0. julia> grid.Δxᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 1.0; 1.0; 4.5; 8.0; ```. A schematic of the cell faces and centers together with the corresponding values for `Δx` is below:. ```julia; F C F C F C F. xᶠᵃᵃ 0 1 2 10; xᶜᵃᵃ 0.5 1.5 6.0. Δxᶠᵃᵃ 1 1 4.5 8; Δxᶜᵃᵃ 1 1 8; ```. I am pretty sure that what we want is what the code actually does. In this case, what's left to be done is simply to fix the docstring. Am I right?. (P.S.: I stumbled upon this while trying to fill the halos properly for #3239.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3252
https://github.com/CliMA/Oceananigans.jl/issues/3254:43,Deployability,continuous,continuous,43,"The metrics across panels don't seem to be continuous for a `ConformalCubedSphereGrid`. They seem a bit iffy between non-trivial panel connections (e.g. East->North, etc). See, e.g., below. Panel 1 East -> Panel 2 West seems OK; Panel 2 West -> Panel 4 South the metrics don't seem to coincide. ```Julia; using Oceananigans; using Oceananigans.MultiRegion: getregion; using GLMakie. Nx, Ny = 5, 5; H = 3. range_with_offset(N, H, offset::Int) = (-H + 1 + offset*N):(N + H + offset*N). grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, 1), z = (0, 1), horizontal_direction_halo = H). j_index = 2; i_index = Nx+1 - j_index. fig = Figure(resolution=(2200, 600), fontsize=30); ax = Axis(fig[1, 1]); lines!(ax, range_with_offset(Nx, H, 0), parent(getregion(grid, 1).Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:green, 0.9), label=""panel 1""); lines!(ax, range_with_offset(Nx, H, 1), parent(getregion(grid, 2).Δxᶜᶜᵃ)[:, j_index+H], linewidth=8, color = (:red, 0.5), label=""panel 2""); lines!(ax, range_with_offset(Ny, H, 2), parent(getregion(grid, 4).Δyᶜᶜᵃ)[i_index+H, :], linewidth=4, color = (:blue, 0.5), label=""panel 4""); vlines!(ax, [1, Nx+1, 2Nx+1, 3Nx+1], linewidth=8, color=(:black, 0.3)); fig[1, 2] = Legend(fig, ax, framevisible = false); fig; save(""metrictest.png"", fig); ```. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/9ed5be14-05b9-4f83-81f5-2d92def37ff5). (thanks to @simone-silvestri)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3254
https://github.com/CliMA/Oceananigans.jl/issues/3254:809,Energy Efficiency,green,green,809,"The metrics across panels don't seem to be continuous for a `ConformalCubedSphereGrid`. They seem a bit iffy between non-trivial panel connections (e.g. East->North, etc). See, e.g., below. Panel 1 East -> Panel 2 West seems OK; Panel 2 West -> Panel 4 South the metrics don't seem to coincide. ```Julia; using Oceananigans; using Oceananigans.MultiRegion: getregion; using GLMakie. Nx, Ny = 5, 5; H = 3. range_with_offset(N, H, offset::Int) = (-H + 1 + offset*N):(N + H + offset*N). grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, 1), z = (0, 1), horizontal_direction_halo = H). j_index = 2; i_index = Nx+1 - j_index. fig = Figure(resolution=(2200, 600), fontsize=30); ax = Axis(fig[1, 1]); lines!(ax, range_with_offset(Nx, H, 0), parent(getregion(grid, 1).Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:green, 0.9), label=""panel 1""); lines!(ax, range_with_offset(Nx, H, 1), parent(getregion(grid, 2).Δxᶜᶜᵃ)[:, j_index+H], linewidth=8, color = (:red, 0.5), label=""panel 2""); lines!(ax, range_with_offset(Ny, H, 2), parent(getregion(grid, 4).Δyᶜᶜᵃ)[i_index+H, :], linewidth=4, color = (:blue, 0.5), label=""panel 4""); vlines!(ax, [1, Nx+1, 2Nx+1, 3Nx+1], linewidth=8, color=(:black, 0.3)); fig[1, 2] = Legend(fig, ax, framevisible = false); fig; save(""metrictest.png"", fig); ```. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/9ed5be14-05b9-4f83-81f5-2d92def37ff5). (thanks to @simone-silvestri)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3254
https://github.com/CliMA/Oceananigans.jl/pull/3259:93,Integrability,wrap,wrap,93,"Begs the question of whether this code was tested? When users pass a tuple to `forcings`, we wrap it inside `MultipleForcings`. Thus we need this method to unwrap the tuple when adding advective forcings to the total velocity field. @jagoosw @simone-silvestri . Should we add a test?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259
https://github.com/CliMA/Oceananigans.jl/pull/3259:43,Testability,test,tested,43,"Begs the question of whether this code was tested? When users pass a tuple to `forcings`, we wrap it inside `MultipleForcings`. Thus we need this method to unwrap the tuple when adding advective forcings to the total velocity field. @jagoosw @simone-silvestri . Should we add a test?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259
https://github.com/CliMA/Oceananigans.jl/pull/3259:278,Testability,test,test,278,"Begs the question of whether this code was tested? When users pass a tuple to `forcings`, we wrap it inside `MultipleForcings`. Thus we need this method to unwrap the tuple when adding advective forcings to the total velocity field. @jagoosw @simone-silvestri . Should we add a test?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259
https://github.com/CliMA/Oceananigans.jl/issues/3260:583,Availability,ERROR,ERROR,583,"I stumbled on this trying to save the free surface for a `HydrostaticFreeSurfaceModel`. Here's an example:. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```. ```Julia; ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:245; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:312; [6] #Field#13; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [7] Field; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [8] construct_output(user_output::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260
https://github.com/CliMA/Oceananigans.jl/issues/3260:486,Energy Efficiency,schedul,schedule,486,"I stumbled on this trying to save the free surface for a `HydrostaticFreeSurfaceModel`. Here's an example:. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```. ```Julia; ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:245; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:312; [6] #Field#13; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [7] Field; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [8] construct_output(user_output::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260
https://github.com/CliMA/Oceananigans.jl/issues/3260:3694,Energy Efficiency,schedul,schedule,3694,"angeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, ...; @ Oceananigans.OutputWriters ~/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [9] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{Colon, Colon, Colon}, Bool, HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :T, :S), Tuple{Field{Face, Center, Center, Nothing, ...; @ Oceananigans.OutputWriters ./none:0; [10] iterate; @ ./generator.jl:47 [inlined]; [11] merge(a::NamedTuple{(), Tuple{}}, itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{Colon, Colon, Colon}, Bool, HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers....; @ Base ./namedtuple.jl:303; [12] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{Colon, Colon, Colon}, Bool, HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, ...; @ Base ./namedtuple.jl:123; [13] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :T, :S), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, ....; @ Oceananigans.OutputWriters ~/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:179; [14] top-level scope; @ REPL[10]:1; ```. However, if I include halos in the output everything seems OK... ```Julia; simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; with_halos = true,; filename = ""surface"",; overwrite_existing = true); JLD2OutputWriter scheduled on TimeInterval(3.333 minutes):; ├── filepath: ./surface.jld2; ├── 1 outputs: η; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260
https://github.com/CliMA/Oceananigans.jl/issues/3260:3813,Energy Efficiency,schedul,scheduled,3813,"angeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, ...; @ Oceananigans.OutputWriters ~/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [9] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{Colon, Colon, Colon}, Bool, HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :T, :S), Tuple{Field{Face, Center, Center, Nothing, ...; @ Oceananigans.OutputWriters ./none:0; [10] iterate; @ ./generator.jl:47 [inlined]; [11] merge(a::NamedTuple{(), Tuple{}}, itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{Colon, Colon, Colon}, Bool, HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers....; @ Base ./namedtuple.jl:303; [12] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{Colon, Colon, Colon}, Bool, HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, ...; @ Base ./namedtuple.jl:123; [13] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :T, :S), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, ....; @ Oceananigans.OutputWriters ~/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:179; [14] top-level scope; @ REPL[10]:1; ```. However, if I include halos in the output everything seems OK... ```Julia; simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; with_halos = true,; filename = ""surface"",; overwrite_existing = true); JLD2OutputWriter scheduled on TimeInterval(3.333 minutes):; ├── filepath: ./surface.jld2; ├── 1 outputs: η; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260
https://github.com/CliMA/Oceananigans.jl/issues/3260:614,Security,access,access,614,"I stumbled on this trying to save the free surface for a `HydrostaticFreeSurfaceModel`. Here's an example:. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```. ```Julia; ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:245; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:312; [6] #Field#13; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [7] Field; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [8] construct_output(user_output::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260
https://github.com/CliMA/Oceananigans.jl/pull/3261:402,Energy Efficiency,schedul,schedule,402,"Attempt to close #3260. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```; ```Julia; JLD2OutputWriter scheduled on TimeInterval(3.333 minutes):; ├── filepath: ./surface.jld2; ├── 1 outputs: η; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB; ```. (with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3261
https://github.com/CliMA/Oceananigans.jl/pull/3261:516,Energy Efficiency,schedul,scheduled,516,"Attempt to close #3260. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```; ```Julia; JLD2OutputWriter scheduled on TimeInterval(3.333 minutes):; ├── filepath: ./surface.jld2; ├── 1 outputs: η; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; └── max filesize: Inf YiB; ```. (with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3261
https://github.com/CliMA/Oceananigans.jl/issues/3265:77,Security,validat,validation,77,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265
https://github.com/CliMA/Oceananigans.jl/issues/3265:611,Security,validat,validation,611,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265
https://github.com/CliMA/Oceananigans.jl/issues/3265:785,Security,validat,validation,785,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265
https://github.com/CliMA/Oceananigans.jl/issues/3265:88,Testability,test,tests,88,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265
https://github.com/CliMA/Oceananigans.jl/issues/3265:366,Testability,test,tests,366,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265
https://github.com/CliMA/Oceananigans.jl/issues/3265:397,Testability,test,test,397,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265
https://github.com/CliMA/Oceananigans.jl/issues/3265:518,Testability,test,test,518,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265
https://github.com/CliMA/Oceananigans.jl/issues/3265:544,Testability,test,test,544,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265
https://github.com/CliMA/Oceananigans.jl/pull/3266:221,Testability,test,tests,221,"Some TODOs:. - [ ] Make `set!` work for `Face, Face, Center` fields (eg streamfunctions); - [ ] Make broadcasting work for cubed sphere fields; - [x] Use plotting utilities from Imaginocean. With the above and fixing the tests then I think we are ready to merge. Supersedes #3221; closes #3204",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3266
https://github.com/CliMA/Oceananigans.jl/issues/3267:38,Availability,error,error,38,"Hi all,. I'm stuck trying to debug an error I keep getting when running a non-hydrostatic model on GPU. . It runs for a bit and then throws this error:; ```; ... (loads of similar CUDA stuff that goes on for a very very long time); @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream) ; @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; [19] top-level scope; @ ~/.julia/packages/InteractiveErrors/JOo2y/src/InteractiveErrors.jl:329; [20] eval; @ ./boot.jl:370 [inlined]; [21] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [22] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [23] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOpti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267
https://github.com/CliMA/Oceananigans.jl/issues/3267:145,Availability,error,error,145,"Hi all,. I'm stuck trying to debug an error I keep getting when running a non-hydrostatic model on GPU. . It runs for a bit and then throws this error:; ```; ... (loads of similar CUDA stuff that goes on for a very very long time); @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream) ; @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; [19] top-level scope; @ ~/.julia/packages/InteractiveErrors/JOo2y/src/InteractiveErrors.jl:329; [20] eval; @ ./boot.jl:370 [inlined]; [21] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [22] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [23] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOpti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267
https://github.com/CliMA/Oceananigans.jl/issues/3267:2086,Availability,error,error,2086,"ckend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [31] _start(); @ Base ./client.jl:522; LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267
https://github.com/CliMA/Oceananigans.jl/issues/3267:3769,Availability,error,error,3769,EGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_solver.jl:134; + [inlined]; Oceananigans.Models.NonhydrostaticModels; + calculate_pressure_correction! ~/.julia/packages/Oceananigans/mwXt0/src/Models/NonhydrostaticModels/pressure_correction.jl:15; > Oceananigans.TimeSteppers; v + #time_step!#8 ~/.julia/packages/Oceananigans/mwXt0/src/TimeSteppers/runge_kutta_3.jl:138; Oceananigans.Simulations; + time_step! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:134; + #run!#7 ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:97; + run! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:85; + [top-level]; (system); ```; I can't get the whole error message because its longer than the screen length but this seems to be the relevant bit when using InteractiveErrors. . If I make the grid smaller it gets more iterations done before it errors but is nowhere near using all of the GPUs memory (A100 with 80GB and model is about 2GB when 256x256x64). This is with the latest version of Oceananigans (87.4). I'll try to make an MWE.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267
https://github.com/CliMA/Oceananigans.jl/issues/3267:3961,Availability,error,errors,3961,EGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_solver.jl:134; + [inlined]; Oceananigans.Models.NonhydrostaticModels; + calculate_pressure_correction! ~/.julia/packages/Oceananigans/mwXt0/src/Models/NonhydrostaticModels/pressure_correction.jl:15; > Oceananigans.TimeSteppers; v + #time_step!#8 ~/.julia/packages/Oceananigans/mwXt0/src/TimeSteppers/runge_kutta_3.jl:138; Oceananigans.Simulations; + time_step! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:134; + #run!#7 ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:97; + run! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:85; + [top-level]; (system); ```; I can't get the whole error message because its longer than the screen length but this seems to be the relevant bit when using InteractiveErrors. . If I make the grid smaller it gets more iterations done before it errors but is nowhere near using all of the GPUs memory (A100 with 80GB and model is about 2GB when 256x256x64). This is with the latest version of Oceananigans (87.4). I'll try to make an MWE.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267
https://github.com/CliMA/Oceananigans.jl/issues/3267:3775,Integrability,message,message,3775,EGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_solver.jl:134; + [inlined]; Oceananigans.Models.NonhydrostaticModels; + calculate_pressure_correction! ~/.julia/packages/Oceananigans/mwXt0/src/Models/NonhydrostaticModels/pressure_correction.jl:15; > Oceananigans.TimeSteppers; v + #time_step!#8 ~/.julia/packages/Oceananigans/mwXt0/src/TimeSteppers/runge_kutta_3.jl:138; Oceananigans.Simulations; + time_step! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:134; + #run!#7 ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:97; + run! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:85; + [top-level]; (system); ```; I can't get the whole error message because its longer than the screen length but this seems to be the relevant bit when using InteractiveErrors. . If I make the grid smaller it gets more iterations done before it errors but is nowhere near using all of the GPUs memory (A100 with 80GB and model is about 2GB when 256x256x64). This is with the latest version of Oceananigans (87.4). I'll try to make an MWE.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267
https://github.com/CliMA/Oceananigans.jl/issues/3267:163,Performance,load,loads,163,"Hi all,. I'm stuck trying to debug an error I keep getting when running a non-hydrostatic model on GPU. . It runs for a bit and then throws this error:; ```; ... (loads of similar CUDA stuff that goes on for a very very long time); @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream) ; @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; [19] top-level scope; @ ~/.julia/packages/InteractiveErrors/JOo2y/src/InteractiveErrors.jl:329; [20] eval; @ ./boot.jl:370 [inlined]; [21] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [22] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [23] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOpti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267
https://github.com/CliMA/Oceananigans.jl/issues/3267:2070,Performance,Load,LoadError,2070,"ckend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [31] _start(); @ Base ./client.jl:522; LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267
https://github.com/CliMA/Oceananigans.jl/issues/3267:2111,Security,access,access,2111,"ckend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [31] _start(); @ Base ./client.jl:522; LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267
https://github.com/CliMA/Oceananigans.jl/issues/3269:92,Usability,feedback,feedbacks,92,Hi devs. This is not an issue but more of comment. I will immediately close this after some feedbacks. . I was wondering if Oceananigans in its current form has support for coastal or regional modelling? I ask because my impression is that Oceananigans follows similar paradigm as MITgcm with the latter seemingly used in regional ocean modelling. Are there plans to use the model for such setup? What will it takes for the community to get to such level? . Thanks.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3269
https://github.com/CliMA/Oceananigans.jl/pull/3276:156,Testability,test,tested,156,"This pull request changes the compat entry for the `CUDA` package from `4` to `4, 5`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3276
https://github.com/CliMA/Oceananigans.jl/pull/3276:262,Testability,test,tests,262,"This pull request changes the compat entry for the `CUDA` package from `4` to `4, 5`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3276
https://github.com/CliMA/Oceananigans.jl/pull/3277:19,Testability,test,test,19,"This PR introduces test functions to verify the accurate halo filling at face-face locations of the orthogonal spherical shell grids comprising the six panels of the conformal cubed sphere. Additionally, it provides comments and docstrings for these test functions, thereby closing #3242.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3277
https://github.com/CliMA/Oceananigans.jl/pull/3277:250,Testability,test,test,250,"This PR introduces test functions to verify the accurate halo filling at face-face locations of the orthogonal spherical shell grids comprising the six panels of the conformal cubed sphere. Additionally, it provides comments and docstrings for these test functions, thereby closing #3242.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3277
https://github.com/CliMA/Oceananigans.jl/pull/3279:404,Deployability,configurat,configuration,404,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279
https://github.com/CliMA/Oceananigans.jl/pull/3279:439,Deployability,configurat,configuration,439,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279
https://github.com/CliMA/Oceananigans.jl/pull/3279:335,Integrability,rout,routine,335,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279
https://github.com/CliMA/Oceananigans.jl/pull/3279:404,Modifiability,config,configuration,404,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279
https://github.com/CliMA/Oceananigans.jl/pull/3279:439,Modifiability,config,configuration,439,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279
https://github.com/CliMA/Oceananigans.jl/pull/3279:296,Performance,perform,performed,296,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279
https://github.com/CliMA/Oceananigans.jl/pull/3280:19,Testability,test,test,19,"This PR introduces test functions to verify the accurate halo filling at face-face locations of the orthogonal spherical shell grids comprising the six panels of the conformal cubed sphere. Additionally, it provides comments and docstrings for these test functions, thereby closing #3242.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280
https://github.com/CliMA/Oceananigans.jl/pull/3280:250,Testability,test,test,250,"This PR introduces test functions to verify the accurate halo filling at face-face locations of the orthogonal spherical shell grids comprising the six panels of the conformal cubed sphere. Additionally, it provides comments and docstrings for these test functions, thereby closing #3242.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280
https://github.com/CliMA/Oceananigans.jl/pull/3282:19,Integrability,interface,interface,19,This PR tweaks the interface for `Simulation` to make it easier to build new models. These improvements will help [`ClimaSeaIce` ](https://github.com/CliMA/ClimaSeaIce.jl) implement a new sea ice model that can leverage `Oceananigans.Simulation`. I've also included a few minor miscellaneous improvements to kernel launching + documentation. This PR deletes MEWSVerticalDiffusivity (which nobody used and is not planned to be developed anymore).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3282
https://github.com/CliMA/Oceananigans.jl/issues/3285:312,Integrability,depend,depend,312,"I think it'd be cleaner to change `node` so that `Flat` dimensions are omitted. For example, this would mean that on a grid that is flat in `z` (two-dimensional in `x, y`, we would write initial conditions. ```julia; ui(x, y) = # initial u; set!(model, u=ui); ```. Basically, grids that are `Flat` in `z` cannot depend on `z`. So it would be clearer if initial conditions also did not depend on `z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285
https://github.com/CliMA/Oceananigans.jl/issues/3285:385,Integrability,depend,depend,385,"I think it'd be cleaner to change `node` so that `Flat` dimensions are omitted. For example, this would mean that on a grid that is flat in `z` (two-dimensional in `x, y`, we would write initial conditions. ```julia; ui(x, y) = # initial u; set!(model, u=ui); ```. Basically, grids that are `Flat` in `z` cannot depend on `z`. So it would be clearer if initial conditions also did not depend on `z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285
https://github.com/CliMA/Oceananigans.jl/issues/3285:342,Usability,clear,clearer,342,"I think it'd be cleaner to change `node` so that `Flat` dimensions are omitted. For example, this would mean that on a grid that is flat in `z` (two-dimensional in `x, y`, we would write initial conditions. ```julia; ui(x, y) = # initial u; set!(model, u=ui); ```. Basically, grids that are `Flat` in `z` cannot depend on `z`. So it would be clearer if initial conditions also did not depend on `z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285
https://github.com/CliMA/Oceananigans.jl/issues/3290:4019,Deployability,configurat,configuration,4019,"me = "" * string(prettytime(times[$n])); fig[1, 1:5] = Label(fig, title, fontsize=24, tellwidth=false);. resize_to_layout!(fig); @info ""Animating...""; record(fig, filename * "".mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```. This simulation runs for 10 minutes and then plots this (on a 32x32 grid):. https://github.com/CliMA/Oceananigans.jl/assets/13205162/e4fc9a13-f14f-4c6d-bda6-0d4aae79ac4c. So basically there's a discontinuity in the vertical direction's pressure, which causes an artificial vertical pressure gradient, causing a spurious flow at the top and bottom, even those aren't supposed to be boundaries since the grid is periodic in `z`.; It seems like this comes from the fact that the hydrostatic pressure isn't periodic (since it always comes from a vertical b integral I think), but the nonhydrostatic pressure *is* periodic. This in turn leads the total pressure to have a discontinuity. In fact if we run the exact same configuration but make both the gravitational direction and the periodic direction the `x` direction (code [here](https://pastebin.com/skAB1Bt4)) we have a plume looks and behaves as expected and has no discontinuities:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/97ab7df9-4b64-4f65-9433-4eb9a5e7fe22. I'm not sure if this is something that needs fixing or if it's just a consequence of the hydrostatic decomposition, which always assumes gravity is in the `NegativeZDirection()` and that `z` is `Bounded`. Hence I'm not sure this is better left as an issue or a discussion, so please lmk if I should move this to a discussion. Also, if I run the example above (where gravity is in the `z` direction) using https://github.com/CliMA/Oceananigans.jl/pull/3080, which gets rid of the hydrostatic pressure separation, then I get what I believe to be the correct behavior (all pressures in the animation below are actually total pressure):. https://github.com/CliMA/Oceananigans.jl/assets/13205162/60ef470d-22d7-429a-9029-adb7db5687ba. Whic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290
https://github.com/CliMA/Oceananigans.jl/issues/3290:1409,Energy Efficiency,schedul,schedule,1409,"t wall, and I'm including a bit of noise in the same west wall to kick off a plume. ```julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(topology = (Bounded, Flat, Periodic), size = (16, 16),; x = (0, 1), z = (0, 1)). buoyancy = BuoyancyTracer(); model = NonhydrostaticModel(; grid, tracers = (:b),; buoyancy = buoyancy,; boundary_conditions = (; b = FieldBoundaryConditions(west=FluxBoundaryCondition(5e-9))),);. noise(x, y, z) = 1e-3 * randn() * exp(-(10x)^2/grid.Lx^2); set!(model, u=noise, w=noise). simulation = Simulation(model, Δt=1, stop_time=10minutes);. wizard = TimeStepWizard(cfl=0.8, min_Δt=0.001seconds); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2)). outputs = (; model.tracers.b, model.velocities.u, model.velocities.w,; pHY = model.pressures.pHY′, pNH = model.pressures.pNHS,; p = sum(model.pressures),); output_filename = ""2d-zper""; simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs, ; schedule = TimeInterval(10seconds),; filename = output_filename,; overwrite_existing = true); run!(simulation). @info ""Begin plotting""; using Rasters; filename = simulation.output_writers[:fields].filepath; ds = RasterStack(filename). using GLMakie. set_theme!(Theme(fontsize = 20)); fig = Figure(). kwargs = (xlabel=""x"", ylabel=""z"", height=150, width=250); ax1 = Axis(fig[2, 1]; title = ""w"", kwargs...);; ax2 = Axis(fig[2, 2]; title = ""b"", kwargs...);; ax3 = Axis(fig[2, 3]; title = ""pHY"", kwargs...);; ax4 = Axis(fig[2, 4]; title = ""pNH"", kwargs...);; ax5 = Axis(fig[2, 5]; title = ""total pressure"", kwargs...);. # Next we use `Observable`s to lift the values and plot heatmaps and their colorbars. n = Observable(1). speed_magnitude = 2e-2; using Statistics; temp_magnitude = max(std(ds.b), 1e-12). wₙ = @lift ds.w[Ti=$n, yC=Near(0)]; hm1 = heatmap!(ax1, wₙ; colormap = :balance, colorrange=(-speed_magnitude, speed_magnitude)); Colorbar(fig[3, 1], hm1, vertical=false, height=8, ticklabelsize=14). bₙ = @lift ds.b[Ti=$n,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290
https://github.com/CliMA/Oceananigans.jl/issues/3290:4019,Modifiability,config,configuration,4019,"me = "" * string(prettytime(times[$n])); fig[1, 1:5] = Label(fig, title, fontsize=24, tellwidth=false);. resize_to_layout!(fig); @info ""Animating...""; record(fig, filename * "".mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```. This simulation runs for 10 minutes and then plots this (on a 32x32 grid):. https://github.com/CliMA/Oceananigans.jl/assets/13205162/e4fc9a13-f14f-4c6d-bda6-0d4aae79ac4c. So basically there's a discontinuity in the vertical direction's pressure, which causes an artificial vertical pressure gradient, causing a spurious flow at the top and bottom, even those aren't supposed to be boundaries since the grid is periodic in `z`.; It seems like this comes from the fact that the hydrostatic pressure isn't periodic (since it always comes from a vertical b integral I think), but the nonhydrostatic pressure *is* periodic. This in turn leads the total pressure to have a discontinuity. In fact if we run the exact same configuration but make both the gravitational direction and the periodic direction the `x` direction (code [here](https://pastebin.com/skAB1Bt4)) we have a plume looks and behaves as expected and has no discontinuities:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/97ab7df9-4b64-4f65-9433-4eb9a5e7fe22. I'm not sure if this is something that needs fixing or if it's just a consequence of the hydrostatic decomposition, which always assumes gravity is in the `NegativeZDirection()` and that `z` is `Bounded`. Hence I'm not sure this is better left as an issue or a discussion, so please lmk if I should move this to a discussion. Also, if I run the example above (where gravity is in the `z` direction) using https://github.com/CliMA/Oceananigans.jl/pull/3080, which gets rid of the hydrostatic pressure separation, then I get what I believe to be the correct behavior (all pressures in the animation below are actually total pressure):. https://github.com/CliMA/Oceananigans.jl/assets/13205162/60ef470d-22d7-429a-9029-adb7db5687ba. Whic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290
https://github.com/CliMA/Oceananigans.jl/pull/3293:143,Availability,down,down,143,"This PR propagates the eltype of the ""3D grid"" into the horizontal grid that's used by the FFT-based implicit free surface solver. Should help down the line with one of the issues that cropped up on #3288. @jagoosw",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3293
https://github.com/CliMA/Oceananigans.jl/issues/3295:658,Availability,ERROR,ERROR,658,"```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(; panel_size = (3, 3, 3),; z = (-1, 0),; horizontal_direction_halo = 6); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×3 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 6×6×6 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); ERROR: UndefVarError: `rotation_from_panel_index` not defined; Stacktrace:; [1] with_halo(new_halo::Tuple{Int64, Int64, Int64}, csg::ConformalCubedSphereGrid{Float64, FullyConnected, ....; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/multi_region_cubed_sphere_grid.jl:431; [2] Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver(grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl:47; [3] build_implicit_step_solver(#unused#::Val{:Default}, grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/unified_implicit_free_surface_solver.jl:67; [4] FreeSurface(free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:95; [5] HydrostaticFreeSurfaceModel(; grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:169; [6] top-level scope; @ REPL[63]:1; ```. cc @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3295
https://github.com/CliMA/Oceananigans.jl/pull/3296:240,Availability,ERROR,ERROR,240,"Closes #3295. Before this PR:. ```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(; panel_size = (3, 3, 3), z = (-1, 0));. julia> model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); ERROR: UndefVarError: `rotation_from_panel_index` not defined; Stacktrace:; [1] with_halo(new_halo::Tuple{Int64, Int64, Int64}, csg::ConformalCubedSphereGrid{Float64, FullyConnected, ....; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/multi_region_cubed_sphere_grid.jl:431; [2] Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver(grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl:47; [3] build_implicit_step_solver(#unused#::Val{:Default}, grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/unified_implicit_free_surface_solver.jl:67; [4] FreeSurface(free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:95; [5] HydrostaticFreeSurfaceModel(; grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:169; [6] top-level scope; @ REPL[63]:1; ```. With this PR:. ```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(; panel_size = (3, 3, 3), z = (-1, 0));. julia> model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); HydrostaticFreeSurfaceModel{CPU, MultiRegionGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×3 ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 6×6×6 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3296
https://github.com/CliMA/Oceananigans.jl/issues/3298:326,Availability,avail,available,326,"It's better to use `Field` for boundary conditions rather than `Array` --- this eliminates translation issues when switching architectures (eg CPU, to GPU, to multi-region, to distributed), and also allows diagnostics to be performed directly on the boundary conditions (which isn't always needed, but is very welcome to have available --- for example the spatial derivative of a flux). So, I think we should declare that it's ""best practice"" to use `Field`, not `Array`. To encourage this we should change the docs that show how to use an `Array`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array. to using a `Field`. Also, we should add correctness tests for using `Field`, which has a bug up until #3287. Curious about @simone-silvestri's input because he has used arrays a lot in boundary conditions. Note that we also are working on support for `FieldTimeSeries` as a boundary condition in #3233 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3298
https://github.com/CliMA/Oceananigans.jl/issues/3298:224,Performance,perform,performed,224,"It's better to use `Field` for boundary conditions rather than `Array` --- this eliminates translation issues when switching architectures (eg CPU, to GPU, to multi-region, to distributed), and also allows diagnostics to be performed directly on the boundary conditions (which isn't always needed, but is very welcome to have available --- for example the spatial derivative of a flux). So, I think we should declare that it's ""best practice"" to use `Field`, not `Array`. To encourage this we should change the docs that show how to use an `Array`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array. to using a `Field`. Also, we should add correctness tests for using `Field`, which has a bug up until #3287. Curious about @simone-silvestri's input because he has used arrays a lot in boundary conditions. Note that we also are working on support for `FieldTimeSeries` as a boundary condition in #3233 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3298
https://github.com/CliMA/Oceananigans.jl/issues/3298:780,Testability,test,tests,780,"It's better to use `Field` for boundary conditions rather than `Array` --- this eliminates translation issues when switching architectures (eg CPU, to GPU, to multi-region, to distributed), and also allows diagnostics to be performed directly on the boundary conditions (which isn't always needed, but is very welcome to have available --- for example the spatial derivative of a flux). So, I think we should declare that it's ""best practice"" to use `Field`, not `Array`. To encourage this we should change the docs that show how to use an `Array`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array. to using a `Field`. Also, we should add correctness tests for using `Field`, which has a bug up until #3287. Curious about @simone-silvestri's input because he has used arrays a lot in boundary conditions. Note that we also are working on support for `FieldTimeSeries` as a boundary condition in #3233 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3298
https://github.com/CliMA/Oceananigans.jl/issues/3301:1511,Integrability,interface,interface,1511,"The user API is currently inconsistent: sometimes users identify parameters (and of course model properties) with English names like `thermal_expansion`. https://github.com/CliMA/Oceananigans.jl/blob/2a7d2a1644997a6400bac41a88a7f6879d93d23d/src/BuoyancyModels/linear_equation_of_state.jl#L18. or `gravitational acceleration`,. https://github.com/CliMA/Oceananigans.jl/blob/2a7d2a1644997a6400bac41a88a7f6879d93d23d/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl#L21. but other times, users identify parameters with mathematical symbols like `ν`,. https://github.com/CliMA/Oceananigans.jl/blob/2a7d2a1644997a6400bac41a88a7f6879d93d23d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L12-L18. or `f₀`:. https://github.com/CliMA/Oceananigans.jl/blob/2a7d2a1644997a6400bac41a88a7f6879d93d23d/src/Coriolis/beta_plane.jl#L14-L15. I think we have basically decided that English names are preferred. But the ""legacy API"" is still around. `BetaPlane` is not even internally consistent: it asks for `rotation_rate` and `radius`, as well as `f₀` and `β`. Should we fix the issue? This would of course be a huge breaking change. But in that case, we should do it sooner rather than later. Sometimes this may not make sense --- I think colloquially it is more common to say ""`β`"" than ""planetary vorticity gradient"". Sometimes, the mathematical symbols has _become_ the English name. But many other times it does: we typically say ""viscosity"" rather than ""`ν`"". The ""legacy"" interface will become more and more prominent as we build out the ecosystem into ClimaOcean and ClimaSeaIce, where (hopefully) we will be using English names for everything. (Hopefully also OceanBiome is on the same page here.) Consistency helps us understand each other.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3301
https://github.com/CliMA/Oceananigans.jl/pull/3302:239,Availability,error,errors,239,"This PR introduces a new steady-state test case tailored for the cubed sphere. It initializes surface elevation and velocities using a steady-state solution, aiming to study the temporal evolution arising from the numerical discretization errors. Smooth spatial and temporal error increments are expected. However, if the errors escalate at an unprecedented rate between panels with non-trivial connectivities, it indicates a potential bug, such as improperly filled halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302
https://github.com/CliMA/Oceananigans.jl/pull/3302:275,Availability,error,error,275,"This PR introduces a new steady-state test case tailored for the cubed sphere. It initializes surface elevation and velocities using a steady-state solution, aiming to study the temporal evolution arising from the numerical discretization errors. Smooth spatial and temporal error increments are expected. However, if the errors escalate at an unprecedented rate between panels with non-trivial connectivities, it indicates a potential bug, such as improperly filled halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302
https://github.com/CliMA/Oceananigans.jl/pull/3302:322,Availability,error,errors,322,"This PR introduces a new steady-state test case tailored for the cubed sphere. It initializes surface elevation and velocities using a steady-state solution, aiming to study the temporal evolution arising from the numerical discretization errors. Smooth spatial and temporal error increments are expected. However, if the errors escalate at an unprecedented rate between panels with non-trivial connectivities, it indicates a potential bug, such as improperly filled halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302
https://github.com/CliMA/Oceananigans.jl/pull/3302:38,Testability,test,test,38,"This PR introduces a new steady-state test case tailored for the cubed sphere. It initializes surface elevation and velocities using a steady-state solution, aiming to study the temporal evolution arising from the numerical discretization errors. Smooth spatial and temporal error increments are expected. However, if the errors escalate at an unprecedented rate between panels with non-trivial connectivities, it indicates a potential bug, such as improperly filled halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302
https://github.com/CliMA/Oceananigans.jl/issues/3307:165,Availability,ERROR,ERROR,165,"We _do_ check that intervals are increasing:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=2, z=(0, -1), topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=(0, -1) should be an increasing interval.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Tuple{Int64, Int64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:73; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[4]:1; ```. However, if we use explicit interfaces rather than an interval, the constructor seems to be happy:. ```julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. This grid is invalid but was able to be constructed. We should check that and throw an appropriate error so users don't get confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3307
https://github.com/CliMA/Oceananigans.jl/issues/3307:1895,Availability,error,error,1895,"We _do_ check that intervals are increasing:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=2, z=(0, -1), topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=(0, -1) should be an increasing interval.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Tuple{Int64, Int64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:73; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[4]:1; ```. However, if we use explicit interfaces rather than an interval, the constructor seems to be happy:. ```julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. This grid is invalid but was able to be constructed. We should check that and throw an appropriate error so users don't get confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3307
https://github.com/CliMA/Oceananigans.jl/issues/3307:1444,Integrability,interface,interfaces,1444,"We _do_ check that intervals are increasing:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=2, z=(0, -1), topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=(0, -1) should be an increasing interval.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Tuple{Int64, Int64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:73; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[4]:1; ```. However, if we use explicit interfaces rather than an interval, the constructor seems to be happy:. ```julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. This grid is invalid but was able to be constructed. We should check that and throw an appropriate error so users don't get confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3307
https://github.com/CliMA/Oceananigans.jl/issues/3307:1742,Modifiability,variab,variably,1742,"We _do_ check that intervals are increasing:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=2, z=(0, -1), topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=(0, -1) should be an increasing interval.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Tuple{Int64, Int64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:73; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[4]:1; ```. However, if we use explicit interfaces rather than an interval, the constructor seems to be happy:. ```julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. This grid is invalid but was able to be constructed. We should check that and throw an appropriate error so users don't get confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3307
https://github.com/CliMA/Oceananigans.jl/pull/3308:121,Deployability,configurat,configuration,121,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308
https://github.com/CliMA/Oceananigans.jl/pull/3308:315,Deployability,configurat,configuration,315,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308
https://github.com/CliMA/Oceananigans.jl/pull/3308:373,Deployability,configurat,configuration,373,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308
https://github.com/CliMA/Oceananigans.jl/pull/3308:121,Modifiability,config,configuration,121,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308
https://github.com/CliMA/Oceananigans.jl/pull/3308:315,Modifiability,config,configuration,315,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308
https://github.com/CliMA/Oceananigans.jl/pull/3308:373,Modifiability,config,configuration,373,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308
https://github.com/CliMA/Oceananigans.jl/pull/3308:1193,Modifiability,refactor,refactoring,1193,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308
https://github.com/CliMA/Oceananigans.jl/pull/3308:36,Usability,clear,clearly,36,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308
https://github.com/CliMA/Oceananigans.jl/issues/3309:63,Deployability,release,releases,63,"See, e.g., at https://github.com/Alexander-Barth/NCDatasets.jl/releases/tag/v0.13.0. Does anything of the above affect us? Should we take care before upgrading?. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3309
https://github.com/CliMA/Oceananigans.jl/issues/3312:31,Integrability,message,message,31,Could be convenient to print a message about the expected total size of output files and throw a warning if they're gonna be huge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312
https://github.com/CliMA/Oceananigans.jl/pull/3313:108,Deployability,release,releases,108,Closes #3309 . Breaking changes for 0.13 are listed here:. https://github.com/Alexander-Barth/NCDatasets.jl/releases/tag/v0.13.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3313
https://github.com/CliMA/Oceananigans.jl/issues/3318:1286,Availability,error,error,1286,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318
https://github.com/CliMA/Oceananigans.jl/issues/3318:1034,Modifiability,extend,extend,1034,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318
https://github.com/CliMA/Oceananigans.jl/issues/3318:198,Security,validat,validation,198,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318
https://github.com/CliMA/Oceananigans.jl/issues/3318:379,Security,validat,validation,379,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318
https://github.com/CliMA/Oceananigans.jl/issues/3318:912,Security,validat,validation,912,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318
https://github.com/CliMA/Oceananigans.jl/issues/3318:1599,Usability,simpl,simply,1599,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318
https://github.com/CliMA/Oceananigans.jl/pull/3319:42,Availability,error,error,42,"Before this PR, the following would *NOT* error:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. After this PR:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:109; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Vector{Float64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[13]:1; ```. ```; julia> grid = LatitudeLongitudeGrid(size=(2, 2, 2), longitude=(-20, 20), latitude=(10, 20), z=[0, -0.5, -1], topology=(Bounded, Bounded, Bounded)). ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319
https://github.com/CliMA/Oceananigans.jl/pull/3319:444,Availability,ERROR,ERROR,444,"Before this PR, the following would *NOT* error:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. After this PR:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:109; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Vector{Float64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[13]:1; ```. ```; julia> grid = LatitudeLongitudeGrid(size=(2, 2, 2), longitude=(-20, 20), latitude=(10, 20), z=[0, -0.5, -1], topology=(Bounded, Bounded, Bounded)). ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319
https://github.com/CliMA/Oceananigans.jl/pull/3319:1758,Availability,ERROR,ERROR,1758,"::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Vector{Float64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[13]:1; ```. ```; julia> grid = LatitudeLongitudeGrid(size=(2, 2, 2), longitude=(-20, 20), latitude=(10, 20), z=[0, -0.5, -1], topology=(Bounded, Bounded, Bounded)). ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:109; [2] validate_lat_lon_grid_args(FT::Type, latitude::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, z::Vector{Float64}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/latitude_longitude_grid.jl:272; [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Vector{Float64}, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/latitude_longitude_grid.jl:189; [4] LatitudeLongitudeGrid; @ ~/Research/OC6.jl/sr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319
https://github.com/CliMA/Oceananigans.jl/pull/3319:276,Modifiability,variab,variably,276,"Before this PR, the following would *NOT* error:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. After this PR:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:109; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Vector{Float64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[13]:1; ```. ```; julia> grid = LatitudeLongitudeGrid(size=(2, 2, 2), longitude=(-20, 20), latitude=(10, 20), z=[0, -0.5, -1], topology=(Bounded, Bounded, Bounded)). ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319
https://github.com/CliMA/Oceananigans.jl/issues/3320:78,Availability,error,error,78,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:307,Availability,error,error,307,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:1884,Availability,error,errors,1884,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:226,Safety,abort,abort,226,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:71,Security,access,access,71,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:300,Security,access,access,300,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:1877,Security,access,access,1877,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:1405,Testability,log,log,1405,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:1473,Testability,log,log,1473,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:1501,Testability,Test,Test,1501,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3320:1572,Testability,Test,Tested,1572,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320
https://github.com/CliMA/Oceananigans.jl/issues/3322:91,Deployability,deploy,deployed,91,I think the [docs](https://clima.github.io/OceananigansDocumentation/stable/) aren't being deployed correctly:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/80a31792-411f-4162-a4e2-d06a9757c86a),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3322
https://github.com/CliMA/Oceananigans.jl/pull/3323:418,Availability,error,error,418,"There is a bug when trying to auto add bgc tracers when a user has specified a namedtuple of tracers. @glwagner I recall discussing dropping support for auto adding tracers, I find it quite useful but can't remember where we landed. . This PR:; - fixes an issue with auto adding bgc tracers; - fixes an issue with auxiliary field dependant forcing in hydrostatic free surface models and boundary conditions; - adds an error when a user tries to define a forcing or functional boundary condition which depends on a field not found in the model, previously this would just raise a mysterious error like the one in https://github.com/OceanBioME/OceanBioME.jl/pull/146#issuecomment-1755771558",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323
https://github.com/CliMA/Oceananigans.jl/pull/3323:590,Availability,error,error,590,"There is a bug when trying to auto add bgc tracers when a user has specified a namedtuple of tracers. @glwagner I recall discussing dropping support for auto adding tracers, I find it quite useful but can't remember where we landed. . This PR:; - fixes an issue with auto adding bgc tracers; - fixes an issue with auxiliary field dependant forcing in hydrostatic free surface models and boundary conditions; - adds an error when a user tries to define a forcing or functional boundary condition which depends on a field not found in the model, previously this would just raise a mysterious error like the one in https://github.com/OceanBioME/OceanBioME.jl/pull/146#issuecomment-1755771558",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323
https://github.com/CliMA/Oceananigans.jl/pull/3323:330,Integrability,depend,dependant,330,"There is a bug when trying to auto add bgc tracers when a user has specified a namedtuple of tracers. @glwagner I recall discussing dropping support for auto adding tracers, I find it quite useful but can't remember where we landed. . This PR:; - fixes an issue with auto adding bgc tracers; - fixes an issue with auxiliary field dependant forcing in hydrostatic free surface models and boundary conditions; - adds an error when a user tries to define a forcing or functional boundary condition which depends on a field not found in the model, previously this would just raise a mysterious error like the one in https://github.com/OceanBioME/OceanBioME.jl/pull/146#issuecomment-1755771558",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323
https://github.com/CliMA/Oceananigans.jl/pull/3323:501,Integrability,depend,depends,501,"There is a bug when trying to auto add bgc tracers when a user has specified a namedtuple of tracers. @glwagner I recall discussing dropping support for auto adding tracers, I find it quite useful but can't remember where we landed. . This PR:; - fixes an issue with auto adding bgc tracers; - fixes an issue with auxiliary field dependant forcing in hydrostatic free surface models and boundary conditions; - adds an error when a user tries to define a forcing or functional boundary condition which depends on a field not found in the model, previously this would just raise a mysterious error like the one in https://github.com/OceanBioME/OceanBioME.jl/pull/146#issuecomment-1755771558",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323
https://github.com/CliMA/Oceananigans.jl/pull/3324:482,Security,validat,validation,482,This PR adds tests for Face-Face halo filling and ensures that the `fill_halo_regions!` for Face-Face fields are done correctly. After this PR a `fill_halo_regions!` works on a Face-Face field on a `ConformalCubedSphereGrid` **with the exception** of the 2 corner points that belong in the halo regions and _do not_ correspond to any interior point!. If those corner points are filled manually. https://github.com/CliMA/Oceananigans.jl/blob/b0ff6c4874355ec69208f437be4f46fc8935f3d7/validation/multi_region/cubed_sphere_tracer_advection.jl#L32-L53. Then everything seems fine. (This is of course not a final solution but I wanted to make a note here.). (work done with @siddharthabishnu),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3324
https://github.com/CliMA/Oceananigans.jl/pull/3324:13,Testability,test,tests,13,This PR adds tests for Face-Face halo filling and ensures that the `fill_halo_regions!` for Face-Face fields are done correctly. After this PR a `fill_halo_regions!` works on a Face-Face field on a `ConformalCubedSphereGrid` **with the exception** of the 2 corner points that belong in the halo regions and _do not_ correspond to any interior point!. If those corner points are filled manually. https://github.com/CliMA/Oceananigans.jl/blob/b0ff6c4874355ec69208f437be4f46fc8935f3d7/validation/multi_region/cubed_sphere_tracer_advection.jl#L32-L53. Then everything seems fine. (This is of course not a final solution but I wanted to make a note here.). (work done with @siddharthabishnu),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3324
https://github.com/CliMA/Oceananigans.jl/pull/3328:8,Energy Efficiency,adapt,adapts,8,This PR adapts the hydrostatic regression tests to be run in distributed mode. an important step in this direction is to allow array partitioning under the hood in `set!` if the array size coincides with the global size of the field (implemented here). a more important step is to remove the topology from the `Distributed` architecture (it should not know anything about topology which is a grid property),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328
https://github.com/CliMA/Oceananigans.jl/pull/3328:8,Modifiability,adapt,adapts,8,This PR adapts the hydrostatic regression tests to be run in distributed mode. an important step in this direction is to allow array partitioning under the hood in `set!` if the array size coincides with the global size of the field (implemented here). a more important step is to remove the topology from the `Distributed` architecture (it should not know anything about topology which is a grid property),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328
https://github.com/CliMA/Oceananigans.jl/pull/3328:42,Testability,test,tests,42,This PR adapts the hydrostatic regression tests to be run in distributed mode. an important step in this direction is to allow array partitioning under the hood in `set!` if the array size coincides with the global size of the field (implemented here). a more important step is to remove the topology from the `Distributed` architecture (it should not know anything about topology which is a grid property),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328
https://github.com/CliMA/Oceananigans.jl/pull/3330:177,Testability,test,tested,177,"This pull request changes the compat entry for the `NCDatasets` package from `0.12.10` to `0.12.10, 0.13`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3330
https://github.com/CliMA/Oceananigans.jl/pull/3330:283,Testability,test,tests,283,"This pull request changes the compat entry for the `NCDatasets` package from `0.12.10` to `0.12.10, 0.13`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3330
https://github.com/CliMA/Oceananigans.jl/pull/3331:217,Availability,error,error,217,"This PR builds on #3319 to give a slightly more accurate message that checks if a coordinate is sorted (thus checking all values of a coordinate, rather than merely the end points). . I also moved the location of the error message. Possibly we should remove some of the error messages, @navidcy can you advise?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331
https://github.com/CliMA/Oceananigans.jl/pull/3331:270,Availability,error,error,270,"This PR builds on #3319 to give a slightly more accurate message that checks if a coordinate is sorted (thus checking all values of a coordinate, rather than merely the end points). . I also moved the location of the error message. Possibly we should remove some of the error messages, @navidcy can you advise?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331
https://github.com/CliMA/Oceananigans.jl/pull/3331:57,Integrability,message,message,57,"This PR builds on #3319 to give a slightly more accurate message that checks if a coordinate is sorted (thus checking all values of a coordinate, rather than merely the end points). . I also moved the location of the error message. Possibly we should remove some of the error messages, @navidcy can you advise?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331
https://github.com/CliMA/Oceananigans.jl/pull/3331:223,Integrability,message,message,223,"This PR builds on #3319 to give a slightly more accurate message that checks if a coordinate is sorted (thus checking all values of a coordinate, rather than merely the end points). . I also moved the location of the error message. Possibly we should remove some of the error messages, @navidcy can you advise?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331
https://github.com/CliMA/Oceananigans.jl/pull/3331:276,Integrability,message,messages,276,"This PR builds on #3319 to give a slightly more accurate message that checks if a coordinate is sorted (thus checking all values of a coordinate, rather than merely the end points). . I also moved the location of the error message. Possibly we should remove some of the error messages, @navidcy can you advise?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331
https://github.com/CliMA/Oceananigans.jl/issues/3335:19,Testability,test,tests,19,We need regression tests for `SplitExplicitFreeSurface` on serial and distributed architectures. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3335
https://github.com/CliMA/Oceananigans.jl/issues/3337:40,Energy Efficiency,reduce,reduce,40,"Reductions over all dimensions (eg that reduce to a scalar, like `maximum(u)`) on `Field`s that are distributed across many ranks should trigger a global reduction across all workers. A second question is, when this feature is implemented, how will we support ""only local"" reductions? (One may still want to know what `maximum(u)` is on a given worker. For that, we may need things like `local_maximum`, etc.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3337
https://github.com/CliMA/Oceananigans.jl/pull/3338:82,Testability,test,tests,82,"The code should allow all types of partitioning but there is a bug preventing the tests from passing for y- and xy-partitions. This PR aims to fix the bug (and consequently add the excluded y- and xy-partitioning tests) . rework `fill_halo_regions!` to split out non-communicating and communicating boundary conditions such that the latter are executed alone. . To give an example, for ; ```julia ; julia> boundary_conditions = FieldBoundaryConditions(west = NoFluxBoundaryCondition(), east = NoFluxBoundaryCondition(), south = ImpenetrableBoundaryCondition(), north = DistributedCommunicationBoundaryCondition(), bottom = nothing, top = nothing); Oceananigans.FieldBoundaryConditions, with boundary conditions; ├── west: FluxBoundaryCondition: Nothing; ├── east: FluxBoundaryCondition: Nothing; ├── south: OpenBoundaryCondition: Nothing; ├── north: DistributedBoundaryCondition: Nothing; ├── bottom: Nothing; ├── top: Nothing; └── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ```. in main:; ```julia; julia> halo_tuple = permute_boundary_conditions(boundary_conditions);. julia> for i in 1:length(halo_tuple[1]); @info ""operation $(halo_tuple[1][i]) with bcs $((halo_tuple[2][i], halo_tuple[3][i]))""; end; [ Info: operation fill_bottom_and_top_halo! with bcs (nothing, nothing); [ Info: operation fill_west_and_east_halo! with bcs (FluxBoundaryCondition: Nothing, FluxBoundaryCondition: Nothing); [ Info: operation fill_south_and_north_halo! with bcs (OpenBoundaryCondition: Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.DistributedCommunication, Nothing}); ```. in this PR; ```julia; julia> halo_tuple = permute_boundary_conditions(boundary_conditions);. julia> for i in 1:length(halo_tuple[1]); @info ""operation $(halo_tuple[1][i]) with bcs $(halo_tuple[2][i])""; end; [ Info: operation fill_bottom_and_top_halo! with bcs (nothing, nothing); [ Info: operation fill_south_halo! with bcs (OpenBoundaryCondition: Nothing,); [ Info: operation fill_west_and_east_halo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338
https://github.com/CliMA/Oceananigans.jl/pull/3338:213,Testability,test,tests,213,"The code should allow all types of partitioning but there is a bug preventing the tests from passing for y- and xy-partitions. This PR aims to fix the bug (and consequently add the excluded y- and xy-partitioning tests) . rework `fill_halo_regions!` to split out non-communicating and communicating boundary conditions such that the latter are executed alone. . To give an example, for ; ```julia ; julia> boundary_conditions = FieldBoundaryConditions(west = NoFluxBoundaryCondition(), east = NoFluxBoundaryCondition(), south = ImpenetrableBoundaryCondition(), north = DistributedCommunicationBoundaryCondition(), bottom = nothing, top = nothing); Oceananigans.FieldBoundaryConditions, with boundary conditions; ├── west: FluxBoundaryCondition: Nothing; ├── east: FluxBoundaryCondition: Nothing; ├── south: OpenBoundaryCondition: Nothing; ├── north: DistributedBoundaryCondition: Nothing; ├── bottom: Nothing; ├── top: Nothing; └── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ```. in main:; ```julia; julia> halo_tuple = permute_boundary_conditions(boundary_conditions);. julia> for i in 1:length(halo_tuple[1]); @info ""operation $(halo_tuple[1][i]) with bcs $((halo_tuple[2][i], halo_tuple[3][i]))""; end; [ Info: operation fill_bottom_and_top_halo! with bcs (nothing, nothing); [ Info: operation fill_west_and_east_halo! with bcs (FluxBoundaryCondition: Nothing, FluxBoundaryCondition: Nothing); [ Info: operation fill_south_and_north_halo! with bcs (OpenBoundaryCondition: Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.DistributedCommunication, Nothing}); ```. in this PR; ```julia; julia> halo_tuple = permute_boundary_conditions(boundary_conditions);. julia> for i in 1:length(halo_tuple[1]); @info ""operation $(halo_tuple[1][i]) with bcs $(halo_tuple[2][i])""; end; [ Info: operation fill_bottom_and_top_halo! with bcs (nothing, nothing); [ Info: operation fill_south_halo! with bcs (OpenBoundaryCondition: Nothing,); [ Info: operation fill_west_and_east_halo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338
https://github.com/CliMA/Oceananigans.jl/pull/3339:125,Modifiability,extend,extends,125,"This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm. This PR also extends the tests to include non-uniform distributed partitioning . The proposal of this PR (up to discussion and tweaking) is to allow calling; ```julia; arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); ```; which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339
https://github.com/CliMA/Oceananigans.jl/pull/3339:137,Testability,test,tests,137,"This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm. This PR also extends the tests to include non-uniform distributed partitioning . The proposal of this PR (up to discussion and tweaking) is to allow calling; ```julia; arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); ```; which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339
https://github.com/CliMA/Oceananigans.jl/pull/3339:26,Usability,simpl,simplify,26,"This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm. This PR also extends the tests to include non-uniform distributed partitioning . The proposal of this PR (up to discussion and tweaking) is to allow calling; ```julia; arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); ```; which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339
https://github.com/CliMA/Oceananigans.jl/pull/3341:223,Modifiability,refactor,refactors,223,"This PR defines and exports ""WENO"" `VectorInvariant`, which is a convenience constructor for `VectorInvariant` wherein the vorticity, divergence, and vertical schemes are all WENO. It also defines the proper type alias and refactors the code to make it slightly more readable.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341
https://github.com/CliMA/Oceananigans.jl/issues/3342:785,Testability,log,logic,785,"At the moment, the fill halo regions follow a particular ordering where. Flux, Value, Gradient > Periodic; Periodic > Halo Communication. where > indicates the priority of execution.; We also fill the two sides of one direction together. ; This execution order cannot be respected in case:; ```julia; bc.west isa Periodic; bc.east isa Periodic; bc.south isa Flux; bc.north isa DistributedCommunication; ```. The possible solutions are two:; - eliminate the order requirements between Flux, Value, Gradient and Periodic by including corners in all local `fill_halo_regions!` (at the moment only `Periodic` fills the corners); - do not fill two sides together. probably the first solution is better because it leads to simpler code both in terms of actual implementation and in terms of logic of execution",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3342
https://github.com/CliMA/Oceananigans.jl/issues/3342:717,Usability,simpl,simpler,717,"At the moment, the fill halo regions follow a particular ordering where. Flux, Value, Gradient > Periodic; Periodic > Halo Communication. where > indicates the priority of execution.; We also fill the two sides of one direction together. ; This execution order cannot be respected in case:; ```julia; bc.west isa Periodic; bc.east isa Periodic; bc.south isa Flux; bc.north isa DistributedCommunication; ```. The possible solutions are two:; - eliminate the order requirements between Flux, Value, Gradient and Periodic by including corners in all local `fill_halo_regions!` (at the moment only `Periodic` fills the corners); - do not fill two sides together. probably the first solution is better because it leads to simpler code both in terms of actual implementation and in terms of logic of execution",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3342
https://github.com/CliMA/Oceananigans.jl/issues/3346:11,Testability,test,test,11,"The simple test code from @christophernhill, now successfully differentiating!. Not sure what the correct answer should be, so someone should check this. This probably makes sense to add a test somewhere at least, and also can be used as a starting point for future development. ```julia; using Enzyme; using Oceananigans; using KernelAbstractions: @index, @kernel; using Oceananigans.Utils: launch!; using Oceananigans.Architectures: device. using EnzymeCore. EnzymeCore.EnzymeRules.inactive_type(::Type{<:Oceananigans.Grids.AbstractGrid}) = true. arch=CPU(); FT=Float64. N = 100; topo = (Periodic, Flat, Flat); grid = RectilinearGrid(arch, FT, topology=topo, size=(N), halo=2, x=(-1, 1), y=(-1, 1), z=(-1, 1)). function del21d!(d2buf,fld::Field); g = fld.grid; Nx = g.Nx; for i=1:Nx; d2buf[i] = fld[i-1,1,1]+fld[i+1,1,1]-2fld[i,1,1]; end; return; end. @kernel function del21d_k!(d2buf_k,fld); i,j,k = @index(Global,NTuple); @inbounds d2buf_k[i,j,k] = fld[i-1,j,k]+fld[i+1,j,k]-2fld[i,j,k]; end. # 2. halo; function halo1d!(fld::Field); g = fld.grid; Hx = g.Hx; Nx = g.Nx; for i=1:Hx; fld[i-Hx,1,1]=fld[Nx-Hx+i,1,1]; fld[Nx+i,1,1]=fld[i ,1,1]; end; return nothing; end. # 3. simple model; function diffuse1d_model!(jcost,fld); grid=fld.grid; d2buf=ones(grid.Nx); arch=grid.architecture; d2buf_k = CenterField(grid); k=1.0; dt=0.1; nsteps=50; for i in 1:nsteps; del21d!(d2buf,fld); ### kernel style; event=launch!(arch,grid,:xyz,del21d_k!,d2buf_k,fld); for j in 1:fld.grid.Nx; d2buf[i] = d2buf_k[i]; end; for j in 1:fld.grid.Nx; fld[j,1,1] = fld[j,1,1] + k*d2buf[j]*dt; end; halo1d!(fld); end; jcost[1]=fld[15,1,1].*fld[15,1,1]; return nothing; end. c = CenterField(grid); c2 = CenterField(grid); f(x, y, z) = exp( -50((x-grid.xᶠᵃᵃ[1])/grid.Lx-0.5)^2 ); set!(c,f); halo1d!(c); set!(c2,f); halo1d!(c2); j=[0.]; diffuse1d_model!(j,c). bc=CenterField(grid); set!(c,f); set!(bc,0); j=[0.]; bj=[1.]; autodiff(Reverse, diffuse1d_model!,Duplicated(j,bj), Duplicated(c,bc) ). @show bj; @show bc; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3346
https://github.com/CliMA/Oceananigans.jl/issues/3346:189,Testability,test,test,189,"The simple test code from @christophernhill, now successfully differentiating!. Not sure what the correct answer should be, so someone should check this. This probably makes sense to add a test somewhere at least, and also can be used as a starting point for future development. ```julia; using Enzyme; using Oceananigans; using KernelAbstractions: @index, @kernel; using Oceananigans.Utils: launch!; using Oceananigans.Architectures: device. using EnzymeCore. EnzymeCore.EnzymeRules.inactive_type(::Type{<:Oceananigans.Grids.AbstractGrid}) = true. arch=CPU(); FT=Float64. N = 100; topo = (Periodic, Flat, Flat); grid = RectilinearGrid(arch, FT, topology=topo, size=(N), halo=2, x=(-1, 1), y=(-1, 1), z=(-1, 1)). function del21d!(d2buf,fld::Field); g = fld.grid; Nx = g.Nx; for i=1:Nx; d2buf[i] = fld[i-1,1,1]+fld[i+1,1,1]-2fld[i,1,1]; end; return; end. @kernel function del21d_k!(d2buf_k,fld); i,j,k = @index(Global,NTuple); @inbounds d2buf_k[i,j,k] = fld[i-1,j,k]+fld[i+1,j,k]-2fld[i,j,k]; end. # 2. halo; function halo1d!(fld::Field); g = fld.grid; Hx = g.Hx; Nx = g.Nx; for i=1:Hx; fld[i-Hx,1,1]=fld[Nx-Hx+i,1,1]; fld[Nx+i,1,1]=fld[i ,1,1]; end; return nothing; end. # 3. simple model; function diffuse1d_model!(jcost,fld); grid=fld.grid; d2buf=ones(grid.Nx); arch=grid.architecture; d2buf_k = CenterField(grid); k=1.0; dt=0.1; nsteps=50; for i in 1:nsteps; del21d!(d2buf,fld); ### kernel style; event=launch!(arch,grid,:xyz,del21d_k!,d2buf_k,fld); for j in 1:fld.grid.Nx; d2buf[i] = d2buf_k[i]; end; for j in 1:fld.grid.Nx; fld[j,1,1] = fld[j,1,1] + k*d2buf[j]*dt; end; halo1d!(fld); end; jcost[1]=fld[15,1,1].*fld[15,1,1]; return nothing; end. c = CenterField(grid); c2 = CenterField(grid); f(x, y, z) = exp( -50((x-grid.xᶠᵃᵃ[1])/grid.Lx-0.5)^2 ); set!(c,f); halo1d!(c); set!(c2,f); halo1d!(c2); j=[0.]; diffuse1d_model!(j,c). bc=CenterField(grid); set!(c,f); set!(bc,0); j=[0.]; bj=[1.]; autodiff(Reverse, diffuse1d_model!,Duplicated(j,bj), Duplicated(c,bc) ). @show bj; @show bc; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3346
https://github.com/CliMA/Oceananigans.jl/issues/3346:4,Usability,simpl,simple,4,"The simple test code from @christophernhill, now successfully differentiating!. Not sure what the correct answer should be, so someone should check this. This probably makes sense to add a test somewhere at least, and also can be used as a starting point for future development. ```julia; using Enzyme; using Oceananigans; using KernelAbstractions: @index, @kernel; using Oceananigans.Utils: launch!; using Oceananigans.Architectures: device. using EnzymeCore. EnzymeCore.EnzymeRules.inactive_type(::Type{<:Oceananigans.Grids.AbstractGrid}) = true. arch=CPU(); FT=Float64. N = 100; topo = (Periodic, Flat, Flat); grid = RectilinearGrid(arch, FT, topology=topo, size=(N), halo=2, x=(-1, 1), y=(-1, 1), z=(-1, 1)). function del21d!(d2buf,fld::Field); g = fld.grid; Nx = g.Nx; for i=1:Nx; d2buf[i] = fld[i-1,1,1]+fld[i+1,1,1]-2fld[i,1,1]; end; return; end. @kernel function del21d_k!(d2buf_k,fld); i,j,k = @index(Global,NTuple); @inbounds d2buf_k[i,j,k] = fld[i-1,j,k]+fld[i+1,j,k]-2fld[i,j,k]; end. # 2. halo; function halo1d!(fld::Field); g = fld.grid; Hx = g.Hx; Nx = g.Nx; for i=1:Hx; fld[i-Hx,1,1]=fld[Nx-Hx+i,1,1]; fld[Nx+i,1,1]=fld[i ,1,1]; end; return nothing; end. # 3. simple model; function diffuse1d_model!(jcost,fld); grid=fld.grid; d2buf=ones(grid.Nx); arch=grid.architecture; d2buf_k = CenterField(grid); k=1.0; dt=0.1; nsteps=50; for i in 1:nsteps; del21d!(d2buf,fld); ### kernel style; event=launch!(arch,grid,:xyz,del21d_k!,d2buf_k,fld); for j in 1:fld.grid.Nx; d2buf[i] = d2buf_k[i]; end; for j in 1:fld.grid.Nx; fld[j,1,1] = fld[j,1,1] + k*d2buf[j]*dt; end; halo1d!(fld); end; jcost[1]=fld[15,1,1].*fld[15,1,1]; return nothing; end. c = CenterField(grid); c2 = CenterField(grid); f(x, y, z) = exp( -50((x-grid.xᶠᵃᵃ[1])/grid.Lx-0.5)^2 ); set!(c,f); halo1d!(c); set!(c2,f); halo1d!(c2); j=[0.]; diffuse1d_model!(j,c). bc=CenterField(grid); set!(c,f); set!(bc,0); j=[0.]; bj=[1.]; autodiff(Reverse, diffuse1d_model!,Duplicated(j,bj), Duplicated(c,bc) ). @show bj; @show bc; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3346
https://github.com/CliMA/Oceananigans.jl/issues/3346:1176,Usability,simpl,simple,1176,"The simple test code from @christophernhill, now successfully differentiating!. Not sure what the correct answer should be, so someone should check this. This probably makes sense to add a test somewhere at least, and also can be used as a starting point for future development. ```julia; using Enzyme; using Oceananigans; using KernelAbstractions: @index, @kernel; using Oceananigans.Utils: launch!; using Oceananigans.Architectures: device. using EnzymeCore. EnzymeCore.EnzymeRules.inactive_type(::Type{<:Oceananigans.Grids.AbstractGrid}) = true. arch=CPU(); FT=Float64. N = 100; topo = (Periodic, Flat, Flat); grid = RectilinearGrid(arch, FT, topology=topo, size=(N), halo=2, x=(-1, 1), y=(-1, 1), z=(-1, 1)). function del21d!(d2buf,fld::Field); g = fld.grid; Nx = g.Nx; for i=1:Nx; d2buf[i] = fld[i-1,1,1]+fld[i+1,1,1]-2fld[i,1,1]; end; return; end. @kernel function del21d_k!(d2buf_k,fld); i,j,k = @index(Global,NTuple); @inbounds d2buf_k[i,j,k] = fld[i-1,j,k]+fld[i+1,j,k]-2fld[i,j,k]; end. # 2. halo; function halo1d!(fld::Field); g = fld.grid; Hx = g.Hx; Nx = g.Nx; for i=1:Hx; fld[i-Hx,1,1]=fld[Nx-Hx+i,1,1]; fld[Nx+i,1,1]=fld[i ,1,1]; end; return nothing; end. # 3. simple model; function diffuse1d_model!(jcost,fld); grid=fld.grid; d2buf=ones(grid.Nx); arch=grid.architecture; d2buf_k = CenterField(grid); k=1.0; dt=0.1; nsteps=50; for i in 1:nsteps; del21d!(d2buf,fld); ### kernel style; event=launch!(arch,grid,:xyz,del21d_k!,d2buf_k,fld); for j in 1:fld.grid.Nx; d2buf[i] = d2buf_k[i]; end; for j in 1:fld.grid.Nx; fld[j,1,1] = fld[j,1,1] + k*d2buf[j]*dt; end; halo1d!(fld); end; jcost[1]=fld[15,1,1].*fld[15,1,1]; return nothing; end. c = CenterField(grid); c2 = CenterField(grid); f(x, y, z) = exp( -50((x-grid.xᶠᵃᵃ[1])/grid.Lx-0.5)^2 ); set!(c,f); halo1d!(c); set!(c2,f); halo1d!(c2); j=[0.]; diffuse1d_model!(j,c). bc=CenterField(grid); set!(c,f); set!(bc,0); j=[0.]; bj=[1.]; autodiff(Reverse, diffuse1d_model!,Duplicated(j,bj), Duplicated(c,bc) ). @show bj; @show bc; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3346
https://github.com/CliMA/Oceananigans.jl/issues/3348:250,Deployability,update,update,250,https://github.com/CliMA/Oceananigans.jl/blob/7af4aad1eb4127c1c3c9605755ceaffaaec0668c/docs/src/model_setup/output_writers.md?plain=1#L28; I believe that `FieldSlicer` is no longer used? I think this is just a small part of the docs that missed this update.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3348
https://github.com/CliMA/Oceananigans.jl/pull/3351:46,Integrability,rout,route,46,This PR contains a handful of changes made en route to coupled global ocean sea-ice simulations. Right now it just has a tweak to the interface for AbstractModel and also makes LatitudeLongitudeGrid support Flat vertical directions.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3351
https://github.com/CliMA/Oceananigans.jl/pull/3351:134,Integrability,interface,interface,134,This PR contains a handful of changes made en route to coupled global ocean sea-ice simulations. Right now it just has a tweak to the interface for AbstractModel and also makes LatitudeLongitudeGrid support Flat vertical directions.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3351
https://github.com/CliMA/Oceananigans.jl/issues/3356:727,Availability,ERROR,ERROR,727,"The function `interpolate` is currently mostly used for Lagrangian particle advection:. https://github.com/CliMA/Oceananigans.jl/blob/d0b7ec8f98c860ce49927e0a7214961d2f47fb75/src/Fields/interpolate.jl#L186-L198. However, it's also potentially useful for many other things. Right now though it doesn't work (or make sense) for fields with `Nothing` locations:. ```julia; source_grid = RectilinearGrid(size=(2, 2), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat)); s = Field{Center, Center, Nothing}(source_grid); set!(s, (x, y) -> x + y); loc = Tuple(L() for L in location(s)); x = y = 0.67; z = 0; interpolate(s, loc..., source_grid, x, y, z); ```. gives. ```julia; julia> interpolate(s, loc..., source_grid, x, y, z); ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] fractional_z_index; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:110 [inlined]; [3] fractional_indices; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:133 [inlined]; [4] interpolate(field::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryConditio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356
https://github.com/CliMA/Oceananigans.jl/issues/3356:2908,Modifiability,refactor,refactor,2908,"g, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, LX::Center, LY::Center, LZ::Nothing, grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, x::Float64, y::Float64, z::Int64); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:187; [5] top-level scope; @ REPL[19]:1; ```. It doesn't really make sense to have to pass a `z` location into `interpolate`. I think we should refactor this function to read something like. ```julia; interpolate(to_node, from_field, from_location, from_grid); ```. Then `to_node` can be a tuple of appropriate length for the `from_location` and `from_grid` topology.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356
https://github.com/CliMA/Oceananigans.jl/issues/3356:758,Security,access,access,758,"The function `interpolate` is currently mostly used for Lagrangian particle advection:. https://github.com/CliMA/Oceananigans.jl/blob/d0b7ec8f98c860ce49927e0a7214961d2f47fb75/src/Fields/interpolate.jl#L186-L198. However, it's also potentially useful for many other things. Right now though it doesn't work (or make sense) for fields with `Nothing` locations:. ```julia; source_grid = RectilinearGrid(size=(2, 2), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat)); s = Field{Center, Center, Nothing}(source_grid); set!(s, (x, y) -> x + y); loc = Tuple(L() for L in location(s)); x = y = 0.67; z = 0; interpolate(s, loc..., source_grid, x, y, z); ```. gives. ```julia; julia> interpolate(s, loc..., source_grid, x, y, z); ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] fractional_z_index; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:110 [inlined]; [3] fractional_indices; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:133 [inlined]; [4] interpolate(field::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryConditio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356
https://github.com/CliMA/Oceananigans.jl/issues/3361:1583,Availability,ERROR,ERROR,1583,"ectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 8×9×10 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, -2:7) with eltype Float64 with indices -2:5×-2:6×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> c2 = CenterField(grid); 2×3×4 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 8×9×10 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, -2:7) with eltype Float64 with indices -2:5×-2:6×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> c1[1, :, 1] .= c2[2, :, 3]; ERROR: DimensionMismatch: array could not be broadcast to match destination; Stacktrace:; [1] check_broadcast_shape; @ ./broadcast.jl:553 [inlined]; [2] check_broadcast_axes; @ ./broadcast.jl:556 [inlined]; [3] instantiate; @ ./broadcast.jl:297 [inlined]; [4] materialize!; @ ./broadcast.jl:884 [inlined]; [5] materialize!; @ ./broadcast.jl:881 [inlined]; [6] materialize!(dest::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{UnitRange{Int64}, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.One",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361
https://github.com/CliMA/Oceananigans.jl/issues/3361:3425,Availability,error,error,3425,"ast.jl:556 [inlined]; [3] instantiate; @ ./broadcast.jl:297 [inlined]; [4] materialize!; @ ./broadcast.jl:884 [inlined]; [5] materialize!; @ ./broadcast.jl:881 [inlined]; [6] materialize!(dest::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{UnitRange{Int64}, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}, false}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(identity), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}}}); @ Oceananigans.Fields ~/Research/OC7.jl/src/Fields/broadcasting_abstract_fields.jl:36; [7] top-level scope; @ REPL[5]:1; ```. While the size of the slices are _exactly_ the same, we we get an error that `ERROR: DimensionMismatch: array could not be broadcast to match destination`. If instead we try to broadcast to the `parent` arrays then things work as expected. ```Julia; julia> parent(c1[1, :, 1]) .= parent(c2[2, :, 3]); 9-element Vector{Float64}:; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; ```. (found with @siddharthabishnu)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361
https://github.com/CliMA/Oceananigans.jl/issues/3361:3437,Availability,ERROR,ERROR,3437,"ast.jl:556 [inlined]; [3] instantiate; @ ./broadcast.jl:297 [inlined]; [4] materialize!; @ ./broadcast.jl:884 [inlined]; [5] materialize!; @ ./broadcast.jl:881 [inlined]; [6] materialize!(dest::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{UnitRange{Int64}, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}, false}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(identity), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}}}); @ Oceananigans.Fields ~/Research/OC7.jl/src/Fields/broadcasting_abstract_fields.jl:36; [7] top-level scope; @ REPL[5]:1; ```. While the size of the slices are _exactly_ the same, we we get an error that `ERROR: DimensionMismatch: array could not be broadcast to match destination`. If instead we try to broadcast to the `parent` arrays then things work as expected. ```Julia; julia> parent(c1[1, :, 1]) .= parent(c2[2, :, 3]); 9-element Vector{Float64}:; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; ```. (found with @siddharthabishnu)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361
https://github.com/CliMA/Oceananigans.jl/issues/3364:2054,Energy Efficiency,schedul,schedule,2054," :RungeKutta3,; closure = ScalarDiffusivity(ν=1e-6, κ=1e-6),; tracers = :b,; buoyancy = BuoyancyTracer(),; background_fields = (; b=B)) # `background_fields` is a `NamedTuple`. A=0.01; u_ic(x,y,z) = A * randn(); w_ic(x,y,z) = A * randn(). set!(model, u=u_ic, w=w_ic). simulation = Simulation(model, Δt = 0.01, stop_iteration=200). wizard = TimeStepWizard(cfl=0.3, diffusive_cfl=0.3, max_change=1.2, max_Δt=1); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(1)). progress(sim) = @printf(""i: % 6d, sim time: % 1.3f, wall time: % 10s, Δt: % 1.4f, advective CFL: %.2e, diffusive CFL: %.2e\n"",; iteration(sim), time(sim), prettytime(sim.run_wall_time),; sim.Δt, AdvectiveCFL(sim.Δt)(sim.model), DiffusiveCFL(sim.Δt)(sim.model)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""background_field_test""; simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,; filename = filename * "".jld2"",; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). xu, yu, zu = nodes(model.velocities.u) ; xw, yw, zw = nodes(model.velocities.w). file = jldopen(filename * "".jld2""). iterations = parse.(Int, keys(file[""timeseries/t""])). anim = @animate for (i,iter) in enumerate(iterations); @info ""Drawing frame $i from iteration $iter..."". u = file[""timeseries/u/$iter""][:,1,:];; w = file[""timeseries/w/$iter""][:,1,:];; t = file[""timeseries/t/$iter""];. ## Plot the heatmaps; u_plot = Plots.heatmap(xu, zu, u', color=:thermal, xlabel=""x"", ylabel=""z"", aspect_ratio = :equal, xlims = (0, Lx), ylims = (0, Lz));; w_plot = Plots.heatmap(xw, zw, w', color=:thermal, xlabel=""x"", ylabel=""z"", aspect_ratio = :equal, xlims = (0, Lz), ylims = (0, Lz));; u_title = @sprintf(""u, t=%s"",round(t));; w_title = @sprintf(""w, t=%s"",round(t));; 	; Plots.plot(u_plot,w_plot,layout=(1,2),size=(1200,600),title =[u_title w_title]);. iter == iterations[end] && close(file) # close the file if we reach the end. end. mp4(anim, filename",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364
https://github.com/CliMA/Oceananigans.jl/issues/3364:131,Usability,simpl,simplest,131,"Hi all,; We have come across what seems to be a bug in background_fields. This arose in another context, but the code below is the simplest way that I have come up with so far that demonstrates the problem. Here there is a stable linear buoyancy profile (imposed as a background gradient) with random noise for the initial velocity. This generates extra turbulence at the top and bottom. I wonder if the background gradient in the halo region isn't playing nicely with the initial conditions. Has anyone else seen something like this or have any ideas for where to look for the problem?; I am using Julia 1.9.2 and Oceananigans 0.85.0; Thanks!; John. ```julia; using Oceananigans; using JLD2; using Plots; using Printf. Lx = 1; Lz = 1; Nx = 64; Nz = 64. grid = RectilinearGrid(size=(Nx, Nz), x=(0, Lx), z=(0, Lz), topology=(Periodic, Flat, Periodic)). # Create a stable background buoyancy gradient; N = 1 # buoyancy frequency [s⁻¹]; B_func(x, y, z, t, N) = N^2 * z; B = BackgroundField(B_func, parameters=N). model = NonhydrostaticModel(; grid,; advection = WENO(),; timestepper = :RungeKutta3,; closure = ScalarDiffusivity(ν=1e-6, κ=1e-6),; tracers = :b,; buoyancy = BuoyancyTracer(),; background_fields = (; b=B)) # `background_fields` is a `NamedTuple`. A=0.01; u_ic(x,y,z) = A * randn(); w_ic(x,y,z) = A * randn(). set!(model, u=u_ic, w=w_ic). simulation = Simulation(model, Δt = 0.01, stop_iteration=200). wizard = TimeStepWizard(cfl=0.3, diffusive_cfl=0.3, max_change=1.2, max_Δt=1); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(1)). progress(sim) = @printf(""i: % 6d, sim time: % 1.3f, wall time: % 10s, Δt: % 1.4f, advective CFL: %.2e, diffusive CFL: %.2e\n"",; iteration(sim), time(sim), prettytime(sim.run_wall_time),; sim.Δt, AdvectiveCFL(sim.Δt)(sim.model), DiffusiveCFL(sim.Δt)(sim.model)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""background_field_test""; simulation.output_writers[:velocities] = JLD2OutputWriter(model",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364
https://github.com/CliMA/Oceananigans.jl/pull/3366:396,Availability,down,downstream,396,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366
https://github.com/CliMA/Oceananigans.jl/pull/3366:334,Deployability,release,release,334,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366
https://github.com/CliMA/Oceananigans.jl/pull/3366:420,Integrability,depend,depend,420,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366
https://github.com/CliMA/Oceananigans.jl/pull/3366:147,Testability,test,tested,147,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366
https://github.com/CliMA/Oceananigans.jl/pull/3366:253,Testability,test,tests,253,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366
https://github.com/CliMA/Oceananigans.jl/pull/3366:439,Testability,test,tests,439,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366
https://github.com/CliMA/Oceananigans.jl/pull/3367:303,Availability,error,error,303,"Currently the user may pass `diffusivity_fields` into model constructors, but `Oceananigans.TurbulantClosures.DiffusivityFields` resets these to the value of `validate_field_tuple_grid` which nominally is `nothing`. I have changed this to return the field values if `validate_field_tuple_grid` does not error instead. E.g. ```julia. using Oceananigans; using Oceananigans.TurbulenceClosures: DiffusivityFields. grid = RectilinearGrid(size = (64, 64, 16), extent = (150, 150, 10)). tracers = (:T, :S). closure = AnisotropicMinimumDissipation(). diffusivity_fields = diffusivity_fields = DiffusivityFields(grid, tracers, NamedTuple(), closure). model = NonhydrostaticModel(; grid,; tracers,; closure,; diffusivity_fields); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3367
https://github.com/CliMA/Oceananigans.jl/pull/3370:25,Modifiability,variab,variable,25,"This PR adds support for variable ""closure constants"" in `SmagorinskyLilly`, and refactors the `AnisotropicMinimumDissipation` to share it. It discontinues support for `Function` closure constants in AMD. As an example, the ""Van Driest"" damping function (discussed in #3369) would be implemented in a simple channel simulation as follows:. ```julia; # Vertically-bounded resolved LES; #; # This script builds a simulation of freely-decaying turbulence in; # a vertically-bounded domain, where turbulence far from the wall is modeled using; # the SmagorinskyLilly eddy diffusivity closure, but the dynamics close to the wall; # is fully resolved. The Van Driest damping function is used to modify the SmagorinkyLilly; # model constant close to the wall to ensure that the dynamics is relatively unaffected; # by the eddy diffusivity. using Oceananigans; using Oceananigans.Grids: zspacing; using Oceananigans.Fields: FunctionField; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization. grid = RectilinearGrid(size=(64, 64, 256), x=(0, 1), y=(0, 1), z=(0, 1),; topology = (Periodic, Periodic, Bounded)). vitd = VerticallyImplicitTimeDiscretization(); molecular_diffusivity = ScalarDiffusivity(vitd, ν=1.05e-6). """"""; van_driest_damping_function(x, y, z, p). Return the model constant for SmagorinskyLilly which decreases to zero; at the center of the first grid cell away from the wall.; """"""; @inline function van_driest_damping_function(x, y, z, p); # Position of first grid cell; z₀ = p.Δz₀ / 2; z₁ = 1 - p.Δz₁ / 2. # Distances to the wall; d⁺₀ = (z - z₀) / p.δ⁺; d⁺₁ = (z₁ - z) / p.δ⁺; d⁺ = min(d⁺₀, d⁺₁). # Model constants; A⁺ = p.A⁺; C = p.C. return C * (1 - exp(d⁺ / A⁺)); end. # Find grid spacing at top and bottom, assuming rectilinearity; Nz = size(grid, 3); Δz₀ = zspacing(1, 1, 1, grid, Center(), Center(), Center()); Δz₁ = zspacing(1, 1, Nz, grid, Center(), Center(), Center()). parameters = (C = 0.16,; A⁺ = 26, # :-D; Δz₀ = Δz₀, # vertical grid spacing at the bottom;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370
https://github.com/CliMA/Oceananigans.jl/pull/3370:81,Modifiability,refactor,refactors,81,"This PR adds support for variable ""closure constants"" in `SmagorinskyLilly`, and refactors the `AnisotropicMinimumDissipation` to share it. It discontinues support for `Function` closure constants in AMD. As an example, the ""Van Driest"" damping function (discussed in #3369) would be implemented in a simple channel simulation as follows:. ```julia; # Vertically-bounded resolved LES; #; # This script builds a simulation of freely-decaying turbulence in; # a vertically-bounded domain, where turbulence far from the wall is modeled using; # the SmagorinskyLilly eddy diffusivity closure, but the dynamics close to the wall; # is fully resolved. The Van Driest damping function is used to modify the SmagorinkyLilly; # model constant close to the wall to ensure that the dynamics is relatively unaffected; # by the eddy diffusivity. using Oceananigans; using Oceananigans.Grids: zspacing; using Oceananigans.Fields: FunctionField; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization. grid = RectilinearGrid(size=(64, 64, 256), x=(0, 1), y=(0, 1), z=(0, 1),; topology = (Periodic, Periodic, Bounded)). vitd = VerticallyImplicitTimeDiscretization(); molecular_diffusivity = ScalarDiffusivity(vitd, ν=1.05e-6). """"""; van_driest_damping_function(x, y, z, p). Return the model constant for SmagorinskyLilly which decreases to zero; at the center of the first grid cell away from the wall.; """"""; @inline function van_driest_damping_function(x, y, z, p); # Position of first grid cell; z₀ = p.Δz₀ / 2; z₁ = 1 - p.Δz₁ / 2. # Distances to the wall; d⁺₀ = (z - z₀) / p.δ⁺; d⁺₁ = (z₁ - z) / p.δ⁺; d⁺ = min(d⁺₀, d⁺₁). # Model constants; A⁺ = p.A⁺; C = p.C. return C * (1 - exp(d⁺ / A⁺)); end. # Find grid spacing at top and bottom, assuming rectilinearity; Nz = size(grid, 3); Δz₀ = zspacing(1, 1, 1, grid, Center(), Center(), Center()); Δz₁ = zspacing(1, 1, Nz, grid, Center(), Center(), Center()). parameters = (C = 0.16,; A⁺ = 26, # :-D; Δz₀ = Δz₀, # vertical grid spacing at the bottom;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370
https://github.com/CliMA/Oceananigans.jl/pull/3370:301,Usability,simpl,simple,301,"This PR adds support for variable ""closure constants"" in `SmagorinskyLilly`, and refactors the `AnisotropicMinimumDissipation` to share it. It discontinues support for `Function` closure constants in AMD. As an example, the ""Van Driest"" damping function (discussed in #3369) would be implemented in a simple channel simulation as follows:. ```julia; # Vertically-bounded resolved LES; #; # This script builds a simulation of freely-decaying turbulence in; # a vertically-bounded domain, where turbulence far from the wall is modeled using; # the SmagorinskyLilly eddy diffusivity closure, but the dynamics close to the wall; # is fully resolved. The Van Driest damping function is used to modify the SmagorinkyLilly; # model constant close to the wall to ensure that the dynamics is relatively unaffected; # by the eddy diffusivity. using Oceananigans; using Oceananigans.Grids: zspacing; using Oceananigans.Fields: FunctionField; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization. grid = RectilinearGrid(size=(64, 64, 256), x=(0, 1), y=(0, 1), z=(0, 1),; topology = (Periodic, Periodic, Bounded)). vitd = VerticallyImplicitTimeDiscretization(); molecular_diffusivity = ScalarDiffusivity(vitd, ν=1.05e-6). """"""; van_driest_damping_function(x, y, z, p). Return the model constant for SmagorinskyLilly which decreases to zero; at the center of the first grid cell away from the wall.; """"""; @inline function van_driest_damping_function(x, y, z, p); # Position of first grid cell; z₀ = p.Δz₀ / 2; z₁ = 1 - p.Δz₁ / 2. # Distances to the wall; d⁺₀ = (z - z₀) / p.δ⁺; d⁺₁ = (z₁ - z) / p.δ⁺; d⁺ = min(d⁺₀, d⁺₁). # Model constants; A⁺ = p.A⁺; C = p.C. return C * (1 - exp(d⁺ / A⁺)); end. # Find grid spacing at top and bottom, assuming rectilinearity; Nz = size(grid, 3); Δz₀ = zspacing(1, 1, 1, grid, Center(), Center(), Center()); Δz₁ = zspacing(1, 1, Nz, grid, Center(), Center(), Center()). parameters = (C = 0.16,; A⁺ = 26, # :-D; Δz₀ = Δz₀, # vertical grid spacing at the bottom;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370
https://github.com/CliMA/Oceananigans.jl/issues/3374:199,Performance,optimiz,optimizer,199,"On Julia 1.10 users are met with an ~~avalanche~~ tsunami of warnings. ```; warning: /Users/gregorywagner/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; ```. For example we try. https://github.com/CliMA/Oceananigans.jl/blob/7291ada057afc9cfcefb2b6e9351cff8782d9217/src/Solvers/batched_tridiagonal_solver.jl#L133-L148. but this loop probably can't be unrolled because `Nx` is a runtime value, not a compile time constant. I don't know if we ever `@unroll` properly... Seems like the easiest thing is just to stop pretending that we `@unroll`. @jlk9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374
https://github.com/CliMA/Oceananigans.jl/issues/3374:223,Performance,perform,perform,223,"On Julia 1.10 users are met with an ~~avalanche~~ tsunami of warnings. ```; warning: /Users/gregorywagner/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; ```. For example we try. https://github.com/CliMA/Oceananigans.jl/blob/7291ada057afc9cfcefb2b6e9351cff8782d9217/src/Solvers/batched_tridiagonal_solver.jl#L133-L148. but this loop probably can't be unrolled because `Nx` is a runtime value, not a compile time constant. I don't know if we ever `@unroll` properly... Seems like the easiest thing is just to stop pretending that we `@unroll`. @jlk9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374
https://github.com/CliMA/Oceananigans.jl/issues/3377:181,Availability,down,downloads,181,"When I click on the link to the documentation/try finding the documentation on Google, it seems like the link https://clima.github.io/OceananigansDocumentation/stable automatically downloads a text file that contains the version number, and nothing more. Here's also a screenshot of clicking on the documentation page on Google:; ![Screenshot 2023-11-05 205429](https://github.com/CliMA/Oceananigans.jl/assets/50624521/ae495f16-51f8-4e9b-bd5c-a3606bc9dcbf). But I suppose the `dev` version of the documentation works:; https://clima.github.io/OceananigansDocumentation/dev/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3377
https://github.com/CliMA/Oceananigans.jl/issues/3381:16,Deployability,update,updates,16,"With the recent updates of Oceananigans, I noticed an unusual behavior of the model that often leads to much slower initialization. . Below is a minimum working example that demonstrates the issue:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=20minutes, stop_time=20days). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)); run!(simulation). ```; Running this code with Julia 1.9.3 and Oceananigans v0.90.0 gives an initialization time of ~ 15 minutes, much longer than common values of a few seconds. The same issue also appears on GPU. This speed issue disappears either when `ζ = ∂x(v) - ∂y(u)` is replaced with `ζ = Field(∂x(v) - ∂y(u))`, or when `ζ` is the only variable in `fields_slice`. However, as pointed out by @tomchor, wrapping outputs in `Field()` tends to waste more memory (a very precious resource on the GPU), so it may be worthwhile to investigate further why this happens.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381
https://github.com/CliMA/Oceananigans.jl/issues/3381:682,Energy Efficiency,schedul,schedule,682,"With the recent updates of Oceananigans, I noticed an unusual behavior of the model that often leads to much slower initialization. . Below is a minimum working example that demonstrates the issue:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=20minutes, stop_time=20days). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)); run!(simulation). ```; Running this code with Julia 1.9.3 and Oceananigans v0.90.0 gives an initialization time of ~ 15 minutes, much longer than common values of a few seconds. The same issue also appears on GPU. This speed issue disappears either when `ζ = ∂x(v) - ∂y(u)` is replaced with `ζ = Field(∂x(v) - ∂y(u))`, or when `ζ` is the only variable in `fields_slice`. However, as pointed out by @tomchor, wrapping outputs in `Field()` tends to waste more memory (a very precious resource on the GPU), so it may be worthwhile to investigate further why this happens.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381
https://github.com/CliMA/Oceananigans.jl/issues/3381:1180,Integrability,wrap,wrapping,1180,"With the recent updates of Oceananigans, I noticed an unusual behavior of the model that often leads to much slower initialization. . Below is a minimum working example that demonstrates the issue:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=20minutes, stop_time=20days). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)); run!(simulation). ```; Running this code with Julia 1.9.3 and Oceananigans v0.90.0 gives an initialization time of ~ 15 minutes, much longer than common values of a few seconds. The same issue also appears on GPU. This speed issue disappears either when `ζ = ∂x(v) - ∂y(u)` is replaced with `ζ = Field(∂x(v) - ∂y(u))`, or when `ζ` is the only variable in `fields_slice`. However, as pointed out by @tomchor, wrapping outputs in `Field()` tends to waste more memory (a very precious resource on the GPU), so it may be worthwhile to investigate further why this happens.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381
https://github.com/CliMA/Oceananigans.jl/issues/3381:1115,Modifiability,variab,variable,1115,"With the recent updates of Oceananigans, I noticed an unusual behavior of the model that often leads to much slower initialization. . Below is a minimum working example that demonstrates the issue:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=20minutes, stop_time=20days). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)); run!(simulation). ```; Running this code with Julia 1.9.3 and Oceananigans v0.90.0 gives an initialization time of ~ 15 minutes, much longer than common values of a few seconds. The same issue also appears on GPU. This speed issue disappears either when `ζ = ∂x(v) - ∂y(u)` is replaced with `ζ = Field(∂x(v) - ∂y(u))`, or when `ζ` is the only variable in `fields_slice`. However, as pointed out by @tomchor, wrapping outputs in `Field()` tends to waste more memory (a very precious resource on the GPU), so it may be worthwhile to investigate further why this happens.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381
https://github.com/CliMA/Oceananigans.jl/issues/3389:98,Testability,test,testing,98,"Hi Oceananigans,. Thank you very much for making your code open!; @olmozavala and I are currently testing out to see if we can run realistic simulations of the Gulf of Mexico but the documentation (https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Oceananigans.Grids.LatitudeLongitudeGrid) seems to only have examples with a flat bottom. Could you advise how one would prescribe a realistic ocean bathymetry?. Thank you.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389
https://github.com/CliMA/Oceananigans.jl/issues/3394:404,Deployability,Update,Update,404,"This issue will help to combine several outstanding issues involving the `ShallowWaterModel.jl`. I suggest the following in this order:. - [ ] Fix inconsistent tendencies in the two models (#2928); - [ ] Fix up shallow water regression tests (#3049); - [ ] Add viscosity; - [ ] Speed up shallow water example when building docs (#3151); - [ ] Make shallow water Bickley jet less expensive (#3169); - [ ] Update immersed bondaries validation scripts (#2985); - [ ] Introduce multi-layer shallow water model (#2507); - [ ] Validate positive preserving WENO schemes. For the first part, I put together this document that shows and derives the equations for the two different models. Next I will look at the tendencies. . Any suggestions on what else to do, or what to do differently, are welcome!. [ShallowWaterModel_eqns.pdf](https://github.com/CliMA/Oceananigans.jl/files/13393977/ShallowWaterModel_eqns.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394
https://github.com/CliMA/Oceananigans.jl/issues/3394:430,Security,validat,validation,430,"This issue will help to combine several outstanding issues involving the `ShallowWaterModel.jl`. I suggest the following in this order:. - [ ] Fix inconsistent tendencies in the two models (#2928); - [ ] Fix up shallow water regression tests (#3049); - [ ] Add viscosity; - [ ] Speed up shallow water example when building docs (#3151); - [ ] Make shallow water Bickley jet less expensive (#3169); - [ ] Update immersed bondaries validation scripts (#2985); - [ ] Introduce multi-layer shallow water model (#2507); - [ ] Validate positive preserving WENO schemes. For the first part, I put together this document that shows and derives the equations for the two different models. Next I will look at the tendencies. . Any suggestions on what else to do, or what to do differently, are welcome!. [ShallowWaterModel_eqns.pdf](https://github.com/CliMA/Oceananigans.jl/files/13393977/ShallowWaterModel_eqns.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394
https://github.com/CliMA/Oceananigans.jl/issues/3394:521,Security,Validat,Validate,521,"This issue will help to combine several outstanding issues involving the `ShallowWaterModel.jl`. I suggest the following in this order:. - [ ] Fix inconsistent tendencies in the two models (#2928); - [ ] Fix up shallow water regression tests (#3049); - [ ] Add viscosity; - [ ] Speed up shallow water example when building docs (#3151); - [ ] Make shallow water Bickley jet less expensive (#3169); - [ ] Update immersed bondaries validation scripts (#2985); - [ ] Introduce multi-layer shallow water model (#2507); - [ ] Validate positive preserving WENO schemes. For the first part, I put together this document that shows and derives the equations for the two different models. Next I will look at the tendencies. . Any suggestions on what else to do, or what to do differently, are welcome!. [ShallowWaterModel_eqns.pdf](https://github.com/CliMA/Oceananigans.jl/files/13393977/ShallowWaterModel_eqns.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394
https://github.com/CliMA/Oceananigans.jl/issues/3394:236,Testability,test,tests,236,"This issue will help to combine several outstanding issues involving the `ShallowWaterModel.jl`. I suggest the following in this order:. - [ ] Fix inconsistent tendencies in the two models (#2928); - [ ] Fix up shallow water regression tests (#3049); - [ ] Add viscosity; - [ ] Speed up shallow water example when building docs (#3151); - [ ] Make shallow water Bickley jet less expensive (#3169); - [ ] Update immersed bondaries validation scripts (#2985); - [ ] Introduce multi-layer shallow water model (#2507); - [ ] Validate positive preserving WENO schemes. For the first part, I put together this document that shows and derives the equations for the two different models. Next I will look at the tendencies. . Any suggestions on what else to do, or what to do differently, are welcome!. [ShallowWaterModel_eqns.pdf](https://github.com/CliMA/Oceananigans.jl/files/13393977/ShallowWaterModel_eqns.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394
https://github.com/CliMA/Oceananigans.jl/issues/3397:1982,Availability,down,downgrading,1982,"e value anyway). This appears to be occurring in the pressure correction step. For example:; ```julia; julia> using Oceananigans; julia> grid = RectilinearGrid(size = (128, 128, 128), extent = (1000, 1000, 1000));; julia> model = NonhydrostaticModel(; grid);; julia> uᵢ(x, y, z) = (1-tanh((x-500)/10));; julia> set!(model, u = uᵢ). julia> model.velocities.u; 128×128×128 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 134×134×134 OffsetArray(::Array{Float64, 3}, -2:131, -2:131, -2:131) with eltype Float64 with indices -2:131×-2:131×-2:131; └── max=1.00781, min=1.00781, mean=1.00781. julia> set!(model, u = uᵢ, enforce_incompressibility=false). julia> model.velocities.u; 128×128×128 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 134×134×134 OffsetArray(::Array{Float64, 3}, -2:131, -2:131, -2:131) with eltype Float64 with indices -2:131×-2:131×-2:131; └── max=2.0, min=0.0, mean=1.00781; ```. I initially spotted this issue after time-stepping a model and the same thing occurs, presumably after the pressure correction, so this isn't isolated to `set!`. This is occurring in all of my julia projects where Oceananigans is in various versions and I know Nonhydrostatic models have worked correctly in before, downgrading is also not working so perhaps this is similar to https://github.com/CliMA/Oceananigans.jl/issues/3381 with a broken dependency. I will try updating to 1.10 to see if that fixes the issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3397
https://github.com/CliMA/Oceananigans.jl/issues/3397:2111,Integrability,depend,dependency,2111,"e value anyway). This appears to be occurring in the pressure correction step. For example:; ```julia; julia> using Oceananigans; julia> grid = RectilinearGrid(size = (128, 128, 128), extent = (1000, 1000, 1000));; julia> model = NonhydrostaticModel(; grid);; julia> uᵢ(x, y, z) = (1-tanh((x-500)/10));; julia> set!(model, u = uᵢ). julia> model.velocities.u; 128×128×128 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 134×134×134 OffsetArray(::Array{Float64, 3}, -2:131, -2:131, -2:131) with eltype Float64 with indices -2:131×-2:131×-2:131; └── max=1.00781, min=1.00781, mean=1.00781. julia> set!(model, u = uᵢ, enforce_incompressibility=false). julia> model.velocities.u; 128×128×128 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 134×134×134 OffsetArray(::Array{Float64, 3}, -2:131, -2:131, -2:131) with eltype Float64 with indices -2:131×-2:131×-2:131; └── max=2.0, min=0.0, mean=1.00781; ```. I initially spotted this issue after time-stepping a model and the same thing occurs, presumably after the pressure correction, so this isn't isolated to `set!`. This is occurring in all of my julia projects where Oceananigans is in various versions and I know Nonhydrostatic models have worked correctly in before, downgrading is also not working so perhaps this is similar to https://github.com/CliMA/Oceananigans.jl/issues/3381 with a broken dependency. I will try updating to 1.10 to see if that fixes the issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3397
https://github.com/CliMA/Oceananigans.jl/pull/3398:74,Integrability,depend,dependence,74,"I noticed that the example could be improved a bit by using a grid with z-dependence, and omitting the irrelevant x and y dependence. Also, the show method for SeawaterBuoyancy needs improvement (underscores are missing from `equation_of_state`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3398
https://github.com/CliMA/Oceananigans.jl/pull/3398:122,Integrability,depend,dependence,122,"I noticed that the example could be improved a bit by using a grid with z-dependence, and omitting the irrelevant x and y dependence. Also, the show method for SeawaterBuoyancy needs improvement (underscores are missing from `equation_of_state`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3398
https://github.com/CliMA/Oceananigans.jl/issues/3399:705,Availability,checkpoint,checkpointer,705,"Below is a minimal working example of the problem:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(Float64,; size = (4, 4, 4),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). b_initial(x, y, z) = rand(). model = NonhydrostaticModel(; ; grid = grid,; buoyancy = BuoyancyTracer(),; tracers = (:b),; timestepper = :RungeKutta3). simulation = Simulation(model, Δt=0.1, stop_iteration=200); outputs = merge(model.velocities, model.tracers). simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:721,Availability,Checkpoint,Checkpointer,721,"Below is a minimal working example of the problem:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(Float64,; size = (4, 4, 4),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). b_initial(x, y, z) = rand(). model = NonhydrostaticModel(; ; grid = grid,; buoyancy = BuoyancyTracer(),; tracers = (:b),; timestepper = :RungeKutta3). simulation = Simulation(model, Δt=0.1, stop_iteration=200); outputs = merge(model.velocities, model.tracers). simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:1493,Availability,checkpoint,checkpoint,1493,"_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./tes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:1687,Availability,checkpoint,checkpoint,1687,"iters[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:2380,Availability,ERROR,ERROR,2380,"!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part numbe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:2728,Availability,checkpoint,checkpoint,2728,"m the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part number. This could mean that there are repetitive iterations saved when examining all output files (new and old). 1) is potentially the most important and common use case, but 2) might not be an unreasonable usage as well. However in the current implementation neither can be achieved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:2769,Availability,avail,available,2769,"m the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part number. This could mean that there are repetitive iterations saved when examining all output files (new and old). 1) is potentially the most important and common use case, but 2) might not be an unreasonable usage as well. However in the current implementation neither can be achieved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:2815,Availability,checkpoint,checkpoint,2815,"m the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part number. This could mean that there are repetitive iterations saved when examining all output files (new and old). 1) is potentially the most important and common use case, but 2) might not be an unreasonable usage as well. However in the current implementation neither can be achieved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:2980,Availability,checkpoint,checkpoint,2980,"m the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part number. This could mean that there are repetitive iterations saved when examining all output files (new and old). 1) is potentially the most important and common use case, but 2) might not be an unreasonable usage as well. However in the current implementation neither can be achieved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:3344,Availability,checkpoint,checkpoint,3344,"m the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part number. This could mean that there are repetitive iterations saved when examining all output files (new and old). 1) is potentially the most important and common use case, but 2) might not be an unreasonable usage as well. However in the current implementation neither can be achieved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:614,Energy Efficiency,schedul,schedule,614,"Below is a minimal working example of the problem:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(Float64,; size = (4, 4, 4),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). b_initial(x, y, z) = rand(). model = NonhydrostaticModel(; ; grid = grid,; buoyancy = BuoyancyTracer(),; tracers = (:b),; timestepper = :RungeKutta3). simulation = Simulation(model, Δt=0.1, stop_iteration=200); outputs = merge(model.velocities, model.tracers). simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:741,Energy Efficiency,schedul,schedule,741,"Below is a minimal working example of the problem:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(Float64,; size = (4, 4, 4),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). b_initial(x, y, z) = rand(). model = NonhydrostaticModel(; ; grid = grid,; buoyancy = BuoyancyTracer(),; tracers = (:b),; timestepper = :RungeKutta3). simulation = Simulation(model, Δt=0.1, stop_iteration=200); outputs = merge(model.velocities, model.tracers). simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:1093,Energy Efficiency,schedul,schedule,1093,"loat64,; size = (4, 4, 4),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). b_initial(x, y, z) = rand(). model = NonhydrostaticModel(; ; grid = grid,; buoyancy = BuoyancyTracer(),; tracers = (:b),; timestepper = :RungeKutta3). simulation = Simulation(model, Δt=0.1, stop_iteration=200); outputs = merge(model.velocities, model.tracers). simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `i",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/issues/3399:2605,Usability,user experience,user experience,2605,"m the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part number. This could mean that there are repetitive iterations saved when examining all output files (new and old). 1) is potentially the most important and common use case, but 2) might not be an unreasonable usage as well. However in the current implementation neither can be achieved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399
https://github.com/CliMA/Oceananigans.jl/pull/3401:98,Energy Efficiency,adapt,adapt,98,"Scalar diffusivity fails on GPU if you use fields for the viscosity/diffusivity since there is no adapt method. . I've added them in this PR along with a test, feel free to remove the test if its too much.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401
https://github.com/CliMA/Oceananigans.jl/pull/3401:98,Modifiability,adapt,adapt,98,"Scalar diffusivity fails on GPU if you use fields for the viscosity/diffusivity since there is no adapt method. . I've added them in this PR along with a test, feel free to remove the test if its too much.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401
https://github.com/CliMA/Oceananigans.jl/pull/3401:154,Testability,test,test,154,"Scalar diffusivity fails on GPU if you use fields for the viscosity/diffusivity since there is no adapt method. . I've added them in this PR along with a test, feel free to remove the test if its too much.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401
https://github.com/CliMA/Oceananigans.jl/pull/3401:184,Testability,test,test,184,"Scalar diffusivity fails on GPU if you use fields for the viscosity/diffusivity since there is no adapt method. . I've added them in this PR along with a test, feel free to remove the test if its too much.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401
https://github.com/CliMA/Oceananigans.jl/pull/3402:852,Availability,ERROR,ERROR,852,"There was a bug in the earlier v4 releases so Oceananigans won't work with them (this has come up as CUDAv4.0 is the final version compatible with CUDA 10.2). ```julia; julia> using Oceananigans; ┌ Warning: The NVIDIA driver on this system only supports up to CUDA 10.2.0.; │ For performance reasons, it is recommended to upgrade to a driver that supports CUDA 11.2 or higher.; └ @ CUDA ~/.julia/packages/CUDA/ZdCxS/src/initialization.jl:71; julia> grid = RectilinearGrid(GPU(); size = (128, 128, 128), extent = (1, 1, 1)); mo128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0078125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0078125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0078125. julia> model = NonhydrostaticModel(; grid); ERROR: UndefVarError: `CUDABackend` not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:31 [inlined]; [2] device(#unused#::GPU); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/f5Cpw/src/Architectures.jl:39; [3] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Oceananigans.Utils.KernelParameters{:xy, (0, 0)}, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; include_right_boundaries::Bool, r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402
https://github.com/CliMA/Oceananigans.jl/pull/3402:34,Deployability,release,releases,34,"There was a bug in the earlier v4 releases so Oceananigans won't work with them (this has come up as CUDAv4.0 is the final version compatible with CUDA 10.2). ```julia; julia> using Oceananigans; ┌ Warning: The NVIDIA driver on this system only supports up to CUDA 10.2.0.; │ For performance reasons, it is recommended to upgrade to a driver that supports CUDA 11.2 or higher.; └ @ CUDA ~/.julia/packages/CUDA/ZdCxS/src/initialization.jl:71; julia> grid = RectilinearGrid(GPU(); size = (128, 128, 128), extent = (1, 1, 1)); mo128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0078125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0078125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0078125. julia> model = NonhydrostaticModel(; grid); ERROR: UndefVarError: `CUDABackend` not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:31 [inlined]; [2] device(#unused#::GPU); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/f5Cpw/src/Architectures.jl:39; [3] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Oceananigans.Utils.KernelParameters{:xy, (0, 0)}, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; include_right_boundaries::Bool, r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402
https://github.com/CliMA/Oceananigans.jl/pull/3402:322,Deployability,upgrade,upgrade,322,"There was a bug in the earlier v4 releases so Oceananigans won't work with them (this has come up as CUDAv4.0 is the final version compatible with CUDA 10.2). ```julia; julia> using Oceananigans; ┌ Warning: The NVIDIA driver on this system only supports up to CUDA 10.2.0.; │ For performance reasons, it is recommended to upgrade to a driver that supports CUDA 11.2 or higher.; └ @ CUDA ~/.julia/packages/CUDA/ZdCxS/src/initialization.jl:71; julia> grid = RectilinearGrid(GPU(); size = (128, 128, 128), extent = (1, 1, 1)); mo128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0078125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0078125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0078125. julia> model = NonhydrostaticModel(; grid); ERROR: UndefVarError: `CUDABackend` not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:31 [inlined]; [2] device(#unused#::GPU); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/f5Cpw/src/Architectures.jl:39; [3] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Oceananigans.Utils.KernelParameters{:xy, (0, 0)}, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; include_right_boundaries::Bool, r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402
https://github.com/CliMA/Oceananigans.jl/pull/3402:280,Performance,perform,performance,280,"There was a bug in the earlier v4 releases so Oceananigans won't work with them (this has come up as CUDAv4.0 is the final version compatible with CUDA 10.2). ```julia; julia> using Oceananigans; ┌ Warning: The NVIDIA driver on this system only supports up to CUDA 10.2.0.; │ For performance reasons, it is recommended to upgrade to a driver that supports CUDA 11.2 or higher.; └ @ CUDA ~/.julia/packages/CUDA/ZdCxS/src/initialization.jl:71; julia> grid = RectilinearGrid(GPU(); size = (128, 128, 128), extent = (1, 1, 1)); mo128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0078125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0078125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0078125. julia> model = NonhydrostaticModel(; grid); ERROR: UndefVarError: `CUDABackend` not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:31 [inlined]; [2] device(#unused#::GPU); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/f5Cpw/src/Architectures.jl:39; [3] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Oceananigans.Utils.KernelParameters{:xy, (0, 0)}, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; include_right_boundaries::Bool, r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402
https://github.com/CliMA/Oceananigans.jl/pull/3404:322,Energy Efficiency,reduce,reduce,322,This PR contains some improvements that allow better scaling on multiple devices. . In particular:; - Splitting the interior active cell map into `west` `east` `north` `south` and `interior` to allow for overlapping communication and computations with _active_ cells.; - Advancements for the `SplitExplicitFreeSurface` to reduce kernel launch latency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3404
https://github.com/CliMA/Oceananigans.jl/pull/3404:343,Performance,latency,latency,343,This PR contains some improvements that allow better scaling on multiple devices. . In particular:; - Splitting the interior active cell map into `west` `east` `north` `south` and `interior` to allow for overlapping communication and computations with _active_ cells.; - Advancements for the `SplitExplicitFreeSurface` to reduce kernel launch latency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3404
https://github.com/CliMA/Oceananigans.jl/pull/3407:62,Testability,test,tests,62,Checking to see if making scalar diffusivity mutable broke CI tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3407
https://github.com/CliMA/Oceananigans.jl/pull/3409:52,Energy Efficiency,Adapt,Adapt,52,"This pull request changes the compat entry for the `Adapt` package from `3` to `3, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409
https://github.com/CliMA/Oceananigans.jl/pull/3409:52,Modifiability,Adapt,Adapt,52,"This pull request changes the compat entry for the `Adapt` package from `3` to `3, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409
https://github.com/CliMA/Oceananigans.jl/pull/3409:157,Testability,test,tested,157,"This pull request changes the compat entry for the `Adapt` package from `3` to `3, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409
https://github.com/CliMA/Oceananigans.jl/pull/3409:263,Testability,test,tests,263,"This pull request changes the compat entry for the `Adapt` package from `3` to `3, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409
https://github.com/CliMA/Oceananigans.jl/pull/3410:193,Testability,test,tested,193,"This pull request changes the compat entry for the `NCDatasets` package from `0.12.10, 0.13.1` to `0.12.10, 0.13.1, 0.14`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3410
https://github.com/CliMA/Oceananigans.jl/pull/3410:299,Testability,test,tests,299,"This pull request changes the compat entry for the `NCDatasets` package from `0.12.10, 0.13.1` to `0.12.10, 0.13.1, 0.14`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3410
https://github.com/CliMA/Oceananigans.jl/pull/3411:98,Modifiability,evolve,evolves,98,"This PR introduces a ZStar, free surface following vertical coordinate. . the vertical coordinate evolves in time and is implemented following the recipe in ; [Rescaled height coordinates for accurate representation of free-surface flows in ocean circulation models ](https://www.sciencedirect.com/science/article/abs/pii/S1463500303000544) that allows the implementation of a general vertical coordinate where the only specification needed is the vertical derivative of the vertical coordinate. Closes https://github.com/CliMA/Oceananigans.jl/issues/1679",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411
https://github.com/CliMA/Oceananigans.jl/issues/3412:136,Availability,error,error,136,"When running the Tilted Bottom Boundary Layer example code on the latest version of Oceananigans and Julia 1.9.2, I found the following error popped up:; ```MethodError: no method matching constant_stratification(::Float64, ::Float64, ::Float64, ::Float64, ::NamedTuple{(:ĝ, :N²), Tuple{Vector{Float64}, Float64}}). Closest candidates are:; constant_stratification(::Any, ::Any, ::Any, ::Any); @ Main In[7]:1. Stacktrace:; [1] call_func; @ ~/.julia/packages/Oceananigans/0y15B/src/Fields/function_field.jl:54 [inlined]; [2] getindex; @ ~/.julia/packages/Oceananigans/0y15B/src/Fields/function_field.jl:63 [inlined]; [3] inner_left_biased_interpolate_xᶠᵃᵃ; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/upwind_biased_reconstruction.jl:114 [inlined]; [4] left_biased_interpolate_xᶠᵃᵃ; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/reconstruction_coefficients.jl:11 [inlined]; [5] _left_biased_interpolate_xᶠᵃᵃ; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/topologically_conditional_interpolation.jl:56 [inlined]; [6] advective_tracer_flux_x; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/upwind_biased_advective_fluxes.jl:106 [inlined]; [7] _advective_tracer_flux_x; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/tracer_advection_operators.jl:4 [inlined]; [8] δxᶜᵃᵃ; @ ~/.julia/packages/Oceananigans/0y15B/src/Operators/difference_operators.jl:20 [inlined]; [9] div_Uc; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/tracer_advection_operators.jl:31 [inlined]; [10] tracer_tendency; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:258 [inlined]; [11] cpu_compute_Gc!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [12] cpu_compute_Gc!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(64, 1, 64)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstrac",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/issues/3412:32213,Availability,error,error,32213,"tepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:119; [18] launch!; @ ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:90 [inlined]; [19] #compute_interior_tendency_contributions!#17; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:122 [inlined]; [20] compute_interior_tendency_contributions!; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:53 [inlined]; ```; Sorry for the length, I also had to remove some of the error message so GitHub would let me post it so feel free to let me know if you need to see more. I was able to fix the code by updating the function formatting from ; ``` @inline constant_stratification(x, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3]) ```; to; ``` @inline constant_stratification(x, y, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3])```; after consulting colleagues and was told this was due to a Julia update. I just wanted to inform y'all of this bug.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/issues/3412:5952,Deployability,Continuous,ContinuousBoundaryFunction,5952,"Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}}}}}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_u), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/issues/3412:7301,Deployability,Continuous,ContinuousBoundaryFunction,7301,"ceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_v), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/issues/3412:14395,Deployability,Continuous,ContinuousBoundaryFunction,14395,"Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}}}}}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_u), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/issues/3412:15744,Deployability,Continuous,ContinuousBoundaryFunction,15744,"ceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_v), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/issues/3412:22879,Deployability,Continuous,ContinuousBoundaryFunction,22879,"Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}}}}}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_u), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/issues/3412:24228,Deployability,Continuous,ContinuousBoundaryFunction,24228,"ceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_v), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/issues/3412:32628,Deployability,update,update,32628,"tepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:119; [18] launch!; @ ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:90 [inlined]; [19] #compute_interior_tendency_contributions!#17; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:122 [inlined]; [20] compute_interior_tendency_contributions!; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:53 [inlined]; ```; Sorry for the length, I also had to remove some of the error message so GitHub would let me post it so feel free to let me know if you need to see more. I was able to fix the code by updating the function formatting from ; ``` @inline constant_stratification(x, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3]) ```; to; ``` @inline constant_stratification(x, y, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3])```; after consulting colleagues and was told this was due to a Julia update. I just wanted to inform y'all of this bug.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/issues/3412:32219,Integrability,message,message,32219,"tepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:119; [18] launch!; @ ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:90 [inlined]; [19] #compute_interior_tendency_contributions!#17; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:122 [inlined]; [20] compute_interior_tendency_contributions!; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:53 [inlined]; ```; Sorry for the length, I also had to remove some of the error message so GitHub would let me post it so feel free to let me know if you need to see more. I was able to fix the code by updating the function formatting from ; ``` @inline constant_stratification(x, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3]) ```; to; ``` @inline constant_stratification(x, y, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3])```; after consulting colleagues and was told this was due to a Julia update. I just wanted to inform y'all of this bug.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412
https://github.com/CliMA/Oceananigans.jl/pull/3413:187,Energy Efficiency,adapt,adapt,187,This PR fixes a bug that (apparently) crept in on #3401 --- I think. It's hard to know for sure because GPU tests don't pass right now. There may be more to fix. @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. @wsmoses @jlk9 we may need this to pass for your test PRs to be useful. @navidcy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413
https://github.com/CliMA/Oceananigans.jl/pull/3413:187,Modifiability,adapt,adapt,187,This PR fixes a bug that (apparently) crept in on #3401 --- I think. It's hard to know for sure because GPU tests don't pass right now. There may be more to fix. @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. @wsmoses @jlk9 we may need this to pass for your test PRs to be useful. @navidcy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413
https://github.com/CliMA/Oceananigans.jl/pull/3413:108,Testability,test,tests,108,This PR fixes a bug that (apparently) crept in on #3401 --- I think. It's hard to know for sure because GPU tests don't pass right now. There may be more to fix. @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. @wsmoses @jlk9 we may need this to pass for your test PRs to be useful. @navidcy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413
https://github.com/CliMA/Oceananigans.jl/pull/3413:258,Testability,test,tests,258,This PR fixes a bug that (apparently) crept in on #3401 --- I think. It's hard to know for sure because GPU tests don't pass right now. There may be more to fix. @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. @wsmoses @jlk9 we may need this to pass for your test PRs to be useful. @navidcy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413
https://github.com/CliMA/Oceananigans.jl/pull/3413:355,Testability,test,test,355,This PR fixes a bug that (apparently) crept in on #3401 --- I think. It's hard to know for sure because GPU tests don't pass right now. There may be more to fix. @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. @wsmoses @jlk9 we may need this to pass for your test PRs to be useful. @navidcy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413
https://github.com/CliMA/Oceananigans.jl/issues/3415:1878,Testability,log,log,1878,"d,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1seconds, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. Here's the output log of the script:; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 74.284 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: ... simulation initialization complete (72.159 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (92.717 ms).; i: 1, t: 100 ms, wall time: 96.815 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.25, 0.5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: Simulation is stopping after running for 171.290 ms.; [ Info: Model iteration 2 equals or exceeds stop iteration 2.; i: 2, t: 200 ms, wall time: 2.341 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.25, 0.5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415
https://github.com/CliMA/Oceananigans.jl/issues/3415:3630,Testability,log,log,3630,"5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: Simulation is stopping after running for 171.290 ms.; [ Info: Model iteration 2 equals or exceeds stop iteration 2.; i: 2, t: 200 ms, wall time: 2.341 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.25, 0.5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; ```. We see that the particles with x- and y- coordinates larger than 0.5 get moved after the first time step when I think it shouldn't be. This is because of the following lines:; https://github.com/CliMA/Oceananigans.jl/blob/3e2650373e9c73231681535aadb5b720a830dc97/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L102C4-L104C27. Instead of ; ```julia; iᴿ = length(f, tx, Nx); jᴿ = length(f, ty, Ny); kᴿ = length(f, tz, Nz); ```; I think it should be ; ```julia; iᴿ = length(f, tx, Nx) + ifelse(tx == Periodic(), 1, 0); jᴿ = length(f, ty, Ny) + ifelse(ty == Periodic(), 1, 0); kᴿ = length(f, tz, Nz) + ifelse(tz == Periodic(), 1, 0); ```; The change gives an output log of; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 59.256 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: ... simulation initialization complete (58.949 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (86.845 ms).; i: 1, t: 100 ms, wall time: 91.015 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: Simulation is stopping after running for 152.524 ms.; [ Info: Model iteration 2 equals or exceeds stop iteration 2.; i: 2, t: 200 ms, wall time: 3.068 ms, max(u)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415
https://github.com/CliMA/Oceananigans.jl/issues/3415:489,Usability,Simpl,SimpleParticle,489,"I noticed that in the `Periodic` directions, particles that have coordinates within the last cell at the end of the domain get moved into the first cell when I think it should not be. Here's a MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using StructArrays; using Printf; using Random; using Statistics. grid = RectilinearGrid(CPU(), Float64,; size = (2, 2, 2),; halo = (5, 5, 5),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. n_particles = 5; x_particle = collect(range(0, stop=1, length=n_particles)); y_particle = collect(range(0, stop=1, length=n_particles)); z_particle = collect(fill(-0.5, n_particles)). particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1seconds, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. Here's the output log of the script:; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 74.284 ms, max(u): (0.000e+00, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415
https://github.com/CliMA/Oceananigans.jl/issues/3415:745,Usability,Simpl,SimpleParticle,745,"I noticed that in the `Periodic` directions, particles that have coordinates within the last cell at the end of the domain get moved into the first cell when I think it should not be. Here's a MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using StructArrays; using Printf; using Random; using Statistics. grid = RectilinearGrid(CPU(), Float64,; size = (2, 2, 2),; halo = (5, 5, 5),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. n_particles = 5; x_particle = collect(range(0, stop=1, length=n_particles)); y_particle = collect(range(0, stop=1, length=n_particles)); z_particle = collect(fill(-0.5, n_particles)). particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1seconds, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. Here's the output log of the script:; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 74.284 ms, max(u): (0.000e+00, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415
https://github.com/CliMA/Oceananigans.jl/issues/3422:1076,Security,validat,validation,1076,"The docstring example for three-dimensional Stokes drift can be improved:. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/StokesDrifts.jl#L219-L226. The `v`-component (for example) is associated with a Stokes drift `vS` of the form:. ```julia; vS = p.Uˢ * exp(z / p.h) * cos(p.k * x) * sin(t); ```. For this to represent a real surface wave field, then it would have to be sinusoidally oscillating in time (hard to imagine). Also, the envelope of the surface drift is modulated in space by `cos(k * x)`. Unfortunately, this is quite confusing because `k` is typically used to represent the wavelength of the _surface wave field_ (not the envelope of the surface waves). For example, for a monochromatic wave field, `h = 2k` is the vertical scale of the Stokes drift. So in this example, `k` has a different meaning (governing the wave field envelope) then it normally does (the wavenumber of the underlying wave field). A better docstring example might represent a wavepacket that is translating at the group velocity, as done in a validation case:. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/surface_wave_quasi_geostrophic_flow.jl#L5-L51",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3422
https://github.com/CliMA/Oceananigans.jl/issues/3422:1181,Security,validat,validation,1181,"The docstring example for three-dimensional Stokes drift can be improved:. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/StokesDrifts.jl#L219-L226. The `v`-component (for example) is associated with a Stokes drift `vS` of the form:. ```julia; vS = p.Uˢ * exp(z / p.h) * cos(p.k * x) * sin(t); ```. For this to represent a real surface wave field, then it would have to be sinusoidally oscillating in time (hard to imagine). Also, the envelope of the surface drift is modulated in space by `cos(k * x)`. Unfortunately, this is quite confusing because `k` is typically used to represent the wavelength of the _surface wave field_ (not the envelope of the surface waves). For example, for a monochromatic wave field, `h = 2k` is the vertical scale of the Stokes drift. So in this example, `k` has a different meaning (governing the wave field envelope) then it normally does (the wavenumber of the underlying wave field). A better docstring example might represent a wavepacket that is translating at the group velocity, as done in a validation case:. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/surface_wave_quasi_geostrophic_flow.jl#L5-L51",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3422
https://github.com/CliMA/Oceananigans.jl/issues/3427:702,Availability,ERROR,ERROR,702,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:725,Availability,error,error,725,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:3790,Availability,mask,mask,3790,":Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:340; [19] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line 20 is the last line of the code snippet above (`maximum(abs, v)`). Here's the Julia version info:; ```; Julia Version 1.10.0; Commit 3120989f39b (2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:3969,Availability,mask,mask,3969,"ckages/CUDA/35NC6/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line 20 is the last line of the code snippet above (`maximum(abs, v)`). Here's the Julia version info:; ```; Julia Version 1.10.0; Commit 3120989f39b (2023-12-25 18:01 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × Intel(R) Xeon(R) Silver 4214 CPU @",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:5778,Availability,avail,available,5778,"elds ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line 20 is the last line of the code snippet above (`maximum(abs, v)`). Here's the Julia version info:; ```; Julia Version 1.10.0; Commit 3120989f39b (2023-12-25 18:01 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, cascadelake); Threads: 1 on 48 virtual cores; ```. Here's the CUDA runtime version:; ```; CUDA runtime 11.8, artifact installation; CUDA driver 11.8; NVIDIA driver 520.61.5. CUDA libraries:; - CUBLAS: 11.11.3; - CURAND: 10.3.0; - CUFFT: 10.9.0; - CUSOLVER: 11.4.1; - CUSPARSE: 11.7.5; - CUPTI: 18.0.0; - NVML: 11.0.0+520.61.5. Julia packages:; - CUDA: 4.4.1; - CUDA_Driver_jll: 0.5.0+1; - CUDA_Runtime_jll: 0.6.0+0. Toolchain:; - Julia: 1.10.0; - LLVM: 15.0.7; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0, 7.1, 7.2, 7.3, 7.4, 7.5; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80, sm_86. 1 device:; 0: NVIDIA TITAN V (sm_70, 9.027 GiB / 12.000 GiB available); ```. In Julia 1.9 this does not seem to be a problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:77,Deployability,upgrade,upgrade,77,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:4860,Deployability,release,release,4860,"elds ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line 20 is the last line of the code snippet above (`maximum(abs, v)`). Here's the Julia version info:; ```; Julia Version 1.10.0; Commit 3120989f39b (2023-12-25 18:01 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, cascadelake); Threads: 1 on 48 virtual cores; ```. Here's the CUDA runtime version:; ```; CUDA runtime 11.8, artifact installation; CUDA driver 11.8; NVIDIA driver 520.61.5. CUDA libraries:; - CUBLAS: 11.11.3; - CURAND: 10.3.0; - CUFFT: 10.9.0; - CUSOLVER: 11.4.1; - CUSPARSE: 11.7.5; - CUPTI: 18.0.0; - NVML: 11.0.0+520.61.5. Julia packages:; - CUDA: 4.4.1; - CUDA_Driver_jll: 0.5.0+1; - CUDA_Runtime_jll: 0.6.0+0. Toolchain:; - Julia: 1.10.0; - LLVM: 15.0.7; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0, 7.1, 7.2, 7.3, 7.4, 7.5; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80, sm_86. 1 device:; 0: NVIDIA TITAN V (sm_70, 9.027 GiB / 12.000 GiB available); ```. In Julia 1.9 this does not seem to be a problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:5151,Deployability,install,installation,5151,"elds ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line 20 is the last line of the code snippet above (`maximum(abs, v)`). Here's the Julia version info:; ```; Julia Version 1.10.0; Commit 3120989f39b (2023-12-25 18:01 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, cascadelake); Threads: 1 on 48 virtual cores; ```. Here's the CUDA runtime version:; ```; CUDA runtime 11.8, artifact installation; CUDA driver 11.8; NVIDIA driver 520.61.5. CUDA libraries:; - CUBLAS: 11.11.3; - CURAND: 10.3.0; - CUFFT: 10.9.0; - CUSOLVER: 11.4.1; - CUSPARSE: 11.7.5; - CUPTI: 18.0.0; - NVML: 11.0.0+520.61.5. Julia packages:; - CUDA: 4.4.1; - CUDA_Driver_jll: 0.5.0+1; - CUDA_Runtime_jll: 0.6.0+0. Toolchain:; - Julia: 1.10.0; - LLVM: 15.0.7; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0, 7.1, 7.2, 7.3, 7.4, 7.5; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80, sm_86. 1 device:; 0: NVIDIA TITAN V (sm_70, 9.027 GiB / 12.000 GiB available); ```. In Julia 1.9 this does not seem to be a problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:3641,Energy Efficiency,reduce,reducedim,3641,"{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:340; [19] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:709,Performance,Load,LoadError,709,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3427:338,Testability,test,tested,338,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427
https://github.com/CliMA/Oceananigans.jl/issues/3432:193,Deployability,update,update,193,At the moment the docs only mention the uniform unidirectional Stokes drift implementation . https://clima.github.io/OceananigansDocumentation/stable/physics/surface_gravity_waves/. We need to update the docs to take into account the 3D Stokes implementation that was introduced with #3384. cc @BrodiePearson @glwagner @LeeAra0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3432
https://github.com/CliMA/Oceananigans.jl/issues/3438:667,Availability,error,error,667,"I'd like to use the [Lambert W function](https://github.com/JuliaMath/LambertW.jl) in a `KernelFunctionOperation` but it doesn't seem to work on the GPU. Here's a MWE that works on the CPU:. ```julia; using Oceananigans; using Oceananigans.Grids: xnode, ynode; using CUDA: has_cuda_gpu; using LambertW: lambertw. arch = has_cuda_gpu() ? GPU() : CPU(); grid = RectilinearGrid(arch, size = (4, 4, 4), extent = (1,1,1)). @inline W(x, y) = lambertw((y/x)^2); @inline W(i, j, k, grid) = W(xnode(i, grid, Center()), ynode(j, grid, Center())); op = KernelFunctionOperation{Center, Center, Center}(W, grid); compute!(Field(op)); ```. When running on a GPU this throws a huge error message, that you can check in full [here](https://github.com/CliMA/Oceananigans.jl/files/14013534/error.txt), but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438
https://github.com/CliMA/Oceananigans.jl/issues/3438:772,Availability,error,error,772,"I'd like to use the [Lambert W function](https://github.com/JuliaMath/LambertW.jl) in a `KernelFunctionOperation` but it doesn't seem to work on the GPU. Here's a MWE that works on the CPU:. ```julia; using Oceananigans; using Oceananigans.Grids: xnode, ynode; using CUDA: has_cuda_gpu; using LambertW: lambertw. arch = has_cuda_gpu() ? GPU() : CPU(); grid = RectilinearGrid(arch, size = (4, 4, 4), extent = (1,1,1)). @inline W(x, y) = lambertw((y/x)^2); @inline W(i, j, k, grid) = W(xnode(i, grid, Center()), ynode(j, grid, Center())); op = KernelFunctionOperation{Center, Center, Center}(W, grid); compute!(Field(op)); ```. When running on a GPU this throws a huge error message, that you can check in full [here](https://github.com/CliMA/Oceananigans.jl/files/14013534/error.txt), but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438
https://github.com/CliMA/Oceananigans.jl/issues/3438:824,Availability,ERROR,ERROR,824,"I'd like to use the [Lambert W function](https://github.com/JuliaMath/LambertW.jl) in a `KernelFunctionOperation` but it doesn't seem to work on the GPU. Here's a MWE that works on the CPU:. ```julia; using Oceananigans; using Oceananigans.Grids: xnode, ynode; using CUDA: has_cuda_gpu; using LambertW: lambertw. arch = has_cuda_gpu() ? GPU() : CPU(); grid = RectilinearGrid(arch, size = (4, 4, 4), extent = (1,1,1)). @inline W(x, y) = lambertw((y/x)^2); @inline W(i, j, k, grid) = W(xnode(i, grid, Center()), ynode(j, grid, Center())); op = KernelFunctionOperation{Center, Center, Center}(W, grid); compute!(Field(op)); ```. When running on a GPU this throws a huge error message, that you can check in full [here](https://github.com/CliMA/Oceananigans.jl/files/14013534/error.txt), but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438
https://github.com/CliMA/Oceananigans.jl/issues/3438:2516,Availability,error,error,2516,", but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.get_pgcstack); Stacktrace:; [1] multiple call sites; @ unknown:0; Reason: unsupported call through a literal pointer (call to jl_gc_run_pending_finalizers); Stacktrace:; [1] enable_finalizers; @ ./gcutils.jl:126; [2] _trylock; @ ./lock.jl:133; [3] multiple call sites; @ unknown:0; Reason: unsupported dynamic function invocation (call to kwcall(::Any, ::typeof(sprint), f::Function, args...) @ Base strings/io.jl:107); ```. I imagine `lambertw` isn't implemented by CUDA, but that doesn't seem to be what the error says, so I wonder if there's something else going on here. I also saw that [ClimaAtmos seems to be one of the packages that use `LambertW.jl`](https://juliapackages.com/p/lambertw), so maybe the Clima people have encountered (and hopefully solved) this before?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438
https://github.com/CliMA/Oceananigans.jl/issues/3438:673,Integrability,message,message,673,"I'd like to use the [Lambert W function](https://github.com/JuliaMath/LambertW.jl) in a `KernelFunctionOperation` but it doesn't seem to work on the GPU. Here's a MWE that works on the CPU:. ```julia; using Oceananigans; using Oceananigans.Grids: xnode, ynode; using CUDA: has_cuda_gpu; using LambertW: lambertw. arch = has_cuda_gpu() ? GPU() : CPU(); grid = RectilinearGrid(arch, size = (4, 4, 4), extent = (1,1,1)). @inline W(x, y) = lambertw((y/x)^2); @inline W(i, j, k, grid) = W(xnode(i, grid, Center()), ynode(j, grid, Center())); op = KernelFunctionOperation{Center, Center, Center}(W, grid); compute!(Field(op)); ```. When running on a GPU this throws a huge error message, that you can check in full [here](https://github.com/CliMA/Oceananigans.jl/files/14013534/error.txt), but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438
https://github.com/CliMA/Oceananigans.jl/issues/3438:831,Performance,Load,LoadError,831,"I'd like to use the [Lambert W function](https://github.com/JuliaMath/LambertW.jl) in a `KernelFunctionOperation` but it doesn't seem to work on the GPU. Here's a MWE that works on the CPU:. ```julia; using Oceananigans; using Oceananigans.Grids: xnode, ynode; using CUDA: has_cuda_gpu; using LambertW: lambertw. arch = has_cuda_gpu() ? GPU() : CPU(); grid = RectilinearGrid(arch, size = (4, 4, 4), extent = (1,1,1)). @inline W(x, y) = lambertw((y/x)^2); @inline W(i, j, k, grid) = W(xnode(i, grid, Center()), ynode(j, grid, Center())); op = KernelFunctionOperation{Center, Center, Center}(W, grid); compute!(Field(op)); ```. When running on a GPU this throws a huge error message, that you can check in full [here](https://github.com/CliMA/Oceananigans.jl/files/14013534/error.txt), but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438
https://github.com/CliMA/Oceananigans.jl/issues/3439:1261,Availability,error,error,1261,"discussions/3423#discussioncomment-8115603 and I dug into it a bit more since then but so far haven't been able to solve it. ```julia; using Oceananigans. grid_base = RectilinearGrid(CPU(), size = (4, 4, 4), extent = (1,1,1)). # The lines immediately below work; using Oceananigans.Grids: boundary_node; boundary_node_ccf = KernelFunctionOperation{Center, Center, Face}(boundary_node, grid_base, Center(), Center(), Face()); c = CenterField(grid_base); compute!(Field(Average(c, condition=(boundary_node_ccf .== true)))). # The last line here doesn't work; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1/2)); c_ib = CenterField(grid); compute!(Field(Average(c_ib, condition=(boundary_node_ccf .== true)))); ```. The first computation above (which doesn't use any immersed boundaries) works, although it's odd that I have to set `condition=(boundary_node_ccf .== true)`, since it fails if I simply set `condition=boundary_node_ccf`. However, the last line, which does use `ImmersedBoundaryGrid`s, fails with the following error:. ```; ERROR: LoadError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Functio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:1274,Availability,ERROR,ERROR,1274,"haven't been able to solve it. ```julia; using Oceananigans. grid_base = RectilinearGrid(CPU(), size = (4, 4, 4), extent = (1,1,1)). # The lines immediately below work; using Oceananigans.Grids: boundary_node; boundary_node_ccf = KernelFunctionOperation{Center, Center, Face}(boundary_node, grid_base, Center(), Center(), Face()); c = CenterField(grid_base); compute!(Field(Average(c, condition=(boundary_node_ccf .== true)))). # The last line here doesn't work; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1/2)); c_ib = CenterField(grid); compute!(Field(Average(c_ib, condition=(boundary_node_ccf .== true)))); ```. The first computation above (which doesn't use any immersed boundaries) works, although it's odd that I have to set `condition=(boundary_node_ccf .== true)`, since it fails if I simply set `condition=boundary_node_ccf`. However, the last line, which does use `ImmersedBoundaryGrid`s, fails with the following error:. ```; ERROR: LoadError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Function, operand::Oceananigans.Fields.AbstractField, condition::AbstractArray, mask); @ Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:2293,Availability,mask,mask,2293,"adError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Function, operand::Oceananigans.Fields.AbstractField, condition::AbstractArray, mask); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/AbstractOperations/conditional_operations.jl:96; condition_operand(func::Function, op::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, cond, mask); @ Oceananigans.ImmersedBoundaries /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/ImmersedBoundaries/immersed_reductions.jl:18. Possible fix, define; condition_operand(::Function, ::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, ::AbstractArray, ::Any). Stacktrace:; [1] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:2565,Availability,mask,mask,2565,"Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Function, operand::Oceananigans.Fields.AbstractField, condition::AbstractArray, mask); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/AbstractOperations/conditional_operations.jl:96; condition_operand(func::Function, op::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, cond, mask); @ Oceananigans.ImmersedBoundaries /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/ImmersedBoundaries/immersed_reductions.jl:18. Possible fix, define; condition_operand(::Function, ::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, ::AbstractArray, ::Any). Stacktrace:; [1] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetM",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:3723,Availability,mask,mask,3723,"tion_operand(::Function, ::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, ::AbstractArray, ::Any). Stacktrace:; [1] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; condition::Array{Bool, 3}, mask::Int64, dims::Tuple{Int64, Int64, Int64}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:643; [2] sum(c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:4761,Availability,mask,mask,4761,"); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:643; [2] sum(c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{Array{Bool, 3}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:654; [3] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:6390,Availability,mask,mask,6390,"CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{Array{Bool, 3}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:654; [3] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Array{Bool, 3}, mask::Int64, dims::Function); ```. I imagine fixing it would only take one extra method definition (as suggested by the error message), but I haven't been able to figure it out so far :grimacing:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:6510,Availability,error,error,6510,"CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{Array{Bool, 3}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:654; [3] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Array{Bool, 3}, mask::Int64, dims::Function); ```. I imagine fixing it would only take one extra method definition (as suggested by the error message), but I haven't been able to figure it out so far :grimacing:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:6516,Integrability,message,message,6516,"CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{Array{Bool, 3}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:654; [3] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Array{Bool, 3}, mask::Int64, dims::Function); ```. I imagine fixing it would only take one extra method definition (as suggested by the error message), but I haven't been able to figure it out so far :grimacing:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:1281,Performance,Load,LoadError,1281,"haven't been able to solve it. ```julia; using Oceananigans. grid_base = RectilinearGrid(CPU(), size = (4, 4, 4), extent = (1,1,1)). # The lines immediately below work; using Oceananigans.Grids: boundary_node; boundary_node_ccf = KernelFunctionOperation{Center, Center, Face}(boundary_node, grid_base, Center(), Center(), Face()); c = CenterField(grid_base); compute!(Field(Average(c, condition=(boundary_node_ccf .== true)))). # The last line here doesn't work; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1/2)); c_ib = CenterField(grid); compute!(Field(Average(c_ib, condition=(boundary_node_ccf .== true)))); ```. The first computation above (which doesn't use any immersed boundaries) works, although it's odd that I have to set `condition=(boundary_node_ccf .== true)`, since it fails if I simply set `condition=boundary_node_ccf`. However, the last line, which does use `ImmersedBoundaryGrid`s, fails with the following error:. ```; ERROR: LoadError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Function, operand::Oceananigans.Fields.AbstractField, condition::AbstractArray, mask); @ Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/issues/3439:1130,Usability,simpl,simply,1130,"undaryGrid`s. This originally popped up in https://github.com/CliMA/Oceananigans.jl/discussions/3423#discussioncomment-8115603 and I dug into it a bit more since then but so far haven't been able to solve it. ```julia; using Oceananigans. grid_base = RectilinearGrid(CPU(), size = (4, 4, 4), extent = (1,1,1)). # The lines immediately below work; using Oceananigans.Grids: boundary_node; boundary_node_ccf = KernelFunctionOperation{Center, Center, Face}(boundary_node, grid_base, Center(), Center(), Face()); c = CenterField(grid_base); compute!(Field(Average(c, condition=(boundary_node_ccf .== true)))). # The last line here doesn't work; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1/2)); c_ib = CenterField(grid); compute!(Field(Average(c_ib, condition=(boundary_node_ccf .== true)))); ```. The first computation above (which doesn't use any immersed boundaries) works, although it's odd that I have to set `condition=(boundary_node_ccf .== true)`, since it fails if I simply set `condition=boundary_node_ccf`. However, the last line, which does use `ImmersedBoundaryGrid`s, fails with the following error:. ```; ERROR: LoadError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439
https://github.com/CliMA/Oceananigans.jl/pull/3440:36,Availability,error,error,36,"This PR fixes an ""ambiguous method"" error that happens when trying to calculate an `Average()` (probably any reduction) with a given `condition` on `ImmersedBoundaryGrids`. Thanks to @glwagner for helping me find the proper method definition. Closes https://github.com/CliMA/Oceananigans.jl/issues/3439",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3440
https://github.com/CliMA/Oceananigans.jl/issues/3442:152,Availability,error,error,152,"Just as in the title the function Label calls initialize_block and gives the ""no method matching initialize_block!(::label; fontsize::Int64) giving the error; got unsupported keyword argument ""fontsize""; Kevin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442
https://github.com/CliMA/Oceananigans.jl/pull/3454:11,Deployability,update,updates,11,This PR. - updates Docs/Grids page; - updates Docs/Architectures page; - updates Docs/Number types page; - resurrects the Docs/Callbacks page. Closes #3275; Closes #3456,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3454
https://github.com/CliMA/Oceananigans.jl/pull/3454:38,Deployability,update,updates,38,This PR. - updates Docs/Grids page; - updates Docs/Architectures page; - updates Docs/Number types page; - resurrects the Docs/Callbacks page. Closes #3275; Closes #3456,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3454
https://github.com/CliMA/Oceananigans.jl/pull/3454:73,Deployability,update,updates,73,This PR. - updates Docs/Grids page; - updates Docs/Architectures page; - updates Docs/Number types page; - resurrects the Docs/Callbacks page. Closes #3275; Closes #3456,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3454
https://github.com/CliMA/Oceananigans.jl/issues/3455:1318,Availability,error,error,1318,"locities`:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: KernelFunctionOperation; using Oceananigans.Fields: @compute. grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));. model = NonhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Also if I bypass tuples altogether the result seems to be correct:. ```julia; julia> @inline ufunc2(i, j, k, grid, u) = u[i, j, k];. julia> u′ = model.velocities.u - Field(Average(model.velocities.u));. julia> @compute f3 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc2, model.grid, u′));. julia> interior(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455
https://github.com/CliMA/Oceananigans.jl/issues/3455:1471,Integrability,wrap,wrap,1471," extent = (1,1,1));. model = NonhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Also if I bypass tuples altogether the result seems to be correct:. ```julia; julia> @inline ufunc2(i, j, k, grid, u) = u[i, j, k];. julia> u′ = model.velocities.u - Field(Average(model.velocities.u));. julia> @compute f3 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc2, model.grid, u′));. julia> interior(f3); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Are KFOs meant to be used only wi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455
https://github.com/CliMA/Oceananigans.jl/issues/3455:1602,Integrability,wrap,wrapping,1602,"nhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Also if I bypass tuples altogether the result seems to be correct:. ```julia; julia> @inline ufunc2(i, j, k, grid, u) = u[i, j, k];. julia> u′ = model.velocities.u - Field(Average(model.velocities.u));. julia> @compute f3 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc2, model.grid, u′));. julia> interior(f3); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Are KFOs meant to be used only with `Field`s? Or is this a bug?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455
https://github.com/CliMA/Oceananigans.jl/issues/3455:132,Modifiability,variab,variables,132,"I noticed that when I pass a `NamedTuple` to a `KernelFunctionOperation`, it'll generally give me an incorrect result if one of the variables used in the calculation is in the tuple and it's an operation. Here's a MWE where I'm creating a model with a constant `u=2`, setting up a simple KFO that returns `u` from `velocities`:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: KernelFunctionOperation; using Oceananigans.Fields: @compute. grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));. model = NonhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Als",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455
https://github.com/CliMA/Oceananigans.jl/issues/3455:281,Usability,simpl,simple,281,"I noticed that when I pass a `NamedTuple` to a `KernelFunctionOperation`, it'll generally give me an incorrect result if one of the variables used in the calculation is in the tuple and it's an operation. Here's a MWE where I'm creating a model with a constant `u=2`, setting up a simple KFO that returns `u` from `velocities`:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: KernelFunctionOperation; using Oceananigans.Fields: @compute. grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));. model = NonhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Als",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455
https://github.com/CliMA/Oceananigans.jl/pull/3458:81,Testability,test,tests,81,See https://github.com/CliMA/Oceananigans.jl/discussions/3457. Made PR to see if tests will pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3458
https://github.com/CliMA/Oceananigans.jl/issues/3459:9001,Availability,error,error,9001,", y, z) = U∞ + 1e-5 * Ξ(z). ## Vertical velocity initial condition: random noise scaled by the friction velocity.; wᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z). Tᵢ(x, y, z) = T0(z) + dTdz * model.grid.Lz * 1e-6 * Ξ(z). ## `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=S₀); ```; When I tried to output `model.pressures.prapid`, I got:. ```julia; 100×100×48 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 100×100×48 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 106×106×54 OffsetArray(::Array{Float64, 3}, -2:103, -2:103, -2:51) with eltype Float64 with indices -2:103×-2:103×-2:51; └── max=NaN, min=NaN, mean=NaN; ```; The NaN value appears. But for $p_{NHS}$ and $p_{HY'}$, the results are reasonable. So any comments or ideas about this error? . Another issue is about the calculation of the pressure terms for which the boundary conditions are inhomogeneous Neumann boundary conditions ($p_b'$, $p_{st}'$ and $p_{sg}'$, see Appendix A for details in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). For this issue, I have checked the related issue #1232. I wanna ask do I need to subtly update the boundary values of $p_b'$, $p_{st}'$ and $p_{sg}'$ to convert the inhomogeneous Neumann problem to the homogeneous Neumann problem? If so, how do I determine the values the boundary should update?. I hope I've described this issue clearly, but please let me know if anything confuse you. In addition, this is my first attempt to make a possible contribution to an open source project, and I would like to ask what is the most efficient way to conduct the discussion? Should we talk about this he",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459
https://github.com/CliMA/Oceananigans.jl/issues/3459:9481,Deployability,update,update,9481,", z) = T0(z) + dTdz * model.grid.Lz * 1e-6 * Ξ(z). ## `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=S₀); ```; When I tried to output `model.pressures.prapid`, I got:. ```julia; 100×100×48 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 100×100×48 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 106×106×54 OffsetArray(::Array{Float64, 3}, -2:103, -2:103, -2:51) with eltype Float64 with indices -2:103×-2:103×-2:51; └── max=NaN, min=NaN, mean=NaN; ```; The NaN value appears. But for $p_{NHS}$ and $p_{HY'}$, the results are reasonable. So any comments or ideas about this error? . Another issue is about the calculation of the pressure terms for which the boundary conditions are inhomogeneous Neumann boundary conditions ($p_b'$, $p_{st}'$ and $p_{sg}'$, see Appendix A for details in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). For this issue, I have checked the related issue #1232. I wanna ask do I need to subtly update the boundary values of $p_b'$, $p_{st}'$ and $p_{sg}'$ to convert the inhomogeneous Neumann problem to the homogeneous Neumann problem? If so, how do I determine the values the boundary should update?. I hope I've described this issue clearly, but please let me know if anything confuse you. In addition, this is my first attempt to make a possible contribution to an open source project, and I would like to ask what is the most efficient way to conduct the discussion? Should we talk about this here firstly or can I start with a PR to better let you know what specific changes I've made to the code?. Thank you very much for any comments, suggestions or ideas!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459
https://github.com/CliMA/Oceananigans.jl/issues/3459:9681,Deployability,update,update,9681,", z) = T0(z) + dTdz * model.grid.Lz * 1e-6 * Ξ(z). ## `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=S₀); ```; When I tried to output `model.pressures.prapid`, I got:. ```julia; 100×100×48 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 100×100×48 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 106×106×54 OffsetArray(::Array{Float64, 3}, -2:103, -2:103, -2:51) with eltype Float64 with indices -2:103×-2:103×-2:51; └── max=NaN, min=NaN, mean=NaN; ```; The NaN value appears. But for $p_{NHS}$ and $p_{HY'}$, the results are reasonable. So any comments or ideas about this error? . Another issue is about the calculation of the pressure terms for which the boundary conditions are inhomogeneous Neumann boundary conditions ($p_b'$, $p_{st}'$ and $p_{sg}'$, see Appendix A for details in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). For this issue, I have checked the related issue #1232. I wanna ask do I need to subtly update the boundary values of $p_b'$, $p_{st}'$ and $p_{sg}'$ to convert the inhomogeneous Neumann problem to the homogeneous Neumann problem? If so, how do I determine the values the boundary should update?. I hope I've described this issue clearly, but please let me know if anything confuse you. In addition, this is my first attempt to make a possible contribution to an open source project, and I would like to ask what is the most efficient way to conduct the discussion? Should we talk about this here firstly or can I start with a PR to better let you know what specific changes I've made to the code?. Thank you very much for any comments, suggestions or ideas!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459
https://github.com/CliMA/Oceananigans.jl/issues/3459:9918,Energy Efficiency,efficient,efficient,9918,", z) = T0(z) + dTdz * model.grid.Lz * 1e-6 * Ξ(z). ## `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=S₀); ```; When I tried to output `model.pressures.prapid`, I got:. ```julia; 100×100×48 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 100×100×48 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 106×106×54 OffsetArray(::Array{Float64, 3}, -2:103, -2:103, -2:51) with eltype Float64 with indices -2:103×-2:103×-2:51; └── max=NaN, min=NaN, mean=NaN; ```; The NaN value appears. But for $p_{NHS}$ and $p_{HY'}$, the results are reasonable. So any comments or ideas about this error? . Another issue is about the calculation of the pressure terms for which the boundary conditions are inhomogeneous Neumann boundary conditions ($p_b'$, $p_{st}'$ and $p_{sg}'$, see Appendix A for details in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). For this issue, I have checked the related issue #1232. I wanna ask do I need to subtly update the boundary values of $p_b'$, $p_{st}'$ and $p_{sg}'$ to convert the inhomogeneous Neumann problem to the homogeneous Neumann problem? If so, how do I determine the values the boundary should update?. I hope I've described this issue clearly, but please let me know if anything confuse you. In addition, this is my first attempt to make a possible contribution to an open source project, and I would like to ask what is the most efficient way to conduct the discussion? Should we talk about this here firstly or can I start with a PR to better let you know what specific changes I've made to the code?. Thank you very much for any comments, suggestions or ideas!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459
https://github.com/CliMA/Oceananigans.jl/issues/3459:715,Modifiability,parameteriz,parameterizations,715,"Hello everyone,. I'm trying to calculate the pressure terms shown in the following figure (Eq.(2.5) from [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)):. ![4031706602798_ pic](https://github.com/CliMA/Oceananigans.jl/assets/112752688/4672fa09-2fa1-4302-8c33-684cefe3612c). The equation in the above figure I think is another form of writing the pressure equation to maintain incompressibility, but different from the common way ($p = p_{HY'}+ p_{NHS}$), it may provide new insights into how different processes contribute to pressures and help to improve second-moment vertical mixing parameterizations, which is the motivation that I want to calculate them. What I'm trying to do is write the code that repeats the pressure solver algorithm for non-hydrostatic pressure (cause this is also an elliptic problem I think) to calculate the terms in the above equation, and re-run the pressure solver separately for each of these new terms. Lastly, I want to save these new pressure terms in a way that will not overwrite the original pressures. . I tried to start with the second term ($p_r'$) in the RHS of the equation. This term is the component that results from rapid distortion by the current shear. For this term, the vertical boundary condition is $\partial p_r' / \partial x_3 = 0$ (see more details about boundary conditions in Appendix A in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). So the goal is to solve an equation $\nabla^2p_r' = -2\frac{\partial U_i}{\partial x_j}\frac{\partial u_j'}{\partial x_i}$ with applying the boundary condition $\partial p_r' / \partial x_3 = 0$. I have written a part of the code (I start from the calculation of $p_r'$ because there is no need to consider the boundary conditions, and the calc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459
https://github.com/CliMA/Oceananigans.jl/issues/3459:2079,Testability,test,tested,2079," way that will not overwrite the original pressures. . I tried to start with the second term ($p_r'$) in the RHS of the equation. This term is the component that results from rapid distortion by the current shear. For this term, the vertical boundary condition is $\partial p_r' / \partial x_3 = 0$ (see more details about boundary conditions in Appendix A in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). So the goal is to solve an equation $\nabla^2p_r' = -2\frac{\partial U_i}{\partial x_j}\frac{\partial u_j'}{\partial x_i}$ with applying the boundary condition $\partial p_r' / \partial x_3 = 0$. I have written a part of the code (I start from the calculation of $p_r'$ because there is no need to consider the boundary conditions, and the calculation I think can directly follow the calculation of $p_{NHS}$). Now I have tested it on the CPU, and output the pressure (I call it “prapid” in my code) like ```model.pressures.prapid ```, but there are also some problems. I add part of the code in [https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/solve_for_pressure.jl](url) following the cacluation of $p_{NHS}$ like: . ```julia; @kernel function calculate_pressure_source_term_fft_based_solver_rapid!(rhs, grid, Δt, U★); i, j, k = @index(Global, NTuple); U = Field(Average(U★.u, dims=(1, 2))); V = Field(Average(U★.v, dims=(1, 2))); W = Field(Average(U★.w, dims=(1, 2))); u_prime = Field(U★.u - U); v_prime = Field(U★.v - V); w_prime = Field(U★.w - W). @inbounds rhs[i, j, k] = -2*( ∂xᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂xᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂x",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459
https://github.com/CliMA/Oceananigans.jl/issues/3459:6202,Testability,log,log,6202,"lver.storage)); arch = architecture(solver); grid = solver.local_grid. launch!(arch, grid, :xyz, calculate_permuted_pressure_source_term_fft_based_solver_rapid!,; rhs, grid, Δt, U★, solver.input_permutation,). # Solve pressure Poisson equation for pressure, given rhs; solve!(pressure, solver). return pressure; end; ```. I tried to run it on CPU (Oceananigans v0.84.1 & Julia v1.8.4) like (A simple case of Langmuir turbulence case in a shallow water):. ```julia; using Oceananigans; using Printf; using Oceananigans.Units. # Grid; const H = 30; grid = RectilinearGrid(GPU();; size = (100, 100, 48),; halo = (3, 3, 3),; x = (0, 2π*H),; y = (0, 2π*H),; z = (-H, 0)); # Buoyancy; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=2e-4, haline_contraction=8e-4)). # Surface boundary conditions; u₁₀ = 10 ; cᴰ = 1.25e-3 ; ρₐ = 1.225 ; ρₒ = 1026.0 ; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) . # Bottom boundary conditions; z₀ = 0.01; κ = 0.4 ; z₁ = grid.Δzᵃᵃᶠ/2 ; cᴰ = (κ / log(z₁ / z₀))^2 . @inline drag_u(x, y, t, u, v, p) = - p.cᴰ * √(u^2 + v^2) * u; @inline drag_v(x, y, t, u, v, p) = - p.cᴰ * √(u^2 + v^2) * v. drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰ)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰ)). u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom = drag_bc_u); v_bcs = FieldBoundaryConditions(bottom = drag_bc_v). # Coriolis; f₀ = 1e-4; coriolis = FPlane(f=f₀). # Background current ; U∞ = 0.25 # m s⁻¹. # Stokes drift; using Oceananigans.BuoyancyModels: g_Earth. const amplitude = 0.8 ; const wavelength = 60 ; const wavenumber = 2π / wavelength ; const frequency = sqrt(g_Earth * wavenumber * tanh(wavenumber * H)) . ## Stokes drift velocity at the surface; const Uˢ = amplitude^2 * wavenumber * frequency # m s⁻¹ # 0.0676 . # The vertical derivative of the Stokes drift is; ∂z_uˢ(z, t) = Uˢ * wavenumber * sinh(2 * wavenumber * (z + H)) / (sinh(wa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459
https://github.com/CliMA/Oceananigans.jl/issues/3459:5593,Usability,simpl,simple,5593,"e) + ∂yᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂xᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂xᶜᶜᶜ(i, j, k, grid, W)*∂zᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, W)*∂zᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, W)*∂zᶜᶜᶜ(i, j, k, grid, w_prime)); end . function solve_for_pressure_rapid!(pressure, solver::DistributedFFTBasedPoissonSolver, Δt, U★); rhs = parent(first(solver.storage)); arch = architecture(solver); grid = solver.local_grid. launch!(arch, grid, :xyz, calculate_permuted_pressure_source_term_fft_based_solver_rapid!,; rhs, grid, Δt, U★, solver.input_permutation,). # Solve pressure Poisson equation for pressure, given rhs; solve!(pressure, solver). return pressure; end; ```. I tried to run it on CPU (Oceananigans v0.84.1 & Julia v1.8.4) like (A simple case of Langmuir turbulence case in a shallow water):. ```julia; using Oceananigans; using Printf; using Oceananigans.Units. # Grid; const H = 30; grid = RectilinearGrid(GPU();; size = (100, 100, 48),; halo = (3, 3, 3),; x = (0, 2π*H),; y = (0, 2π*H),; z = (-H, 0)); # Buoyancy; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=2e-4, haline_contraction=8e-4)). # Surface boundary conditions; u₁₀ = 10 ; cᴰ = 1.25e-3 ; ρₐ = 1.225 ; ρₒ = 1026.0 ; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) . # Bottom boundary conditions; z₀ = 0.01; κ = 0.4 ; z₁ = grid.Δzᵃᵃᶠ/2 ; cᴰ = (κ / log(z₁ / z₀))^2 . @inline drag_u(x, y, t, u, v, p) = - p.cᴰ * √(u^2 + v^2) * u; @inline drag_v(x, y, t, u, v, p) = - p.cᴰ * √(u^2 + v^2) * v. drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰ)); drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰ)). u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom = drag_bc_u); v_bcs ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459
https://github.com/CliMA/Oceananigans.jl/issues/3459:9723,Usability,clear,clearly,9723,", z) = T0(z) + dTdz * model.grid.Lz * 1e-6 * Ξ(z). ## `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=S₀); ```; When I tried to output `model.pressures.prapid`, I got:. ```julia; 100×100×48 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 100×100×48 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 106×106×54 OffsetArray(::Array{Float64, 3}, -2:103, -2:103, -2:51) with eltype Float64 with indices -2:103×-2:103×-2:51; └── max=NaN, min=NaN, mean=NaN; ```; The NaN value appears. But for $p_{NHS}$ and $p_{HY'}$, the results are reasonable. So any comments or ideas about this error? . Another issue is about the calculation of the pressure terms for which the boundary conditions are inhomogeneous Neumann boundary conditions ($p_b'$, $p_{st}'$ and $p_{sg}'$, see Appendix A for details in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). For this issue, I have checked the related issue #1232. I wanna ask do I need to subtly update the boundary values of $p_b'$, $p_{st}'$ and $p_{sg}'$ to convert the inhomogeneous Neumann problem to the homogeneous Neumann problem? If so, how do I determine the values the boundary should update?. I hope I've described this issue clearly, but please let me know if anything confuse you. In addition, this is my first attempt to make a possible contribution to an open source project, and I would like to ask what is the most efficient way to conduct the discussion? Should we talk about this here firstly or can I start with a PR to better let you know what specific changes I've made to the code?. Thank you very much for any comments, suggestions or ideas!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459
https://github.com/CliMA/Oceananigans.jl/issues/3460:572,Availability,ERROR,ERROR,572,"I'd like to compute a `Field` (ideally in order to write it to a NetCDF file) but only at every `N` grid points. Something like the following example, which tries to compute `u` at every 2 grid points in the vertical direction:. ```julia; using Oceananigans; grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid,); u_slices = Field(model.velocities.u, indices=(:, :, 1:2:grid.Nz)); ```. However, the above code fails since `Field` currently doesn't accept `StepRange`s as `indices`, just (I think) `UnitRange`s and `Int`s:. ```; ERROR: LoadError: MethodError: no method matching isinteger(::StepRange{Int64, Int64}). Closest candidates are:; isinteger(::Integer); @ Base number.jl:20; isinteger(::Complex); @ Base complex.jl:148; isinteger(::Rational); @ Base rational.jl:281; ... Stacktrace:; [1] validate_index(idx::StepRange{Int64, Int64}, loc::Center, topo::Bounded, N::Int64, H::Int64); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:196; [2] map (repeats 3 times); @ ./tuple.jl:318 [inlined]; [3] validate_indices(indices::Tuple{Colon, Colon, StepRange{Int64, Int64}}, loc::Tuple{DataType, DataType, DataType}, topo::Tuple{DataType, DataType, DataType}, sz::Tuple{Int64, Int64, Int64}, halo_sz::Tuple{Int64, Int64, Int64}); ```. Is there a workaround?. CC @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460
https://github.com/CliMA/Oceananigans.jl/issues/3460:579,Performance,Load,LoadError,579,"I'd like to compute a `Field` (ideally in order to write it to a NetCDF file) but only at every `N` grid points. Something like the following example, which tries to compute `u` at every 2 grid points in the vertical direction:. ```julia; using Oceananigans; grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid,); u_slices = Field(model.velocities.u, indices=(:, :, 1:2:grid.Nz)); ```. However, the above code fails since `Field` currently doesn't accept `StepRange`s as `indices`, just (I think) `UnitRange`s and `Int`s:. ```; ERROR: LoadError: MethodError: no method matching isinteger(::StepRange{Int64, Int64}). Closest candidates are:; isinteger(::Integer); @ Base number.jl:20; isinteger(::Complex); @ Base complex.jl:148; isinteger(::Rational); @ Base rational.jl:281; ... Stacktrace:; [1] validate_index(idx::StepRange{Int64, Int64}, loc::Center, topo::Bounded, N::Int64, H::Int64); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:196; [2] map (repeats 3 times); @ ./tuple.jl:318 [inlined]; [3] validate_indices(indices::Tuple{Colon, Colon, StepRange{Int64, Int64}}, loc::Tuple{DataType, DataType, DataType}, topo::Tuple{DataType, DataType, DataType}, sz::Tuple{Int64, Int64, Int64}, halo_sz::Tuple{Int64, Int64, Int64}); ```. Is there a workaround?. CC @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460
https://github.com/CliMA/Oceananigans.jl/issues/3462:323,Availability,checkpoint,checkpointer,323,I see it here being exported:. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/OutputWriters.jl#L5. but nowhere else. I believe that currently this happens via. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L201. Right?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3462
https://github.com/CliMA/Oceananigans.jl/issues/3463:175,Availability,checkpoint,checkpointer,175,"I don't think architecture is required, despite being included here:. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L74. For example, `:architecture` property is not called within. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L201",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3463
https://github.com/CliMA/Oceananigans.jl/issues/3463:361,Availability,checkpoint,checkpointer,361,"I don't think architecture is required, despite being included here:. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L74. For example, `:architecture` property is not called within. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L201",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3463
https://github.com/CliMA/Oceananigans.jl/pull/3466:498,Testability,test,testbed,498,"This PR is a revision of Github issue PR [2949](https://github.com/CliMA/Oceananigans.jl/pull/2949) and is related to issue [1546](https://github.com/CliMA/Oceananigans.jl/issues/1546). There is a potential conflicting PR [2538](https://github.com/CliMA/Oceananigans.jl/pull/2538). This PR brings in the AMDGPU backend for kernelabstractions for the hydrostatic primitive equation solver. . @simone-silvestri and @siddharthabishnu have guided me towards using a global double drake simulation as a testbed for this porting activity, benchmark scripts are at https://github.com/simone-silvestri/OceanScalingTests.jl/blob/ss-js/adapt_double_drake/run_double_drake.sh",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3466
https://github.com/CliMA/Oceananigans.jl/pull/3466:533,Testability,benchmark,benchmark,533,"This PR is a revision of Github issue PR [2949](https://github.com/CliMA/Oceananigans.jl/pull/2949) and is related to issue [1546](https://github.com/CliMA/Oceananigans.jl/issues/1546). There is a potential conflicting PR [2538](https://github.com/CliMA/Oceananigans.jl/pull/2538). This PR brings in the AMDGPU backend for kernelabstractions for the hydrostatic primitive equation solver. . @simone-silvestri and @siddharthabishnu have guided me towards using a global double drake simulation as a testbed for this porting activity, benchmark scripts are at https://github.com/simone-silvestri/OceanScalingTests.jl/blob/ss-js/adapt_double_drake/run_double_drake.sh",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3466
https://github.com/CliMA/Oceananigans.jl/pull/3466:436,Usability,guid,guided,436,"This PR is a revision of Github issue PR [2949](https://github.com/CliMA/Oceananigans.jl/pull/2949) and is related to issue [1546](https://github.com/CliMA/Oceananigans.jl/issues/1546). There is a potential conflicting PR [2538](https://github.com/CliMA/Oceananigans.jl/pull/2538). This PR brings in the AMDGPU backend for kernelabstractions for the hydrostatic primitive equation solver. . @simone-silvestri and @siddharthabishnu have guided me towards using a global double drake simulation as a testbed for this porting activity, benchmark scripts are at https://github.com/simone-silvestri/OceanScalingTests.jl/blob/ss-js/adapt_double_drake/run_double_drake.sh",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3466
https://github.com/CliMA/Oceananigans.jl/pull/3468:63,Deployability,update,updates,63,This draft PR is for bringing in support for AMD GPUs.; Status updates will be dropped in the comments.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468
https://github.com/CliMA/Oceananigans.jl/issues/3470:187,Security,access,access,187,"@fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed. It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?. Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated. _Originally posted by @navidcy in https://github.com/CliMA/Oceananigans.jl/issues/3468#issuecomment-1936950079_. What do you mean by outdated or deprecated here? Can you help me understand how this relates to the CI?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3470
https://github.com/CliMA/Oceananigans.jl/issues/3472:185,Energy Efficiency,adapt,adapted,185,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:224,Energy Efficiency,adapt,adapted,224,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:274,Energy Efficiency,adapt,adapted,274,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:471,Energy Efficiency,adapt,adapted,471,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:559,Energy Efficiency,adapt,adapted,559,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:940,Energy Efficiency,adapt,adapt,940,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:962,Energy Efficiency,adapt,adapt,962,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:185,Modifiability,adapt,adapted,185,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:224,Modifiability,adapt,adapted,224,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:274,Modifiability,adapt,adapted,274,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:471,Modifiability,adapt,adapted,471,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:559,Modifiability,adapt,adapted,559,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:940,Modifiability,adapt,adapt,940,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:962,Modifiability,adapt,adapt,962,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3472:66,Performance,load,load,66,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472
https://github.com/CliMA/Oceananigans.jl/issues/3473:1029,Safety,avoid,avoid,1029,"To fill the halos of sliced fields we call `fill_halo_size`:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L335-L337. However, that code incorrectly assumes that an indices of `:` means that the whole dimension should be filled. This is wrong for fields with `Nothing` locations, which have only 1 point in the `Nothing` direction, but can still have indices `:`. There is also logic for `Nothing` locations:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L339-L352. But this is never used because of the incorrect assumption about the meaning of indices. One possibility is to convert indices in `Nothing` directions to `nothing`. That would permit dispatching on the type of the indices like we're trying to do. Another possibility is to fix the logic here. Dispatch is annoying because `loc` is a tuple, but it can be done. A third possibility is just to avoid the symbol sizes `:yz`, `xz` and `:xy`. That last seems maybe like the best choice. This bug would prevent anyone from using `ImmersedBoundaryGrid`. So I'm confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3473
https://github.com/CliMA/Oceananigans.jl/issues/3473:464,Testability,log,logic,464,"To fill the halos of sliced fields we call `fill_halo_size`:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L335-L337. However, that code incorrectly assumes that an indices of `:` means that the whole dimension should be filled. This is wrong for fields with `Nothing` locations, which have only 1 point in the `Nothing` direction, but can still have indices `:`. There is also logic for `Nothing` locations:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L339-L352. But this is never used because of the incorrect assumption about the meaning of indices. One possibility is to convert indices in `Nothing` directions to `nothing`. That would permit dispatching on the type of the indices like we're trying to do. Another possibility is to fix the logic here. Dispatch is annoying because `loc` is a tuple, but it can be done. A third possibility is just to avoid the symbol sizes `:yz`, `xz` and `:xy`. That last seems maybe like the best choice. This bug would prevent anyone from using `ImmersedBoundaryGrid`. So I'm confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3473
https://github.com/CliMA/Oceananigans.jl/issues/3473:919,Testability,log,logic,919,"To fill the halos of sliced fields we call `fill_halo_size`:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L335-L337. However, that code incorrectly assumes that an indices of `:` means that the whole dimension should be filled. This is wrong for fields with `Nothing` locations, which have only 1 point in the `Nothing` direction, but can still have indices `:`. There is also logic for `Nothing` locations:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L339-L352. But this is never used because of the incorrect assumption about the meaning of indices. One possibility is to convert indices in `Nothing` directions to `nothing`. That would permit dispatching on the type of the indices like we're trying to do. Another possibility is to fix the logic here. Dispatch is annoying because `loc` is a tuple, but it can be done. A third possibility is just to avoid the symbol sizes `:yz`, `xz` and `:xy`. That last seems maybe like the best choice. This bug would prevent anyone from using `ImmersedBoundaryGrid`. So I'm confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3473
https://github.com/CliMA/Oceananigans.jl/pull/3474:21,Availability,error,error,21,This PR fixes a sign error in the implicit dissipative buoyancy flux. We're also recalibrating parameters and will update them here before merging the PR. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3474
https://github.com/CliMA/Oceananigans.jl/pull/3474:115,Deployability,update,update,115,This PR fixes a sign error in the implicit dissipative buoyancy flux. We're also recalibrating parameters and will update them here before merging the PR. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3474
https://github.com/CliMA/Oceananigans.jl/pull/3477:1538,Energy Efficiency,reduce,reduces,1538,"This PR removes argument splatting in intermediate functions that are called to compute the hydrostatic free surface tendencies. Argument splatting was removed in a prior PR (that'd be great if someone can remember), but was reinstated in #3360. This PR re-removes splatting. It yields a 2x performance gain for a column model:. # `main`. ```julia; julia> include(""test_single_column_model.jl""); ┌ Info: Running a simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); │ ├── grid: 1×1×64 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; │ ├── timestepper: QuasiAdamsBashforth2TimeStepper; │ ├── tracers: (b, e); │ ├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}; │ ├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection(); └ └── coriolis: FPlane{Float64}...; 0.398369 seconds (727.30 k allocations: 706.103 MiB, 30.55% gc time); ```. # This PR; ```julia; julia> include(""test_single_column_model.jl""); ┌ Info: Running a simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); │ ├── grid: 1×1×64 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; │ ├── timestepper: QuasiAdamsBashforth2TimeStepper; │ ├── tracers: (b, e); │ ├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}; │ ├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection(); └ └── coriolis: FPlane{Float64}...; 0.214935 seconds (258.50 k allocations: 195.374 MiB, 10.57% gc time); ```. It also reduces memory allocation. . Note that the nonhydrostatic model was not changed (it does not splat).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477
https://github.com/CliMA/Oceananigans.jl/pull/3477:291,Performance,perform,performance,291,"This PR removes argument splatting in intermediate functions that are called to compute the hydrostatic free surface tendencies. Argument splatting was removed in a prior PR (that'd be great if someone can remember), but was reinstated in #3360. This PR re-removes splatting. It yields a 2x performance gain for a column model:. # `main`. ```julia; julia> include(""test_single_column_model.jl""); ┌ Info: Running a simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); │ ├── grid: 1×1×64 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; │ ├── timestepper: QuasiAdamsBashforth2TimeStepper; │ ├── tracers: (b, e); │ ├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}; │ ├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection(); └ └── coriolis: FPlane{Float64}...; 0.398369 seconds (727.30 k allocations: 706.103 MiB, 30.55% gc time); ```. # This PR; ```julia; julia> include(""test_single_column_model.jl""); ┌ Info: Running a simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); │ ├── grid: 1×1×64 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; │ ├── timestepper: QuasiAdamsBashforth2TimeStepper; │ ├── tracers: (b, e); │ ├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}; │ ├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection(); └ └── coriolis: FPlane{Float64}...; 0.214935 seconds (258.50 k allocations: 195.374 MiB, 10.57% gc time); ```. It also reduces memory allocation. . Note that the nonhydrostatic model was not changed (it does not splat).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477
https://github.com/CliMA/Oceananigans.jl/pull/3480:20,Testability,test,test,20,Added an additional test to the enzyme test set for differentiating a `HydrostaticFreeSurfaceModel` with tracer advection and diffusion.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480
https://github.com/CliMA/Oceananigans.jl/pull/3480:39,Testability,test,test,39,Added an additional test to the enzyme test set for differentiating a `HydrostaticFreeSurfaceModel` with tracer advection and diffusion.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480
https://github.com/CliMA/Oceananigans.jl/issues/3481:74,Performance,load,loaded,74,It'd be nice if we move CUDA functionality into an extension so it's only loaded for CUDA-enabled devices. @vchuravy made a first attempt to do that at https://github.com/CliMA/Oceananigans.jl/pull/3066. similar effort but for AMDGPU is at https://github.com/CliMA/Oceananigans.jl/pull/3475,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3481
https://github.com/CliMA/Oceananigans.jl/pull/3482:1410,Availability,down,downstream,1410," to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set `OpenBoundaryCondition(nothing)` unless a user sets something else.; - Should we have an automatic way to setup a sponge layer?; - Do we think it is correct not to add a term to the pressure for time-varying inflow? I think we do not (see below",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:546,Deployability,update,update,546,"This PR implements the infrastructure for open boundary conditions in the `NonhydrostaticModel` as well as a few simple methods. . This PR:. - [x] Adds a `matching_scheme` property to `Open` boundary classifications to allow different `fill_X_halo!` to be dispatched; - [x] Introduces `update_boundary_condition!` to be called before halo fills allowing the `mathcing_scheme` to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:4256,Integrability,depend,depend,4256,"u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clumsy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:4333,Integrability,depend,depend,4333,"u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clumsy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:405,Modifiability,evolve,evolve,405,"This PR implements the infrastructure for open boundary conditions in the `NonhydrostaticModel` as well as a few simple methods. . This PR:. - [x] Adds a `matching_scheme` property to `Open` boundary classifications to allow different `fill_X_halo!` to be dispatched; - [x] Introduces `update_boundary_condition!` to be called before halo fills allowing the `mathcing_scheme` to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:4054,Modifiability,extend,extend,4054,"ec u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clums",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:4912,Safety,avoid,avoid,4912,"u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clumsy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:452,Testability,test,tests,452,"This PR implements the infrastructure for open boundary conditions in the `NonhydrostaticModel` as well as a few simple methods. . This PR:. - [x] Adds a `matching_scheme` property to `Open` boundary classifications to allow different `fill_X_halo!` to be dispatched; - [x] Introduces `update_boundary_condition!` to be called before halo fills allowing the `mathcing_scheme` to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:1864,Testability,test,test,1864,"seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set `OpenBoundaryCondition(nothing)` unless a user sets something else.; - Should we have an automatic way to setup a sponge layer?; - Do we think it is correct not to add a term to the pressure for time-varying inflow? I think we do not (see below). <details>; <summary>How I understand the maths:</summary>; Starting from the momentum equation:. $\partial_t\vec u = \vec{G_u} - \nabla P$. We split the time step by defining:. $\vec u^\star - \vec u^n = \int_{t_n}^{t_{n+1}}\vec{G_u}dt$. so. $\vec u^{n+1} - \vec u^\star = -\int_{t_n}^{t_{n+1}}\nabla P_{non}dt \approx -\Delta t\nabla P_{non}$. we take the divergence of this (and requiring $\nabla \cdot \vec u^{n+1}$) to give:. $\nabla^2P_{non} = \frac{\nabla \cdot \vec u^\star}{\Delta t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:4984,Testability,test,testing,4984,"u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clumsy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3482:113,Usability,simpl,simple,113,"This PR implements the infrastructure for open boundary conditions in the `NonhydrostaticModel` as well as a few simple methods. . This PR:. - [x] Adds a `matching_scheme` property to `Open` boundary classifications to allow different `fill_X_halo!` to be dispatched; - [x] Introduces `update_boundary_condition!` to be called before halo fills allowing the `mathcing_scheme` to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482
https://github.com/CliMA/Oceananigans.jl/pull/3484:21,Availability,error,error,21,This PR fixes a sign error in the implicit dissipative buoyancy flux. We're also recalibrating parameters and will update them here before merging the PR.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3484
https://github.com/CliMA/Oceananigans.jl/pull/3484:115,Deployability,update,update,115,This PR fixes a sign error in the implicit dissipative buoyancy flux. We're also recalibrating parameters and will update them here before merging the PR.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3484
https://github.com/CliMA/Oceananigans.jl/issues/3485:195,Availability,checkpoint,checkpoint,195,"I've been using `WindowedTimeAverage`s for my simulations (by setting `schedule = AveragedTimeInterval(...)` in a `NetCDFOutputWriter`). I noticed that whenever I run out of walltime and have to checkpoint my simulations, when I pick them up again I get the following warning for each of the time-averaged outputs:. ```; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters /glade/work/tomasc/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/windowed_time_average.jl:201; ```; (which comes from [this call](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/src/OutputWriters/windowed_time_average.jl#L196-L204).). Does this mean that the time averages aren't being correctly calculated after picking up? I tried following the trail to figure it out but couldn't determine the answer...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485
https://github.com/CliMA/Oceananigans.jl/issues/3485:71,Energy Efficiency,schedul,schedule,71,"I've been using `WindowedTimeAverage`s for my simulations (by setting `schedule = AveragedTimeInterval(...)` in a `NetCDFOutputWriter`). I noticed that whenever I run out of walltime and have to checkpoint my simulations, when I pick them up again I get the following warning for each of the time-averaged outputs:. ```; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters /glade/work/tomasc/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/windowed_time_average.jl:201; ```; (which comes from [this call](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/src/OutputWriters/windowed_time_average.jl#L196-L204).). Does this mean that the time averages aren't being correctly calculated after picking up? I tried following the trail to figure it out but couldn't determine the answer...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485
https://github.com/CliMA/Oceananigans.jl/pull/3486:201,Testability,test,tests,201,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3051. Following up on #3394, this PR tries to do the first two tasks, fix the tendencies in the shallow water model and bring back the regression tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486
https://github.com/CliMA/Oceananigans.jl/pull/3487:21,Testability,test,test,21,This PR introduces a test to verify the correct execution of a distributed immersed latitude longitude grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3487
https://github.com/CliMA/Oceananigans.jl/pull/3489:36,Modifiability,variab,variables,36,"@Sbozzolo, did I remove all the ENV variables I should have removed?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3489
https://github.com/CliMA/Oceananigans.jl/pull/3490:391,Energy Efficiency,allocate,allocated,391,"We have two functions called `arch_array` and `on_architecture` that pretty much do the same thing: moving a variable between GPU and CPU. However, neither of them covers all the types in Oceananigans, like `Fields` or `Models`. So, this PR tidies things up a bit. It removes `arch_array` in favor of `on_architecture`. In addition, it extends `on_architecture` to all the types with memory-allocated variables.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490
https://github.com/CliMA/Oceananigans.jl/pull/3490:109,Modifiability,variab,variable,109,"We have two functions called `arch_array` and `on_architecture` that pretty much do the same thing: moving a variable between GPU and CPU. However, neither of them covers all the types in Oceananigans, like `Fields` or `Models`. So, this PR tidies things up a bit. It removes `arch_array` in favor of `on_architecture`. In addition, it extends `on_architecture` to all the types with memory-allocated variables.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490
https://github.com/CliMA/Oceananigans.jl/pull/3490:336,Modifiability,extend,extends,336,"We have two functions called `arch_array` and `on_architecture` that pretty much do the same thing: moving a variable between GPU and CPU. However, neither of them covers all the types in Oceananigans, like `Fields` or `Models`. So, this PR tidies things up a bit. It removes `arch_array` in favor of `on_architecture`. In addition, it extends `on_architecture` to all the types with memory-allocated variables.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490
https://github.com/CliMA/Oceananigans.jl/pull/3490:401,Modifiability,variab,variables,401,"We have two functions called `arch_array` and `on_architecture` that pretty much do the same thing: moving a variable between GPU and CPU. However, neither of them covers all the types in Oceananigans, like `Fields` or `Models`. So, this PR tidies things up a bit. It removes `arch_array` in favor of `on_architecture`. In addition, it extends `on_architecture` to all the types with memory-allocated variables.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490
https://github.com/CliMA/Oceananigans.jl/issues/3492:209,Integrability,depend,dependencies,209,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3492:31,Performance,optimiz,optimized,31,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3492:74,Performance,perform,performance,74,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3492:125,Performance,perform,performance,125,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3492:544,Performance,perform,performance,544,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3492:966,Performance,perform,performing,966,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3492:556,Testability,test,test,556,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3492:850,Testability,test,tests,850,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3492:981,Testability,test,tests,981,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3492:450,Usability,simpl,simplify,450,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492
https://github.com/CliMA/Oceananigans.jl/issues/3494:525,Performance,optimiz,optimizer,525,"I have continued to retest the 2D turbulence example and now get some loop warnings from several calls with the CPU architecture:; It would be nice to remove these or fix a possible flaw. I am using the latest versions of Julia and Oceananigans as at 5th March 2024. model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; closure = ScalarDiffusivity(ν=1e-5)); warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:549,Performance,perform,perform,549,"I have continued to retest the 2D turbulence example and now get some loop warnings from several calls with the CPU architecture:; It would be nice to remove these or fix a possible flaw. I am using the latest versions of Julia and Oceananigans as at 5th March 2024. model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; closure = ScalarDiffusivity(ν=1e-5)); warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:803,Performance,optimiz,optimizer,803,"I have continued to retest the 2D turbulence example and now get some loop warnings from several calls with the CPU architecture:; It would be nice to remove these or fix a possible flaw. I am using the latest versions of Julia and Oceananigans as at 5th March 2024. model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; closure = ScalarDiffusivity(ν=1e-5)); warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:827,Performance,perform,perform,827,"I have continued to retest the 2D turbulence example and now get some loop warnings from several calls with the CPU architecture:; It would be nice to remove these or fix a possible flaw. I am using the latest versions of Julia and Oceananigans as at 5th March 2024. model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; closure = ScalarDiffusivity(ν=1e-5)); warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:1081,Performance,optimiz,optimizer,1081,"these or fix a possible flaw. I am using the latest versions of Julia and Oceananigans as at 5th March 2024. model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; closure = ScalarDiffusivity(ν=1e-5)); warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:1105,Performance,perform,perform,1105,"these or fix a possible flaw. I am using the latest versions of Julia and Oceananigans as at 5th March 2024. model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; closure = ScalarDiffusivity(ν=1e-5)); warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:1359,Performance,optimiz,optimizer,1359,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:1383,Performance,perform,perform,1383,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:1637,Performance,optimiz,optimizer,1637,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:1661,Performance,perform,perform,1661,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:1915,Performance,optimiz,optimizer,1915,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:1939,Performance,perform,perform,1939,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:2193,Performance,optimiz,optimizer,2193,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:2217,Performance,perform,perform,2217,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:2471,Performance,optimiz,optimizer,2471,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:2495,Performance,perform,perform,2495,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:2749,Performance,optimiz,optimizer,2749,"ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:2773,Performance,perform,perform,2773,"ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:3027,Performance,optimiz,optimizer,3027,"\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── tracers: (); ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-5); ├── buoyancy: Nothing; └── coriolis: Nothing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:3051,Performance,perform,perform,3051,"\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── tracers: (); ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-5); ├── buoyancy: Nothing; └── coriolis: Nothing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:3305,Performance,optimiz,optimizer,3305,"\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── tracers: (); ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-5); ├── buoyancy: Nothing; └── coriolis: Nothing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:3329,Performance,perform,perform,3329,"\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── tracers: (); ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-5); ├── buoyancy: Nothing; └── coriolis: Nothing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:3583,Performance,optimiz,optimizer,3583,"\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── tracers: (); ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-5); ├── buoyancy: Nothing; └── coriolis: Nothing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/issues/3494:3607,Performance,perform,perform,3607,"\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── tracers: (); ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-5); ├── buoyancy: Nothing; └── coriolis: Nothing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494
https://github.com/CliMA/Oceananigans.jl/pull/3498:138,Testability,test,test,138,I'm amazed that the ultra-simple case of forcing with array values is still not properly supported. This PR adds that support. It needs a test.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498
https://github.com/CliMA/Oceananigans.jl/pull/3498:26,Usability,simpl,simple,26,I'm amazed that the ultra-simple case of forcing with array values is still not properly supported. This PR adds that support. It needs a test.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498
https://github.com/CliMA/Oceananigans.jl/pull/3503:58,Integrability,interface,interface,58,"The PR revisits a bit the `SplitExplicitFreeSurface` user-interface and internals and changes the `HydrostaticFreeSurfaceModel` constructor to use the `SplitExplicitFreeSurface` as the default when the grid is appropriate, i.e., all the time except when `grid` is horizontally-regular rectilinear grid. Furthermore, the PR cleans up a bit the free surface constructions. Now all free surfaces have an ""outer constructor"" and then they get materialized via `materialize_free_surface` within the `HydrostaticFreeSurfaceModel` constructor. Closes #3289; Closes #3238",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503
https://github.com/CliMA/Oceananigans.jl/issues/3507:128,Testability,test,test,128,"At the moment, supposedly we can change. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/dependencies_for_runtests.jl#L82. to. ```julia; test_file = ""test_some_new_feature.jl""; ```. and then. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/runtests.jl#L6-L10. will run that test file. But then, the `runtest.jl` *will continue* running the whole test suite!. We'd like to stop after testing the `test_file`, right?. cc @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507
https://github.com/CliMA/Oceananigans.jl/issues/3507:323,Testability,test,test,323,"At the moment, supposedly we can change. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/dependencies_for_runtests.jl#L82. to. ```julia; test_file = ""test_some_new_feature.jl""; ```. and then. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/runtests.jl#L6-L10. will run that test file. But then, the `runtest.jl` *will continue* running the whole test suite!. We'd like to stop after testing the `test_file`, right?. cc @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507
https://github.com/CliMA/Oceananigans.jl/issues/3507:362,Testability,test,test,362,"At the moment, supposedly we can change. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/dependencies_for_runtests.jl#L82. to. ```julia; test_file = ""test_some_new_feature.jl""; ```. and then. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/runtests.jl#L6-L10. will run that test file. But then, the `runtest.jl` *will continue* running the whole test suite!. We'd like to stop after testing the `test_file`, right?. cc @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507
https://github.com/CliMA/Oceananigans.jl/issues/3507:434,Testability,test,test,434,"At the moment, supposedly we can change. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/dependencies_for_runtests.jl#L82. to. ```julia; test_file = ""test_some_new_feature.jl""; ```. and then. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/runtests.jl#L6-L10. will run that test file. But then, the `runtest.jl` *will continue* running the whole test suite!. We'd like to stop after testing the `test_file`, right?. cc @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507
https://github.com/CliMA/Oceananigans.jl/issues/3507:471,Testability,test,testing,471,"At the moment, supposedly we can change. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/dependencies_for_runtests.jl#L82. to. ```julia; test_file = ""test_some_new_feature.jl""; ```. and then. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/runtests.jl#L6-L10. will run that test file. But then, the `runtest.jl` *will continue* running the whole test suite!. We'd like to stop after testing the `test_file`, right?. cc @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507
https://github.com/CliMA/Oceananigans.jl/pull/3508:47,Availability,avail,available,47,This PR adds `last_Δt` to `Clock` to make `Δt` available in more places (particularly in boundary condition halo fills addressing a challenge in #3482).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3508
https://github.com/CliMA/Oceananigans.jl/pull/3509:84,Energy Efficiency,energy,energy,84,"This PR implements a two-equation turbulent closure, which evolve turbulent kinetic energy and an additional ""scale variable"". Here we choose the scale variable dissipation; another name for this two-equation model is ""k-epsilon"". In Oceananigans it will be called the `TKEDissipationVerticalDiffusivity`. This PR is a WIP; we still have to implement the stability functions and, perhaps more importantly, figure out how to make time-stepping stable. . Closes #2278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3509
https://github.com/CliMA/Oceananigans.jl/pull/3509:59,Modifiability,evolve,evolve,59,"This PR implements a two-equation turbulent closure, which evolve turbulent kinetic energy and an additional ""scale variable"". Here we choose the scale variable dissipation; another name for this two-equation model is ""k-epsilon"". In Oceananigans it will be called the `TKEDissipationVerticalDiffusivity`. This PR is a WIP; we still have to implement the stability functions and, perhaps more importantly, figure out how to make time-stepping stable. . Closes #2278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3509
https://github.com/CliMA/Oceananigans.jl/pull/3509:116,Modifiability,variab,variable,116,"This PR implements a two-equation turbulent closure, which evolve turbulent kinetic energy and an additional ""scale variable"". Here we choose the scale variable dissipation; another name for this two-equation model is ""k-epsilon"". In Oceananigans it will be called the `TKEDissipationVerticalDiffusivity`. This PR is a WIP; we still have to implement the stability functions and, perhaps more importantly, figure out how to make time-stepping stable. . Closes #2278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3509
https://github.com/CliMA/Oceananigans.jl/pull/3509:152,Modifiability,variab,variable,152,"This PR implements a two-equation turbulent closure, which evolve turbulent kinetic energy and an additional ""scale variable"". Here we choose the scale variable dissipation; another name for this two-equation model is ""k-epsilon"". In Oceananigans it will be called the `TKEDissipationVerticalDiffusivity`. This PR is a WIP; we still have to implement the stability functions and, perhaps more importantly, figure out how to make time-stepping stable. . Closes #2278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3509
https://github.com/CliMA/Oceananigans.jl/pull/3510:88,Deployability,configurat,configuration,88,A bug in the limiting by `maximum_diffusivity` caused this scheme to blow up in default configuration (and be generally incorrect). This PR fixes that and makes a few more tweaks: horizontal filtering can be optionally added (and we implement an interface for adding new horizontal filters). We also add a minimum entrainment buoyancy gradient. Closes #3283,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3510
https://github.com/CliMA/Oceananigans.jl/pull/3510:246,Integrability,interface,interface,246,A bug in the limiting by `maximum_diffusivity` caused this scheme to blow up in default configuration (and be generally incorrect). This PR fixes that and makes a few more tweaks: horizontal filtering can be optionally added (and we implement an interface for adding new horizontal filters). We also add a minimum entrainment buoyancy gradient. Closes #3283,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3510
https://github.com/CliMA/Oceananigans.jl/pull/3510:88,Modifiability,config,configuration,88,A bug in the limiting by `maximum_diffusivity` caused this scheme to blow up in default configuration (and be generally incorrect). This PR fixes that and makes a few more tweaks: horizontal filtering can be optionally added (and we implement an interface for adding new horizontal filters). We also add a minimum entrainment buoyancy gradient. Closes #3283,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3510
https://github.com/CliMA/Oceananigans.jl/pull/3511:10403,Availability,Down,Downloads,10403,rsor_jll v0.1.4+0; [12413925] Xorg_xcb_util_image_jll v0.4.0+1; [2def613f] Xorg_xcb_util_jll v0.4.0+1; [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1; [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1; [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1; [35661453] Xorg_xkbcomp_jll v1.4.6+0; [33bec58e] Xorg_xkeyboard_config_jll v2.39.0+0; [c5fb5394] Xorg_xtrans_jll v1.5.0+0; [3161d3a3] Zstd_jll v1.5.5+0; [35ca27e7] eudev_jll v3.2.9+0; [214eeab7] fzf_jll v0.43.0+0; [1a1c6b14] gperf_jll v3.1.1+0; [477f73a3] libaec_jll v1.1.2+0; [a4ae2306] libaom_jll v3.4.0+0; [0ac62f75] libass_jll v0.15.1+0; [2db6ffa8] libevdev_jll v1.11.0+0; [f638f0a6] libfdk_aac_jll v2.0.2+0; [36db933b] libinput_jll v1.18.0+0; [b53b4c65] libpng_jll v1.6.43+1; [f27f6e37] libvorbis_jll v1.3.7+1; [337d8026] libzip_jll v1.10.1+0; [009596ad] mtdev_jll v1.1.6+0; [1270edf5] x264_jll v2021.5.5+0; [dfaa095f] x265_jll v3.5.0+0; [d8fb68d0] xkbcommon_jll v1.4.1+1; [0dad84c5] ArgTools v1.1.1; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8ba89e20] Distributed; [f43a241f] Downloads v1.6.0; [7b1f6079] FileWatching; [9fa8497b] Future; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL v0.6.4; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9abbd945] Profile; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:11648,Availability,avail,available,11648,"gging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9abbd945] Profile; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:12221,Deployability,Release,Release,12221,"933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:13307,Deployability,Release,Release,13307,"UG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:661,Energy Efficiency,Adapt,Adapt,661,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:2033,Energy Efficiency,Adapt,Adapt,2033,fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:12421,Integrability,depend,dependency-tracking,12421,"933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:13507,Integrability,depend,dependency-tracking,13507,"UG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:474,Modifiability,variab,variable,474,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:661,Modifiability,Adapt,Adapt,661,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:2033,Modifiability,Adapt,Adapt,2033,fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:12316,Modifiability,config,configure,12316,"933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:13402,Modifiability,config,configure,13402,"UG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:2585,Performance,Concurren,ConcurrentUtilities,2585, v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [7da242da] Enzyme v0.11.19; ⌅ [f151be2c] EnzymeCore v0.6.5; [460bff9d] ExceptionUnwrapping v0.1.10; [e2ba6199] ExprTools v0.1.10; [c87230d0] FFMPEG v0.4.1; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.2; [53c48c17] FixedPointNumbers v0.8.4; [1fa38f19] Format v1.3.6; [0c68f7d7] GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:1473,Safety,Safe,SafeTestsets,1473,"variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:5442,Safety,Safe,SafeTestsets,5442,0.14.3; [5da4648a] NVTX v0.3.4; [77ba4419] NaNMath v1.0.2; [d8793406] ObjectFile v0.4.1; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [01d81517] RecipesPipeline v0.6.12; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.1; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [6c6a2e73] Scratch v1.2.1; [d496a93d] SeawaterPolynomials v0.3.4; [91c51154] SentinelArrays v1.4.1; [992d4aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:6568,Safety,Unsafe,UnsafeAtomics,6568,aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c2747f8] URIs v1.5.1; [1cfade01] UnicodeFun v0.4.1; [1986cc42] Unitful v1.19.0; [45397f5d] UnitfulLatexify v1.6.3; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] UnsafeAtomicsLLVM v0.1.3; [41fe7b60] Unzip v0.2.0; [81def892] VersionParsing v1.3.0; [0b7ba130] Blosc_jll v1.21.5+0; [6e34b625] Bzip2_jll v1.0.8+1; ⌅ [4ee394cb] CUDA_Driver_jll v0.7.0+1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; [83423d85] Cairo_jll v1.18.0+1; [7cc45869] Enzyme_jll v0.0.102+0; [2702e6a9] EpollShim_jll v0.0.20230411+0; [2e619515] Expat_jll v2.5.0+0; ⌅ [b22a6f82] FFMPEG_jll v4.4.4+1; [f5851436] FFTW_jll v3.3.10+0; [a3f928ae] Fontconfig_jll v2.13.93+0; [d7e528f0] FreeType2_jll v2.13.1+0; [559328eb] FriBidi_jll v1.0.10+0; [0656b61e] GLFW_jll v3.3.9+0; [d2c73de3] GR_jll v0.73.3+0; [78b55507] Gettext_jll v0.21.0+0; [7746bdde] Glib_jll v2.80.0+0; [0951126a] GnuTLS_jll v3.8.3+0; [3b182d85] Graphite2_jll v1.3.14+0; [0234f1f7] HDF5_jll v1.14.3+1; [2e76f6c2] HarfBuzz_jll v2.8.1+1; [e33a78d0] Hwloc_jll v2.10.0+0; [1d5cc7b8] IntelOpenMP_jll v2024.0.2+0; [aacddb02] JpegTurbo_jll v3.0.2+0; [9c1d0b0a] JuliaNVTXCallbacks_jll v0.2.1+0; [c1c5ebd0] LAME_jll v,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:6601,Safety,Unsafe,UnsafeAtomicsLLVM,6601,pleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c2747f8] URIs v1.5.1; [1cfade01] UnicodeFun v0.4.1; [1986cc42] Unitful v1.19.0; [45397f5d] UnitfulLatexify v1.6.3; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] UnsafeAtomicsLLVM v0.1.3; [41fe7b60] Unzip v0.2.0; [81def892] VersionParsing v1.3.0; [0b7ba130] Blosc_jll v1.21.5+0; [6e34b625] Bzip2_jll v1.0.8+1; ⌅ [4ee394cb] CUDA_Driver_jll v0.7.0+1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; [83423d85] Cairo_jll v1.18.0+1; [7cc45869] Enzyme_jll v0.0.102+0; [2702e6a9] EpollShim_jll v0.0.20230411+0; [2e619515] Expat_jll v2.5.0+0; ⌅ [b22a6f82] FFMPEG_jll v4.4.4+1; [f5851436] FFTW_jll v3.3.10+0; [a3f928ae] Fontconfig_jll v2.13.93+0; [d7e528f0] FreeType2_jll v2.13.1+0; [559328eb] FriBidi_jll v1.0.10+0; [0656b61e] GLFW_jll v3.3.9+0; [d2c73de3] GR_jll v0.73.3+0; [78b55507] Gettext_jll v0.21.0+0; [7746bdde] Glib_jll v2.80.0+0; [0951126a] GnuTLS_jll v3.8.3+0; [3b182d85] Graphite2_jll v1.3.14+0; [0234f1f7] HDF5_jll v1.14.3+1; [2e76f6c2] HarfBuzz_jll v2.8.1+1; [e33a78d0] Hwloc_jll v2.10.0+0; [1d5cc7b8] IntelOpenMP_jll v2024.0.2+0; [aacddb02] JpegTurbo_jll v3.0.2+0; [9c1d0b0a] JuliaNVTXCallbacks_jll v0.2.1+0; [c1c5ebd0] LAME_jll v3.100.1+0; [88015f11] LERC_jll v3.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:140,Testability,test,test,140,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:227,Testability,test,test,227,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:256,Testability,test,test,256,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:334,Testability,test,test,334,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:363,Testability,test,testset,363,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:384,Testability,test,test,384,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:437,Testability,test,test-suite,437,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:571,Testability,test,test,571,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:580,Testability,Test,Testing,580,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:686,Testability,Benchmark,BenchmarkTools,686,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:1789,Testability,Log,Logging,1789,0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:1935,Testability,Test,Test,1935,c6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:2151,Testability,Benchmark,BenchmarkTools,2151,da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [7da242da] Enzyme v0.11.19; ⌅ [,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:4161,Testability,Log,LogExpFunctions,4161,EnzymeCore v0.6.5; [460bff9d] ExceptionUnwrapping v0.1.10; [e2ba6199] ExprTools v0.1.10; [c87230d0] FFMPEG v0.4.1; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.2; [53c48c17] FixedPointNumbers v0.8.4; [1fa38f19] Format v1.3.6; [0c68f7d7] GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.1; [842dd82b] InlineStrings v1.4.0; [41ab1584] InvertedIndices v1.3.0; [92d709cd] IrrationalConstants v0.2.2; [42fd0dbc] IterativeSolvers v0.9.4; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.46; [1019f520] JLFzf v0.1.7; [692b3bcd] JLLWrappers v1.5.0; [682c06a0] JSON v0.21.4; [0f8b85d8] JSON3 v1.14.0; [63c18a36] KernelAbstractions v0.9.18; [929cbde3] LLVM v6.6.0; [8b046642] LLVMLoopInfo v1.0.0; [8ac3fa9e] LRUCache v1.6.1; [b964fa9f] LaTeXStrings v1.3.1; [23fbe1c1] Latexify v0.16.2; [2ab3a3ac] LogExpFunctions v0.3.27; [e6f89c97] LoggingExtras v1.0.3; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [1914dd2f] MacroTools v0.5.13; [739be429] MbedTLS v1.1.9; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.7; [85f8d34a] NCDatasets v0.14.3; [5da4648a] NVTX v0.3.4; [77ba4419] NaNMath v1.0.2; [d8793406] ObjectFile v0.4.1; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] R,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:4197,Testability,Log,LoggingExtras,4197,tionUnwrapping v0.1.10; [e2ba6199] ExprTools v0.1.10; [c87230d0] FFMPEG v0.4.1; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.2; [53c48c17] FixedPointNumbers v0.8.4; [1fa38f19] Format v1.3.6; [0c68f7d7] GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.1; [842dd82b] InlineStrings v1.4.0; [41ab1584] InvertedIndices v1.3.0; [92d709cd] IrrationalConstants v0.2.2; [42fd0dbc] IterativeSolvers v0.9.4; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.46; [1019f520] JLFzf v0.1.7; [692b3bcd] JLLWrappers v1.5.0; [682c06a0] JSON v0.21.4; [0f8b85d8] JSON3 v1.14.0; [63c18a36] KernelAbstractions v0.9.18; [929cbde3] LLVM v6.6.0; [8b046642] LLVMLoopInfo v1.0.0; [8ac3fa9e] LRUCache v1.6.1; [b964fa9f] LaTeXStrings v1.3.1; [23fbe1c1] Latexify v0.16.2; [2ab3a3ac] LogExpFunctions v0.3.27; [e6f89c97] LoggingExtras v1.0.3; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [1914dd2f] MacroTools v0.5.13; [739be429] MbedTLS v1.1.9; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.7; [85f8d34a] NCDatasets v0.14.3; [5da4648a] NVTX v0.3.4; [77ba4419] NaNMath v1.0.2; [d8793406] ObjectFile v0.4.1; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] Random,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:4404,Testability,Mock,Mocking,4404, GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.1; [842dd82b] InlineStrings v1.4.0; [41ab1584] InvertedIndices v1.3.0; [92d709cd] IrrationalConstants v0.2.2; [42fd0dbc] IterativeSolvers v0.9.4; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.46; [1019f520] JLFzf v0.1.7; [692b3bcd] JLLWrappers v1.5.0; [682c06a0] JSON v0.21.4; [0f8b85d8] JSON3 v1.14.0; [63c18a36] KernelAbstractions v0.9.18; [929cbde3] LLVM v6.6.0; [8b046642] LLVMLoopInfo v1.0.0; [8ac3fa9e] LRUCache v1.6.1; [b964fa9f] LaTeXStrings v1.3.1; [23fbe1c1] Latexify v0.16.2; [2ab3a3ac] LogExpFunctions v0.3.27; [e6f89c97] LoggingExtras v1.0.3; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [1914dd2f] MacroTools v0.5.13; [739be429] MbedTLS v1.1.9; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.7; [85f8d34a] NCDatasets v0.14.3; [5da4648a] NVTX v0.3.4; [77ba4419] NaNMath v1.0.2; [d8793406] ObjectFile v0.4.1; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [01d81517] RecipesPipeline v0.6.12; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.1; [ae029012] Requires v1.3.0; [,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:10622,Testability,Log,Logging,10622,bcomp_jll v1.4.6+0; [33bec58e] Xorg_xkeyboard_config_jll v2.39.0+0; [c5fb5394] Xorg_xtrans_jll v1.5.0+0; [3161d3a3] Zstd_jll v1.5.5+0; [35ca27e7] eudev_jll v3.2.9+0; [214eeab7] fzf_jll v0.43.0+0; [1a1c6b14] gperf_jll v3.1.1+0; [477f73a3] libaec_jll v1.1.2+0; [a4ae2306] libaom_jll v3.4.0+0; [0ac62f75] libass_jll v0.15.1+0; [2db6ffa8] libevdev_jll v1.11.0+0; [f638f0a6] libfdk_aac_jll v2.0.2+0; [36db933b] libinput_jll v1.18.0+0; [b53b4c65] libpng_jll v1.6.43+1; [f27f6e37] libvorbis_jll v1.3.7+1; [337d8026] libzip_jll v1.10.1+0; [009596ad] mtdev_jll v1.1.6+0; [1270edf5] x264_jll v2021.5.5+0; [dfaa095f] x265_jll v3.5.0+0; [d8fb68d0] xkbcommon_jll v1.4.1+1; [0dad84c5] ArgTools v1.1.1; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8ba89e20] Distributed; [f43a241f] Downloads v1.6.0; [7b1f6079] FileWatching; [9fa8497b] Future; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL v0.6.4; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9abbd945] Profile; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:11018,Testability,Test,Test,11018,"3b4c65] libpng_jll v1.6.43+1; [f27f6e37] libvorbis_jll v1.3.7+1; [337d8026] libzip_jll v1.10.1+0; [009596ad] mtdev_jll v1.1.6+0; [1270edf5] x264_jll v2021.5.5+0; [dfaa095f] x265_jll v3.5.0+0; [d8fb68d0] xkbcommon_jll v1.4.1+1; [0dad84c5] ArgTools v1.1.1; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8ba89e20] Distributed; [f43a241f] Downloads v1.6.0; [7b1f6079] FileWatching; [9fa8497b] Future; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL v0.6.4; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9abbd945] Profile; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi d",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:11769,Testability,Test,Testing,11769,"PL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:11785,Testability,test,tests,11785,"PL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:14022,Testability,test,test,14022," libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwrit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:14235,Testability,test,test,14235,"ersion: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:14450,Testability,test,test,14450,"x-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_ru",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:14667,Testability,test,test,14667," FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritte",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:15248,Testability,test,test,15248,".jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:15444,Testability,test,test,15444,"/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:15637,Testability,test,test,15637,"id/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Us",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:15835,Testability,test,test,15835,"itten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:16045,Testability,test,test,16045,"definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:16249,Testability,test,test,16249,"for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition fie",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:16458,Testability,test,test,16458,"jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Me",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:16675,Testability,test,test,16675,"e same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNIN",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:16911,Testability,test,test,16911," to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:17127,Testability,test,test,17127,"nclude`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Ma",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:17355,Testability,test,test,17355,"od definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:17577,Testability,test,test,17577," discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:17771,Testability,test,test,17771,"NING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_ru",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:17970,Testability,test,test,17970,"r duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:18174,Testability,test,test,18174,"ne (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:18366,Testability,test,test,18366,"ts.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:18563,Testability,test,test,18563,".jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:18765,Testability,test,test,18765,"/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:18962,Testability,test,test,18962,"st/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:19164,Testability,test,test,19164,"test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:19371,Testability,test,test,19371,"runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:19563,Testability,test,test,19563,"_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:19760,Testability,test,test,19760,"utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/na",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:19962,Testability,test,test,19962,"_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:20164,Testability,test,test,20164,"_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:20371,Testability,test,test,20371,"_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:20583,Testability,test,test,20583," overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:20792,Testability,test,test,20792," on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_funct",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:21006,Testability,test,test,21006," line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_funct",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:21225,Testability,test,test,21225,"duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:21436,Testability,test,test,21436,"icate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:21652,Testability,test,test,21652,"e calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:21873,Testability,test,test,21873,"include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(A",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:22077,Testability,test,test,22077,"calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_dis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:22286,Testability,test,test,22286,"duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definitio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:22500,Testability,test,test,22500,"licate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Metho",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:22718,Testability,test,test,22718,"cate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:22941,Testability,test,test,22941,"te calls to `include`).; WARNING: Method definition discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:23169,Testability,test,test,23169," WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:23394,Testability,test,test,23394," definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPla",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:23624,Testability,test,test,23624,"meterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float64}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float64}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); Test Summary: | Pass Total Time; Oceananigans | 90 90 1.8s; Testing Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:23859,Testability,test,test,23859," in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float64}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float64}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); Test Summary: | Pass Total Time; Oceananigans | 90 90 1.8s; Testing Oceananigans tests passed ; ```. Closes #3507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:23993,Testability,Test,Testing,23993," in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float64}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float64}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); Test Summary: | Pass Total Time; Oceananigans | 90 90 1.8s; Testing Oceananigans tests passed ; ```. Closes #3507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:24556,Testability,Test,Test,24556," in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float64}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float64}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); Test Summary: | Pass Total Time; Oceananigans | 90 90 1.8s; Testing Oceananigans tests passed ; ```. Closes #3507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:24616,Testability,Test,Testing,24616," in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float64}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float64}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); Test Summary: | Pass Total Time; Oceananigans | 90 90 1.8s; Testing Oceananigans tests passed ; ```. Closes #3507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:24637,Testability,test,tests,24637," in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float64}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float64}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); Test Summary: | Pass Total Time; Oceananigans | 90 90 1.8s; Testing Oceananigans tests passed ; ```. Closes #3507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3511:5601,Usability,Simpl,SimpleBufferStream,5601,rrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [01d81517] RecipesPipeline v0.6.12; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.1; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [6c6a2e73] Scratch v1.2.1; [d496a93d] SeawaterPolynomials v0.3.4; [91c51154] SentinelArrays v1.4.1; [992d4aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c2747f8] URIs v1.5.1; [1cfade01] UnicodeFun v0.4.1; [1986cc42] Unitful v1.19.0; [45397f5d] UnitfulLatexify v1.6.3; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] Unsa,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511
https://github.com/CliMA/Oceananigans.jl/pull/3515:421,Energy Efficiency,schedul,schedule,421,"This PR generalizes file splitting for `JLD2OutputWriter`, replacing `max_filesize` with a `file_splitting` keyword argument. To implement a maximum filesize we use. ```julia; JLD2OutputWriter(model, outputs; file_splitting=FileSizeLimit(max_filesize), ...); ```. This feature should also be extended to `NetCDFOutputWriter` in this PR -- hopefully @josuemtzmo can help!. This PR will enable `TimeInterval` (or any other schedule --- `IterationInterval`, `WallTimeInterval`) to be used for splitting output files. Closes #2967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515
https://github.com/CliMA/Oceananigans.jl/pull/3515:292,Modifiability,extend,extended,292,"This PR generalizes file splitting for `JLD2OutputWriter`, replacing `max_filesize` with a `file_splitting` keyword argument. To implement a maximum filesize we use. ```julia; JLD2OutputWriter(model, outputs; file_splitting=FileSizeLimit(max_filesize), ...); ```. This feature should also be extended to `NetCDFOutputWriter` in this PR -- hopefully @josuemtzmo can help!. This PR will enable `TimeInterval` (or any other schedule --- `IterationInterval`, `WallTimeInterval`) to be used for splitting output files. Closes #2967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515
https://github.com/CliMA/Oceananigans.jl/pull/3518:1118,Availability,down,down,1118,"This PR tries to improve the GPU efficiency of the WENO algorithm by; - using fast math for smoothness calculation (this should not be a problem since weights are normalized); - resorting the WENO algorithm to enforce register reuse by accumulating the solution instead of computing all the stencils at tge same time. WENO-Z weights are calculated as $$\alpha_s = C_s \left( 1 + \left(\frac{\tau}{\beta_s +\varepsilon}\right)^2 \right)$$; and the interpolation is calculated as $$\psi =\frac{1}{\sum \alpha_s} \sum \psi_s \alpha_s$$; so if we reorder we can calculate $\psi$ as $$\psi = \frac{ \tau^2 \hat{\psi}_1 + \hat{\psi}_2}{ \tau^2 \sum \alpha^{\star}_s + 1}$$; where $$\hat{\psi}_1 = \sum\psi_s \alpha^{\star}_s$$ and $$\hat{\psi}_2 = \sum \psi_s C_s$$ and $\alpha^{\star}_s$ are the WENO-JS coefficients that depend only on the local stencil: $$\alpha^{\star}_s = \frac{C_s}{(\beta_s + \varepsilon)^2}$$; We can then calculate stencils one by one by accumulating the results and ""throwing away"" registers we don't need after the computation. This PR is a draft because, despite it works, everything is written down manually unrolled and maybe there is a way to express the same concept with metaprogramming",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3518
https://github.com/CliMA/Oceananigans.jl/pull/3518:817,Integrability,depend,depend,817,"This PR tries to improve the GPU efficiency of the WENO algorithm by; - using fast math for smoothness calculation (this should not be a problem since weights are normalized); - resorting the WENO algorithm to enforce register reuse by accumulating the solution instead of computing all the stencils at tge same time. WENO-Z weights are calculated as $$\alpha_s = C_s \left( 1 + \left(\frac{\tau}{\beta_s +\varepsilon}\right)^2 \right)$$; and the interpolation is calculated as $$\psi =\frac{1}{\sum \alpha_s} \sum \psi_s \alpha_s$$; so if we reorder we can calculate $\psi$ as $$\psi = \frac{ \tau^2 \hat{\psi}_1 + \hat{\psi}_2}{ \tau^2 \sum \alpha^{\star}_s + 1}$$; where $$\hat{\psi}_1 = \sum\psi_s \alpha^{\star}_s$$ and $$\hat{\psi}_2 = \sum \psi_s C_s$$ and $\alpha^{\star}_s$ are the WENO-JS coefficients that depend only on the local stencil: $$\alpha^{\star}_s = \frac{C_s}{(\beta_s + \varepsilon)^2}$$; We can then calculate stencils one by one by accumulating the results and ""throwing away"" registers we don't need after the computation. This PR is a draft because, despite it works, everything is written down manually unrolled and maybe there is a way to express the same concept with metaprogramming",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3518
https://github.com/CliMA/Oceananigans.jl/issues/3520:60,Availability,error,errors,60,"A lot of times the docs build fail. I notice that there are errors in the installation of deps and precompilation part of the docs build. I'm not totally sure that Manifest.toml is the culprit but shipping docs with its Manifest does require us to use non-conventional ways to build the docs. Specifically, we can't use `Pkg.develop` to install the required deps eg. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. and instead we have to rely to. https://github.com/CliMA/Oceananigans.jl/blob/adb728c8f5bdcd24729b8b9282459fc0344bca5b/docs/make.jl#L5-L11. I would like to experiment whether removing docs/Manifest.toml and using proper compat entries in docs/Project.toml will alleviate some of the issues",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3520
https://github.com/CliMA/Oceananigans.jl/issues/3520:74,Deployability,install,installation,74,"A lot of times the docs build fail. I notice that there are errors in the installation of deps and precompilation part of the docs build. I'm not totally sure that Manifest.toml is the culprit but shipping docs with its Manifest does require us to use non-conventional ways to build the docs. Specifically, we can't use `Pkg.develop` to install the required deps eg. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. and instead we have to rely to. https://github.com/CliMA/Oceananigans.jl/blob/adb728c8f5bdcd24729b8b9282459fc0344bca5b/docs/make.jl#L5-L11. I would like to experiment whether removing docs/Manifest.toml and using proper compat entries in docs/Project.toml will alleviate some of the issues",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3520
https://github.com/CliMA/Oceananigans.jl/issues/3520:337,Deployability,install,install,337,"A lot of times the docs build fail. I notice that there are errors in the installation of deps and precompilation part of the docs build. I'm not totally sure that Manifest.toml is the culprit but shipping docs with its Manifest does require us to use non-conventional ways to build the docs. Specifically, we can't use `Pkg.develop` to install the required deps eg. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. and instead we have to rely to. https://github.com/CliMA/Oceananigans.jl/blob/adb728c8f5bdcd24729b8b9282459fc0344bca5b/docs/make.jl#L5-L11. I would like to experiment whether removing docs/Manifest.toml and using proper compat entries in docs/Project.toml will alleviate some of the issues",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3520
https://github.com/CliMA/Oceananigans.jl/issues/3522:115,Availability,error,errors,115,"@glwagner I am attempting to run the Kelvin-Helmholtz instability example on a GPU, but the model fails and throws errors. Can someone help me to sort out this error? Please find the attached error below: . ```julia; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. ```; Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522
https://github.com/CliMA/Oceananigans.jl/issues/3522:160,Availability,error,error,160,"@glwagner I am attempting to run the Kelvin-Helmholtz instability example on a GPU, but the model fails and throws errors. Can someone help me to sort out this error? Please find the attached error below: . ```julia; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. ```; Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522
https://github.com/CliMA/Oceananigans.jl/issues/3522:192,Availability,error,error,192,"@glwagner I am attempting to run the Kelvin-Helmholtz instability example on a GPU, but the model fails and throws errors. Can someone help me to sort out this error? Please find the attached error below: . ```julia; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. ```; Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522
https://github.com/CliMA/Oceananigans.jl/issues/3522:686,Availability,Error,Error,686,"@glwagner I am attempting to run the Kelvin-Helmholtz instability example on a GPU, but the model fails and throws errors. Can someone help me to sort out this error? Please find the attached error below: . ```julia; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. ```; Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522
https://github.com/CliMA/Oceananigans.jl/issues/3522:602,Energy Efficiency,Power,Power,602,"@glwagner I am attempting to run the Kelvin-Helmholtz instability example on a GPU, but the model fails and throws errors. Can someone help me to sort out this error? Please find the attached error below: . ```julia; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. ```; Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522
https://github.com/CliMA/Oceananigans.jl/issues/3522:974,Safety,avoid,avoided,974,"@glwagner I am attempting to run the Kelvin-Helmholtz instability example on a GPU, but the model fails and throws errors. Can someone help me to sort out this error? Please find the attached error below: . ```julia; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. ```; Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522
https://github.com/CliMA/Oceananigans.jl/pull/3523:5,Testability,test,tests,5,"Adds tests for splitting output based on time-interval, e.g., . ```Julia; ow = JLD2OutputWriter(model, (; u);; filename = ""test.jld2"",; ...; file_splitting = TimeInterval(3seconds); ); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523
https://github.com/CliMA/Oceananigans.jl/pull/3523:123,Testability,test,test,123,"Adds tests for splitting output based on time-interval, e.g., . ```Julia; ow = JLD2OutputWriter(model, (; u);; filename = ""test.jld2"",; ...; file_splitting = TimeInterval(3seconds); ); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523
https://github.com/CliMA/Oceananigans.jl/issues/3525:59,Modifiability,layers,layers,59,"It seems to me that the use of `Forcing` as sponge/nudging layers that are only active in a small part of the domain is pretty common for code written with Oceananigans. I've done that in pretty much every doubly-periodic upper ocean LES that I've run. With open boundary conditions being implemented in https://github.com/CliMA/Oceananigans.jl/pull/3482, it looks like the use of these thin sponge layers will become even more common. Currently implementing these layers as `Forcing` means they'll be calculated at every point in the domain, regardless of them being useful only in a small region. I wonder if it's worth adding some mapping of active nodes so that we can save computational resources by only calculating `Forcing` where it's needed. If I understand correctly, `ImmersedBoundaryGrid` already has something like that?:. https://github.com/CliMA/Oceananigans.jl/blob/4367d422fd5780396da4ef660acd81a7fccce6df/src/ImmersedBoundaries/active_cells_map.jl#L91-L109. Although I do remember some discussion in the past about how it wasn't always worth passing a map, which is probably why this feature is optional. I'm curious about what people think of this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525
https://github.com/CliMA/Oceananigans.jl/issues/3525:399,Modifiability,layers,layers,399,"It seems to me that the use of `Forcing` as sponge/nudging layers that are only active in a small part of the domain is pretty common for code written with Oceananigans. I've done that in pretty much every doubly-periodic upper ocean LES that I've run. With open boundary conditions being implemented in https://github.com/CliMA/Oceananigans.jl/pull/3482, it looks like the use of these thin sponge layers will become even more common. Currently implementing these layers as `Forcing` means they'll be calculated at every point in the domain, regardless of them being useful only in a small region. I wonder if it's worth adding some mapping of active nodes so that we can save computational resources by only calculating `Forcing` where it's needed. If I understand correctly, `ImmersedBoundaryGrid` already has something like that?:. https://github.com/CliMA/Oceananigans.jl/blob/4367d422fd5780396da4ef660acd81a7fccce6df/src/ImmersedBoundaries/active_cells_map.jl#L91-L109. Although I do remember some discussion in the past about how it wasn't always worth passing a map, which is probably why this feature is optional. I'm curious about what people think of this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525
https://github.com/CliMA/Oceananigans.jl/issues/3525:465,Modifiability,layers,layers,465,"It seems to me that the use of `Forcing` as sponge/nudging layers that are only active in a small part of the domain is pretty common for code written with Oceananigans. I've done that in pretty much every doubly-periodic upper ocean LES that I've run. With open boundary conditions being implemented in https://github.com/CliMA/Oceananigans.jl/pull/3482, it looks like the use of these thin sponge layers will become even more common. Currently implementing these layers as `Forcing` means they'll be calculated at every point in the domain, regardless of them being useful only in a small region. I wonder if it's worth adding some mapping of active nodes so that we can save computational resources by only calculating `Forcing` where it's needed. If I understand correctly, `ImmersedBoundaryGrid` already has something like that?:. https://github.com/CliMA/Oceananigans.jl/blob/4367d422fd5780396da4ef660acd81a7fccce6df/src/ImmersedBoundaries/active_cells_map.jl#L91-L109. Although I do remember some discussion in the past about how it wasn't always worth passing a map, which is probably why this feature is optional. I'm curious about what people think of this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525
https://github.com/CliMA/Oceananigans.jl/issues/3526:721,Safety,avoid,avoid,721,"To better understand [Wenegrat and Thomas, JPO 2020](https://journals.ametsoc.org/view/journals/phoc/50/6/JPO-D-20-0027.1.xml?tab_body=pdf) (WT2020) I modifed the following examples:. 1. [Internal tide by a seamount](https://clima.github.io/OceananigansDocumentation/stable/generated/internal_tide/) and . 2. [Tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/) ,. to study the dynamics of constant flow over a linearly slowing bottom. Note that I tried to pick the parameters as close to one of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526
https://github.com/CliMA/Oceananigans.jl/issues/3526:1350,Security,validat,validation,1350,"ma.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/) ,. to study the dynamics of constant flow over a linearly slowing bottom. Note that I tried to pick the parameters as close to one of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with what is said in the paper. It seems odd that slip boundary conditions yields a flow that gets faster over the topography, but that is not a problem. ![v_b_final_slip_take1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/b1c88bdf-cdcd-4286-967c-b56e8aab5e07). The second plot shows at heatmap of the velocity profile and a contour plot of the isopycna",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526
https://github.com/CliMA/Oceananigans.jl/issues/3526:1567,Security,validat,validation,1567," of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with what is said in the paper. It seems odd that slip boundary conditions yields a flow that gets faster over the topography, but that is not a problem. ![v_b_final_slip_take1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/b1c88bdf-cdcd-4286-967c-b56e8aab5e07). The second plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of a tilted geometry (take2). This case generates a boundary layer at the top as well, but it's less well resolved because I am using a stretched grid at the bottom. Not a problem, just an observation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526
https://github.com/CliMA/Oceananigans.jl/issues/3526:763,Usability,simpl,simpler,763,"To better understand [Wenegrat and Thomas, JPO 2020](https://journals.ametsoc.org/view/journals/phoc/50/6/JPO-D-20-0027.1.xml?tab_body=pdf) (WT2020) I modifed the following examples:. 1. [Internal tide by a seamount](https://clima.github.io/OceananigansDocumentation/stable/generated/internal_tide/) and . 2. [Tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/) ,. to study the dynamics of constant flow over a linearly slowing bottom. Note that I tried to pick the parameters as close to one of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526
https://github.com/CliMA/Oceananigans.jl/pull/3530:290,Availability,robust,robust,290,"There was a. ```Julia; x, y, z = node(...); ```. but only `z` was needed. And `node` returns a different-size tuple depending on how many dimensions of `grid` are non-flat. Thus there was issues sometimes. Now that part of the code became. ```Julia; z = znode(...); ```. which is much more robust!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3530
https://github.com/CliMA/Oceananigans.jl/pull/3530:116,Integrability,depend,depending,116,"There was a. ```Julia; x, y, z = node(...); ```. but only `z` was needed. And `node` returns a different-size tuple depending on how many dimensions of `grid` are non-flat. Thus there was issues sometimes. Now that part of the code became. ```Julia; z = znode(...); ```. which is much more robust!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3530
https://github.com/CliMA/Oceananigans.jl/pull/3535:589,Energy Efficiency,reduce,reduced,589,"This is a small nicety for friendliness^TM. For safety^TM we throw a warning if we reshaped. Just in case it wasn't intended. This allows things like. ```julia; julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1)); 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> c = Field{Nothing, Nothing, Center}(grid); 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand(4)); ┌ Warning: Reshaped 4-element Vector{Float64} to set! its data to; │ 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; └ @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/set!.jl:86; 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.172696, min=0.00231136, mean=0.0906944; ```. which is nice when working with 1D data.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3535
https://github.com/CliMA/Oceananigans.jl/pull/3535:1185,Energy Efficiency,reduce,reduced,1185,"This is a small nicety for friendliness^TM. For safety^TM we throw a warning if we reshaped. Just in case it wasn't intended. This allows things like. ```julia; julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1)); 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> c = Field{Nothing, Nothing, Center}(grid); 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand(4)); ┌ Warning: Reshaped 4-element Vector{Float64} to set! its data to; │ 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; └ @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/set!.jl:86; 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.172696, min=0.00231136, mean=0.0906944; ```. which is nice when working with 1D data.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3535
https://github.com/CliMA/Oceananigans.jl/pull/3535:1351,Energy Efficiency,reduce,reduced,1351,"This is a small nicety for friendliness^TM. For safety^TM we throw a warning if we reshaped. Just in case it wasn't intended. This allows things like. ```julia; julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1)); 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> c = Field{Nothing, Nothing, Center}(grid); 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand(4)); ┌ Warning: Reshaped 4-element Vector{Float64} to set! its data to; │ 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; └ @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/set!.jl:86; 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.172696, min=0.00231136, mean=0.0906944; ```. which is nice when working with 1D data.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3535
https://github.com/CliMA/Oceananigans.jl/pull/3535:48,Safety,safe,safety,48,"This is a small nicety for friendliness^TM. For safety^TM we throw a warning if we reshaped. Just in case it wasn't intended. This allows things like. ```julia; julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1)); 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> c = Field{Nothing, Nothing, Center}(grid); 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand(4)); ┌ Warning: Reshaped 4-element Vector{Float64} to set! its data to; │ 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; └ @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/set!.jl:86; 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.172696, min=0.00231136, mean=0.0906944; ```. which is nice when working with 1D data.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3535
https://github.com/CliMA/Oceananigans.jl/issues/3537:11,Usability,simpl,simple,11,"Below is a simple script that defines an immersed boundary method for the case of a linearly sloping bottom. Nothing fancy but the resolution is very coarse. ```; using Oceananigans; Lx, Lz = 1000, 200; bottom(x) = -Lz + 2e-2*x; underlying_grid = RectilinearGrid(size = (5, 5), x = (0, Lx), z = (-Lz, 0),; topology = (Bounded, Flat, Bounded)); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)); ```. The `z` levels are correct. ```; julia> underlying_grid.zᵃᵃᶠ[1:6, 1, 1]; 6-element Vector{Float64}:; -200.0; -160.0; -120.0; -80.0; -40.0; 0.0; ```. However, the bottom heights can't be right as they do not align with the level heights. Can someone help me find exactly where the `bottom_heights` are computed?; ````; julia> grid.immersed_boundary.bottom_height.data[1:6,1,1]; 6-element Vector{Float64}:; -198.0; -194.0; -190.0; -186.0; -182.0; -182.0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3537
https://github.com/CliMA/Oceananigans.jl/pull/3541:644,Deployability,pipeline,pipelines,644,"🤖 Beep boop. I am GabrieleBOT. 🤖 Good news! I found a way to reduce unnecessary precompilations! Have you ever noticed that when you move to a GPU node from a CPU one (or viceversa), everything has to be recompiled again? Or sometimes it seems that you are always precompiling... Well, this is partially because the nodes on the Caltech cluster have different architectures, and Julia compiles for the native one, but when you move to a new architecture, the compiled code has to be invalidated and recompiled again. With the latest version of climacommon, I force Julia to always compile for all the possible targets in our cluster. Buildkite pipelines partially do this with the JULIA_TARGET_CPU, but the strings there are incorrect. This PR fixes that too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3541
https://github.com/CliMA/Oceananigans.jl/pull/3541:61,Energy Efficiency,reduce,reduce,61,"🤖 Beep boop. I am GabrieleBOT. 🤖 Good news! I found a way to reduce unnecessary precompilations! Have you ever noticed that when you move to a GPU node from a CPU one (or viceversa), everything has to be recompiled again? Or sometimes it seems that you are always precompiling... Well, this is partially because the nodes on the Caltech cluster have different architectures, and Julia compiles for the native one, but when you move to a new architecture, the compiled code has to be invalidated and recompiled again. With the latest version of climacommon, I force Julia to always compile for all the possible targets in our cluster. Buildkite pipelines partially do this with the JULIA_TARGET_CPU, but the strings there are incorrect. This PR fixes that too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3541
https://github.com/CliMA/Oceananigans.jl/pull/3542:821,Security,validat,validation,821,"Closes #3534. After this PR:. ```Julia; julia> using Oceananigans. julia> model = NonhydrostaticModel(grid = RectilinearGrid(size=(2, 3, 4), extent=(1, 1, 1))); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── advection scheme: Centered reconstruction order 2; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> model = ShallowWaterModel(grid = RectilinearGrid(size = (4, 4), extent = (1, 1), topology=(Periodic, Bounded, Flat)), gravitational_acceleration = 1); ┌ Warning: The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation.; └ @ Oceananigans.Models.ShallowWaterModels ~/Research/OC8.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ShallowWaterModel{typename(CPU), Float64}(time = 0 seconds, iteration = 0) ; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── advection scheme: ; │ ├── momentum: Upwind Biased reconstruction order 5; │ └── mass: WENO reconstruction order 5; ├── tracers: (); └── coriolis: Nothing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3542
https://github.com/CliMA/Oceananigans.jl/issues/3543:1714,Availability,down,downside,1714,"@Sbozzolo suggested that this is a bit silly and I have to agree it is sort of pointless red tape in some ways, rather like ""accepting cookies"" every time we have to visit a website. We don't really think about that anymore, we just click as fast as we can so we can move on with out lives... I think @Sbozzolo might have some idea for how to do this better. More or less I think the gist is that, rather than having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniform",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543
https://github.com/CliMA/Oceananigans.jl/issues/3543:1905,Availability,down,downside,1905,"hink about that anymore, we just click as fast as we can so we can move on with out lives... I think @Sbozzolo might have some idea for how to do this better. More or less I think the gist is that, rather than having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543
https://github.com/CliMA/Oceananigans.jl/issues/3543:3008,Deployability,integrat,integrate,3008,"han having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of introducing anything now (maybe actually showing how to integrate workflow management tools into Oceananigans scripts is a better solution). But I thought it would be useful to open this up for discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543
https://github.com/CliMA/Oceananigans.jl/issues/3543:3008,Integrability,integrat,integrate,3008,"han having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of introducing anything now (maybe actually showing how to integrate workflow management tools into Oceananigans scripts is a better solution). But I thought it would be useful to open this up for discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543
https://github.com/CliMA/Oceananigans.jl/issues/3543:2806,Safety,risk,risk,2806,"han having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of introducing anything now (maybe actually showing how to integrate workflow management tools into Oceananigans scripts is a better solution). But I thought it would be useful to open this up for discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543
https://github.com/CliMA/Oceananigans.jl/issues/3543:1876,Usability,learn,learn,1876,"ss red tape in some ways, rather like ""accepting cookies"" every time we have to visit a website. We don't really think about that anymore, we just click as fast as we can so we can move on with out lives... I think @Sbozzolo might have some idea for how to do this better. More or less I think the gist is that, rather than having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543
https://github.com/CliMA/Oceananigans.jl/issues/3543:2313,Usability,simpl,simply,2313,"han having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of introducing anything now (maybe actually showing how to integrate workflow management tools into Oceananigans scripts is a better solution). But I thought it would be useful to open this up for discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543
https://github.com/CliMA/Oceananigans.jl/pull/3544:5946,Availability,mainten,maintenance,5946,"<a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependenc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:114,Deployability,Release,Release,114,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:213,Deployability,release,releases,213,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:251,Deployability,release,releases,251,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:302,Deployability,Update,Update,302,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:360,Deployability,update,update,360,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:2292,Deployability,install,installation,2292,"abot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0"">https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <code>aarch64</code> / <code>arm64</code>) URLs for Julia nightly by <a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:5928,Deployability,install,install,5928,"<a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependenc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:6634,Deployability,update,updates,6634,"irect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependencies &amp; build</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/b96a5725f5a28e33e247b8ebedb77663a8b9f960""><code>b96a572</code></a> Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> ...</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/437a175294dd49c0c379f79067d8ba50c3f0f31b""><code>437a175</code></a> update to node20 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/209"">#209</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/e9d953d306cac42c94058f27c6564ec50d97d913""><code>e9d953d</code></a> Bump <code>@​types/node</code> from 20.11.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:7333,Deployability,update,update,7333,"ef=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependencies &amp; build</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/b96a5725f5a28e33e247b8ebedb77663a8b9f960""><code>b96a572</code></a> Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> ...</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/437a175294dd49c0c379f79067d8ba50c3f0f31b""><code>437a175</code></a> update to node20 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/209"">#209</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/e9d953d306cac42c94058f27c6564ec50d97d913""><code>e9d953d</code></a> Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8702,Deployability,update,updates,8702,"setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9979,Deployability,upgrade,upgrade,9979,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:10155,Deployability,upgrade,upgrade,10155,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:10325,Deployability,upgrade,upgrade,10325,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:746,Integrability,Depend,Dependencies,746,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:847,Integrability,depend,dependabot,847,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:867,Integrability,depend,dependabot,867,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:1093,Integrability,depend,dependabot,1093,"s</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://githu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:1113,Integrability,depend,dependabot,1113,"s</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://githu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:1343,Integrability,depend,dependabot,1343," by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0"">https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:1363,Integrability,depend,dependabot,1363," by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0"">https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:2970,Integrability,depend,dependabot,2970,"up-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0"">https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <code>aarch64</code> / <code>arm64</code>) URLs for Julia nightly by <a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:2990,Integrability,depend,dependabot,2990,"up-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0"">https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <code>aarch64</code> / <code>arm64</code>) URLs for Julia nightly by <a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:3219,Integrability,depend,dependabot,3219,"</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <code>aarch64</code> / <code>arm64</code>) URLs for Julia nightly by <a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-action",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:3239,Integrability,depend,dependabot,3239,"</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <code>aarch64</code> / <code>arm64</code>) URLs for Julia nightly by <a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-action",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:3447,Integrability,depend,dependabot,3447,"z""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:3467,Integrability,depend,dependabot,3467,"z""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:3672,Integrability,depend,dependabot,3672,"utterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:3692,Integrability,depend,dependabot,3692,"utterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:3897,Integrability,depend,dependabot,3897,"m 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a hr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:3917,Integrability,depend,dependabot,3917,"m 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a hr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:4076,Integrability,Depend,Dependabot,4076,"ns/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contribut",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:4386,Integrability,depend,dependabot,4386,"<a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:4406,Integrability,depend,dependabot,4406,"<a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:4634,Integrability,depend,dependabot,4634,".com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">Julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:4654,Integrability,depend,dependabot,4654,".com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/217"">julia-actions/setup-julia#217</a></li>; <li>CI: Increase the Dependabot &quot;number of open PRs&quot; limit by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/218"">julia-actions/setup-julia#218</a></li>; <li>Bump prettier from 3.1.1 to 3.2.5 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/216"">julia-actions/setup-julia#216</a></li>; <li>Bump <code>@​types/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">Julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:6918,Integrability,depend,dependencies,6918,"nged</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependencies &amp; build</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/b96a5725f5a28e33e247b8ebedb77663a8b9f960""><code>b96a572</code></a> Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> ...</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/437a175294dd49c0c379f79067d8ba50c3f0f31b""><code>437a175</code></a> update to node20 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/209"">#209</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/e9d953d306cac42c94058f27c6564ec50d97d913""><code>e9d953d</code></a> Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8401,Integrability,Depend,Dependabot,8401,"09</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/e9d953d306cac42c94058f27c6564ec50d97d913""><code>e9d953d</code></a> Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@depend",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8441,Integrability,depend,dependabot-badges,8441,"09</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/e9d953d306cac42c94058f27c6564ec50d97d913""><code>e9d953d</code></a> Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@depend",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8500,Integrability,depend,dependency-name,8500,"13""><code>e9d953d</code></a> Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8682,Integrability,depend,dependabot-security-updates,8682,"setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8739,Integrability,Depend,Dependabot,8739,"mmit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8885,Integrability,depend,dependabot,8885,"@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major versio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8914,Integrability,depend,dependabot-automerge-start,8914,".com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8952,Integrability,depend,dependabot-automerge-end,8952,".com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9004,Integrability,Depend,Dependabot,9004,"://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9071,Integrability,Depend,Dependabot,9071,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9121,Integrability,depend,dependabot,9121,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9165,Integrability,depend,dependabot,9165,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9262,Integrability,depend,dependabot,9262,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9331,Integrability,depend,dependabot,9331,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9422,Integrability,depend,dependabot,9422,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9515,Integrability,depend,dependabot,9515,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9575,Integrability,depend,dependabot,9575,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9621,Integrability,Depend,Dependabot,9621,"mpare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9707,Integrability,depend,dependabot,9707,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9724,Integrability,depend,dependency,9724,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9816,Integrability,depend,dependency,9816,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9832,Integrability,depend,dependabot,9832,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:9898,Integrability,Depend,Dependabot,9898,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:10008,Integrability,depend,dependabot,10008,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:10074,Integrability,Depend,Dependabot,10074,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:10184,Integrability,depend,dependabot,10184,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:10207,Integrability,depend,dependency,10207,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:10247,Integrability,Depend,Dependabot,10247,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:10285,Integrability,depend,dependency,10285,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:2921,Performance,cache,cache,2921,"com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0"">https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <code>aarch64</code> / <code>arm64</code>) URLs for Julia nightly by <a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:5765,Performance,cache,cached,5765,"/li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""htt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:5795,Performance,cache,caches,5795,"/li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""htt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:5542,Safety,avoid,avoid,5542,"es/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8651,Security,secur,security-vulnerabilities,8651,"setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:8693,Security,secur,security-updates,8693,"setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/pull/3544:5913,Testability,test,test,5913,"<a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependenc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544
https://github.com/CliMA/Oceananigans.jl/issues/3545:936,Availability,ERROR,ERROR,936,"I was trying to add some Lagrangian particles to a 2D simulation I was running but Lagrangian particle advection currently assumes that the grid is bounded or periodic in all dimensions. An MWE (on Julia 1.10.1+0.x64.w64.mingw32 and Oceananigans version 0.90.12) that reproduces the issue is:. ```; using Oceananigans; NX, NZ = 16, 16; grid = RectilinearGrid(size=(NX,NZ), x=(0,1), z=(0,1), topology=(Periodic, Flat, Bounded)); # initialise some particles at the cell centres; x₀ = reshape(xnodes(grid, Center()) * ones(NZ)', NX * NZ); y₀ = zeros(NX * NZ); z₀ = reshape(ones(NX) * znodes(grid, Center())', NX * NZ); model = NonhydrostaticModel(; grid, particles=LagrangianParticles(x=x₀, y=y₀, z=z₀)); simulation = Simulation(model; Δt=1, stop_iteration=5); run!(simulation); ```. with output. ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (115.810 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching unsafe_trunc(::Type{Int64}, ::Nothing). Closest candidates are:; unsafe_trunc(::Type{Int64}, ::Union{Float16, Float32, Float64}); @ Base float.jl:336; unsafe_trunc(::Type{<:Integer}, ::BFloat16s.BFloat16); @ BFloat16s C:\Users\hildi\.julia\packages\BFloat16s\u3WQc\src\bfloat16.jl:288; unsafe_trunc(::Type{T}, ::BigFloat) where T<:Integer; @ Base mpfr.jl:358; ... Stacktrace:; [1] advect_particle; @ C:\Users\hildi\.julia\packages\Oceananigans\kBe5X\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:81 [inlined]. ...; ```. The offending line is https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L81 . which fails because ; https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L79; returns `j = nothing` when `y` is `Flat`. However, I think that in general `advect_particle` is not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3545
https://github.com/CliMA/Oceananigans.jl/issues/3545:943,Performance,Load,LoadError,943,"I was trying to add some Lagrangian particles to a 2D simulation I was running but Lagrangian particle advection currently assumes that the grid is bounded or periodic in all dimensions. An MWE (on Julia 1.10.1+0.x64.w64.mingw32 and Oceananigans version 0.90.12) that reproduces the issue is:. ```; using Oceananigans; NX, NZ = 16, 16; grid = RectilinearGrid(size=(NX,NZ), x=(0,1), z=(0,1), topology=(Periodic, Flat, Bounded)); # initialise some particles at the cell centres; x₀ = reshape(xnodes(grid, Center()) * ones(NZ)', NX * NZ); y₀ = zeros(NX * NZ); z₀ = reshape(ones(NX) * znodes(grid, Center())', NX * NZ); model = NonhydrostaticModel(; grid, particles=LagrangianParticles(x=x₀, y=y₀, z=z₀)); simulation = Simulation(model; Δt=1, stop_iteration=5); run!(simulation); ```. with output. ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (115.810 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching unsafe_trunc(::Type{Int64}, ::Nothing). Closest candidates are:; unsafe_trunc(::Type{Int64}, ::Union{Float16, Float32, Float64}); @ Base float.jl:336; unsafe_trunc(::Type{<:Integer}, ::BFloat16s.BFloat16); @ BFloat16s C:\Users\hildi\.julia\packages\BFloat16s\u3WQc\src\bfloat16.jl:288; unsafe_trunc(::Type{T}, ::BigFloat) where T<:Integer; @ Base mpfr.jl:358; ... Stacktrace:; [1] advect_particle; @ C:\Users\hildi\.julia\packages\Oceananigans\kBe5X\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:81 [inlined]. ...; ```. The offending line is https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L81 . which fails because ; https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L79; returns `j = nothing` when `y` is `Flat`. However, I think that in general `advect_particle` is not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3545
https://github.com/CliMA/Oceananigans.jl/issues/3545:2318,Usability,simpl,simply,2318,"cktrace:; [1] advect_particle; @ C:\Users\hildi\.julia\packages\Oceananigans\kBe5X\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:81 [inlined]. ...; ```. The offending line is https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L81 . which fails because ; https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L79; returns `j = nothing` when `y` is `Flat`. However, I think that in general `advect_particle` is not written with Flat topologies in mind. For example, there are no boundary conditions implemented for the Flat topology. . The ability to do 2D (and 1D) Lagrangian particles would be quite useful. Although, it's not obvious what it means to advect a particle in the Flat direction. Skipping that direction entirely or simply accumulating the displacement in that direction (as I do below) could both be valid in some contexts. (For my original use case I don't care what happens in `y`.). Finally, for this particular simple example, propagating `j = nothing` through `unsafe_trunc` and defining some boundary conditions was sufficient to make the example run. ```; using Oceananigans. Base.unsafe_trunc(::T, ::Nothing) where {T} = nothing; Oceananigans.Models.LagrangianParticleTracking.enforce_boundary_conditions(::Flat, x, xᴸ, xᴿ, Cʳ) = x. NX, NZ = 16, 16; grid = RectilinearGrid(size=(NX,NZ), x=(0,1), z=(0,1), topology=(Periodic, Flat, Bounded)); # initialise some particles at the cell centres; x₀ = reshape(xnodes(grid, Center()) * ones(NZ)', NX * NZ); y₀ = zeros(NX * NZ); z₀ = reshape(ones(NX) * znodes(grid, Center())', NX * NZ); model = NonhydrostaticModel(; grid, particles=LagrangianParticles(x=x₀, y=y₀, z=z₀)); simulation = Simulation(model; Δt=1, stop_iteration=5); run!(simulation); ```; I'm not sure whether propagating `j = nothing` f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3545
https://github.com/CliMA/Oceananigans.jl/issues/3545:2518,Usability,simpl,simple,2518,"icle_advection.jl:81 [inlined]. ...; ```. The offending line is https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L81 . which fails because ; https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L79; returns `j = nothing` when `y` is `Flat`. However, I think that in general `advect_particle` is not written with Flat topologies in mind. For example, there are no boundary conditions implemented for the Flat topology. . The ability to do 2D (and 1D) Lagrangian particles would be quite useful. Although, it's not obvious what it means to advect a particle in the Flat direction. Skipping that direction entirely or simply accumulating the displacement in that direction (as I do below) could both be valid in some contexts. (For my original use case I don't care what happens in `y`.). Finally, for this particular simple example, propagating `j = nothing` through `unsafe_trunc` and defining some boundary conditions was sufficient to make the example run. ```; using Oceananigans. Base.unsafe_trunc(::T, ::Nothing) where {T} = nothing; Oceananigans.Models.LagrangianParticleTracking.enforce_boundary_conditions(::Flat, x, xᴸ, xᴿ, Cʳ) = x. NX, NZ = 16, 16; grid = RectilinearGrid(size=(NX,NZ), x=(0,1), z=(0,1), topology=(Periodic, Flat, Bounded)); # initialise some particles at the cell centres; x₀ = reshape(xnodes(grid, Center()) * ones(NZ)', NX * NZ); y₀ = zeros(NX * NZ); z₀ = reshape(ones(NX) * znodes(grid, Center())', NX * NZ); model = NonhydrostaticModel(; grid, particles=LagrangianParticles(x=x₀, y=y₀, z=z₀)); simulation = Simulation(model; Δt=1, stop_iteration=5); run!(simulation); ```; I'm not sure whether propagating `j = nothing` forward is a sensible or desirable thing to do, or if it even works in other cases, but I thought that I'd point out that it works here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3545
https://github.com/CliMA/Oceananigans.jl/pull/3551:10,Availability,error,error,10,"Fixing an error in the quick start code: set!(model, u=\epsilon, v=\epsilon) fails if the function \epsilon only has two arguments. Code runs if a third argument is added to the \epsilon definition.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3551
https://github.com/CliMA/Oceananigans.jl/issues/3552:1584,Testability,log,logs,1584,"cd64354) as suggested by @simone-silvestri. It turned out that using `ImmersedPoissonSolver` makes the simulation tens of times slower than the original simulation without using an immersed boundary condition. Besides. using `AsymptoticInverse` or `ILUFactorization` preconditioner makes the simulation even slower. Here are the details of my runs. I did three runs. The domain size is 170 x 1320 x 50. In the first run, I used no preconditioner,; and the pressure solver is; ```Julia; pressure_solver = ImmersedPoissonSolver(; ib_grid,; solver_method = :HeptadiagonalIterativeSolver,; reltol = 1e-8,; verbose = true; ); ```. In the second run, I used the `AsymptoticInverse` preconditioner:; ```Julia; pressure_solver = ImmersedPoissonSolver(; ib_grid,; solver_method = :HeptadiagonalIterativeSolver,; reltol = 1e-8,; preconditioner = :AsymptoticInverse,; verbose = true; ); ```. In the third run, I used the `ILUFactorization` preconditioner:; ```Julia; pressure_solver = ImmersedPoissonSolver(; ib_grid,; solver_method = :HeptadiagonalIterativeSolver,; reltol = 1e-8,; preconditioner = :ILUFactorization,; verbose = true; ); ```. I ran each simulation on a NVIDIA V100 GPU \(on MIT Satori\) for 4 hours and calculated the number of iterations in unit time. As a result, the speeds of these three simulations are 134, 62, and 29 iterations per hour respectively. The full scripts for three runs and the corresponding output logs are given here:; - No preconditioner: [run_a1.tar.gz](https://github.com/CliMA/Oceananigans.jl/files/14963710/run_a1.tar.gz); - `AsymptoticInverse` preconditioner: [run_a2.tar.gz](https://github.com/CliMA/Oceananigans.jl/files/14963712/run_a2.tar.gz); - `ILUFactorization` preconditioner: [run_a3.tar.gz](https://github.com/CliMA/Oceananigans.jl/files/14963714/run_a3.tar.gz). Version info:; - Julia: v1.9.3; - Oceananigans v0.86.0 `dev/Oceananigans` [this branch](https://github.com/CliMA/Oceananigans.jl/commit/4529c6e49b9ebd9dbefb71725ef32b1d3cd64354); - CUDA v5.2.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552
https://github.com/CliMA/Oceananigans.jl/pull/3553:14,Testability,test,testing,14,@glwagner I'm testing in this PR using https://github.com/glwagner/OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3553
https://github.com/CliMA/Oceananigans.jl/pull/3554:23,Usability,simpl,simple,23,Fix typo in header for simple diffusion example.; It also fixes crosslinks from quickstart not working.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3554
https://github.com/CliMA/Oceananigans.jl/issues/3555:138,Availability,error,error,138,"Trying to use OceanScalingTest.jl from @simone-silvestri as a benchmark for TTFTS (Time-To-First-Time-Step) I came across this delightful error:. ```; ERROR: LoadError: Evaluation into the closed module `Grids` breaks incremental compilation because the side effects will not be permanent. This is likely due to some other module mutating `Grids` with `eval` during precompilation - don't do this.; Stacktrace:; [1] eval; @ ./boot.jl:428 [inlined]; [2] allocate_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Oceananigans.DistributedComputations.Distributed{Oceananigans.Architectures.GPU, false, Oceananigans.DistributedComputations.Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/kBe5X/src/Grids/latitude_longitude_grid.jl:554; [3] with_precomputed_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555
https://github.com/CliMA/Oceananigans.jl/issues/3555:151,Availability,ERROR,ERROR,151,"Trying to use OceanScalingTest.jl from @simone-silvestri as a benchmark for TTFTS (Time-To-First-Time-Step) I came across this delightful error:. ```; ERROR: LoadError: Evaluation into the closed module `Grids` breaks incremental compilation because the side effects will not be permanent. This is likely due to some other module mutating `Grids` with `eval` during precompilation - don't do this.; Stacktrace:; [1] eval; @ ./boot.jl:428 [inlined]; [2] allocate_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Oceananigans.DistributedComputations.Distributed{Oceananigans.Architectures.GPU, false, Oceananigans.DistributedComputations.Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/kBe5X/src/Grids/latitude_longitude_grid.jl:554; [3] with_precomputed_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555
https://github.com/CliMA/Oceananigans.jl/issues/3555:7183,Modifiability,variab,variables,7183,"ol, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2664; [17] top-level scope; @ stdin:4; in expression starting at /home/vchuravy/src/OceanScalingTests.jl/src/OceanScalingTests.jl:1; in expression starting at stdin:; ```. Caused by `@eval`. Note that `@eval` uses the current module and not the module the user is calling this function from.; This means we are trying to modify the Oceananigans after it has already been closed. This is imcompatible with precompilation since we are unable to track and restore this modification. My intuition is that you probably just want a dictionary for these kind of globals, maybe even within the model? ; Instead of using global variables. . https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Grids/latitude_longitude_grid.jl#L554-L555. The use-case is shown in https://github.com/simone-silvestri/OceanScalingTests.jl/pull/8 where one wants to use `PrecompileTools` to cache important functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555
https://github.com/CliMA/Oceananigans.jl/issues/3555:158,Performance,Load,LoadError,158,"Trying to use OceanScalingTest.jl from @simone-silvestri as a benchmark for TTFTS (Time-To-First-Time-Step) I came across this delightful error:. ```; ERROR: LoadError: Evaluation into the closed module `Grids` breaks incremental compilation because the side effects will not be permanent. This is likely due to some other module mutating `Grids` with `eval` during precompilation - don't do this.; Stacktrace:; [1] eval; @ ./boot.jl:428 [inlined]; [2] allocate_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Oceananigans.DistributedComputations.Distributed{Oceananigans.Architectures.GPU, false, Oceananigans.DistributedComputations.Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/kBe5X/src/Grids/latitude_longitude_grid.jl:554; [3] with_precomputed_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555
https://github.com/CliMA/Oceananigans.jl/issues/3555:5475,Performance,load,loadbalance,5475,"utedComputations.Distributed{Oceananigans.Architectures.GPU, false, Oceananigans.DistributedComputations.Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}, precision::Type, N::Tuple{Int64, Int64, Int64}, latitude::Tuple{Int64, Int64}, z_faces::Vector{Float64}, resolution::Int64, ::Val{false}, ::Val{:DoubleDrake}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/grid_load_balance.jl:16; [9] scaling_test_simulation(resolution::Int64, ranks::Tuple{Int64, Int64, Int64}, Δt::Tuple{Int64, Float64}, stop_time::Float64; child_arch::Oceananigans.Architectures.GPU, experiment::Symbol, Depth::Int64, latitude::Tuple{Int64, Int64}, restart::String, z_faces_function::typeof(OceanScalingTests.exponential_z_faces), Nz::Int64, profile::Bool, with_fluxes::Bool, with_restoring::Bool, loadbalance::Bool, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{Strin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555
https://github.com/CliMA/Oceananigans.jl/issues/3555:6553,Performance,load,loading,6553,"ol, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2664; [17] top-level scope; @ stdin:4; in expression starting at /home/vchuravy/src/OceanScalingTests.jl/src/OceanScalingTests.jl:1; in expression starting at stdin:; ```. Caused by `@eval`. Note that `@eval` uses the current module and not the module the user is calling this function from.; This means we are trying to modify the Oceananigans after it has already been closed. This is imcompatible with precompilation since we are unable to track and restore this modification. My intuition is that you probably just want a dictionary for these kind of globals, maybe even within the model? ; Instead of using global variables. . https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Grids/latitude_longitude_grid.jl#L554-L555. The use-case is shown in https://github.com/simone-silvestri/OceanScalingTests.jl/pull/8 where one wants to use `PrecompileTools` to cache important functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555
https://github.com/CliMA/Oceananigans.jl/issues/3555:7464,Performance,cache,cache,7464,"ol, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2664; [17] top-level scope; @ stdin:4; in expression starting at /home/vchuravy/src/OceanScalingTests.jl/src/OceanScalingTests.jl:1; in expression starting at stdin:; ```. Caused by `@eval`. Note that `@eval` uses the current module and not the module the user is calling this function from.; This means we are trying to modify the Oceananigans after it has already been closed. This is imcompatible with precompilation since we are unable to track and restore this modification. My intuition is that you probably just want a dictionary for these kind of globals, maybe even within the model? ; Instead of using global variables. . https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Grids/latitude_longitude_grid.jl#L554-L555. The use-case is shown in https://github.com/simone-silvestri/OceanScalingTests.jl/pull/8 where one wants to use `PrecompileTools` to cache important functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555
https://github.com/CliMA/Oceananigans.jl/issues/3555:62,Testability,benchmark,benchmark,62,"Trying to use OceanScalingTest.jl from @simone-silvestri as a benchmark for TTFTS (Time-To-First-Time-Step) I came across this delightful error:. ```; ERROR: LoadError: Evaluation into the closed module `Grids` breaks incremental compilation because the side effects will not be permanent. This is likely due to some other module mutating `Grids` with `eval` during precompilation - don't do this.; Stacktrace:; [1] eval; @ ./boot.jl:428 [inlined]; [2] allocate_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Oceananigans.DistributedComputations.Distributed{Oceananigans.Architectures.GPU, false, Oceananigans.DistributedComputations.Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/kBe5X/src/Grids/latitude_longitude_grid.jl:554; [3] with_precomputed_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555
https://github.com/CliMA/Oceananigans.jl/issues/3555:7047,Usability,intuit,intuition,7047,"ol, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2664; [17] top-level scope; @ stdin:4; in expression starting at /home/vchuravy/src/OceanScalingTests.jl/src/OceanScalingTests.jl:1; in expression starting at stdin:; ```. Caused by `@eval`. Note that `@eval` uses the current module and not the module the user is calling this function from.; This means we are trying to modify the Oceananigans after it has already been closed. This is imcompatible with precompilation since we are unable to track and restore this modification. My intuition is that you probably just want a dictionary for these kind of globals, maybe even within the model? ; Instead of using global variables. . https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Grids/latitude_longitude_grid.jl#L554-L555. The use-case is shown in https://github.com/simone-silvestri/OceanScalingTests.jl/pull/8 where one wants to use `PrecompileTools` to cache important functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555
https://github.com/CliMA/Oceananigans.jl/issues/3560:161,Availability,mask,mask,161,"Hi all, I am simulating an ocean surface mixed layer. However, I always get lots of noise in the ocean interior below the mixed layer. I have applied a Gaussian-mask sponge layer near the bottom. But the noise is still there. Below are two figures of the vertical velocity and buoyancy perturbations. Any suggestions?; ![b](https://github.com/CliMA/Oceananigans.jl/assets/46232007/f160c0b6-df59-4d8a-89a2-b6de279a6e23); ![w](https://github.com/CliMA/Oceananigans.jl/assets/46232007/1d42358b-c512-41c4-bffb-035a6a169b2b). Here are the codes for the sponge. ps. the whole depth is Lz = 150 m and the mixed layer is about 80m. ######========================================; damping_rate = 1/1800 # relax fields on a 100 second time-scale; bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/3); uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask). model = NonhydrostaticModel(; grid, coriolis,; advection = WENO(),; timestepper = :RungeKutta3,; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = AnisotropicMinimumDissipation(),; stokes_drift = UniformStokesDrift(∂z_vˢ=∂z_vˢ),; boundary_conditions = (v=v_boundary_conditions, b=b_boundary_conditions),; forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge)); #####============================================",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3560
https://github.com/CliMA/Oceananigans.jl/issues/3560:846,Availability,mask,mask,846,"Hi all, I am simulating an ocean surface mixed layer. However, I always get lots of noise in the ocean interior below the mixed layer. I have applied a Gaussian-mask sponge layer near the bottom. But the noise is still there. Below are two figures of the vertical velocity and buoyancy perturbations. Any suggestions?; ![b](https://github.com/CliMA/Oceananigans.jl/assets/46232007/f160c0b6-df59-4d8a-89a2-b6de279a6e23); ![w](https://github.com/CliMA/Oceananigans.jl/assets/46232007/1d42358b-c512-41c4-bffb-035a6a169b2b). Here are the codes for the sponge. ps. the whole depth is Lz = 150 m and the mixed layer is about 80m. ######========================================; damping_rate = 1/1800 # relax fields on a 100 second time-scale; bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/3); uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask). model = NonhydrostaticModel(; grid, coriolis,; advection = WENO(),; timestepper = :RungeKutta3,; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = AnisotropicMinimumDissipation(),; stokes_drift = UniformStokesDrift(∂z_vˢ=∂z_vˢ),; boundary_conditions = (v=v_boundary_conditions, b=b_boundary_conditions),; forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge)); #####============================================",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3560
https://github.com/CliMA/Oceananigans.jl/issues/3564:5,Safety,redund,redundancy,5,"This redundancy creates the risk that they can be inconsistent, plus confusion about whether `previous_Δt` and `last_Δt` represent the same thing (they do). https://github.com/CliMA/Oceananigans.jl/blob/1ee317b9b6986436f18dd12d7fcdd7067d9234b7/src/TimeSteppers/clock.jl#L17. https://github.com/CliMA/Oceananigans.jl/blob/1ee317b9b6986436f18dd12d7fcdd7067d9234b7/src/TimeSteppers/quasi_adams_bashforth_2.jl#L8. We need to eliminate `previous_Δt` from `QuasiAdamsBashforth2TimeStepper`. cc @jagoosw",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3564
https://github.com/CliMA/Oceananigans.jl/issues/3564:28,Safety,risk,risk,28,"This redundancy creates the risk that they can be inconsistent, plus confusion about whether `previous_Δt` and `last_Δt` represent the same thing (they do). https://github.com/CliMA/Oceananigans.jl/blob/1ee317b9b6986436f18dd12d7fcdd7067d9234b7/src/TimeSteppers/clock.jl#L17. https://github.com/CliMA/Oceananigans.jl/blob/1ee317b9b6986436f18dd12d7fcdd7067d9234b7/src/TimeSteppers/quasi_adams_bashforth_2.jl#L8. We need to eliminate `previous_Δt` from `QuasiAdamsBashforth2TimeStepper`. cc @jagoosw",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3564
https://github.com/CliMA/Oceananigans.jl/issues/3568:1218,Deployability,configurat,configurations,1218,"ary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. https://github.com/CliMA/Oceananigans.jl/assets/68127124/d350c5ad-2e14-4992-8c5d-f947a1ddf7bb. This brings up the question: what should the default behavior for background fields b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568
https://github.com/CliMA/Oceananigans.jl/issues/3568:1961,Deployability,configurat,configuration,1961,"n_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. https://github.com/CliMA/Oceananigans.jl/assets/68127124/d350c5ad-2e14-4992-8c5d-f947a1ddf7bb. This brings up the question: what should the default behavior for background fields be? Should they really only appear in the advective terms, or should they also be diffused? And what should the boundary conditions on perturbations be when there are background fields?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568
https://github.com/CliMA/Oceananigans.jl/issues/3568:1218,Modifiability,config,configurations,1218,"ary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. https://github.com/CliMA/Oceananigans.jl/assets/68127124/d350c5ad-2e14-4992-8c5d-f947a1ddf7bb. This brings up the question: what should the default behavior for background fields b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568
https://github.com/CliMA/Oceananigans.jl/issues/3568:1961,Modifiability,config,configuration,1961,"n_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. https://github.com/CliMA/Oceananigans.jl/assets/68127124/d350c5ad-2e14-4992-8c5d-f947a1ddf7bb. This brings up the question: what should the default behavior for background fields be? Should they really only appear in the advective terms, or should they also be diffused? And what should the boundary conditions on perturbations be when there are background fields?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568
https://github.com/CliMA/Oceananigans.jl/issues/3568:150,Testability,test,test,150,"I have modified the [simple 1D diffusion example](https://clima.github.io/OceananigansDocumentation/v0.90.13/literated/one_dimensional_diffusion/) to test how to correct the boundary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568
https://github.com/CliMA/Oceananigans.jl/issues/3568:302,Testability,test,tests,302,"I have modified the [simple 1D diffusion example](https://clima.github.io/OceananigansDocumentation/v0.90.13/literated/one_dimensional_diffusion/) to test how to correct the boundary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568
https://github.com/CliMA/Oceananigans.jl/issues/3568:21,Usability,simpl,simple,21,"I have modified the [simple 1D diffusion example](https://clima.github.io/OceananigansDocumentation/v0.90.13/literated/one_dimensional_diffusion/) to test how to correct the boundary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568
https://github.com/CliMA/Oceananigans.jl/issues/3568:295,Usability,Simpl,Simple-tests,295,"I have modified the [simple 1D diffusion example](https://clima.github.io/OceananigansDocumentation/v0.90.13/literated/one_dimensional_diffusion/) to test how to correct the boundary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568
https://github.com/CliMA/Oceananigans.jl/issues/3568:619,Usability,simpl,simple,619,"I have modified the [simple 1D diffusion example](https://clima.github.io/OceananigansDocumentation/v0.90.13/literated/one_dimensional_diffusion/) to test how to correct the boundary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568
https://github.com/CliMA/Oceananigans.jl/pull/3570:33,Deployability,update,updates,33,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570
https://github.com/CliMA/Oceananigans.jl/pull/3570:119,Deployability,update,update,119,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570
https://github.com/CliMA/Oceananigans.jl/pull/3570:154,Modifiability,variab,variables,154,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570
https://github.com/CliMA/Oceananigans.jl/pull/3570:237,Modifiability,enhance,enhances,237,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570
https://github.com/CliMA/Oceananigans.jl/pull/3570:436,Modifiability,variab,variables,436,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570
https://github.com/CliMA/Oceananigans.jl/pull/3570:389,Testability,test,test,389,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570
https://github.com/CliMA/Oceananigans.jl/pull/3571:52,Deployability,release,release,52,"🤖 Beep boop. I am GabrieleBOT. 🤖 Please, check the [release notes](https://github.com/CliMA/ClimaModules/blob/main/NEWS.md) before merging this PR. Modifications might be required.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3571
https://github.com/CliMA/Oceananigans.jl/issues/3572:918,Availability,ERROR,ERROR,918,"WE:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3, 1), x=(0, 1), y=(0, 1), z=(0, 1));. julia> model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface = ExplicitFreeSurface(; gravitational_acceleration = 10),; closure = nothing,; tracers = nothing,; buoyancy = nothing); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; ├── free surface: ExplicitFreeSurface with gravitational acceleration 10.0 m s⁻²; ├── advection scheme:; │ └── momentum: Nothing; └── coriolis: Nothing. julia> Hc, Nc, Nz = grid.Hx, grid.Nx, grid.Nz; (2, 4, 1). julia> model.free_surface.η[1:Hc, 1:Nc, Nz+1:Nz+1] .= 1; ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [4:6, 4:6, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:248; [5] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:316; [6] maybeview; @ ./views.jl:148 [inlined]; [7] dotview(::Field{…}, ::UnitRange{…}, ::UnitRange{…}, ::UnitRange{…}); @ Base.Broadcast ./broadcast.jl:1244; [8] top-level scope; @ REPL[40]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. The error occurs because",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572
https://github.com/CliMA/Oceananigans.jl/issues/3572:2005,Availability,error,error,2005,"faceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; ├── free surface: ExplicitFreeSurface with gravitational acceleration 10.0 m s⁻²; ├── advection scheme:; │ └── momentum: Nothing; └── coriolis: Nothing. julia> Hc, Nc, Nz = grid.Hx, grid.Nx, grid.Nz; (2, 4, 1). julia> model.free_surface.η[1:Hc, 1:Nc, Nz+1:Nz+1] .= 1; ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [4:6, 4:6, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:248; [5] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:316; [6] maybeview; @ ./views.jl:148 [inlined]; [7] dotview(::Field{…}, ::UnitRange{…}, ::UnitRange{…}, ::UnitRange{…}); @ Base.Broadcast ./broadcast.jl:1244; [8] top-level scope; @ REPL[40]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. The error occurs because the parent array of `model.free_surface.η` takes the z-halo into consideration, which does not exist for the ssh field. Generally, when dealing with 1D or 2D fields, the parent array should consider halos only in the dimensions along which the field is defined, rather than in all dimensions as currently implemented. PR #3573 aims to close this issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572
https://github.com/CliMA/Oceananigans.jl/issues/3572:949,Security,access,access,949,"WE:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3, 1), x=(0, 1), y=(0, 1), z=(0, 1));. julia> model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface = ExplicitFreeSurface(; gravitational_acceleration = 10),; closure = nothing,; tracers = nothing,; buoyancy = nothing); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; ├── free surface: ExplicitFreeSurface with gravitational acceleration 10.0 m s⁻²; ├── advection scheme:; │ └── momentum: Nothing; └── coriolis: Nothing. julia> Hc, Nc, Nz = grid.Hx, grid.Nx, grid.Nz; (2, 4, 1). julia> model.free_surface.η[1:Hc, 1:Nc, Nz+1:Nz+1] .= 1; ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [4:6, 4:6, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:248; [5] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:316; [6] maybeview; @ ./views.jl:148 [inlined]; [7] dotview(::Field{…}, ::UnitRange{…}, ::UnitRange{…}, ::UnitRange{…}); @ Base.Broadcast ./broadcast.jl:1244; [8] top-level scope; @ REPL[40]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. The error occurs because",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572
https://github.com/CliMA/Oceananigans.jl/pull/3574:458,Modifiability,extend,extended,458,"This PR makes the separation computation of the hydrostatic pressure anomaly an optional feature of `NonhydrostaticModel`. It's also off by default, which hopefully means that triply periodic simulations should work by default (@johnryantaylor a while ago you wanted to do a triply periodic simulation, hopefully this PR makes that possible). @tomchor ready to review, let me know what you think about the design. This PR supercedes #3080, where there is an extended description of this change plus a discussion about its pros and cons. Closes #3364 (I think...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574
https://github.com/CliMA/Oceananigans.jl/pull/3575:1029,Modifiability,variab,variably,1029,"Before this PR we couldn't create a ConformalCubedSphereGrid on the GPU due to some scalar operations that occur when we fill the metrics. After this PR:. ```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(GPU(), panel_size = (3, 3, 1), z = (0, 1), radius = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on GPU(): ; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on GPU with 3×3×3 halo and with precomputed metrics ; ├── partitioning: CubedSpherePartition with (1 region in each panel) ; ├── connectivity: CubedSphereConnectivity ; └── devices: (CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0)). julia> grid[3]; 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on GPU with 3×3×3 halo and with precomputed metrics; ├── centered at: North Pole, (λ, φ) = (0.0, 90.0); ├── longitude: FullyConnected extent 90.0 degrees variably spaced with min(Δλ)=16.8962, max(Δλ)=29.6661; ├── latitude: FullyConnected extent 86.9617 degrees variably spaced with min(Δφ)=16.8962, max(Δφ)=29.6661; └── z: Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=1.0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3575
https://github.com/CliMA/Oceananigans.jl/pull/3575:1136,Modifiability,variab,variably,1136,"Before this PR we couldn't create a ConformalCubedSphereGrid on the GPU due to some scalar operations that occur when we fill the metrics. After this PR:. ```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(GPU(), panel_size = (3, 3, 1), z = (0, 1), radius = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on GPU(): ; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on GPU with 3×3×3 halo and with precomputed metrics ; ├── partitioning: CubedSpherePartition with (1 region in each panel) ; ├── connectivity: CubedSphereConnectivity ; └── devices: (CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0)). julia> grid[3]; 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on GPU with 3×3×3 halo and with precomputed metrics; ├── centered at: North Pole, (λ, φ) = (0.0, 90.0); ├── longitude: FullyConnected extent 90.0 degrees variably spaced with min(Δλ)=16.8962, max(Δλ)=29.6661; ├── latitude: FullyConnected extent 86.9617 degrees variably spaced with min(Δφ)=16.8962, max(Δφ)=29.6661; └── z: Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=1.0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3575
https://github.com/CliMA/Oceananigans.jl/issues/3577:357,Security,validat,validation,357,"In for `MultiRegionField`s, we often forced to do, e.g.,. ```julia; for region in 1:number_of_regions(grid); u[region] .= - ∂y(ψ[region]); v[region] .= + ∂x(ψ[region]); end; ```. We'd like to be able to simply do:. ```Julia; u .= - ∂y(ψ); v .= + ∂x(ψ); ```. See, e.g.,; https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/validation/multi_region/cubed_sphere_tracer_advection.jl#L59-L69. cc @siddharthabishnu, @simone-silvestri, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577
https://github.com/CliMA/Oceananigans.jl/issues/3577:203,Usability,simpl,simply,203,"In for `MultiRegionField`s, we often forced to do, e.g.,. ```julia; for region in 1:number_of_regions(grid); u[region] .= - ∂y(ψ[region]); v[region] .= + ∂x(ψ[region]); end; ```. We'd like to be able to simply do:. ```Julia; u .= - ∂y(ψ); v .= + ∂x(ψ); ```. See, e.g.,; https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/validation/multi_region/cubed_sphere_tracer_advection.jl#L59-L69. cc @siddharthabishnu, @simone-silvestri, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577
https://github.com/CliMA/Oceananigans.jl/pull/3579:736,Modifiability,variab,variables,736,"This PR removes a bunch of scalar operations introduced by #3575 on the GPU and instead performs operations on CPU and converts to CuArrays afterwards. There are two issues that don't allow us to create the grid natively on the GPU but rather force us to create the grid on CPU and then convert it. 1. The metrics for the `OrthogonalSphericalShellGrid` use scalar operations; see the functions that are called at https://github.com/CliMA/Oceananigans.jl/blob/4c853b94e6c99949134981153250a4e2391bb0f1/src/Grids/orthogonal_spherical_shell_grid.jl#L780-L782. 2. When we create the `ConformalCubedSphreGrid`, to fill the metric and coordinate horizontal halos properly we use the same functionality that we use to fill halos for prognostic variables. To do that, we create Fields with the coordinate and metric values, call `fill_halo_regions!` on these fields, and then copy back the data from the Fields to the metrics. Copying the data from the metrics to the fields and vice-versa requires scalar operations, e.g., see ; https://github.com/CliMA/Oceananigans.jl/blob/7f12be3d82486b8be2923d8675d2e59c84efd722/src/MultiRegion/cubed_sphere_grid.jl#L280-L292. cc @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3579
https://github.com/CliMA/Oceananigans.jl/pull/3579:88,Performance,perform,performs,88,"This PR removes a bunch of scalar operations introduced by #3575 on the GPU and instead performs operations on CPU and converts to CuArrays afterwards. There are two issues that don't allow us to create the grid natively on the GPU but rather force us to create the grid on CPU and then convert it. 1. The metrics for the `OrthogonalSphericalShellGrid` use scalar operations; see the functions that are called at https://github.com/CliMA/Oceananigans.jl/blob/4c853b94e6c99949134981153250a4e2391bb0f1/src/Grids/orthogonal_spherical_shell_grid.jl#L780-L782. 2. When we create the `ConformalCubedSphreGrid`, to fill the metric and coordinate horizontal halos properly we use the same functionality that we use to fill halos for prognostic variables. To do that, we create Fields with the coordinate and metric values, call `fill_halo_regions!` on these fields, and then copy back the data from the Fields to the metrics. Copying the data from the metrics to the fields and vice-versa requires scalar operations, e.g., see ; https://github.com/CliMA/Oceananigans.jl/blob/7f12be3d82486b8be2923d8675d2e59c84efd722/src/MultiRegion/cubed_sphere_grid.jl#L280-L292. cc @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3579
https://github.com/CliMA/Oceananigans.jl/issues/3582:63,Integrability,depend,depend,63,"@liuchihl and I are trying to implement forcing functions that depend the tracer diffusivity. It is clear how to do this for a `ScalarDiffusivity` but not for a flow-dependent closure such as `SmagorinskyLilly`. The root of the problem seems to be that forcing functions only have access to the model `grid` and a limited tuple of `model_fields`. Since [diffusivities are also treated as `Fields` internally](https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/diffusivity_fields.jl), it is not clear to me why these are not included in the `model_fields` tuple that is passed to the Forcing function:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L203-L204. Maybe what I am asking for is the same thing as suggested by this comment:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/Models.jl#L124-L126",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582
https://github.com/CliMA/Oceananigans.jl/issues/3582:166,Integrability,depend,dependent,166,"@liuchihl and I are trying to implement forcing functions that depend the tracer diffusivity. It is clear how to do this for a `ScalarDiffusivity` but not for a flow-dependent closure such as `SmagorinskyLilly`. The root of the problem seems to be that forcing functions only have access to the model `grid` and a limited tuple of `model_fields`. Since [diffusivities are also treated as `Fields` internally](https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/diffusivity_fields.jl), it is not clear to me why these are not included in the `model_fields` tuple that is passed to the Forcing function:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L203-L204. Maybe what I am asking for is the same thing as suggested by this comment:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/Models.jl#L124-L126",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582
https://github.com/CliMA/Oceananigans.jl/issues/3582:281,Security,access,access,281,"@liuchihl and I are trying to implement forcing functions that depend the tracer diffusivity. It is clear how to do this for a `ScalarDiffusivity` but not for a flow-dependent closure such as `SmagorinskyLilly`. The root of the problem seems to be that forcing functions only have access to the model `grid` and a limited tuple of `model_fields`. Since [diffusivities are also treated as `Fields` internally](https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/diffusivity_fields.jl), it is not clear to me why these are not included in the `model_fields` tuple that is passed to the Forcing function:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L203-L204. Maybe what I am asking for is the same thing as suggested by this comment:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/Models.jl#L124-L126",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582
https://github.com/CliMA/Oceananigans.jl/issues/3582:100,Usability,clear,clear,100,"@liuchihl and I are trying to implement forcing functions that depend the tracer diffusivity. It is clear how to do this for a `ScalarDiffusivity` but not for a flow-dependent closure such as `SmagorinskyLilly`. The root of the problem seems to be that forcing functions only have access to the model `grid` and a limited tuple of `model_fields`. Since [diffusivities are also treated as `Fields` internally](https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/diffusivity_fields.jl), it is not clear to me why these are not included in the `model_fields` tuple that is passed to the Forcing function:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L203-L204. Maybe what I am asking for is the same thing as suggested by this comment:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/Models.jl#L124-L126",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582
https://github.com/CliMA/Oceananigans.jl/issues/3582:517,Usability,clear,clear,517,"@liuchihl and I are trying to implement forcing functions that depend the tracer diffusivity. It is clear how to do this for a `ScalarDiffusivity` but not for a flow-dependent closure such as `SmagorinskyLilly`. The root of the problem seems to be that forcing functions only have access to the model `grid` and a limited tuple of `model_fields`. Since [diffusivities are also treated as `Fields` internally](https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/diffusivity_fields.jl), it is not clear to me why these are not included in the `model_fields` tuple that is passed to the Forcing function:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L203-L204. Maybe what I am asking for is the same thing as suggested by this comment:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/Models.jl#L124-L126",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582
https://github.com/CliMA/Oceananigans.jl/pull/3585:557,Energy Efficiency,energy,energy,557,"This PR implements two advancements for CATKE. First is a reformulation of the shear production term. Previously this was computed using the velocity field at time-step `n` in the TKE tendency, like all other terms in the velocity and tracer explicit tendencies. However, [Burchard (2002)](https://www.sciencedirect.com/science/article/pii/S1463500302000094?casa_token=3cKiqlICvN8AAAAA:Hg3iGP-1q_UYh2We7maQRb9z9F5blbp8lHiH61T_Gep7y0DG8VYVRWwGvzvCDlbD2iANNHbLp4g) argue that the shear production term should be formulated to _exactly_ conserve total kinetic energy, which means that it's form actually depends on the time-stepping scheme being used. In our case, temporally-discrete shear production requires using the velocity field at time step `n` and `n+1`. To implement this scheme we have to add some features to the time stepping routine. In particular we have to allow closures to tell `HydrostaticFreeSurfaceModel` not to step forward certain tracers. Next, we step forward the TKE within `compute_diffusivities!`. Second, this PR also implements split-explicit substepping for CATKE's TKE. It seems that this is required because even though the new shear production discretization dramatically stabilizes CATKE (allowing long time-steps stably), it does not render CATKE's solutions completely insensitive to the time-step. So, for _accuracy_ (and performance) purposes, we are motivated to also add the capability to advance the TKE on a short time-step while the velocities and tracers advance on a slower time-step. This only matters for high vertical resolutions and very strong forcing. But when you do global simulations, there is strong forcing somewhere on the Earth, and we probably want to represented it accurately... More documentation to come.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3585
https://github.com/CliMA/Oceananigans.jl/pull/3585:601,Integrability,depend,depends,601,"This PR implements two advancements for CATKE. First is a reformulation of the shear production term. Previously this was computed using the velocity field at time-step `n` in the TKE tendency, like all other terms in the velocity and tracer explicit tendencies. However, [Burchard (2002)](https://www.sciencedirect.com/science/article/pii/S1463500302000094?casa_token=3cKiqlICvN8AAAAA:Hg3iGP-1q_UYh2We7maQRb9z9F5blbp8lHiH61T_Gep7y0DG8VYVRWwGvzvCDlbD2iANNHbLp4g) argue that the shear production term should be formulated to _exactly_ conserve total kinetic energy, which means that it's form actually depends on the time-stepping scheme being used. In our case, temporally-discrete shear production requires using the velocity field at time step `n` and `n+1`. To implement this scheme we have to add some features to the time stepping routine. In particular we have to allow closures to tell `HydrostaticFreeSurfaceModel` not to step forward certain tracers. Next, we step forward the TKE within `compute_diffusivities!`. Second, this PR also implements split-explicit substepping for CATKE's TKE. It seems that this is required because even though the new shear production discretization dramatically stabilizes CATKE (allowing long time-steps stably), it does not render CATKE's solutions completely insensitive to the time-step. So, for _accuracy_ (and performance) purposes, we are motivated to also add the capability to advance the TKE on a short time-step while the velocities and tracers advance on a slower time-step. This only matters for high vertical resolutions and very strong forcing. But when you do global simulations, there is strong forcing somewhere on the Earth, and we probably want to represented it accurately... More documentation to come.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3585
https://github.com/CliMA/Oceananigans.jl/pull/3585:836,Integrability,rout,routine,836,"This PR implements two advancements for CATKE. First is a reformulation of the shear production term. Previously this was computed using the velocity field at time-step `n` in the TKE tendency, like all other terms in the velocity and tracer explicit tendencies. However, [Burchard (2002)](https://www.sciencedirect.com/science/article/pii/S1463500302000094?casa_token=3cKiqlICvN8AAAAA:Hg3iGP-1q_UYh2We7maQRb9z9F5blbp8lHiH61T_Gep7y0DG8VYVRWwGvzvCDlbD2iANNHbLp4g) argue that the shear production term should be formulated to _exactly_ conserve total kinetic energy, which means that it's form actually depends on the time-stepping scheme being used. In our case, temporally-discrete shear production requires using the velocity field at time step `n` and `n+1`. To implement this scheme we have to add some features to the time stepping routine. In particular we have to allow closures to tell `HydrostaticFreeSurfaceModel` not to step forward certain tracers. Next, we step forward the TKE within `compute_diffusivities!`. Second, this PR also implements split-explicit substepping for CATKE's TKE. It seems that this is required because even though the new shear production discretization dramatically stabilizes CATKE (allowing long time-steps stably), it does not render CATKE's solutions completely insensitive to the time-step. So, for _accuracy_ (and performance) purposes, we are motivated to also add the capability to advance the TKE on a short time-step while the velocities and tracers advance on a slower time-step. This only matters for high vertical resolutions and very strong forcing. But when you do global simulations, there is strong forcing somewhere on the Earth, and we probably want to represented it accurately... More documentation to come.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3585
https://github.com/CliMA/Oceananigans.jl/pull/3585:1357,Performance,perform,performance,1357,"This PR implements two advancements for CATKE. First is a reformulation of the shear production term. Previously this was computed using the velocity field at time-step `n` in the TKE tendency, like all other terms in the velocity and tracer explicit tendencies. However, [Burchard (2002)](https://www.sciencedirect.com/science/article/pii/S1463500302000094?casa_token=3cKiqlICvN8AAAAA:Hg3iGP-1q_UYh2We7maQRb9z9F5blbp8lHiH61T_Gep7y0DG8VYVRWwGvzvCDlbD2iANNHbLp4g) argue that the shear production term should be formulated to _exactly_ conserve total kinetic energy, which means that it's form actually depends on the time-stepping scheme being used. In our case, temporally-discrete shear production requires using the velocity field at time step `n` and `n+1`. To implement this scheme we have to add some features to the time stepping routine. In particular we have to allow closures to tell `HydrostaticFreeSurfaceModel` not to step forward certain tracers. Next, we step forward the TKE within `compute_diffusivities!`. Second, this PR also implements split-explicit substepping for CATKE's TKE. It seems that this is required because even though the new shear production discretization dramatically stabilizes CATKE (allowing long time-steps stably), it does not render CATKE's solutions completely insensitive to the time-step. So, for _accuracy_ (and performance) purposes, we are motivated to also add the capability to advance the TKE on a short time-step while the velocities and tracers advance on a slower time-step. This only matters for high vertical resolutions and very strong forcing. But when you do global simulations, there is strong forcing somewhere on the Earth, and we probably want to represented it accurately... More documentation to come.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3585
https://github.com/CliMA/Oceananigans.jl/issues/3588:144,Energy Efficiency,reduce,reduced,144,"From the discussion #3587 @scott-conn found out that our definition of immersed derivatives ~~does not work very well~~ is **wrong** when using reduced fields. Consider, for example, a field reduced in z. If we try performing a derivative in the x-direction it will check the immersed condition ; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/ImmersedBoundaries/conditional_differences.jl#L21; on `k == 1`. This might be ~~very~~ wrong if the field is a sum (or a mean) over the column. ; For example, for integrals we want to check if the whole column is immersed.; If we are dealing with a `GridFittedBottom`, instead, we just need to check the upmost grid cell (`k == Nz`). We could procede in a couple of ways from here:; - use simple derivatives for `AsbtractOperations` that do not account for immersed boundaries. ; - We can augment operations on Immersed `Reduced` fields by attaching to them a `condition` like in conditional operations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588
https://github.com/CliMA/Oceananigans.jl/issues/3588:191,Energy Efficiency,reduce,reduced,191,"From the discussion #3587 @scott-conn found out that our definition of immersed derivatives ~~does not work very well~~ is **wrong** when using reduced fields. Consider, for example, a field reduced in z. If we try performing a derivative in the x-direction it will check the immersed condition ; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/ImmersedBoundaries/conditional_differences.jl#L21; on `k == 1`. This might be ~~very~~ wrong if the field is a sum (or a mean) over the column. ; For example, for integrals we want to check if the whole column is immersed.; If we are dealing with a `GridFittedBottom`, instead, we just need to check the upmost grid cell (`k == Nz`). We could procede in a couple of ways from here:; - use simple derivatives for `AsbtractOperations` that do not account for immersed boundaries. ; - We can augment operations on Immersed `Reduced` fields by attaching to them a `condition` like in conditional operations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588
https://github.com/CliMA/Oceananigans.jl/issues/3588:909,Energy Efficiency,Reduce,Reduced,909,"From the discussion #3587 @scott-conn found out that our definition of immersed derivatives ~~does not work very well~~ is **wrong** when using reduced fields. Consider, for example, a field reduced in z. If we try performing a derivative in the x-direction it will check the immersed condition ; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/ImmersedBoundaries/conditional_differences.jl#L21; on `k == 1`. This might be ~~very~~ wrong if the field is a sum (or a mean) over the column. ; For example, for integrals we want to check if the whole column is immersed.; If we are dealing with a `GridFittedBottom`, instead, we just need to check the upmost grid cell (`k == Nz`). We could procede in a couple of ways from here:; - use simple derivatives for `AsbtractOperations` that do not account for immersed boundaries. ; - We can augment operations on Immersed `Reduced` fields by attaching to them a `condition` like in conditional operations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588
https://github.com/CliMA/Oceananigans.jl/issues/3588:215,Performance,perform,performing,215,"From the discussion #3587 @scott-conn found out that our definition of immersed derivatives ~~does not work very well~~ is **wrong** when using reduced fields. Consider, for example, a field reduced in z. If we try performing a derivative in the x-direction it will check the immersed condition ; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/ImmersedBoundaries/conditional_differences.jl#L21; on `k == 1`. This might be ~~very~~ wrong if the field is a sum (or a mean) over the column. ; For example, for integrals we want to check if the whole column is immersed.; If we are dealing with a `GridFittedBottom`, instead, we just need to check the upmost grid cell (`k == Nz`). We could procede in a couple of ways from here:; - use simple derivatives for `AsbtractOperations` that do not account for immersed boundaries. ; - We can augment operations on Immersed `Reduced` fields by attaching to them a `condition` like in conditional operations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588
https://github.com/CliMA/Oceananigans.jl/issues/3588:777,Usability,simpl,simple,777,"From the discussion #3587 @scott-conn found out that our definition of immersed derivatives ~~does not work very well~~ is **wrong** when using reduced fields. Consider, for example, a field reduced in z. If we try performing a derivative in the x-direction it will check the immersed condition ; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/ImmersedBoundaries/conditional_differences.jl#L21; on `k == 1`. This might be ~~very~~ wrong if the field is a sum (or a mean) over the column. ; For example, for integrals we want to check if the whole column is immersed.; If we are dealing with a `GridFittedBottom`, instead, we just need to check the upmost grid cell (`k == Nz`). We could procede in a couple of ways from here:; - use simple derivatives for `AsbtractOperations` that do not account for immersed boundaries. ; - We can augment operations on Immersed `Reduced` fields by attaching to them a `condition` like in conditional operations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588
https://github.com/CliMA/Oceananigans.jl/pull/3590:140,Integrability,interface,interface,140,"This PR generalizes `Reduction` to also support accumulating ""scanning"" operations like `cumsum!`. This should not change the existing user interface but instead add the new feature, something like. ```julia; cumulative_u = Accumulation(cumsum!, u, dims=3); ```. and. ```julia; cumint_u = CumulativeIntegral(u, dims=3); ```. ~~Previously I don't think this was possible on GPU because `cumsum!` was not supported for `CuArray` (?) But it is now it seems.~~ To support this feature, we've implemented kernels for forward and reverse accumulation. I also have used the generalization of `Scan` to clean up the internals / user interface for `Average` and `Integral` (now they are proper type aliases). cc @hdrake @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590
https://github.com/CliMA/Oceananigans.jl/pull/3590:625,Integrability,interface,interface,625,"This PR generalizes `Reduction` to also support accumulating ""scanning"" operations like `cumsum!`. This should not change the existing user interface but instead add the new feature, something like. ```julia; cumulative_u = Accumulation(cumsum!, u, dims=3); ```. and. ```julia; cumint_u = CumulativeIntegral(u, dims=3); ```. ~~Previously I don't think this was possible on GPU because `cumsum!` was not supported for `CuArray` (?) But it is now it seems.~~ To support this feature, we've implemented kernels for forward and reverse accumulation. I also have used the generalization of `Scan` to clean up the internals / user interface for `Average` and `Integral` (now they are proper type aliases). cc @hdrake @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590
https://github.com/CliMA/Oceananigans.jl/issues/3593:1140,Energy Efficiency,schedul,schedule,1140,"gly random (time) chunks of the simulations, and then everything comes back to normal before happening again in other chunks. Here's a MWE where I create a grid with channel-like topology which has an immersed boundary at `x=400meters` that acts as an East wall. I initialize it with a uniform stratification of `6e-6/second` and zero velocities everywhere. ```julia; using Oceananigans. grid_base = RectilinearGrid(topology = (Bounded, Periodic, Bounded),; size = (16, 20, 4), extent = (800, 1000, 100),). @inline east_wall(x, y, z) = x > 400; grid = ImmersedBoundaryGrid(grid_base, GridFittedBoundary(east_wall)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; buoyancy = BuoyancyTracer(), tracers = :b,; ). N² = 6e-6; b∞(x, y, z) = N² * z; set!(model, b=b∞). simulation = Simulation(model, Δt=25, stop_time=1e4,); simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. Here are some snapshots of the pressure (the blue line is where the immersed boundary is):. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/8904fd81-70ee-465b-a664-3eb6042f94ca). And here's a plot of the standard deviation of pressure over the whole domain as a function of time where we can visualize when this issue happens:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/86e5687e-0290-45ac-80d9-0cc2552f2b7d). [Here](https://pastebin.com/XArt8Bik) is the code I used to generate these figures in case anyone's interested in playing around with it. A bit of context: I noticed this issue a long time ago, and @whitleyv before me (I believe @amrapallig also mentioned coming across this issue at some point). It hasn't been an issue in the past, but now that I need to close a KE balance in a domain where the pressure contributions don't vanish I find that this issue prevents me from obtaining any sort of reasonab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593
https://github.com/CliMA/Oceananigans.jl/issues/3593:2391,Integrability,interface,interface,2391,"e (the blue line is where the immersed boundary is):. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/8904fd81-70ee-465b-a664-3eb6042f94ca). And here's a plot of the standard deviation of pressure over the whole domain as a function of time where we can visualize when this issue happens:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/86e5687e-0290-45ac-80d9-0cc2552f2b7d). [Here](https://pastebin.com/XArt8Bik) is the code I used to generate these figures in case anyone's interested in playing around with it. A bit of context: I noticed this issue a long time ago, and @whitleyv before me (I believe @amrapallig also mentioned coming across this issue at some point). It hasn't been an issue in the past, but now that I need to close a KE balance in a domain where the pressure contributions don't vanish I find that this issue prevents me from obtaining any sort of reasonable estimate for the pressure contribution. (Which is odd, since it implies that these ""jumps"" have no impact on dynamics...). A few notes:. 1. This only seems to happen when there's a _vertical_ immersed boundary interface and buoyancy isn't `nothing` (or zero). To clarify, this issue does happen in sloping topographies, but it goes away if instead I make the immersed boundary a ""faux"" flat bottom (e.g. if `east_wall(x, y, z) = z < -50`).; 2. I haven't tried branch https://github.com/CliMA/Oceananigans.jl/pull/3188 yet, but it's on my to-do list. I figured even if that branch fixes it, it was worth opening this issue.; 3. In this particular MWE if I switch the time-stepper to Adams-Bashforth the issue seemingly goes away (even though there's an initial jump in the pressure that I wouldn't expect), but it does persist (albeit more mildly) in more complex simulations.; 4. This example was run with the latest version of Oceananigans `v0.91.0` which doesn't separate the pressure anymore, but it also to happened in older versions with the pressure separation. CC @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593
https://github.com/CliMA/Oceananigans.jl/issues/3594:1804,Energy Efficiency,adapt,adapt,1804,"igansDocumentation/stable/simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs) section of the docs probably needs updating. For example it says. > For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:. This example is contrived though; the problem is that the `show` method for `OffsetArrays` has scalar indexing. But the `show` method for `CuArray` works fine, so. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> c.data.parent; 3×3×3 CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}:; [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. The example also creates a `model` which is probably overkill, a `Field` would do. Also, the example uses. ```julia; julia> adapt(Array, model.velocities.u.data); ```. To show an array on CPU. But we have a built-in method `on_archiecture(CPU(), field)` that would probably be better to use, since its more flexible and also generalizes to distributed architectures, etc...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594
https://github.com/CliMA/Oceananigans.jl/issues/3594:1804,Modifiability,adapt,adapt,1804,"igansDocumentation/stable/simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs) section of the docs probably needs updating. For example it says. > For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:. This example is contrived though; the problem is that the `show` method for `OffsetArrays` has scalar indexing. But the `show` method for `CuArray` works fine, so. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> c.data.parent; 3×3×3 CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}:; [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. The example also creates a `model` which is probably overkill, a `Field` would do. Also, the example uses. ```julia; julia> adapt(Array, model.velocities.u.data); ```. To show an array on CPU. But we have a built-in method `on_archiecture(CPU(), field)` that would probably be better to use, since its more flexible and also generalizes to distributed architectures, etc...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594
https://github.com/CliMA/Oceananigans.jl/issues/3594:1987,Modifiability,flexible,flexible,1987,"igansDocumentation/stable/simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs) section of the docs probably needs updating. For example it says. > For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:. This example is contrived though; the problem is that the `show` method for `OffsetArrays` has scalar indexing. But the `show` method for `CuArray` works fine, so. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> c.data.parent; 3×3×3 CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}:; [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. The example also creates a `model` which is probably overkill, a `Field` would do. Also, the example uses. ```julia; julia> adapt(Array, model.velocities.u.data); ```. To show an array on CPU. But we have a built-in method `on_archiecture(CPU(), field)` that would probably be better to use, since its more flexible and also generalizes to distributed architectures, etc...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594
https://github.com/CliMA/Oceananigans.jl/issues/3594:299,Security,access,access,299,"The [Simulation tips](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs) section of the docs probably needs updating. For example it says. > For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:. This example is contrived though; the problem is that the `show` method for `OffsetArrays` has scalar indexing. But the `show` method for `CuArray` works fine, so. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> c.data.parent; 3×3×3 CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}:; [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. The example also creates a `model` which is probably overkill, a `Field` would do. Also, the example uses. ```julia; julia> adapt(Array, model.velocities.u.data); ```. To show an array on CPU. But we have a built-in method `on_archiecture(CPU(), field)` that would probably be better to use, since its more flexible and a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594
https://github.com/CliMA/Oceananigans.jl/pull/3595:198,Availability,checkpoint,checkpointing,198,"This PR fixes a bug where `last_Δt` was incorrect for RK3. This bug was found by @tomchor, cc @jagoosw . Also it removes `previous_Δt` from the QuasiAdamsBashforth2 time-stepper. Note, this affects checkpointing. I also correctly restore `last_Δt` from the checkpoint. I also updated some docstrings just so we have uniform language, replacing ""previous"" with ""last"" in a few places.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3595
https://github.com/CliMA/Oceananigans.jl/pull/3595:257,Availability,checkpoint,checkpoint,257,"This PR fixes a bug where `last_Δt` was incorrect for RK3. This bug was found by @tomchor, cc @jagoosw . Also it removes `previous_Δt` from the QuasiAdamsBashforth2 time-stepper. Note, this affects checkpointing. I also correctly restore `last_Δt` from the checkpoint. I also updated some docstrings just so we have uniform language, replacing ""previous"" with ""last"" in a few places.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3595
https://github.com/CliMA/Oceananigans.jl/pull/3595:276,Deployability,update,updated,276,"This PR fixes a bug where `last_Δt` was incorrect for RK3. This bug was found by @tomchor, cc @jagoosw . Also it removes `previous_Δt` from the QuasiAdamsBashforth2 time-stepper. Note, this affects checkpointing. I also correctly restore `last_Δt` from the checkpoint. I also updated some docstrings just so we have uniform language, replacing ""previous"" with ""last"" in a few places.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3595
https://github.com/CliMA/Oceananigans.jl/pull/3596:43,Deployability,integrat,integrating,43,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596
https://github.com/CliMA/Oceananigans.jl/pull/3596:600,Energy Efficiency,efficient,efficient,600,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596
https://github.com/CliMA/Oceananigans.jl/pull/3596:43,Integrability,integrat,integrating,43,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596
https://github.com/CliMA/Oceananigans.jl/pull/3596:935,Integrability,wrap,wraps,935,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596
https://github.com/CliMA/Oceananigans.jl/pull/3596:438,Modifiability,extend,extend,438,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596
https://github.com/CliMA/Oceananigans.jl/pull/3596:530,Performance,perform,performance,530,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596
https://github.com/CliMA/Oceananigans.jl/pull/3598:31,Deployability,update,updates,31,There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598
https://github.com/CliMA/Oceananigans.jl/pull/3598:151,Testability,test,test,151,There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598
https://github.com/CliMA/Oceananigans.jl/pull/3599:57,Availability,checkpoint,checkpoints,57,"**TL;DR: We can compress 18GB of Oceananigans simulation checkpoints into 350MB with bitrounding and lossless compression.**. #### Problem; Output is currently uncompressed in Float64 which contains; - redundancies: zeros for immersed boundaries, halos; similar/identical exponent bits; - false information: tailing mantissa bits with no mutual information to neighbouring grid points. #### Proposed solution; Bitrounding to remove false information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3599:609,Availability,checkpoint,checkpoint,609,"**TL;DR: We can compress 18GB of Oceananigans simulation checkpoints into 350MB with bitrounding and lossless compression.**. #### Problem; Output is currently uncompressed in Float64 which contains; - redundancies: zeros for immersed boundaries, halos; similar/identical exponent bits; - false information: tailing mantissa bits with no mutual information to neighbouring grid points. #### Proposed solution; Bitrounding to remove false information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3599:1325,Availability,checkpoint,checkpoint,1325,"se information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3599:2154,Availability,avail,available,2154,"tively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://github.com/JuliaIO/JLD2.jl/pull/560. While this PR is still a draft I'm proposing the new defaults; - lossless compression with `compress=true` for JLD2, `deflatelevel=3` for netCDF; - bitrounding to keepbits ~20 (single precision-ish) whether you output in Float32/64 (doesn't matter when lossless compression is on); - a default `bitrounder` that rounds to the keepbits as suggested above that can be used instead of `bitrounder=nothing` (default). We can then independently tweak the precision (how many keepbits, ideally as a function of the vertical, see salinity) and the lossless compressor (Zlib -> Zstandard)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3599:2208,Integrability,interface,interface,2208,"tively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://github.com/JuliaIO/JLD2.jl/pull/560. While this PR is still a draft I'm proposing the new defaults; - lossless compression with `compress=true` for JLD2, `deflatelevel=3` for netCDF; - bitrounding to keepbits ~20 (single precision-ish) whether you output in Float32/64 (doesn't matter when lossless compression is on); - a default `bitrounder` that rounds to the keepbits as suggested above that can be used instead of `bitrounder=nothing` (default). We can then independently tweak the precision (how many keepbits, ideally as a function of the vertical, see salinity) and the lossless compressor (Zlib -> Zstandard)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3599:1486,Modifiability,variab,variables,1486,"se information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3599:202,Safety,redund,redundancies,202,"**TL;DR: We can compress 18GB of Oceananigans simulation checkpoints into 350MB with bitrounding and lossless compression.**. #### Problem; Output is currently uncompressed in Float64 which contains; - redundancies: zeros for immersed boundaries, halos; similar/identical exponent bits; - false information: tailing mantissa bits with no mutual information to neighbouring grid points. #### Proposed solution; Bitrounding to remove false information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3599:478,Safety,redund,redundancies,478,"**TL;DR: We can compress 18GB of Oceananigans simulation checkpoints into 350MB with bitrounding and lossless compression.**. #### Problem; Output is currently uncompressed in Float64 which contains; - redundancies: zeros for immersed boundaries, halos; similar/identical exponent bits; - false information: tailing mantissa bits with no mutual information to neighbouring grid points. #### Proposed solution; Bitrounding to remove false information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3599:528,Safety,redund,redundancies,528,"**TL;DR: We can compress 18GB of Oceananigans simulation checkpoints into 350MB with bitrounding and lossless compression.**. #### Problem; Output is currently uncompressed in Float64 which contains; - redundancies: zeros for immersed boundaries, halos; similar/identical exponent bits; - false information: tailing mantissa bits with no mutual information to neighbouring grid points. #### Proposed solution; Bitrounding to remove false information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3599:1649,Safety,redund,redundancies,1649,"ation . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://github.com/JuliaIO/JLD2.jl/pull/560. While this PR is still a draft I'm proposing the new defaults; - lossless compression with `compress=true` for JLD2, `deflatelevel=3` for netCDF; - bitrounding to keepbits ~20 (single precision-ish) whether you output in Float32/64 (doesn't matter w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599
https://github.com/CliMA/Oceananigans.jl/pull/3603:8,Deployability,update,updated,8,We need updated KernelAbstractions as well as the varargs fix on kernel parameters for type stability. This merge combines the PRs for both of these improvements into one.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3603
https://github.com/CliMA/Oceananigans.jl/pull/3605:775,Integrability,depend,depending,775,"This PR replaces #3509. Also, it builds off #3585 which hopefully we can merge soon so we don't enter merge conflict hell. In short this PR implements k-epsilon. Although, the version that's implemented now is not by-the-book k-epsilon but rather a simplified version. I'd like to merge this PR basically as is and hopefully continue to work on it in the future. There are some numerical considerations which should be reviewed and documented I think. First of all is the challenge of specifying a minimum tke, minimum dissipation rate, and also a maximum dissipation rate. These are useful for producing smooth diffusivities, which note are . $$ \kappa \sim \frac{e^2}{\epsilon} $$. But then there are challenges with implementing the TKE and dissipation equations. Because depending on the term, one may either want to impose or not impose these constraints. It could be useful to try to get some lessons from other codes too. It's not ready for production use, but at least it's doing reasonable things... <img width=""384"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/c7df14e6-8ed2-4c13-b892-99b04e5f8809"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605
https://github.com/CliMA/Oceananigans.jl/pull/3605:249,Usability,simpl,simplified,249,"This PR replaces #3509. Also, it builds off #3585 which hopefully we can merge soon so we don't enter merge conflict hell. In short this PR implements k-epsilon. Although, the version that's implemented now is not by-the-book k-epsilon but rather a simplified version. I'd like to merge this PR basically as is and hopefully continue to work on it in the future. There are some numerical considerations which should be reviewed and documented I think. First of all is the challenge of specifying a minimum tke, minimum dissipation rate, and also a maximum dissipation rate. These are useful for producing smooth diffusivities, which note are . $$ \kappa \sim \frac{e^2}{\epsilon} $$. But then there are challenges with implementing the TKE and dissipation equations. Because depending on the term, one may either want to impose or not impose these constraints. It could be useful to try to get some lessons from other codes too. It's not ready for production use, but at least it's doing reasonable things... <img width=""384"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/c7df14e6-8ed2-4c13-b892-99b04e5f8809"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605
https://github.com/CliMA/Oceananigans.jl/pull/3606:2302,Availability,error,error,2302,", Δt=25, stop_time=1e4,). using Statistics: std; using Printf; progress_message(sim) = @printf(""Iteration: %04d, time: %s, iteration×Δt: %s, std(pNHS) = %.2e\n"",; iteration(sim), sim.model.clock.time, iteration(sim) * sim.Δt, std(model.pressures.pNHS)); add_callback!(simulation, progress_message, IterationInterval(1)). simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. On main this produces stuff like:. ```; Iteration: 0001, time: 25.0, iteration×Δt: 25.0, std(pNHS) = 6.02e-03; Iteration: 0002, time: 50.0, iteration×Δt: 50.0, std(pNHS) = 6.02e-03; Iteration: 0003, time: 75.0, iteration×Δt: 75.0, std(pNHS) = 6.02e-03; Iteration: 0004, time: 99.99999999999999, iteration×Δt: 100.0, std(pNHS) = 6.02e-03; Iteration: 0005, time: 100.0, iteration×Δt: 125.0, std(pNHS) = 2.72e+10; ```. The last two lines are of note where we went from `time: 99.99999999999999` to `time: 100.0`, implying a very tiny time-step, which results in a weird pressure field, as quantified by the last output of the last line: `std(pNHS) = 2.72e+10`. Note that because of this, `time` and `iteration×Δt` don't match up anymore in the last line. Namely `time: 100.0, iteration×Δt: 125.0`. This ""misstep"" happens many times throughout the run on `main`. On this branch this doesn't happen anymore, and even after many time-steps things remain aligned (albeit with a very small round-off error):. ```; Iteration: 0396, time: 9900.0, iteration×Δt: 9900.0, std(pNHS) = 5.99e-03; Iteration: 0397, time: 9925.000000000002, iteration×Δt: 9925.0, std(pNHS) = 5.99e-03; Iteration: 0398, time: 9950.000000000004, iteration×Δt: 9950.0, std(pNHS) = 5.99e-03; Iteration: 0399, time: 9975.000000000005, iteration×Δt: 9975.0, std(pNHS) = 5.99e-03; ```. Ideally the way to really fix this would be to figure out a way to avoid round-off errors, but I haven't been able to do that yet.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606
https://github.com/CliMA/Oceananigans.jl/pull/3606:2737,Availability,error,errors,2737,", Δt=25, stop_time=1e4,). using Statistics: std; using Printf; progress_message(sim) = @printf(""Iteration: %04d, time: %s, iteration×Δt: %s, std(pNHS) = %.2e\n"",; iteration(sim), sim.model.clock.time, iteration(sim) * sim.Δt, std(model.pressures.pNHS)); add_callback!(simulation, progress_message, IterationInterval(1)). simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. On main this produces stuff like:. ```; Iteration: 0001, time: 25.0, iteration×Δt: 25.0, std(pNHS) = 6.02e-03; Iteration: 0002, time: 50.0, iteration×Δt: 50.0, std(pNHS) = 6.02e-03; Iteration: 0003, time: 75.0, iteration×Δt: 75.0, std(pNHS) = 6.02e-03; Iteration: 0004, time: 99.99999999999999, iteration×Δt: 100.0, std(pNHS) = 6.02e-03; Iteration: 0005, time: 100.0, iteration×Δt: 125.0, std(pNHS) = 2.72e+10; ```. The last two lines are of note where we went from `time: 99.99999999999999` to `time: 100.0`, implying a very tiny time-step, which results in a weird pressure field, as quantified by the last output of the last line: `std(pNHS) = 2.72e+10`. Note that because of this, `time` and `iteration×Δt` don't match up anymore in the last line. Namely `time: 100.0, iteration×Δt: 125.0`. This ""misstep"" happens many times throughout the run on `main`. On this branch this doesn't happen anymore, and even after many time-steps things remain aligned (albeit with a very small round-off error):. ```; Iteration: 0396, time: 9900.0, iteration×Δt: 9900.0, std(pNHS) = 5.99e-03; Iteration: 0397, time: 9925.000000000002, iteration×Δt: 9925.0, std(pNHS) = 5.99e-03; Iteration: 0398, time: 9950.000000000004, iteration×Δt: 9950.0, std(pNHS) = 5.99e-03; Iteration: 0399, time: 9975.000000000005, iteration×Δt: 9975.0, std(pNHS) = 5.99e-03; ```. Ideally the way to really fix this would be to figure out a way to avoid round-off errors, but I haven't been able to do that yet.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606
https://github.com/CliMA/Oceananigans.jl/pull/3606:1227,Energy Efficiency,schedul,schedule,1227,"does seem to solve the problem. Here's a MWE to demonstrate:. ```julia; using Oceananigans. grid_base = RectilinearGrid(topology = (Bounded, Periodic, Bounded),; size = (16, 20, 4), extent = (800, 1000, 100),); ; @inline east_wall(x, y, z) = x > 400; grid = ImmersedBoundaryGrid(grid_base, GridFittedBoundary(east_wall)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3, buoyancy = BuoyancyTracer(), tracers = :b,). N² = 6e-6; b∞(x, y, z) = N² * z; set!(model, b=b∞); ; simulation = Simulation(model, Δt=25, stop_time=1e4,). using Statistics: std; using Printf; progress_message(sim) = @printf(""Iteration: %04d, time: %s, iteration×Δt: %s, std(pNHS) = %.2e\n"",; iteration(sim), sim.model.clock.time, iteration(sim) * sim.Δt, std(model.pressures.pNHS)); add_callback!(simulation, progress_message, IterationInterval(1)). simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. On main this produces stuff like:. ```; Iteration: 0001, time: 25.0, iteration×Δt: 25.0, std(pNHS) = 6.02e-03; Iteration: 0002, time: 50.0, iteration×Δt: 50.0, std(pNHS) = 6.02e-03; Iteration: 0003, time: 75.0, iteration×Δt: 75.0, std(pNHS) = 6.02e-03; Iteration: 0004, time: 99.99999999999999, iteration×Δt: 100.0, std(pNHS) = 6.02e-03; Iteration: 0005, time: 100.0, iteration×Δt: 125.0, std(pNHS) = 2.72e+10; ```. The last two lines are of note where we went from `time: 99.99999999999999` to `time: 100.0`, implying a very tiny time-step, which results in a weird pressure field, as quantified by the last output of the last line: `std(pNHS) = 2.72e+10`. Note that because of this, `time` and `iteration×Δt` don't match up anymore in the last line. Namely `time: 100.0, iteration×Δt: 125.0`. This ""misstep"" happens many times throughout the run on `main`. On this branch this doesn't happen anymore, and even after many time-steps things remain aligned",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606
https://github.com/CliMA/Oceananigans.jl/pull/3606:2721,Safety,avoid,avoid,2721,", Δt=25, stop_time=1e4,). using Statistics: std; using Printf; progress_message(sim) = @printf(""Iteration: %04d, time: %s, iteration×Δt: %s, std(pNHS) = %.2e\n"",; iteration(sim), sim.model.clock.time, iteration(sim) * sim.Δt, std(model.pressures.pNHS)); add_callback!(simulation, progress_message, IterationInterval(1)). simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. On main this produces stuff like:. ```; Iteration: 0001, time: 25.0, iteration×Δt: 25.0, std(pNHS) = 6.02e-03; Iteration: 0002, time: 50.0, iteration×Δt: 50.0, std(pNHS) = 6.02e-03; Iteration: 0003, time: 75.0, iteration×Δt: 75.0, std(pNHS) = 6.02e-03; Iteration: 0004, time: 99.99999999999999, iteration×Δt: 100.0, std(pNHS) = 6.02e-03; Iteration: 0005, time: 100.0, iteration×Δt: 125.0, std(pNHS) = 2.72e+10; ```. The last two lines are of note where we went from `time: 99.99999999999999` to `time: 100.0`, implying a very tiny time-step, which results in a weird pressure field, as quantified by the last output of the last line: `std(pNHS) = 2.72e+10`. Note that because of this, `time` and `iteration×Δt` don't match up anymore in the last line. Namely `time: 100.0, iteration×Δt: 125.0`. This ""misstep"" happens many times throughout the run on `main`. On this branch this doesn't happen anymore, and even after many time-steps things remain aligned (albeit with a very small round-off error):. ```; Iteration: 0396, time: 9900.0, iteration×Δt: 9900.0, std(pNHS) = 5.99e-03; Iteration: 0397, time: 9925.000000000002, iteration×Δt: 9925.0, std(pNHS) = 5.99e-03; Iteration: 0398, time: 9950.000000000004, iteration×Δt: 9950.0, std(pNHS) = 5.99e-03; Iteration: 0399, time: 9975.000000000005, iteration×Δt: 9975.0, std(pNHS) = 5.99e-03; ```. Ideally the way to really fix this would be to figure out a way to avoid round-off errors, but I haven't been able to do that yet.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606
https://github.com/CliMA/Oceananigans.jl/pull/3607:173,Testability,test,tested,173,"This pull request changes the compat entry for the `Enzyme` package from `0.11.14` to `0.11.14, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3607
https://github.com/CliMA/Oceananigans.jl/pull/3607:279,Testability,test,tests,279,"This pull request changes the compat entry for the `Enzyme` package from `0.11.14` to `0.11.14, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3607
https://github.com/CliMA/Oceananigans.jl/pull/3608:48,Deployability,update,update,48,"🤖 Beep boop. I am GabrieleBOT. 🤖. I received an update so that I can inform you directly of the changes (but feel free to check the [release notes](https://github.com/CliMA/ClimaModules/blob/main/NEWS.md)). Over the weekend, a new version of MPITrampoline was released. This version is incompatible with the version of MPIwrapper we were using, so we had to install a new version of MPIwrapper. The most recent version of climacommon uses this updated version of MPIwrapper.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3608
https://github.com/CliMA/Oceananigans.jl/pull/3608:133,Deployability,release,release,133,"🤖 Beep boop. I am GabrieleBOT. 🤖. I received an update so that I can inform you directly of the changes (but feel free to check the [release notes](https://github.com/CliMA/ClimaModules/blob/main/NEWS.md)). Over the weekend, a new version of MPITrampoline was released. This version is incompatible with the version of MPIwrapper we were using, so we had to install a new version of MPIwrapper. The most recent version of climacommon uses this updated version of MPIwrapper.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3608
https://github.com/CliMA/Oceananigans.jl/pull/3608:260,Deployability,release,released,260,"🤖 Beep boop. I am GabrieleBOT. 🤖. I received an update so that I can inform you directly of the changes (but feel free to check the [release notes](https://github.com/CliMA/ClimaModules/blob/main/NEWS.md)). Over the weekend, a new version of MPITrampoline was released. This version is incompatible with the version of MPIwrapper we were using, so we had to install a new version of MPIwrapper. The most recent version of climacommon uses this updated version of MPIwrapper.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3608
https://github.com/CliMA/Oceananigans.jl/pull/3608:358,Deployability,install,install,358,"🤖 Beep boop. I am GabrieleBOT. 🤖. I received an update so that I can inform you directly of the changes (but feel free to check the [release notes](https://github.com/CliMA/ClimaModules/blob/main/NEWS.md)). Over the weekend, a new version of MPITrampoline was released. This version is incompatible with the version of MPIwrapper we were using, so we had to install a new version of MPIwrapper. The most recent version of climacommon uses this updated version of MPIwrapper.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3608
https://github.com/CliMA/Oceananigans.jl/pull/3608:444,Deployability,update,updated,444,"🤖 Beep boop. I am GabrieleBOT. 🤖. I received an update so that I can inform you directly of the changes (but feel free to check the [release notes](https://github.com/CliMA/ClimaModules/blob/main/NEWS.md)). Over the weekend, a new version of MPITrampoline was released. This version is incompatible with the version of MPIwrapper we were using, so we had to install a new version of MPIwrapper. The most recent version of climacommon uses this updated version of MPIwrapper.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3608
https://github.com/CliMA/Oceananigans.jl/issues/3609:98,Availability,error,error,98,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:319,Availability,avail,available,319,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:1899,Availability,error,error,1899,"es); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ::Nothing, ::Nothing, ::Nothing) is ambiguous. Candidates:; _fractional_indices(::Any, grid, ℓx, ::Nothing, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:187; _fractional_indices(::Any, grid, ::Nothing, ℓy, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:195; _fractional_indices(::Any, grid, ℓx, ℓy, ::Nothing); @ Oceananigans.Fi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:31715,Availability,error,error,31715,"{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}, LagrangianParticles{StructVector{CustomParticle, NamedTuple{(:x, :y, :z, :T), NTuple{4, Vector{Float64}}}, Int64}, Float64, NamedTuple{(:T,), Tuple{Vector{Float64}}}, typeof(Oceananigans.Models.LagrangianParticleTracking.no_dynamics), Nothing}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Float64); @ Oceananigans.Models.LagrangianParticleTracking ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/update_lagrangian_particle_properties.jl:31; [10] step_lagrangian_particles!; @ ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:137 [inlined]; [11] step_lagrangian_particles!. ```. (2) I also ran (x,y,z) position tracking only while immersed boundary was active. There was a method error relating to cpu__advect_particle >>advect_lagrangian_particles:. ```Julia. ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(2000,)}, KernelAbstractions.NDIteration.DynamicCheck, CartesianIndex{1}, Nothing, KernelAbstractions.NDIteration.NDRange{1, KernelAbstractions.NDIteration.StaticSize{(8,)}, KernelAbstractions.NDIteration.StaticSize{(256,)}, Nothing, Nothing}}, ::StructVector{Oceananigans.Models.LagrangianParticleTracking.Particle, NamedTuple{(:x, :y, :z), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}}, Int64}, ::Float64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:31796,Availability,ERROR,ERROR,31796,"uple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}, LagrangianParticles{StructVector{CustomParticle, NamedTuple{(:x, :y, :z, :T), NTuple{4, Vector{Float64}}}, Int64}, Float64, NamedTuple{(:T,), Tuple{Vector{Float64}}}, typeof(Oceananigans.Models.LagrangianParticleTracking.no_dynamics), Nothing}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Float64); @ Oceananigans.Models.LagrangianParticleTracking ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/update_lagrangian_particle_properties.jl:31; [10] step_lagrangian_particles!; @ ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:137 [inlined]; [11] step_lagrangian_particles!. ```. (2) I also ran (x,y,z) position tracking only while immersed boundary was active. There was a method error relating to cpu__advect_particle >>advect_lagrangian_particles:. ```Julia. ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(2000,)}, KernelAbstractions.NDIteration.DynamicCheck, CartesianIndex{1}, Nothing, KernelAbstractions.NDIteration.NDRange{1, KernelAbstractions.NDIteration.StaticSize{(8,)}, KernelAbstractions.NDIteration.StaticSize{(256,)}, Nothing, Nothing}}, ::StructVector{Oceananigans.Models.LagrangianParticleTracking.Particle, NamedTuple{(:x, :y, :z), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}}, Int64}, ::Float64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:16029,Deployability,Continuous,ContinuousBoundaryFunction,16029,"64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_v), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:17540,Deployability,Continuous,ContinuousBoundaryFunction,17540,"64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_w), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:T, :S), Tuple{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:23299,Deployability,Continuous,ContinuousForcing,23299,"StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_T), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_S), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}}}, WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:23702,Deployability,Continuous,ContinuousForcing,23702,"othing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_T), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_S), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}}}, WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, Oceananigans.Solvers.FFTBasedPoissonSolver{RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:24021,Deployability,Continuous,ContinuousForcing,24021,"fers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_T), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_S), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}}}, WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, Oceananigans.Solvers.FFTBasedPoissonSolver{RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Ba",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:38702,Deployability,Continuous,ContinuousBoundaryFunction,38702,"ecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(drag_v), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.Fields.ZeroField{Int64, 3}}}, Oceananigans.Utils.SumOfArrays{2, Tuple{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, St",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:41538,Deployability,Continuous,ContinuousBoundaryFunction,41538,"cision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(drag_w), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}). Closest candidates are:; cpu__advect_particles!(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractUnderlyingGrid, ::Any, ::Any); @ Oceananigans none:0. Stacktrace:; [1] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:49478,Deployability,Continuous,ContinuousBoundaryFunction,49478,"ecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(drag_v), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.Fields.ZeroField{Int64, 3}}}, Oceananigans.Utils.SumOfArrays{2, Tuple{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, St",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:52314,Deployability,Continuous,ContinuousBoundaryFunction,52314,"cision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(drag_w), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/sZvJo/src/cpu.jl:115; [2] __run(obj::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(256,)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:60181,Deployability,Continuous,ContinuousBoundaryFunction,60181,"ecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(drag_v), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.Fields.ZeroField{Int64, 3}}}, Oceananigans.Utils.SumOfArrays{2, Tuple{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, St",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:63017,Deployability,Continuous,ContinuousBoundaryFunction,63017,".OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(drag_w), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/sZvJo/src/cpu.jl:82. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:104,Integrability,message,messages,104,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:1917,Performance,Load,LoadError,1917,"oordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ::Nothing, ::Nothing, ::Nothing) is ambiguous. Candidates:; _fractional_indices(::Any, grid, ℓx, ::Nothing, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:187; _fractional_indices(::Any, grid, ::Nothing, ℓy, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:195; _fractional_indices(::Any, grid, ℓx, ℓy, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:180; _fractional_indices(::Any, grid, ::Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:31803,Performance,Load,LoadError,31803,"uple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}, LagrangianParticles{StructVector{CustomParticle, NamedTuple{(:x, :y, :z, :T), NTuple{4, Vector{Float64}}}, Int64}, Float64, NamedTuple{(:T,), Tuple{Vector{Float64}}}, typeof(Oceananigans.Models.LagrangianParticleTracking.no_dynamics), Nothing}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Float64); @ Oceananigans.Models.LagrangianParticleTracking ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/update_lagrangian_particle_properties.jl:31; [10] step_lagrangian_particles!; @ ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:137 [inlined]; [11] step_lagrangian_particles!. ```. (2) I also ran (x,y,z) position tracking only while immersed boundary was active. There was a method error relating to cpu__advect_particle >>advect_lagrangian_particles:. ```Julia. ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(2000,)}, KernelAbstractions.NDIteration.DynamicCheck, CartesianIndex{1}, Nothing, KernelAbstractions.NDIteration.NDRange{1, KernelAbstractions.NDIteration.StaticSize{(8,)}, KernelAbstractions.NDIteration.StaticSize{(256,)}, Nothing, Nothing}}, ::StructVector{Oceananigans.Models.LagrangianParticleTracking.Particle, NamedTuple{(:x, :y, :z), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}}, Int64}, ::Float64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:18,Testability,test,testing,18,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:478,Testability,test,testing,478,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:558,Testability,test,testing,558,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:579,Testability,test,tested,579,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3609:137,Usability,simpl,simplicity,137,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609
https://github.com/CliMA/Oceananigans.jl/issues/3612:96,Modifiability,variab,variables,96,"I want to set the gradient boundary condition to east, west, south, north directions in u and v variables. However, for u variable, cannot specify east boundary condition using GradientBoundaryCondition at Face(). So, how should i solve this problem. . Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. Thanks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612
https://github.com/CliMA/Oceananigans.jl/issues/3612:122,Modifiability,variab,variable,122,"I want to set the gradient boundary condition to east, west, south, north directions in u and v variables. However, for u variable, cannot specify east boundary condition using GradientBoundaryCondition at Face(). So, how should i solve this problem. . Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. Thanks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612
https://github.com/CliMA/Oceananigans.jl/issues/3612:461,Modifiability,variab,variable,461,"I want to set the gradient boundary condition to east, west, south, north directions in u and v variables. However, for u variable, cannot specify east boundary condition using GradientBoundaryCondition at Face(). So, how should i solve this problem. . Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. Thanks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612
https://github.com/CliMA/Oceananigans.jl/issues/3612:512,Usability,simpl,simple,512,"I want to set the gradient boundary condition to east, west, south, north directions in u and v variables. However, for u variable, cannot specify east boundary condition using GradientBoundaryCondition at Face(). So, how should i solve this problem. . Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. Thanks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612
https://github.com/CliMA/Oceananigans.jl/issues/3614:184,Energy Efficiency,schedul,schedule,184,"I've run a simulation with a timestep of $\Delta t = 1.066666...$ and it looks as though there's some kind of rounding bug which is resulting in multiple saves occasionally. I choose 'schedule = TimeInterval(t_end/num_saves)' and expect to get 'num_saves' (or possibly 'num_saves+1') points in the saved 'time' variable. However, I end up with about 30 extra saves. Examining 'time' in more detail reveals that most of the points are separated by 't_end/num_saves' but a few (around 30) are separated by a much smaller interval. My guess is that this is a rounding bug with when the code saves the field. Alternatively I could have messed something up. Matt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614
https://github.com/CliMA/Oceananigans.jl/issues/3614:311,Modifiability,variab,variable,311,"I've run a simulation with a timestep of $\Delta t = 1.066666...$ and it looks as though there's some kind of rounding bug which is resulting in multiple saves occasionally. I choose 'schedule = TimeInterval(t_end/num_saves)' and expect to get 'num_saves' (or possibly 'num_saves+1') points in the saved 'time' variable. However, I end up with about 30 extra saves. Examining 'time' in more detail reveals that most of the points are separated by 't_end/num_saves' but a few (around 30) are separated by a much smaller interval. My guess is that this is a rounding bug with when the code saves the field. Alternatively I could have messed something up. Matt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614
https://github.com/CliMA/Oceananigans.jl/issues/3615:2008,Availability,error,errors,2008,"0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, -2, :]; 6×8 OffsetArray(::Matrix{Float64}, -1:4, -1:6) with eltype Float64 with indices -1:4×-1:6:; 4.06893e233 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 7.49511e247 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 3.83945e151 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 5.33788e223 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, :, -2]; 6×7 OffsetArray(::Matrix{Float64}, -1:4, -1:5) with eltype Float64 with indices -1:4×-1:5:; 0.0 NaN 0.0 2.42941e-314 5.13924e151 3.5e-323 4.06893e233; 0.0 0.0 0.0 2.66157e-314 5.6593e-314 4.0e-323 7.49511e247; NaN 0.0 NaN 1.4545e-320 2.98408e-314 6.09933e6 2.09002e-95; 0.0 0.0 0.0 8.46763e165 1.66e-321 4.06893e233 3.83945e151; 0.0 NaN 0.0 6.09933e6 2.75228e-318 7.49089e247 5.33788e223; 0.0 0.0 0.0 9.85509e165 3.0e-323 6.09933e6 2.09002e-95; ```. Even by accessing array elements indices outside the interior and halo ranges, we don’t get out-of-bounds errors. Instead, we obtain junk values for these indices. This behavior applies to windowed fields as well. But why is that the case? What is the reasoning behind this design choice, since I am assuming it’s on purpose?. Secondly, when accessing the interior elements of a windowed field, the indices in the windowed dimension must start from 1 instead of their actual values, which also results in junk values for these elements. Is this also intentional, or should I create a pull request to address it?. ```julia; julia> my_windowed_field = CenterField(grid, indices=(:, :, 5:6)); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 5:6); └── data: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615
https://github.com/CliMA/Oceananigans.jl/issues/3615:1910,Security,access,accessing,1910,"0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, -2, :]; 6×8 OffsetArray(::Matrix{Float64}, -1:4, -1:6) with eltype Float64 with indices -1:4×-1:6:; 4.06893e233 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 7.49511e247 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 3.83945e151 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 5.33788e223 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, :, -2]; 6×7 OffsetArray(::Matrix{Float64}, -1:4, -1:5) with eltype Float64 with indices -1:4×-1:5:; 0.0 NaN 0.0 2.42941e-314 5.13924e151 3.5e-323 4.06893e233; 0.0 0.0 0.0 2.66157e-314 5.6593e-314 4.0e-323 7.49511e247; NaN 0.0 NaN 1.4545e-320 2.98408e-314 6.09933e6 2.09002e-95; 0.0 0.0 0.0 8.46763e165 1.66e-321 4.06893e233 3.83945e151; 0.0 NaN 0.0 6.09933e6 2.75228e-318 7.49089e247 5.33788e223; 0.0 0.0 0.0 9.85509e165 3.0e-323 6.09933e6 2.09002e-95; ```. Even by accessing array elements indices outside the interior and halo ranges, we don’t get out-of-bounds errors. Instead, we obtain junk values for these indices. This behavior applies to windowed fields as well. But why is that the case? What is the reasoning behind this design choice, since I am assuming it’s on purpose?. Secondly, when accessing the interior elements of a windowed field, the indices in the windowed dimension must start from 1 instead of their actual values, which also results in junk values for these elements. Is this also intentional, or should I create a pull request to address it?. ```julia; julia> my_windowed_field = CenterField(grid, indices=(:, :, 5:6)); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 5:6); └── data: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615
https://github.com/CliMA/Oceananigans.jl/issues/3615:2244,Security,access,accessing,2244," 0.0 0.0; 5.33788e223 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, :, -2]; 6×7 OffsetArray(::Matrix{Float64}, -1:4, -1:5) with eltype Float64 with indices -1:4×-1:5:; 0.0 NaN 0.0 2.42941e-314 5.13924e151 3.5e-323 4.06893e233; 0.0 0.0 0.0 2.66157e-314 5.6593e-314 4.0e-323 7.49511e247; NaN 0.0 NaN 1.4545e-320 2.98408e-314 6.09933e6 2.09002e-95; 0.0 0.0 0.0 8.46763e165 1.66e-321 4.06893e233 3.83945e151; 0.0 NaN 0.0 6.09933e6 2.75228e-318 7.49089e247 5.33788e223; 0.0 0.0 0.0 9.85509e165 3.0e-323 6.09933e6 2.09002e-95; ```. Even by accessing array elements indices outside the interior and halo ranges, we don’t get out-of-bounds errors. Instead, we obtain junk values for these indices. This behavior applies to windowed fields as well. But why is that the case? What is the reasoning behind this design choice, since I am assuming it’s on purpose?. Secondly, when accessing the interior elements of a windowed field, the indices in the windowed dimension must start from 1 instead of their actual values, which also results in junk values for these elements. Is this also intentional, or should I create a pull request to address it?. ```julia; julia> my_windowed_field = CenterField(grid, indices=(:, :, 5:6)); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 5:6); └── data: 6×7×2 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, 5:6) with eltype Float64 with indices -1:4×-1:5×5:6; └── max=0.0, min=0.0, mean=0.0. julia> set!(my_windowed_field, 1); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryCondition",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615
https://github.com/CliMA/Oceananigans.jl/pull/3616:298,Energy Efficiency,schedul,schedule,298,"This PR modifies `TimeInterval` so that, rather than keeping track of the `previous_actuation_time`, it keeps track of the `first_actuation_time` plus the number of `actuations` (including the initial actuation). The next actuation time is then computed by . ```julia; function next_actuation_time(schedule::TimeInterval); t₀ = schedule.first_actuation_time; N = schedule.actuations; T = schedule.interval; return = t₀ + N * T; end; ```. Note we use `N` instead of `N+1` because the first actuation occurs at `t₀`. So for example, after this first actuation the next actuation time is `t₀ + T`. This may address #3056.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3616
https://github.com/CliMA/Oceananigans.jl/pull/3616:328,Energy Efficiency,schedul,schedule,328,"This PR modifies `TimeInterval` so that, rather than keeping track of the `previous_actuation_time`, it keeps track of the `first_actuation_time` plus the number of `actuations` (including the initial actuation). The next actuation time is then computed by . ```julia; function next_actuation_time(schedule::TimeInterval); t₀ = schedule.first_actuation_time; N = schedule.actuations; T = schedule.interval; return = t₀ + N * T; end; ```. Note we use `N` instead of `N+1` because the first actuation occurs at `t₀`. So for example, after this first actuation the next actuation time is `t₀ + T`. This may address #3056.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3616
https://github.com/CliMA/Oceananigans.jl/pull/3616:363,Energy Efficiency,schedul,schedule,363,"This PR modifies `TimeInterval` so that, rather than keeping track of the `previous_actuation_time`, it keeps track of the `first_actuation_time` plus the number of `actuations` (including the initial actuation). The next actuation time is then computed by . ```julia; function next_actuation_time(schedule::TimeInterval); t₀ = schedule.first_actuation_time; N = schedule.actuations; T = schedule.interval; return = t₀ + N * T; end; ```. Note we use `N` instead of `N+1` because the first actuation occurs at `t₀`. So for example, after this first actuation the next actuation time is `t₀ + T`. This may address #3056.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3616
https://github.com/CliMA/Oceananigans.jl/pull/3616:388,Energy Efficiency,schedul,schedule,388,"This PR modifies `TimeInterval` so that, rather than keeping track of the `previous_actuation_time`, it keeps track of the `first_actuation_time` plus the number of `actuations` (including the initial actuation). The next actuation time is then computed by . ```julia; function next_actuation_time(schedule::TimeInterval); t₀ = schedule.first_actuation_time; N = schedule.actuations; T = schedule.interval; return = t₀ + N * T; end; ```. Note we use `N` instead of `N+1` because the first actuation occurs at `t₀`. So for example, after this first actuation the next actuation time is `t₀ + T`. This may address #3056.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3616
https://github.com/CliMA/Oceananigans.jl/pull/3617:50,Availability,error,error,50,"Should help address some outstanding issues about error accumulation in `model.clock.time`, like #3606 and #3056.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3617
https://github.com/CliMA/Oceananigans.jl/pull/3618:60,Deployability,release,release,60,"Requires https://github.com/EnzymeAD/Enzyme.jl/pull/1485 to release, which itself requires https://github.com/JuliaRegistries/General/pull/108556. Perhaps means we don't change the other varargs stuff, but we'll have to wait and see.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3618
https://github.com/CliMA/Oceananigans.jl/issues/3622:239,Availability,error,errors,239,"For example,. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. errors with. ```julia; julia> include(""problem.jl""); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/OHYQj/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:223; ERROR: LoadError: ArgumentError: halo must be ≤ size for coordinate y; ```. Sad, because I didn't actually ask for a halo (3, 3, 3)! Manually setting things doesn't help:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. I guess the restriction on the halo size is supposed to be an optimization, but its not working in this case because I can't even set up my model. @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622
https://github.com/CliMA/Oceananigans.jl/issues/3622:644,Availability,ERROR,ERROR,644,"For example,. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. errors with. ```julia; julia> include(""problem.jl""); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/OHYQj/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:223; ERROR: LoadError: ArgumentError: halo must be ≤ size for coordinate y; ```. Sad, because I didn't actually ask for a halo (3, 3, 3)! Manually setting things doesn't help:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. I guess the restriction on the halo size is supposed to be an optimization, but its not working in this case because I can't even set up my model. @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622
https://github.com/CliMA/Oceananigans.jl/issues/3622:651,Performance,Load,LoadError,651,"For example,. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. errors with. ```julia; julia> include(""problem.jl""); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/OHYQj/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:223; ERROR: LoadError: ArgumentError: halo must be ≤ size for coordinate y; ```. Sad, because I didn't actually ask for a halo (3, 3, 3)! Manually setting things doesn't help:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. I guess the restriction on the halo size is supposed to be an optimization, but its not working in this case because I can't even set up my model. @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622
https://github.com/CliMA/Oceananigans.jl/issues/3622:1122,Performance,optimiz,optimization,1122,"For example,. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. errors with. ```julia; julia> include(""problem.jl""); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/OHYQj/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:223; ERROR: LoadError: ArgumentError: halo must be ≤ size for coordinate y; ```. Sad, because I didn't actually ask for a halo (3, 3, 3)! Manually setting things doesn't help:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. I guess the restriction on the halo size is supposed to be an optimization, but its not working in this case because I can't even set up my model. @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622
https://github.com/CliMA/Oceananigans.jl/issues/3625:708,Integrability,interface,interface,708,"Both `RectilinearGrid` and `LatitudeLongitudeGrid` have the property that the ""extrinsic"" coordinate system --- Cartesian for `RectilinearGrid`, and lat-lon for `LatitudeLongitudeGrid` --- coincide with the ""intrinsic"" coordinate system in which vector fields (like velocities) are expressed. However, for more general grids, like the tripolar grid, the intrinsic coordinate system of the grid differs from the extrinsic coordinate system. The extrinsic coordinate system is prescribed by us. We've decided to use lat-lon on the sphere and Cartesian otherwise. But the intrinsic coordinate system is a property of each grid independently. The main challenge with grids like the tripolar grid is providing an interface to `set!` the velocity fields. I think we should define `set!` so that `u, v, w` are assumed to be provided in the extrinsic coordinate system. This means that the provided velocities need to be rotated under the hood into the intrinsic coordinate system. One of the basic features we need is a function that rotates a vector field:. ```julia; ue, ve, we = extrinsic_vector(i, j, k, grid, ui, vi, wi); ```. and. ```julia; ui, vi, wi = intrinsic_vector(i, j, k, grid, ue, ve, we); ```. We may also want something like `intrinsic_vector_from_centered` and `intrinsic_vector_from_staggered` etc... Let's split the way we add this functionality into a few PRs, eg first develop `extrinsic_vector` and `intrinsic_vector`, and then in a new PR work on `set!`. . cc @simone-silvestri @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625
https://github.com/CliMA/Oceananigans.jl/issues/3626:232,Integrability,interface,interface,232,"We want to be able to build single column grids with `topology=(Flat, Flat, Bounded)`, but with non-trivial locations (either `x, y` for `RectilinearGrid` or `latitude` and `longitude` for `LatitudeLongitudeGrid`). I think the user interface should be something like. ```julia; grid = LatitudeLongitudeGrid(size=100, latitude=45, longitude=0, z=(-100, 0), topology=(Flat, Flat, Bounded)); ```. This will allow us to write code that automatically interpolates from another grid (say one associated with JRA55) to the location of `grid`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3626
https://github.com/CliMA/Oceananigans.jl/issues/3628:100,Availability,error,error,100,"When I use a function to set an `OpenBoundaryCondition` on a `HydrostaticFreeSurfaceModel` I get an error and I don't understand why. Here's a MWE:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)). u₀ = 1; @inline u_func(z, t) = u₀. u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u_func), west = OpenBoundaryCondition(u_func)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. This gives me the error:. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: objects of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(u_func), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628
https://github.com/CliMA/Oceananigans.jl/issues/3628:567,Availability,error,error,567,"When I use a function to set an `OpenBoundaryCondition` on a `HydrostaticFreeSurfaceModel` I get an error and I don't understand why. Here's a MWE:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)). u₀ = 1; @inline u_func(z, t) = u₀. u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u_func), west = OpenBoundaryCondition(u_func)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. This gives me the error:. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: objects of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(u_func), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628
https://github.com/CliMA/Oceananigans.jl/issues/3628:580,Availability,ERROR,ERROR,580,"When I use a function to set an `OpenBoundaryCondition` on a `HydrostaticFreeSurfaceModel` I get an error and I don't understand why. Here's a MWE:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)). u₀ = 1; @inline u_func(z, t) = u₀. u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u_func), west = OpenBoundaryCondition(u_func)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. This gives me the error:. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: objects of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(u_func), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628
https://github.com/CliMA/Oceananigans.jl/issues/3628:631,Availability,error,error,631,"When I use a function to set an `OpenBoundaryCondition` on a `HydrostaticFreeSurfaceModel` I get an error and I don't understand why. Here's a MWE:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)). u₀ = 1; @inline u_func(z, t) = u₀. u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u_func), west = OpenBoundaryCondition(u_func)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. This gives me the error:. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: objects of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(u_func), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628
https://github.com/CliMA/Oceananigans.jl/issues/3628:699,Deployability,Continuous,ContinuousBoundaryFunction,699,"When I use a function to set an `OpenBoundaryCondition` on a `HydrostaticFreeSurfaceModel` I get an error and I don't understand why. Here's a MWE:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)). u₀ = 1; @inline u_func(z, t) = u₀. u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u_func), west = OpenBoundaryCondition(u_func)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. This gives me the error:. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: objects of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(u_func), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628
https://github.com/CliMA/Oceananigans.jl/issues/3628:587,Performance,Load,LoadError,587,"When I use a function to set an `OpenBoundaryCondition` on a `HydrostaticFreeSurfaceModel` I get an error and I don't understand why. Here's a MWE:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)). u₀ = 1; @inline u_func(z, t) = u₀. u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u_func), west = OpenBoundaryCondition(u_func)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. This gives me the error:. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: objects of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(u_func), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628
https://github.com/CliMA/Oceananigans.jl/issues/3628:2713,Security,validat,validation,2713,"nc), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method. If I set-up exactly the same code but using a `NonhydrostaticModel` things work as expected. Things also work if I set the `OpenBoundaryCondition` using a constant, such as:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)); u₀ = 1; u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u₀), west = OpenBoundaryCondition(u₀)); model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. Am I missing something obvious here, or is something wrong? Also I couldn't find any scripts in the repo that exemplify `OpenBoundaryConditions`, so I'm happy to set-up a validation script or something once this is figured out if you guys think it's a good addition.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628
https://github.com/CliMA/Oceananigans.jl/pull/3630:307,Usability,clear,clear,307,"This makes it so that discrete-form function boundary conditions. ```; bc(i, j, grid, a, b, c, d); ```. will work provided that `fill_halo_regions!` is called with. ```julia; fill_halo_regions!(field, a, b, c, d); ```. The trade-off here is between code clarity and generality. I added a comment to make it clear that at least for Oceananigans models, we use `clock, model_fields`. @simone-silvestri wants to advertise Oceananigans as more generally applicable to any model using a finite volume grid, so this will help achieve that goal...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3630
https://github.com/CliMA/Oceananigans.jl/issues/3632:1659,Availability,error,error,1659,"drostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:133 [inlined]; [4] advect_particle; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:75 [inlined]; [5] macro expansion; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:145 [inlined]; [6] cpu__advect_particles!; @ C:\Users\xinle\.julia\packages\KernelAbstractions\WoCk1\src\macros.jl:276 [inlined]; [7] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632
https://github.com/CliMA/Oceananigans.jl/issues/3632:1686,Availability,ERROR,ERROR,1686,",; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:133 [inlined]; [4] advect_particle; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:75 [inlined]; [5] macro expansion; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:145 [inlined]; [6] cpu__advect_particles!; @ C:\Users\xinle\.julia\packages\KernelAbstractions\WoCk1\src\macros.jl:276 [inlined]; [7] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, particles::StructVector{…}, restitution::Float64, grid::RectilinearGrid{…}, Δt::Float64, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632
https://github.com/CliMA/Oceananigans.jl/issues/3632:5514,Availability,error,error,5514,"MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:161; [13] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\LagrangianParticleTracking.jl:131 [inlined]; [14] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:76 [inlined]; [15] time_step!(model::NonhydrostaticModel{…}, Δt::Float64; callbacks::Tuple{}, compute_tendencies::Bool); @ Oceananigans.TimeSteppers c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:110; [16] time_step!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:81 [inlined]; [17] time_step!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:122; [18] run!(sim::Simulation{…}; pickup::Bool); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:97; [19] run!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:85; [20] top-level scope; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\lagrangian_particle_MWE.jl:59; ```. The error indicates that `fractional_z_index` function hits https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L133 instead of https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L129, which is the intended function dispatch. Note: doing something like ; ```julia; struct SimpleParticle{X}; x :: X; y :: X; end; ```; is not supported, but perhaps this is a separate discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632
https://github.com/CliMA/Oceananigans.jl/issues/3632:1717,Security,access,access,1717,",; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:133 [inlined]; [4] advect_particle; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:75 [inlined]; [5] macro expansion; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:145 [inlined]; [6] cpu__advect_particles!; @ C:\Users\xinle\.julia\packages\KernelAbstractions\WoCk1\src\macros.jl:276 [inlined]; [7] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, particles::StructVector{…}, restitution::Float64, grid::RectilinearGrid{…}, Δt::Float64, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632
https://github.com/CliMA/Oceananigans.jl/issues/3632:399,Usability,Simpl,SimpleParticle,399,"When using `LagrangianParticles` in a `grid` with one direction having `Flat` topology, the code fails because the fractional index function hits the wrong line of code. Here is a MWE:. ```julia; using Oceananigans; using StructArrays; using Printf. grid = RectilinearGrid(CPU(), Float64,; size = (2, 2),; halo = (5, 5),; x = (0, 1),; y = (0, 1),; topology = (Periodic, Bounded, Flat)). #%%; struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. x_particle = [0.5]; y_particle = [0.5]; z_particle = [0.5]. particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). #%%; model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Use",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632
https://github.com/CliMA/Oceananigans.jl/issues/3632:531,Usability,Simpl,SimpleParticle,531,"When using `LagrangianParticles` in a `grid` with one direction having `Flat` topology, the code fails because the fractional index function hits the wrong line of code. Here is a MWE:. ```julia; using Oceananigans; using StructArrays; using Printf. grid = RectilinearGrid(CPU(), Float64,; size = (2, 2),; halo = (5, 5),; x = (0, 1),; y = (0, 1),; topology = (Periodic, Bounded, Flat)). #%%; struct SimpleParticle{X}; x :: X; y :: X; z :: X; end. x_particle = [0.5]; y_particle = [0.5]; z_particle = [0.5]. particles = StructArray{SimpleParticle}((x_particle, y_particle, z_particle)). lagrangian_particles = LagrangianParticles(particles). #%%; model = NonhydrostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Use",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632
https://github.com/CliMA/Oceananigans.jl/issues/3632:5905,Usability,Simpl,SimpleParticle,5905,"MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:161; [13] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\LagrangianParticleTracking.jl:131 [inlined]; [14] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:76 [inlined]; [15] time_step!(model::NonhydrostaticModel{…}, Δt::Float64; callbacks::Tuple{}, compute_tendencies::Bool); @ Oceananigans.TimeSteppers c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:110; [16] time_step!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:81 [inlined]; [17] time_step!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:122; [18] run!(sim::Simulation{…}; pickup::Bool); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:97; [19] run!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:85; [20] top-level scope; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\lagrangian_particle_MWE.jl:59; ```. The error indicates that `fractional_z_index` function hits https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L133 instead of https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L129, which is the intended function dispatch. Note: doing something like ; ```julia; struct SimpleParticle{X}; x :: X; y :: X; end; ```; is not supported, but perhaps this is a separate discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632
https://github.com/CliMA/Oceananigans.jl/issues/3637:251,Availability,down,downsides,251,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637
https://github.com/CliMA/Oceananigans.jl/issues/3637:822,Integrability,depend,depend,822,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637
https://github.com/CliMA/Oceananigans.jl/issues/3637:1736,Modifiability,extend,extend,1736,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637
https://github.com/CliMA/Oceananigans.jl/issues/3637:531,Usability,clear,clear,531,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637
https://github.com/CliMA/Oceananigans.jl/issues/3637:1819,Usability,simpl,simpler,1819,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637
https://github.com/CliMA/Oceananigans.jl/pull/3638:100,Integrability,depend,dependent,100,Closes https://github.com/CliMA/Oceananigans.jl/issues/3637. This is an implementation of the scale-dependent Lagrangian-averaged dynamic Smagorinsky model as outlined in section C III. in [Bou-Zeid et al. 2005](https://dx.doi.org/10.1063/1.1839152). @simone-silvestri @tomchor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3638
https://github.com/CliMA/Oceananigans.jl/pull/3642:506,Availability,error,error,506,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3637. This PR implements the scale-invariant dynamic Smagorinsky. My main reference for this was [Bou-Zeid et al. (2005)](https://dx.doi.org/10.1063/1.1839152), just because it's nicely summarized there. As a refresher, the coefficient in this case is calculated as. ```math; c_s^2 = \frac{\langle L_{ij} M_{ij}\rangle}{\langle M_{ij} M_{ij} \rangle},; ```; where $M_{ij}$ and $L_{ij}$ are obtained by applying the Germano identity and minimizing the error. $\langle \cdot \rangle$ is an average which usually is implemented as planar averaging. I'm implementing it here with an arbitrary `DirectionalAveraging` procedure that can average in whatever direction the user wants. Following a suggestion by @glwagner in #3637, I'm also starting to put the pieces in place for a more general averaging procedure so that eventually we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a d",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642
https://github.com/CliMA/Oceananigans.jl/pull/3642:1287,Energy Efficiency,efficient,efficient,1287,"nt in this case is calculated as. ```math; c_s^2 = \frac{\langle L_{ij} M_{ij}\rangle}{\langle M_{ij} M_{ij} \rangle},; ```; where $M_{ij}$ and $L_{ij}$ are obtained by applying the Germano identity and minimizing the error. $\langle \cdot \rangle$ is an average which usually is implemented as planar averaging. I'm implementing it here with an arbitrary `DirectionalAveraging` procedure that can average in whatever direction the user wants. Following a suggestion by @glwagner in #3637, I'm also starting to put the pieces in place for a more general averaging procedure so that eventually we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fie",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642
https://github.com/CliMA/Oceananigans.jl/pull/3642:2203,Performance,Optimiz,Optimize,2203,"ally we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fields in order to calculate the Smag coefficient: `LM`, `MM` are 3D fields; and `LM_avg` and `MM_avg` are 1D or 2D. What I'm doing is to first calculate $L_{ij} M_{ij}$ and $M_{ij} M_{ij}$ pointwise, and then `LM_avg` and `MM_avg` receive their averages. We should be able to calculate everything without needing `LM`, `MM` are 3D fields, I just couldn't figure out how yet :); - [ ] Write docs; - [x] Write tests; - [x] Validate that model is working as intended. CC @glwagner @simone-silvestri @xkykai @whitleyv . Feel free to add more things to the to-do list that I may have forgotten.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642
https://github.com/CliMA/Oceananigans.jl/pull/3642:2708,Security,Validat,Validate,2708,"ally we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fields in order to calculate the Smag coefficient: `LM`, `MM` are 3D fields; and `LM_avg` and `MM_avg` are 1D or 2D. What I'm doing is to first calculate $L_{ij} M_{ij}$ and $M_{ij} M_{ij}$ pointwise, and then `LM_avg` and `MM_avg` receive their averages. We should be able to calculate everything without needing `LM`, `MM` are 3D fields, I just couldn't figure out how yet :); - [ ] Write docs; - [x] Write tests; - [x] Validate that model is working as intended. CC @glwagner @simone-silvestri @xkykai @whitleyv . Feel free to add more things to the to-do list that I may have forgotten.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642
https://github.com/CliMA/Oceananigans.jl/pull/3642:2695,Testability,test,tests,2695,"ally we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fields in order to calculate the Smag coefficient: `LM`, `MM` are 3D fields; and `LM_avg` and `MM_avg` are 1D or 2D. What I'm doing is to first calculate $L_{ij} M_{ij}$ and $M_{ij} M_{ij}$ pointwise, and then `LM_avg` and `MM_avg` receive their averages. We should be able to calculate everything without needing `LM`, `MM` are 3D fields, I just couldn't figure out how yet :); - [ ] Write docs; - [x] Write tests; - [x] Validate that model is working as intended. CC @glwagner @simone-silvestri @xkykai @whitleyv . Feel free to add more things to the to-do list that I may have forgotten.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642
https://github.com/CliMA/Oceananigans.jl/pull/3642:2152,Usability,simpl,simplicity,2152,"ally we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fields in order to calculate the Smag coefficient: `LM`, `MM` are 3D fields; and `LM_avg` and `MM_avg` are 1D or 2D. What I'm doing is to first calculate $L_{ij} M_{ij}$ and $M_{ij} M_{ij}$ pointwise, and then `LM_avg` and `MM_avg` receive their averages. We should be able to calculate everything without needing `LM`, `MM` are 3D fields, I just couldn't figure out how yet :); - [ ] Write docs; - [x] Write tests; - [x] Validate that model is working as intended. CC @glwagner @simone-silvestri @xkykai @whitleyv . Feel free to add more things to the to-do list that I may have forgotten.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642
https://github.com/CliMA/Oceananigans.jl/pull/3643:20,Testability,test,test,20,"This adds an enzyme test for differentiating flux boundary conditions with Enzyme, which is of interest for solving inverse problems and other applications. @wsmoses",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3643
https://github.com/CliMA/Oceananigans.jl/pull/3652:109,Availability,down,downloads,109,Is something like this useful? See how they look at https://github.com/CliMA/Oceananigans.jl/tree/ncc/readme-downloads,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3652
https://github.com/CliMA/Oceananigans.jl/issues/3655:448,Availability,error,error,448,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655
https://github.com/CliMA/Oceananigans.jl/issues/3655:497,Availability,fault,fault,497,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655
https://github.com/CliMA/Oceananigans.jl/issues/3655:825,Availability,down,downloads,825,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655
https://github.com/CliMA/Oceananigans.jl/issues/3655:1089,Availability,error,errors,1089,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655
https://github.com/CliMA/Oceananigans.jl/issues/3655:1525,Availability,error,errors,1525,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655
https://github.com/CliMA/Oceananigans.jl/issues/3655:1161,Modifiability,variab,variable,1161,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655
https://github.com/CliMA/Oceananigans.jl/issues/3655:74,Performance,Load,Load,74,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655
https://github.com/CliMA/Oceananigans.jl/issues/3655:959,Performance,load,loaded,959,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655
https://github.com/CliMA/Oceananigans.jl/issues/3655:1394,Performance,load,loaded,1394,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655
https://github.com/CliMA/Oceananigans.jl/issues/3657:35,Availability,checkpoint,checkpoint,35,"Hi all,; I have an issue with post-checkpoint runs. I've set the output saving interval to 30 minutes, but for the first few hours after picking up the checkpoint, the saving interval is actually equal to Δt (approximately 30 seconds in my case). Additionally, the progress message is generated every iteration (30 seconds) instead of every 30 minutes as intended. This strange behavior continues until iteration 13398, after which the interval and progress messages behave correctly (see the progress message below).; It is unclear to me what went wrong. Any ideas would be much appreciated!; (I can provide the code about how I set the `outputwriter` and progress message if needed; I am using Oceananigans v0.91.3, and Julia/1.10.2). ![image](https://github.com/user-attachments/assets/5cbba3b7-c686-48c2-8364-a85926867441)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657
https://github.com/CliMA/Oceananigans.jl/issues/3657:152,Availability,checkpoint,checkpoint,152,"Hi all,; I have an issue with post-checkpoint runs. I've set the output saving interval to 30 minutes, but for the first few hours after picking up the checkpoint, the saving interval is actually equal to Δt (approximately 30 seconds in my case). Additionally, the progress message is generated every iteration (30 seconds) instead of every 30 minutes as intended. This strange behavior continues until iteration 13398, after which the interval and progress messages behave correctly (see the progress message below).; It is unclear to me what went wrong. Any ideas would be much appreciated!; (I can provide the code about how I set the `outputwriter` and progress message if needed; I am using Oceananigans v0.91.3, and Julia/1.10.2). ![image](https://github.com/user-attachments/assets/5cbba3b7-c686-48c2-8364-a85926867441)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657
https://github.com/CliMA/Oceananigans.jl/issues/3657:274,Integrability,message,message,274,"Hi all,; I have an issue with post-checkpoint runs. I've set the output saving interval to 30 minutes, but for the first few hours after picking up the checkpoint, the saving interval is actually equal to Δt (approximately 30 seconds in my case). Additionally, the progress message is generated every iteration (30 seconds) instead of every 30 minutes as intended. This strange behavior continues until iteration 13398, after which the interval and progress messages behave correctly (see the progress message below).; It is unclear to me what went wrong. Any ideas would be much appreciated!; (I can provide the code about how I set the `outputwriter` and progress message if needed; I am using Oceananigans v0.91.3, and Julia/1.10.2). ![image](https://github.com/user-attachments/assets/5cbba3b7-c686-48c2-8364-a85926867441)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657
https://github.com/CliMA/Oceananigans.jl/issues/3657:458,Integrability,message,messages,458,"Hi all,; I have an issue with post-checkpoint runs. I've set the output saving interval to 30 minutes, but for the first few hours after picking up the checkpoint, the saving interval is actually equal to Δt (approximately 30 seconds in my case). Additionally, the progress message is generated every iteration (30 seconds) instead of every 30 minutes as intended. This strange behavior continues until iteration 13398, after which the interval and progress messages behave correctly (see the progress message below).; It is unclear to me what went wrong. Any ideas would be much appreciated!; (I can provide the code about how I set the `outputwriter` and progress message if needed; I am using Oceananigans v0.91.3, and Julia/1.10.2). ![image](https://github.com/user-attachments/assets/5cbba3b7-c686-48c2-8364-a85926867441)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657
https://github.com/CliMA/Oceananigans.jl/issues/3657:502,Integrability,message,message,502,"Hi all,; I have an issue with post-checkpoint runs. I've set the output saving interval to 30 minutes, but for the first few hours after picking up the checkpoint, the saving interval is actually equal to Δt (approximately 30 seconds in my case). Additionally, the progress message is generated every iteration (30 seconds) instead of every 30 minutes as intended. This strange behavior continues until iteration 13398, after which the interval and progress messages behave correctly (see the progress message below).; It is unclear to me what went wrong. Any ideas would be much appreciated!; (I can provide the code about how I set the `outputwriter` and progress message if needed; I am using Oceananigans v0.91.3, and Julia/1.10.2). ![image](https://github.com/user-attachments/assets/5cbba3b7-c686-48c2-8364-a85926867441)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657
https://github.com/CliMA/Oceananigans.jl/issues/3657:666,Integrability,message,message,666,"Hi all,; I have an issue with post-checkpoint runs. I've set the output saving interval to 30 minutes, but for the first few hours after picking up the checkpoint, the saving interval is actually equal to Δt (approximately 30 seconds in my case). Additionally, the progress message is generated every iteration (30 seconds) instead of every 30 minutes as intended. This strange behavior continues until iteration 13398, after which the interval and progress messages behave correctly (see the progress message below).; It is unclear to me what went wrong. Any ideas would be much appreciated!; (I can provide the code about how I set the `outputwriter` and progress message if needed; I am using Oceananigans v0.91.3, and Julia/1.10.2). ![image](https://github.com/user-attachments/assets/5cbba3b7-c686-48c2-8364-a85926867441)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657
https://github.com/CliMA/Oceananigans.jl/pull/3658:12,Performance,optimiz,optimization,12,"Yet another optimization for upwind stencil computations.; The pattern in Oceananigans to perform upwind reconstruction is roughly:; ```julia; R_left = _left_reconstruction(.....); R_right = _right_reconstruction(.....). return ifelse(u > 0, u * R_left, u * R_right); ``` . This means that we are always performing the reconstruction twice. This is not a huge problem for linear reconstruction schemes (`UpwindBiased`) but leads to register blowup for `WENO` schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3658:90,Performance,perform,perform,90,"Yet another optimization for upwind stencil computations.; The pattern in Oceananigans to perform upwind reconstruction is roughly:; ```julia; R_left = _left_reconstruction(.....); R_right = _right_reconstruction(.....). return ifelse(u > 0, u * R_left, u * R_right); ``` . This means that we are always performing the reconstruction twice. This is not a huge problem for linear reconstruction schemes (`UpwindBiased`) but leads to register blowup for `WENO` schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3658:304,Performance,perform,performing,304,"Yet another optimization for upwind stencil computations.; The pattern in Oceananigans to perform upwind reconstruction is roughly:; ```julia; R_left = _left_reconstruction(.....); R_right = _right_reconstruction(.....). return ifelse(u > 0, u * R_left, u * R_right); ``` . This means that we are always performing the reconstruction twice. This is not a huge problem for linear reconstruction schemes (`UpwindBiased`) but leads to register blowup for `WENO` schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3658:3756,Performance,perform,performance,3756,"mark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new branch `julia --project=""environments/one_sided_branch"" --check-bounds=no`; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true; BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 16.463 ms … 18.503 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 16.466 ms ┊ GC (median): 0.00%; Time (mean ± σ): 16.878 ms ± 908.449 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆ ▁; 16.5 ms Histogram: frequency by time 18.5 ms <. Memory estimate: 250.06 KiB, allocs estimate: 676. julia> trial1 = run_model_benchmark!(tracer_kernel_test, arch;; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 6.695 ms … 7.461 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 6.789 ms ┊ GC (median): 0.00%; Time (mean ± σ): 6.908 ms ± 312.944 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ ██ █ █; █▁▁▁▁▁██▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 6.69 ms Histogram: frequency by time 7.46 ms <. Memory estimate: 46.39 KiB, allocs estimate: 231. ```. P.S. some vestigial code not used is being removed as part of this PR because not beneficial (in terms of both accuracy and performance) that is; - the JS weno formulation (dominated by the Z-weno formulation); - Velocity Upwinding for the vector invariant weno formulation (dominated by the other two formulations)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3658:1048,Testability,benchmark,benchmarks,1048,"in Oceananigans to perform upwind reconstruction is roughly:; ```julia; R_left = _left_reconstruction(.....); R_right = _right_reconstruction(.....). return ifelse(u > 0, u * R_left, u * R_right); ``` . This means that we are always performing the reconstruction twice. This is not a huge problem for linear reconstruction schemes (`UpwindBiased`) but leads to register blowup for `WENO` schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3658:1198,Testability,test,tests,1198," we are always performing the reconstruction twice. This is not a huge problem for linear reconstruction schemes (`UpwindBiased`) but leads to register blowup for `WENO` schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3658:1499,Testability,Benchmark,BenchmarkTools,1499," schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3658:2009,Testability,Benchmark,BenchmarkTools,2009,"f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new branch `julia --project=""environments/one_sided_branch"" --check-bounds=no`; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true; BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 16.463 ms … 18.503 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 16.466 ms ┊ GC (median): 0.00%; Time (mean ± σ): 16.878 ms ± 908.449 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▁▁▁▁▁▁▁▁▁",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3658:2712,Testability,Benchmark,BenchmarkTools,2712,"Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new branch `julia --project=""environments/one_sided_branch"" --check-bounds=no`; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true; BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 16.463 ms … 18.503 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 16.466 ms ┊ GC (median): 0.00%; Time (mean ± σ): 16.878 ms ± 908.449 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆ ▁; 16.5 ms Histogram: frequency by time 18.5 ms <. Memory estimate: 250.06 KiB, allocs estimate: 676. julia> trial1 = run_model_benchmark!(tracer_kernel_test, arch;; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 6.695 ms … 7.461 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 6.789 ms ┊ GC (median): 0.00%; Time (mean ± σ): 6.908 ms ± 312.944 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ ██ █ █; █▁▁▁▁▁██▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 6.69 ms Histogram: frequency by time 7.46 ms <. Memory estimate: 46.39 KiB, allocs estimate: 231. ```. P.S. some vestigial code not used is bei",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3658:3215,Testability,Benchmark,BenchmarkTools,3215,"mark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new branch `julia --project=""environments/one_sided_branch"" --check-bounds=no`; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true; BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 16.463 ms … 18.503 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 16.466 ms ┊ GC (median): 0.00%; Time (mean ± σ): 16.878 ms ± 908.449 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆ ▁; 16.5 ms Histogram: frequency by time 18.5 ms <. Memory estimate: 250.06 KiB, allocs estimate: 676. julia> trial1 = run_model_benchmark!(tracer_kernel_test, arch;; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 6.695 ms … 7.461 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 6.789 ms ┊ GC (median): 0.00%; Time (mean ± σ): 6.908 ms ± 312.944 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ ██ █ █; █▁▁▁▁▁██▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 6.69 ms Histogram: frequency by time 7.46 ms <. Memory estimate: 46.39 KiB, allocs estimate: 231. ```. P.S. some vestigial code not used is being removed as part of this PR because not beneficial (in terms of both accuracy and performance) that is; - the JS weno formulation (dominated by the Z-weno formulation); - Velocity Upwinding for the vector invariant weno formulation (dominated by the other two formulations)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658
https://github.com/CliMA/Oceananigans.jl/pull/3660:63,Energy Efficiency,schedul,schedules,63,"This PR tweaks the initialization procedure for `run!` so that schedules are initialized separately from the execution of callbacks and output writers at `iteration == 0`. This allows simulations that start from iterations other than `0` to execute correctly. It also re-defines the meaning of ""actuations"" for `TimeInterval` to be more sensible. Previously the actual number of actuations was `actuations - 1` which is confusing. There are still some issues with initialization. However I think this PR helps to clarify the distinction between ""initialization"", which occurs whenever we call `run!`, vs the thing we do at ""iteration 0"", like writing output. Resolves #3657",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3660
https://github.com/CliMA/Oceananigans.jl/pull/3665:0,Deployability,update,updates,0,updates the creation of a unified memory array following the (new?) CUDA.jl syntax. closes #3664,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3665
https://github.com/CliMA/Oceananigans.jl/pull/3666:264,Testability,test,tested,264,"`NetCDFOutputwriter` has a bug for Immersed curvilinear grids, in practice for an immersed boundary the default ; `native_dimensions_for_netcdf_output` is called instead of the one for curvilinear grids. This PR should address the issue. ; Also it seems to not be tested so I ll add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3666
https://github.com/CliMA/Oceananigans.jl/pull/3666:285,Testability,test,test,285,"`NetCDFOutputwriter` has a bug for Immersed curvilinear grids, in practice for an immersed boundary the default ; `native_dimensions_for_netcdf_output` is called instead of the one for curvilinear grids. This PR should address the issue. ; Also it seems to not be tested so I ll add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3666
https://github.com/CliMA/Oceananigans.jl/issues/3670:260,Availability,checkpoint,checkpoint,260,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:511,Availability,checkpoint,checkpoint,511,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:744,Availability,error,errors,744,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:888,Availability,checkpoint,checkpoint,888,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:1706,Availability,checkpoint,checkpointer,1706,"e:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:1721,Availability,Checkpoint,Checkpointer,1721,"e:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:1841,Availability,checkpoint,checkpointer,1841,"Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/f9964aa3-f708-4c43-88a3-7b0a565148c1"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:1857,Availability,checkpoint,checkpointer,1857,"Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/f9964aa3-f708-4c43-88a3-7b0a565148c1"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:2150,Availability,checkpoint,checkpoint,2150,"Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/f9964aa3-f708-4c43-88a3-7b0a565148c1"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:2278,Availability,checkpoint,checkpoint,2278,"Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/f9964aa3-f708-4c43-88a3-7b0a565148c1"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:2317,Availability,checkpoint,checkpoint,2317,"Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/f9964aa3-f708-4c43-88a3-7b0a565148c1"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:2428,Availability,checkpoint,checkpoint,2428,"Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/f9964aa3-f708-4c43-88a3-7b0a565148c1"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:1590,Energy Efficiency,schedul,schedule,1590,"e:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:1641,Energy Efficiency,schedul,schedule,1641,"e:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:1742,Energy Efficiency,schedul,schedule,1742,"e:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:2065,Integrability,message,message,2065,"Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/f9964aa3-f708-4c43-88a3-7b0a565148c1"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:865,Testability,test,test,865,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:1789,Testability,test,test,1789,"e:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3670:844,Usability,simpl,simple,844,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670
https://github.com/CliMA/Oceananigans.jl/issues/3672:1223,Availability,Checkpoint,Checkpointing,1223,"tup"" part of the documentation. We've noticed that while our examples and docstrings seem to be useful, the ""model setup"" is less so, and also leaves out a lot of information necessary for running more complex simulations. ## What we have now. The basic idea is to flatten the current structure a bit. Right now it reads:. ```; - Home; - Quick start; - Examples > ; - Physics > ; - Numerical implementation > ; - Model setup > ; - <etc>; ```. ## What we propose. We propose to create top-level sections for important concepts such as `Grids`, `Fields`, `Simulations` etc. Then less important details would be subsumed into the `Models` section (which would overlap strongly with the current `Model setup` section). Here's an outline:. ```; - Home; - Quick start; - Examples >; - Grids, architectures, and number types; - Fields and operations; - Models; - Setting initial conditions; - Tracers; - Advection schemes; - Turbulence closures; - Buoyancy models and equations of state; - Rotation and Coriolis forces; - Turbulence closures; - Forcing functions; - Background fields; - Lagrangian particles; - Clocks; - Simulations; - Callbacks; - Output writers; - Checkpointing and picking up from a checkpoint; - Physics > ; - Numerical implementation > ; - <etc>; ```. The ordering of subjects is carefully chosen here, so please comment on that if you think it should be changed. To do this incrementally, I will open a PR that adds the `Grids` and `Fields` sections. Then we can build the `Models` section incrementally by porting material from `Model setup`. While we are working I will add the qualifer `Model setup (legacy)`. Related issues:. * https://github.com/CliMA/Oceananigans.jl/issues/3594; * https://github.com/CliMA/Oceananigans.jl/issues/3166; * https://github.com/CliMA/Oceananigans.jl/issues/2448; * https://github.com/CliMA/Oceananigans.jl/issues/2308; * https://github.com/CliMA/Oceananigans.jl/issues/1879; * https://github.com/CliMA/Oceananigans.jl/issues/1779; * https://github.c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3672
https://github.com/CliMA/Oceananigans.jl/issues/3672:1259,Availability,checkpoint,checkpoint,1259,"tup"" part of the documentation. We've noticed that while our examples and docstrings seem to be useful, the ""model setup"" is less so, and also leaves out a lot of information necessary for running more complex simulations. ## What we have now. The basic idea is to flatten the current structure a bit. Right now it reads:. ```; - Home; - Quick start; - Examples > ; - Physics > ; - Numerical implementation > ; - Model setup > ; - <etc>; ```. ## What we propose. We propose to create top-level sections for important concepts such as `Grids`, `Fields`, `Simulations` etc. Then less important details would be subsumed into the `Models` section (which would overlap strongly with the current `Model setup` section). Here's an outline:. ```; - Home; - Quick start; - Examples >; - Grids, architectures, and number types; - Fields and operations; - Models; - Setting initial conditions; - Tracers; - Advection schemes; - Turbulence closures; - Buoyancy models and equations of state; - Rotation and Coriolis forces; - Turbulence closures; - Forcing functions; - Background fields; - Lagrangian particles; - Clocks; - Simulations; - Callbacks; - Output writers; - Checkpointing and picking up from a checkpoint; - Physics > ; - Numerical implementation > ; - <etc>; ```. The ordering of subjects is carefully chosen here, so please comment on that if you think it should be changed. To do this incrementally, I will open a PR that adds the `Grids` and `Fields` sections. Then we can build the `Models` section incrementally by porting material from `Model setup`. While we are working I will add the qualifer `Model setup (legacy)`. Related issues:. * https://github.com/CliMA/Oceananigans.jl/issues/3594; * https://github.com/CliMA/Oceananigans.jl/issues/3166; * https://github.com/CliMA/Oceananigans.jl/issues/2448; * https://github.com/CliMA/Oceananigans.jl/issues/2308; * https://github.com/CliMA/Oceananigans.jl/issues/1879; * https://github.com/CliMA/Oceananigans.jl/issues/1779; * https://github.c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3672
https://github.com/CliMA/Oceananigans.jl/issues/3672:35,Modifiability,refactor,refactoring,35,"This issue describes an overhaul / refactoring of the ""Model setup"" part of the documentation. We've noticed that while our examples and docstrings seem to be useful, the ""model setup"" is less so, and also leaves out a lot of information necessary for running more complex simulations. ## What we have now. The basic idea is to flatten the current structure a bit. Right now it reads:. ```; - Home; - Quick start; - Examples > ; - Physics > ; - Numerical implementation > ; - Model setup > ; - <etc>; ```. ## What we propose. We propose to create top-level sections for important concepts such as `Grids`, `Fields`, `Simulations` etc. Then less important details would be subsumed into the `Models` section (which would overlap strongly with the current `Model setup` section). Here's an outline:. ```; - Home; - Quick start; - Examples >; - Grids, architectures, and number types; - Fields and operations; - Models; - Setting initial conditions; - Tracers; - Advection schemes; - Turbulence closures; - Buoyancy models and equations of state; - Rotation and Coriolis forces; - Turbulence closures; - Forcing functions; - Background fields; - Lagrangian particles; - Clocks; - Simulations; - Callbacks; - Output writers; - Checkpointing and picking up from a checkpoint; - Physics > ; - Numerical implementation > ; - <etc>; ```. The ordering of subjects is carefully chosen here, so please comment on that if you think it should be changed. To do this incrementally, I will open a PR that adds the `Grids` and `Fields` sections. Then we can build the `Models` section incrementally by porting material from `Model setup`. While we are working I will add the qualifer `Model setup (legacy)`. Related issues:. * https://github.com/CliMA/Oceananigans.jl/issues/3594; * https://github.com/CliMA/Oceananigans.jl/issues/3166; * https://github.com/CliMA/Oceananigans.jl/issues/2448; * https://github.com/CliMA/Oceananigans.jl/issues/2308; * https://github.com/CliMA/Oceananigans.jl/issues/1879; * https://gi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3672
https://github.com/CliMA/Oceananigans.jl/pull/3676:167,Availability,error,error,167,This PR adds a method to `mask_immersed_field!` for `SumOfArrays`. I was trying to make a model which has an auxiliary field which is a `SumOfArrays` but ran into the error that all of the prognostic and auxiliary fields in the `HydrostaticFreeSurfaceModel` get masked during the `update_state!` step. (Ran into the issue here: https://github.com/OceanBioME/OceanBioME.jl/pull/195),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676
https://github.com/CliMA/Oceananigans.jl/pull/3676:262,Availability,mask,masked,262,This PR adds a method to `mask_immersed_field!` for `SumOfArrays`. I was trying to make a model which has an auxiliary field which is a `SumOfArrays` but ran into the error that all of the prognostic and auxiliary fields in the `HydrostaticFreeSurfaceModel` get masked during the `update_state!` step. (Ran into the issue here: https://github.com/OceanBioME/OceanBioME.jl/pull/195),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676
https://github.com/CliMA/Oceananigans.jl/issues/3677:130,Deployability,release,releases,130,"I have noticed an issue with immersed boundaries in the latest version of [Oceananigans](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.91.4). At the immersed boundaries we expect the default tracer flux boundary conditions to be zero. While doing energy analysis, I noticed that something seemed off with my simulation. After increasing the colorrange in my animation, I noticed that near my immersed boundaries, the minimum buoyancy was drifting to values much less than the minimum value prescribed by the surface value boundary conditions, suggesting that the tracer flux at the immersed boundary is non-zero. For context, I'm running a 2D Horizontal Convection simulation, in which the buoyancy is initialized as zero everywhere to start. I apply a buoyancy gradient at the surface, cooling half of the surface and warming the other half. The boundaries are insulated and I have a pair of gaussian hills at the bottom defined using the immersed boundary function. Link to my [simulation setup](https://github.com/ikeshwani/HorizontalConvection/blob/main/src/simulation.jl). . Here is an animation of topographically-constrained horizontal convection where the nonhydrostatic pressure is not separated:. https://github.com/user-attachments/assets/9fd054c9-f1da-4b8d-9d04-b99479dbe348. Notice there seems to be a source of dense fluid in the basin between the hills. . To address this issue @hdrake and I separated the hydrostatic and nonhydrostatic pressure components in the `NonHydrostaticModel` by changing https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L70. To `hydrostatic_pressure_anomaly = CenterField(grid)`. Here is the animation of topographically-constrained horizontal convection when the pressure components are separated:. https://github.com/user-attachments/assets/249e9814-335f-49bb-999e-73a6f95fcf37",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677
https://github.com/CliMA/Oceananigans.jl/issues/3677:258,Energy Efficiency,energy,energy,258,"I have noticed an issue with immersed boundaries in the latest version of [Oceananigans](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.91.4). At the immersed boundaries we expect the default tracer flux boundary conditions to be zero. While doing energy analysis, I noticed that something seemed off with my simulation. After increasing the colorrange in my animation, I noticed that near my immersed boundaries, the minimum buoyancy was drifting to values much less than the minimum value prescribed by the surface value boundary conditions, suggesting that the tracer flux at the immersed boundary is non-zero. For context, I'm running a 2D Horizontal Convection simulation, in which the buoyancy is initialized as zero everywhere to start. I apply a buoyancy gradient at the surface, cooling half of the surface and warming the other half. The boundaries are insulated and I have a pair of gaussian hills at the bottom defined using the immersed boundary function. Link to my [simulation setup](https://github.com/ikeshwani/HorizontalConvection/blob/main/src/simulation.jl). . Here is an animation of topographically-constrained horizontal convection where the nonhydrostatic pressure is not separated:. https://github.com/user-attachments/assets/9fd054c9-f1da-4b8d-9d04-b99479dbe348. Notice there seems to be a source of dense fluid in the basin between the hills. . To address this issue @hdrake and I separated the hydrostatic and nonhydrostatic pressure components in the `NonHydrostaticModel` by changing https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L70. To `hydrostatic_pressure_anomaly = CenterField(grid)`. Here is the animation of topographically-constrained horizontal convection when the pressure components are separated:. https://github.com/user-attachments/assets/249e9814-335f-49bb-999e-73a6f95fcf37",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677
https://github.com/CliMA/Oceananigans.jl/issues/3681:730,Availability,error,error,730,"I know `PartialCellBottom` is unexported and therefore experimental but just opening an issue that it doesn't currently work on GPUs with `HydrostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBot",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:743,Availability,ERROR,ERROR,743,"I know `PartialCellBottom` is unexported and therefore experimental but just opening an issue that it doesn't currently work on GPUs with `HydrostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBot",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:187,Energy Efficiency,Adapt,Adapt,187,"I know `PartialCellBottom` is unexported and therefore experimental but just opening an issue that it doesn't currently work on GPUs with `HydrostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBot",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1141,Energy Efficiency,adapt,adapt,1141,"ostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1278,Energy Efficiency,Adapt,Adapt,1278,"unctions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1313,Energy Efficiency,Adapt,Adapt,1313," easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1329,Energy Efficiency,Adapt,Adapt,1329," easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1666,Energy Efficiency,adapt,adapt,1666,"SurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1827,Energy Efficiency,Adapt,Adapt,1827,"ay has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstracti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1862,Energy Efficiency,Adapt,Adapt,1862,":CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstractions\MAxUm\src\extras\loopinfo.jl:26 [inlined]; [13] iterate_split_explicit!(free_surface::SplitExplici",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1878,Energy Efficiency,Adapt,Adapt,1878,":CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstractions\MAxUm\src\extras\loopinfo.jl:26 [inlined]; [13] iterate_split_explicit!(free_surface::SplitExplici",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:187,Modifiability,Adapt,Adapt,187,"I know `PartialCellBottom` is unexported and therefore experimental but just opening an issue that it doesn't currently work on GPUs with `HydrostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBot",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1141,Modifiability,adapt,adapt,1141,"ostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1278,Modifiability,Adapt,Adapt,1278,"unctions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1313,Modifiability,Adapt,Adapt,1313," easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1329,Modifiability,Adapt,Adapt,1329," easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1666,Modifiability,adapt,adapt,1666,"SurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1827,Modifiability,Adapt,Adapt,1827,"ay has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstracti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1862,Modifiability,Adapt,Adapt,1862,":CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstractions\MAxUm\src\extras\loopinfo.jl:26 [inlined]; [13] iterate_split_explicit!(free_surface::SplitExplici",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/issues/3681:1878,Modifiability,Adapt,Adapt,1878,":CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstractions\MAxUm\src\extras\loopinfo.jl:26 [inlined]; [13] iterate_split_explicit!(free_surface::SplitExplici",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681
https://github.com/CliMA/Oceananigans.jl/pull/3682:56,Security,validat,validation,56,closes #3681. We can probably use this PR to add also a validation for the `PartialCellBottom` and the bug-fixes in the implementation.; What do people think?. cc @jm-c,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682
https://github.com/CliMA/Oceananigans.jl/issues/3684:66,Deployability,update,updated,66,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684
https://github.com/CliMA/Oceananigans.jl/issues/3684:40,Modifiability,rewrite,rewrite,40,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684
https://github.com/CliMA/Oceananigans.jl/issues/3684:192,Performance,perform,performance-benchmarks,192,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684
https://github.com/CliMA/Oceananigans.jl/issues/3684:74,Testability,benchmark,benchmarks,74,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684
https://github.com/CliMA/Oceananigans.jl/issues/3684:204,Testability,benchmark,benchmarks,204,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684
https://github.com/CliMA/Oceananigans.jl/pull/3686:179,Integrability,depend,dependencies,179,"This PR implements an extension to Oceananigans with `convert_arguments` for Makie plots. For example:. ```julia; julia> using Oceananigans, GLMakie; Precompiling Oceananigans; 7 dependencies successfully precompiled in 18 seconds. 157 already precompiled.; [ Info: Precompiling GLMakie [e9467ef8-e4e7-5192-8a1a-b1aee30e663a]; [ Info: Precompiling OceananigansMakieExt [8b7e02c2-18e1-5ade-af7b-cfb5875075c8]; [ Info: Precompiling ChainRulesCoreExt [eae2faf6-b232-58cb-a410-7764fda2830c]. julia> grid = RectilinearGrid(size=(10, 10, 10), x=(0, 1), y=(0, 1), z=(0, 1)); 10×10×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.1; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.1. julia> c = CenterField(grid); 10×10×10 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 10×10×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 16×16×16 OffsetArray(::Array{Float64, 3}, -2:13, -2:13, -2:13) with eltype Float64 with indices -2:13×-2:13×-2:13; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, (x, y, z) -> rand()); 10×10×10 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 10×10×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 16×16×16 OffsetArray(::Array{Float64, 3}, -2:13, -2:13, -2:13) with eltype Float64 with indices -2:13×-2:13×-2:13; └── max=0.998531, min=0.000368158, mean=0.516368. julia> heatmap(view(c, :, 2, :)); ```. <img width=""597"" alt=""image"" src=""https://github.com/user-a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686
https://github.com/CliMA/Oceananigans.jl/issues/3687:870,Availability,ERROR,ERROR,870,"It's a bug:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat)); 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.333333; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Flat z. julia> ct = FieldTimeSeries{Center, Center, Center}(grid, (0, 1)); 3×3×1×2 FieldTimeSeries{InMemory} located at (Center, Center, Center) on CPU; ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── indices: (:, :, :); ├── time_indexing: Linear(); ├── backend: InMemory(); └── data: 9×9×1×2 OffsetArray(::Array{Float64, 4}, -2:6, -2:6, 1:1, 1:2) with eltype Float64 with indices -2:6×-2:6×1:1×1:2; └── max=0.0, min=0.0, mean=0.0. julia> view(ct[1], :, :, 1); ERROR: MethodError: no method matching topology(::Tuple{Colon, Colon, UnitRange{Int64}}). Closest candidates are:; topology(::Any, ::Any); @ Oceananigans ~/Projects/Oceananigans.jl/src/Grids/grid_utils.jl:59; topology(::Oceananigans.Fields.AbstractField, Any...); @ Oceananigans ~/Projects/Oceananigans.jl/src/Fields/abstract_field.jl:47; topology(::Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}) where {FT, TX, TY, TZ}; @ Oceananigans ~/Projects/Oceananigans.jl/src/Grids/grid_utils.jl:52. Stacktrace:; [1] topology; @ ~/Projects/Oceananigans.jl/src/Grids/grid_utils.jl:59 [inlined]; [2] FieldBoundaryConditions(grid::Tuple{Colon, Colon, UnitRange{Int64}}, location::Nothing, indices::Tuple{Colon, Colon, Colon}); @ Oceananigans.BoundaryConditions ~/Projects/Oceananigans.jl/src/BoundaryConditions/field_boundary_conditions.jl:135; [3] view(f::Field{…}, i::Function, j::Function, k::Int64); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:326; [4] top-level scope; @ REPL[13]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3687
https://github.com/CliMA/Oceananigans.jl/pull/3690:20,Energy Efficiency,adapt,adapting,20,"This PR removes the adapting of the immersed map from the immersed boundary grid by shuffling some definitions around and making sure that the active cells map is always passed as an argument instead of being embedded in the grid. This can possibly help with parameter space issues in complex kernels (see [ClimaOcean, Issue#116](https://github.com/CliMA/ClimaOcean.jl/issues/116#issuecomment-2273878888)). . This PR is still a draft because I would like to take the opportunity to add some docstring for the immersed map",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3690
https://github.com/CliMA/Oceananigans.jl/pull/3690:20,Modifiability,adapt,adapting,20,"This PR removes the adapting of the immersed map from the immersed boundary grid by shuffling some definitions around and making sure that the active cells map is always passed as an argument instead of being embedded in the grid. This can possibly help with parameter space issues in complex kernels (see [ClimaOcean, Issue#116](https://github.com/CliMA/ClimaOcean.jl/issues/116#issuecomment-2273878888)). . This PR is still a draft because I would like to take the opportunity to add some docstring for the immersed map",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3690
https://github.com/CliMA/Oceananigans.jl/pull/3696:121,Testability,test,test,121,PR #3668 Introduced ambiguity for `TracerAdvection` on `ImmersedBoundaryGrid`s; This PR removes the ambiguity and adds a test to make sure this method is tested,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3696
https://github.com/CliMA/Oceananigans.jl/pull/3696:154,Testability,test,tested,154,PR #3668 Introduced ambiguity for `TracerAdvection` on `ImmersedBoundaryGrid`s; This PR removes the ambiguity and adds a test to make sure this method is tested,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3696
https://github.com/CliMA/Oceananigans.jl/issues/3699:581,Availability,error,error,581,"This code:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; halo = (4, 4, 1),; x = (0, 2π),; y = (0, 2π),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). momentum_advection = VectorInvariant(vorticity_scheme = WENO(order=5),; vertical_scheme = Centered(),; divergence_scheme = WENO(order=5)); buoyancy = nothing; tracers = nothing; free_surface = ExplicitFreeSurface(gravitational_acceleration=10); model_args = (; momentum_advection, buoyancy, tracers, free_surface). model = HydrostaticFreeSurfaceModel(; grid, model_args...); ```. throws an error:. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: ArgumentError: The grid halo (4, 4, 1) must be at least equal to (4, 4, 4).; Note that an ImmersedBoundaryGrid requires an extra halo point in all; non-flat directions compared to a non-immersed boundary grid.; Stacktrace:; [1] validate_model_halo; @ ~/.julia/packages/Oceananigans/OMBY0/src/Models/Models.jl:55 [inlined]; ```. This seems like a bug to me, because a `Centered()` scheme in the vertical should only require one halo point.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3699
https://github.com/CliMA/Oceananigans.jl/issues/3699:644,Availability,ERROR,ERROR,644,"This code:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; halo = (4, 4, 1),; x = (0, 2π),; y = (0, 2π),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). momentum_advection = VectorInvariant(vorticity_scheme = WENO(order=5),; vertical_scheme = Centered(),; divergence_scheme = WENO(order=5)); buoyancy = nothing; tracers = nothing; free_surface = ExplicitFreeSurface(gravitational_acceleration=10); model_args = (; momentum_advection, buoyancy, tracers, free_surface). model = HydrostaticFreeSurfaceModel(; grid, model_args...); ```. throws an error:. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: ArgumentError: The grid halo (4, 4, 1) must be at least equal to (4, 4, 4).; Note that an ImmersedBoundaryGrid requires an extra halo point in all; non-flat directions compared to a non-immersed boundary grid.; Stacktrace:; [1] validate_model_halo; @ ~/.julia/packages/Oceananigans/OMBY0/src/Models/Models.jl:55 [inlined]; ```. This seems like a bug to me, because a `Centered()` scheme in the vertical should only require one halo point.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3699
https://github.com/CliMA/Oceananigans.jl/issues/3699:651,Performance,Load,LoadError,651,"This code:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; halo = (4, 4, 1),; x = (0, 2π),; y = (0, 2π),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). momentum_advection = VectorInvariant(vorticity_scheme = WENO(order=5),; vertical_scheme = Centered(),; divergence_scheme = WENO(order=5)); buoyancy = nothing; tracers = nothing; free_surface = ExplicitFreeSurface(gravitational_acceleration=10); model_args = (; momentum_advection, buoyancy, tracers, free_surface). model = HydrostaticFreeSurfaceModel(; grid, model_args...); ```. throws an error:. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: ArgumentError: The grid halo (4, 4, 1) must be at least equal to (4, 4, 4).; Note that an ImmersedBoundaryGrid requires an extra halo point in all; non-flat directions compared to a non-immersed boundary grid.; Stacktrace:; [1] validate_model_halo; @ ~/.julia/packages/Oceananigans/OMBY0/src/Models/Models.jl:55 [inlined]; ```. This seems like a bug to me, because a `Centered()` scheme in the vertical should only require one halo point.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3699
https://github.com/CliMA/Oceananigans.jl/issues/3701:380,Availability,ERROR,ERROR,380,"MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; x = (-5, 5),; y = (-5, 5),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). island(x, y) = (x^2 + y^2) < 1; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(island)). Δx = xspacings(grid, Center(), Center(), Center()); ```. produces. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: MethodError: no method matching xspacings(::ImmersedBoundaryGrid{…}, ::Center; with_halos::Bool). Closest candidates are:; xspacings(::Any, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; xspacings(::LatitudeLongitudeGrid{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Number, <:Number}, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:674; xspacings(::LatitudeLongitudeGrid, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:658; ... Stacktrace:; [1] xspacings(grid::ImmersedBoundaryGrid{…}, ℓx::Center, ℓy::Center, ℓz::Center); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; ```. This is probably also a problem for `yspacings` and `zspacings`, but I'm not sure. For `GridFittedBottom`, the spacings should just return spacings for the underlying grid (right now only `PartialCellBottom` immersed boundaries have different metrics than the underlying grid).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3701
https://github.com/CliMA/Oceananigans.jl/issues/3701:387,Performance,Load,LoadError,387,"MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; x = (-5, 5),; y = (-5, 5),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). island(x, y) = (x^2 + y^2) < 1; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(island)). Δx = xspacings(grid, Center(), Center(), Center()); ```. produces. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: MethodError: no method matching xspacings(::ImmersedBoundaryGrid{…}, ::Center; with_halos::Bool). Closest candidates are:; xspacings(::Any, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; xspacings(::LatitudeLongitudeGrid{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Number, <:Number}, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:674; xspacings(::LatitudeLongitudeGrid, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:658; ... Stacktrace:; [1] xspacings(grid::ImmersedBoundaryGrid{…}, ℓx::Center, ℓy::Center, ℓz::Center); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; ```. This is probably also a problem for `yspacings` and `zspacings`, but I'm not sure. For `GridFittedBottom`, the spacings should just return spacings for the underlying grid (right now only `PartialCellBottom` immersed boundaries have different metrics than the underlying grid).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3701
https://github.com/CliMA/Oceananigans.jl/issues/3703:216,Usability,clear,clear,216,"This is the current docstring:. ```julia; help?> WENOVectorInvariant; search: WENOVectorInvariant. WENOVectorInvariant(; upwinding = nothing,; multi_dimensional_stencil = false,; weno_kw...); ```. It doesn't make it clear how we would build the advection scheme that is the current default for the hydrostatic model in `ClimaOcean` (arguably the most important case). X-ref: https://github.com/CliMA/ClimaOcean.jl/issues/129",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3703
https://github.com/CliMA/Oceananigans.jl/issues/3708:496,Availability,down,downstream,496,"Contributors,. We are planning to re-license Oceananigans under the [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0), as required by the primary sponsors of the Climate Modeling Alliance, [Schmidt Sciences](https://www.schmidtsciences.org/). Practically speaking, [the two licenses are similarly permissive and open](https://soos.io/apache-vs-mit-license). However, the Apache license adds some additional protection for contributors (like yourselves) by, for example, requiring downstream applications that depend on Oceananigans to disclose major changes. Let us know if there are any concerns. Otherwise, we plan to make the change on August 19. The top 20 outside contributors are tagged here:. @ali-ramadhan ; @tomchor ; @francispoulin ; @hennyg888 ; @elise-palethorpe ; @whitleyv ; @suyashbire1 ; @jagoosw ; @vchuravy ; @xiaozhour ; @maeckha ; @iuryt ; @kburns ; @jbisits ; @maleadt ; @wsmoses ; @Moelf ; @RaphaelRR ; @simonbyrne ; @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3708
https://github.com/CliMA/Oceananigans.jl/issues/3708:525,Integrability,depend,depend,525,"Contributors,. We are planning to re-license Oceananigans under the [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0), as required by the primary sponsors of the Climate Modeling Alliance, [Schmidt Sciences](https://www.schmidtsciences.org/). Practically speaking, [the two licenses are similarly permissive and open](https://soos.io/apache-vs-mit-license). However, the Apache license adds some additional protection for contributors (like yourselves) by, for example, requiring downstream applications that depend on Oceananigans to disclose major changes. Let us know if there are any concerns. Otherwise, we plan to make the change on August 19. The top 20 outside contributors are tagged here:. @ali-ramadhan ; @tomchor ; @francispoulin ; @hennyg888 ; @elise-palethorpe ; @whitleyv ; @suyashbire1 ; @jagoosw ; @vchuravy ; @xiaozhour ; @maeckha ; @iuryt ; @kburns ; @jbisits ; @maleadt ; @wsmoses ; @Moelf ; @RaphaelRR ; @simonbyrne ; @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3708
https://github.com/CliMA/Oceananigans.jl/pull/3709:5,Deployability,release,release,5,this release includes PR #3695 that ensures backwards compatibility with versions 0.91.x and adds tests that were missing in #3695,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3709
https://github.com/CliMA/Oceananigans.jl/pull/3709:98,Testability,test,tests,98,this release includes PR #3695 that ensures backwards compatibility with versions 0.91.x and adds tests that were missing in #3695,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3709
https://github.com/CliMA/Oceananigans.jl/pull/3714:137,Deployability,update,update,137,"To asynchronously fill the halos of distributed fields, the code uses an incremental counter to track how many MPI requests are live and update the MPI send and receive tag. The counter is reset when communication is synchronized. As it is defined right now, the counter is always incremented at the end of a `fill_halo_regions!` on a distributed grid, irrespective of what happened in the `fill_halo_regions!`, with the assumption that all cores participate in the `fill_halo_regions!` so the counters are correctly synchronized. ; https://github.com/CliMA/Oceananigans.jl/blob/315e66bb330b44acc2a0daf74ae357ee66e801d1/src/DistributedComputations/halo_communication.jl#L117-L121. Unfortunately, I experienced a situation where this was not the case. ; In this case, I wanted to do different things on different cores, which is allowed when using the `only_local_halos = true` keyword argument (a very rare occurrence, but a possibility nonetheless). For example, if we execute this code on the main branch; ```julia; arch = Distributed(CPU()); grid = RectilinearGrid(size = (2, 2, 1), extent = (1, 1, 1)); c = Field(grid). if arch.local_rank == 0; fill_halo_regions!(c; only_local_halos = true); end; ```; The mpi_tag will be `1` on rank 0 and `0` on other ranks. This means that in subsequent halo passes, MPI will stall because it cannot match the tag between the send and receive operations of cores that communicate with rank 0. This PR fixes this issue by incrementing the counter _only_ if we have actually launched a mpi send or receive operation, that happens when at least one of the `bcs` is a distributed boundary condition _and_ `only_local_halos == false`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714
https://github.com/CliMA/Oceananigans.jl/pull/3714:217,Integrability,synchroniz,synchronized,217,"To asynchronously fill the halos of distributed fields, the code uses an incremental counter to track how many MPI requests are live and update the MPI send and receive tag. The counter is reset when communication is synchronized. As it is defined right now, the counter is always incremented at the end of a `fill_halo_regions!` on a distributed grid, irrespective of what happened in the `fill_halo_regions!`, with the assumption that all cores participate in the `fill_halo_regions!` so the counters are correctly synchronized. ; https://github.com/CliMA/Oceananigans.jl/blob/315e66bb330b44acc2a0daf74ae357ee66e801d1/src/DistributedComputations/halo_communication.jl#L117-L121. Unfortunately, I experienced a situation where this was not the case. ; In this case, I wanted to do different things on different cores, which is allowed when using the `only_local_halos = true` keyword argument (a very rare occurrence, but a possibility nonetheless). For example, if we execute this code on the main branch; ```julia; arch = Distributed(CPU()); grid = RectilinearGrid(size = (2, 2, 1), extent = (1, 1, 1)); c = Field(grid). if arch.local_rank == 0; fill_halo_regions!(c; only_local_halos = true); end; ```; The mpi_tag will be `1` on rank 0 and `0` on other ranks. This means that in subsequent halo passes, MPI will stall because it cannot match the tag between the send and receive operations of cores that communicate with rank 0. This PR fixes this issue by incrementing the counter _only_ if we have actually launched a mpi send or receive operation, that happens when at least one of the `bcs` is a distributed boundary condition _and_ `only_local_halos == false`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714
https://github.com/CliMA/Oceananigans.jl/pull/3714:517,Integrability,synchroniz,synchronized,517,"To asynchronously fill the halos of distributed fields, the code uses an incremental counter to track how many MPI requests are live and update the MPI send and receive tag. The counter is reset when communication is synchronized. As it is defined right now, the counter is always incremented at the end of a `fill_halo_regions!` on a distributed grid, irrespective of what happened in the `fill_halo_regions!`, with the assumption that all cores participate in the `fill_halo_regions!` so the counters are correctly synchronized. ; https://github.com/CliMA/Oceananigans.jl/blob/315e66bb330b44acc2a0daf74ae357ee66e801d1/src/DistributedComputations/halo_communication.jl#L117-L121. Unfortunately, I experienced a situation where this was not the case. ; In this case, I wanted to do different things on different cores, which is allowed when using the `only_local_halos = true` keyword argument (a very rare occurrence, but a possibility nonetheless). For example, if we execute this code on the main branch; ```julia; arch = Distributed(CPU()); grid = RectilinearGrid(size = (2, 2, 1), extent = (1, 1, 1)); c = Field(grid). if arch.local_rank == 0; fill_halo_regions!(c; only_local_halos = true); end; ```; The mpi_tag will be `1` on rank 0 and `0` on other ranks. This means that in subsequent halo passes, MPI will stall because it cannot match the tag between the send and receive operations of cores that communicate with rank 0. This PR fixes this issue by incrementing the counter _only_ if we have actually launched a mpi send or receive operation, that happens when at least one of the `bcs` is a distributed boundary condition _and_ `only_local_halos == false`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714
https://github.com/CliMA/Oceananigans.jl/pull/3717:132,Availability,error,errors,132,"This PR addresses issue https://github.com/CliMA/Oceananigans.jl/issues/3670, focusing on a problem likely caused by floating-point errors; https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L91; Similar to https://github.com/CliMA/Oceananigans.jl/blob/a18b81d4c8776987d3cf619521941ba85000a1cb/src/Utils/schedules.jl#L58-L63; Implementing actuation time helps prevent floating-point errors, ensuring the correct execution of statements in; `advance_time_average!` https://github.com/CliMA/Oceananigans.jl/blob/56dbae31bb54c1293e12b6ccc88f77976cc1103f/src/OutputWriters/windowed_time_average.jl#L271-L335. There is still an issue for post-checkpoint when checkpoint interval is _not_ an integer multiple of the `AveragedTimeInterval`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717
https://github.com/CliMA/Oceananigans.jl/pull/3717:462,Availability,error,errors,462,"This PR addresses issue https://github.com/CliMA/Oceananigans.jl/issues/3670, focusing on a problem likely caused by floating-point errors; https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L91; Similar to https://github.com/CliMA/Oceananigans.jl/blob/a18b81d4c8776987d3cf619521941ba85000a1cb/src/Utils/schedules.jl#L58-L63; Implementing actuation time helps prevent floating-point errors, ensuring the correct execution of statements in; `advance_time_average!` https://github.com/CliMA/Oceananigans.jl/blob/56dbae31bb54c1293e12b6ccc88f77976cc1103f/src/OutputWriters/windowed_time_average.jl#L271-L335. There is still an issue for post-checkpoint when checkpoint interval is _not_ an integer multiple of the `AveragedTimeInterval`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717
https://github.com/CliMA/Oceananigans.jl/pull/3717:717,Availability,checkpoint,checkpoint,717,"This PR addresses issue https://github.com/CliMA/Oceananigans.jl/issues/3670, focusing on a problem likely caused by floating-point errors; https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L91; Similar to https://github.com/CliMA/Oceananigans.jl/blob/a18b81d4c8776987d3cf619521941ba85000a1cb/src/Utils/schedules.jl#L58-L63; Implementing actuation time helps prevent floating-point errors, ensuring the correct execution of statements in; `advance_time_average!` https://github.com/CliMA/Oceananigans.jl/blob/56dbae31bb54c1293e12b6ccc88f77976cc1103f/src/OutputWriters/windowed_time_average.jl#L271-L335. There is still an issue for post-checkpoint when checkpoint interval is _not_ an integer multiple of the `AveragedTimeInterval`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717
https://github.com/CliMA/Oceananigans.jl/pull/3717:733,Availability,checkpoint,checkpoint,733,"This PR addresses issue https://github.com/CliMA/Oceananigans.jl/issues/3670, focusing on a problem likely caused by floating-point errors; https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L91; Similar to https://github.com/CliMA/Oceananigans.jl/blob/a18b81d4c8776987d3cf619521941ba85000a1cb/src/Utils/schedules.jl#L58-L63; Implementing actuation time helps prevent floating-point errors, ensuring the correct execution of statements in; `advance_time_average!` https://github.com/CliMA/Oceananigans.jl/blob/56dbae31bb54c1293e12b6ccc88f77976cc1103f/src/OutputWriters/windowed_time_average.jl#L271-L335. There is still an issue for post-checkpoint when checkpoint interval is _not_ an integer multiple of the `AveragedTimeInterval`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717
https://github.com/CliMA/Oceananigans.jl/pull/3717:383,Energy Efficiency,schedul,schedules,383,"This PR addresses issue https://github.com/CliMA/Oceananigans.jl/issues/3670, focusing on a problem likely caused by floating-point errors; https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L91; Similar to https://github.com/CliMA/Oceananigans.jl/blob/a18b81d4c8776987d3cf619521941ba85000a1cb/src/Utils/schedules.jl#L58-L63; Implementing actuation time helps prevent floating-point errors, ensuring the correct execution of statements in; `advance_time_average!` https://github.com/CliMA/Oceananigans.jl/blob/56dbae31bb54c1293e12b6ccc88f77976cc1103f/src/OutputWriters/windowed_time_average.jl#L271-L335. There is still an issue for post-checkpoint when checkpoint interval is _not_ an integer multiple of the `AveragedTimeInterval`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717
https://github.com/CliMA/Oceananigans.jl/pull/3722:0,Deployability,Patch,Patch,0,"Patch release including bug fix for biogeochemistry fallbacks (#3685), `mask_immersed_field!` method for `BinaryOperations` (#3683), restricting lat/lon grid topologies (#3694), and more Makie recipe components (#3715).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3722
https://github.com/CliMA/Oceananigans.jl/pull/3722:6,Deployability,release,release,6,"Patch release including bug fix for biogeochemistry fallbacks (#3685), `mask_immersed_field!` method for `BinaryOperations` (#3683), restricting lat/lon grid topologies (#3694), and more Makie recipe components (#3715).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3722
https://github.com/CliMA/Oceananigans.jl/pull/3723:90,Availability,error,errors,90,"`target_times` is not passed to the correct architecture before interpolation, leading to errors like [this one](https://buildkite.com/clima/climaocean-ci/builds/1251#0191774b-12c6-4f07-9b7f-35119ef4e639). This happens when `target_times` is a range, then `map` creates a vector which is not isbits.; This PR corrects this bug.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3723
https://github.com/CliMA/Oceananigans.jl/issues/3728:142,Availability,mask,mask,142,"MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10),; x = (0, 1),; z = (0, 1),; topology = (Periodic, Flat, Bounded)). mask = GaussianMask{:x}(center=1, width=0.1); sponge = Relaxation(rate=1; mask). model = HydrostaticFreeSurfaceModel(; grid, forcing = (; u=sponge)). simulation = Simulation(model; Δt=1, stop_iteration=1); run!(simulation); ```. The fix is a little involved because we can't distinguish between the arguments `(y, z)` and `(x, y)` by function arguments alone. Thus the mask itself needs to have grid information. This and other bug are the extended consequences of changing `node` to drop flat dimensions (#3355, with discussion on #3285). I still think the price was worth it for betting scripting, but it has come with a pretty significant trade-off in terms of under the hood code complexity...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3728
https://github.com/CliMA/Oceananigans.jl/issues/3728:216,Availability,mask,mask,216,"MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10),; x = (0, 1),; z = (0, 1),; topology = (Periodic, Flat, Bounded)). mask = GaussianMask{:x}(center=1, width=0.1); sponge = Relaxation(rate=1; mask). model = HydrostaticFreeSurfaceModel(; grid, forcing = (; u=sponge)). simulation = Simulation(model; Δt=1, stop_iteration=1); run!(simulation); ```. The fix is a little involved because we can't distinguish between the arguments `(y, z)` and `(x, y)` by function arguments alone. Thus the mask itself needs to have grid information. This and other bug are the extended consequences of changing `node` to drop flat dimensions (#3355, with discussion on #3285). I still think the price was worth it for betting scripting, but it has come with a pretty significant trade-off in terms of under the hood code complexity...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3728
https://github.com/CliMA/Oceananigans.jl/issues/3728:511,Availability,mask,mask,511,"MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10),; x = (0, 1),; z = (0, 1),; topology = (Periodic, Flat, Bounded)). mask = GaussianMask{:x}(center=1, width=0.1); sponge = Relaxation(rate=1; mask). model = HydrostaticFreeSurfaceModel(; grid, forcing = (; u=sponge)). simulation = Simulation(model; Δt=1, stop_iteration=1); run!(simulation); ```. The fix is a little involved because we can't distinguish between the arguments `(y, z)` and `(x, y)` by function arguments alone. Thus the mask itself needs to have grid information. This and other bug are the extended consequences of changing `node` to drop flat dimensions (#3355, with discussion on #3285). I still think the price was worth it for betting scripting, but it has come with a pretty significant trade-off in terms of under the hood code complexity...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3728
https://github.com/CliMA/Oceananigans.jl/issues/3728:582,Modifiability,extend,extended,582,"MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10),; x = (0, 1),; z = (0, 1),; topology = (Periodic, Flat, Bounded)). mask = GaussianMask{:x}(center=1, width=0.1); sponge = Relaxation(rate=1; mask). model = HydrostaticFreeSurfaceModel(; grid, forcing = (; u=sponge)). simulation = Simulation(model; Δt=1, stop_iteration=1); run!(simulation); ```. The fix is a little involved because we can't distinguish between the arguments `(y, z)` and `(x, y)` by function arguments alone. Thus the mask itself needs to have grid information. This and other bug are the extended consequences of changing `node` to drop flat dimensions (#3355, with discussion on #3285). I still think the price was worth it for betting scripting, but it has come with a pretty significant trade-off in terms of under the hood code complexity...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3728
https://github.com/CliMA/Oceananigans.jl/pull/3729:13,Availability,mask,masking,13,Captures the masking of immersed cells for visualization in #3725. We can use this in https://github.com/CliMA/ClimaOcean.jl/pull/156,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3729
https://github.com/CliMA/Oceananigans.jl/issues/3731:259,Availability,error,error,259,Seems that there is a bug here?. https://github.com/CliMA/Oceananigans.jl/blob/5218acd72d146f063838286e7bf61c2d26165fbf/src/OutputReaders/field_time_series_indexing.jl#L205. `target_times` is never defined but used as an arg in the kernel?. This produces the error in the ClimaOcean CI; see https://buildkite.com/clima/climaocean-ci/builds/1264#01918d21-30e8-4d9c-9ee8-a220eb16eb28/202-514. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3731
https://github.com/CliMA/Oceananigans.jl/issues/3735:328,Availability,error,error,328,"I noticed a file called `rigid_lid.jl` exists (https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/rigid_lid.jl) so I was curious whether `HydrostaticFreeSurfaceModel` can run with a free surface, presumably by passing `free_surface = nothing`. It does error (see MWE below) but with a couple of extra function definitions (see far below) it seems to time step. Are these fixes enough for a working rigid lid? If not, does it make sense to remove the `rigid_lid.jl` file?. Note: The documentation also mentions a rigid lid here: https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator. ---. Minimal working example to reproduce the error:. ```julia; using Oceananigans. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. Error:. ```; ERROR: MethodError: no method matching materialize_free_surface(::Nothing, ::@NamedTuple{…}, ::LatitudeLongitudeGrid{…}). Closest candidates are:; materialize_free_surface(::ExplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl:32; materialize_free_surface(::SplitExplicitFreeSurface, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735
https://github.com/CliMA/Oceananigans.jl/issues/3735:779,Availability,error,error,779,"I noticed a file called `rigid_lid.jl` exists (https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/rigid_lid.jl) so I was curious whether `HydrostaticFreeSurfaceModel` can run with a free surface, presumably by passing `free_surface = nothing`. It does error (see MWE below) but with a couple of extra function definitions (see far below) it seems to time step. Are these fixes enough for a working rigid lid? If not, does it make sense to remove the `rigid_lid.jl` file?. Note: The documentation also mentions a rigid lid here: https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator. ---. Minimal working example to reproduce the error:. ```julia; using Oceananigans. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. Error:. ```; ERROR: MethodError: no method matching materialize_free_surface(::Nothing, ::@NamedTuple{…}, ::LatitudeLongitudeGrid{…}). Closest candidates are:; materialize_free_surface(::ExplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl:32; materialize_free_surface(::SplitExplicitFreeSurface, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735
https://github.com/CliMA/Oceananigans.jl/issues/3735:1006,Availability,Error,Error,1006," a file called `rigid_lid.jl` exists (https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/rigid_lid.jl) so I was curious whether `HydrostaticFreeSurfaceModel` can run with a free surface, presumably by passing `free_surface = nothing`. It does error (see MWE below) but with a couple of extra function definitions (see far below) it seems to time step. Are these fixes enough for a working rigid lid? If not, does it make sense to remove the `rigid_lid.jl` file?. Note: The documentation also mentions a rigid lid here: https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator. ---. Minimal working example to reproduce the error:. ```julia; using Oceananigans. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. Error:. ```; ERROR: MethodError: no method matching materialize_free_surface(::Nothing, ::@NamedTuple{…}, ::LatitudeLongitudeGrid{…}). Closest candidates are:; materialize_free_surface(::ExplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl:32; materialize_free_surface(::SplitExplicitFreeSurface, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@NamedTup",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735
https://github.com/CliMA/Oceananigans.jl/issues/3735:1019,Availability,ERROR,ERROR,1019,"nanigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/rigid_lid.jl) so I was curious whether `HydrostaticFreeSurfaceModel` can run with a free surface, presumably by passing `free_surface = nothing`. It does error (see MWE below) but with a couple of extra function definitions (see far below) it seems to time step. Are these fixes enough for a working rigid lid? If not, does it make sense to remove the `rigid_lid.jl` file?. Note: The documentation also mentions a rigid lid here: https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator. ---. Minimal working example to reproduce the error:. ```julia; using Oceananigans. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. Error:. ```; ERROR: MethodError: no method matching materialize_free_surface(::Nothing, ::@NamedTuple{…}, ::LatitudeLongitudeGrid{…}). Closest candidates are:; materialize_free_surface(::ExplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl:32; materialize_free_surface(::SplitExplicitFreeSurface, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@NamedTuple{}, closure::Nothing, boundary_conditions::@NamedTuple{}, particle",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735
https://github.com/CliMA/Oceananigans.jl/issues/3735:3245,Deployability,release,release,3245,"s/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@NamedTuple{}, closure::Nothing, boundary_conditions::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::@NamedTuple{}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:177; [2] top-level scope; @ REPL[3]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. ---. ""Fixes"":. ```julia; using Oceananigans. import Oceananigans.Models.HydrostaticFreeSurfaceModels: materialize_free_surface, compute_free_surface_tendency!. materialize_free_surface(free_surface::Nothing, velocities, grid) = nothing. compute_free_surface_tendency!(grid, model::HydrostaticFreeSurfaceModel{<:Any, <:Any, <:Any, Nothing}, kernel_parameters) = nothing. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. ---. Environment: Oceananigans.jl v0.91.11 and. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735
https://github.com/CliMA/Oceananigans.jl/issues/3736:148,Availability,error,error,148,"I know `MultipleForcings` is not exported and not tested so it's experimental. It seems like a useful feature so I tried using it but I ran into an error. Seems to be related to forcing function call arguments (or maybe incorrect regularization?) but I haven't been able to figure out the exact cause. Minimal working example:. ```julia; using Oceananigans. using Oceananigans.Forcings: MultipleForcings. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)). weird_forcing(λ, φ, z, t) = λ * φ + z; wonky_forcing(λ, φ, z, t) = z / (λ - φ). forcing1 = Forcing(weird_forcing); forcing2 = Forcing(wonky_forcing). forcing = (; u=MultipleForcings((forcing1, forcing2))). model = HydrostaticFreeSurfaceModel(; grid, forcing); ```. produces this error:. ```; ERROR: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::LatitudeLongitudeGrid{…}, ::@NamedTuple{…}, ::Nothing, ::Nothing). Closest candidates are:; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:8; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:4; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{Any}); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:1; ... Stacktrace:; [1] user_function_arguments; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:21 [inlined]; [2] ContinuousForcing; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/continuous_forcing.jl:137 [inlined]; [3] MultipleForcings; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/multiple_forcings.jl:32 [inlined]; [4] hydrostatic_free_surface_u_velocity_tendency; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tenden",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736
https://github.com/CliMA/Oceananigans.jl/issues/3736:779,Availability,error,error,779,"I know `MultipleForcings` is not exported and not tested so it's experimental. It seems like a useful feature so I tried using it but I ran into an error. Seems to be related to forcing function call arguments (or maybe incorrect regularization?) but I haven't been able to figure out the exact cause. Minimal working example:. ```julia; using Oceananigans. using Oceananigans.Forcings: MultipleForcings. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)). weird_forcing(λ, φ, z, t) = λ * φ + z; wonky_forcing(λ, φ, z, t) = z / (λ - φ). forcing1 = Forcing(weird_forcing); forcing2 = Forcing(wonky_forcing). forcing = (; u=MultipleForcings((forcing1, forcing2))). model = HydrostaticFreeSurfaceModel(; grid, forcing); ```. produces this error:. ```; ERROR: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::LatitudeLongitudeGrid{…}, ::@NamedTuple{…}, ::Nothing, ::Nothing). Closest candidates are:; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:8; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:4; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{Any}); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:1; ... Stacktrace:; [1] user_function_arguments; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:21 [inlined]; [2] ContinuousForcing; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/continuous_forcing.jl:137 [inlined]; [3] MultipleForcings; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/multiple_forcings.jl:32 [inlined]; [4] hydrostatic_free_surface_u_velocity_tendency; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tenden",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736
https://github.com/CliMA/Oceananigans.jl/issues/3736:792,Availability,ERROR,ERROR,792,"I know `MultipleForcings` is not exported and not tested so it's experimental. It seems like a useful feature so I tried using it but I ran into an error. Seems to be related to forcing function call arguments (or maybe incorrect regularization?) but I haven't been able to figure out the exact cause. Minimal working example:. ```julia; using Oceananigans. using Oceananigans.Forcings: MultipleForcings. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)). weird_forcing(λ, φ, z, t) = λ * φ + z; wonky_forcing(λ, φ, z, t) = z / (λ - φ). forcing1 = Forcing(weird_forcing); forcing2 = Forcing(wonky_forcing). forcing = (; u=MultipleForcings((forcing1, forcing2))). model = HydrostaticFreeSurfaceModel(; grid, forcing); ```. produces this error:. ```; ERROR: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::LatitudeLongitudeGrid{…}, ::@NamedTuple{…}, ::Nothing, ::Nothing). Closest candidates are:; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:8; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:4; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{Any}); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:1; ... Stacktrace:; [1] user_function_arguments; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:21 [inlined]; [2] ContinuousForcing; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/continuous_forcing.jl:137 [inlined]; [3] MultipleForcings; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/multiple_forcings.jl:32 [inlined]; [4] hydrostatic_free_surface_u_velocity_tendency; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tenden",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736
https://github.com/CliMA/Oceananigans.jl/issues/3736:1624,Deployability,Continuous,ContinuousForcing,1624," Forcing(wonky_forcing). forcing = (; u=MultipleForcings((forcing1, forcing2))). model = HydrostaticFreeSurfaceModel(; grid, forcing); ```. produces this error:. ```; ERROR: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::LatitudeLongitudeGrid{…}, ::@NamedTuple{…}, ::Nothing, ::Nothing). Closest candidates are:; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:8; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:4; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{Any}); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:1; ... Stacktrace:; [1] user_function_arguments; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:21 [inlined]; [2] ContinuousForcing; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/continuous_forcing.jl:137 [inlined]; [3] MultipleForcings; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/multiple_forcings.jl:32 [inlined]; [4] hydrostatic_free_surface_u_velocity_tendency; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl:46 [inlined]; [5] cpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/3B1v2/src/macros.jl:291 [inlined]; [6] cpu_compute_hydrostatic_free_surface_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{…}, Gu::Field{…}, grid::LatitudeLongitudeGrid{…}, map::Nothing, args::Tuple{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ./none:0; [7] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ Ker",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736
https://github.com/CliMA/Oceananigans.jl/issues/3736:7052,Deployability,release,release,7052,"LatitudeLongitudeGrid{…}, callbacks::Vector{…}; compute_tendencies::Bool); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:50; [22] update_state!; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:31 [inlined]; [23] update_state!; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:28 [inlined]; [24] update_state!(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:28; [25] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{…}, tracers::Nothing, forcing::@NamedTuple{…}, closure::Nothing, boundary_conditions::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::@NamedTuple{}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:204; [26] top-level scope; @ REPL[30]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. ---. Environment: Oceananigans.jl v0.91.11 and. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736
https://github.com/CliMA/Oceananigans.jl/issues/3736:50,Testability,test,tested,50,"I know `MultipleForcings` is not exported and not tested so it's experimental. It seems like a useful feature so I tried using it but I ran into an error. Seems to be related to forcing function call arguments (or maybe incorrect regularization?) but I haven't been able to figure out the exact cause. Minimal working example:. ```julia; using Oceananigans. using Oceananigans.Forcings: MultipleForcings. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)). weird_forcing(λ, φ, z, t) = λ * φ + z; wonky_forcing(λ, φ, z, t) = z / (λ - φ). forcing1 = Forcing(weird_forcing); forcing2 = Forcing(wonky_forcing). forcing = (; u=MultipleForcings((forcing1, forcing2))). model = HydrostaticFreeSurfaceModel(; grid, forcing); ```. produces this error:. ```; ERROR: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::LatitudeLongitudeGrid{…}, ::@NamedTuple{…}, ::Nothing, ::Nothing). Closest candidates are:; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:8; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:4; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{Any}); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:1; ... Stacktrace:; [1] user_function_arguments; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:21 [inlined]; [2] ContinuousForcing; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/continuous_forcing.jl:137 [inlined]; [3] MultipleForcings; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/multiple_forcings.jl:32 [inlined]; [4] hydrostatic_free_surface_u_velocity_tendency; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tenden",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736
https://github.com/CliMA/Oceananigans.jl/pull/3737:130,Testability,test,test,130,"This PR just implements the proposed solution in issue #3679 so that the CFL calculation is correct on flat grids. I also added a test that fails without the fix, and passes with the fix. Resolves #3679",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3737
https://github.com/CliMA/Oceananigans.jl/issues/3738:1502,Availability,error,error,1502," the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} += \Delta t^{n+1} (1.5 G^{n+1} - 0.5 G^{n}); ```; we remain with a spurious $G^n (1.5\Delta t^{n} - 0.5 \Delta t^{n-1}) - G^n$. . Given [this](https://homepages.m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738
https://github.com/CliMA/Oceananigans.jl/issues/3738:365,Energy Efficiency,reduce,reduce,365,"The Adams-Bashforth time stepper relies on an approximate time-integral to calculate the tendencies. ; This time integral, when using a constant time step, is simply approximated as; ```math; G^{n+1} = \left(\frac{3}{2} + \chi \right) G^n - \left( \frac{1}{2} +\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have adde",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738
https://github.com/CliMA/Oceananigans.jl/issues/3738:1610,Integrability,depend,dependent,1610,"se $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} += \Delta t^{n+1} (1.5 G^{n+1} - 0.5 G^{n}); ```; we remain with a spurious $G^n (1.5\Delta t^{n} - 0.5 \Delta t^{n-1}) - G^n$. . Given [this](https://homepages.math.uic.edu/~jan/mcs471/variablestep.pdf) reference, the correct formualtion might be; ```math; G^{n+1} = \frac{1}{2} \left( \left( 2 + \frac{\Delta ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738
https://github.com/CliMA/Oceananigans.jl/issues/3738:531,Modifiability,variab,variable,531,"The Adams-Bashforth time stepper relies on an approximate time-integral to calculate the tendencies. ; This time integral, when using a constant time step, is simply approximated as; ```math; G^{n+1} = \left(\frac{3}{2} + \chi \right) G^n - \left( \frac{1}{2} +\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have adde",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738
https://github.com/CliMA/Oceananigans.jl/issues/3738:1200,Modifiability,variab,variable,1200,"\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738
https://github.com/CliMA/Oceananigans.jl/issues/3738:1257,Modifiability,variab,variable,1257,"\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738
https://github.com/CliMA/Oceananigans.jl/issues/3738:2119,Modifiability,variab,variable,2119,"tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} += \Delta t^{n+1} (1.5 G^{n+1} - 0.5 G^{n}); ```; we remain with a spurious $G^n (1.5\Delta t^{n} - 0.5 \Delta t^{n-1}) - G^n$. . Given [this](https://homepages.math.uic.edu/~jan/mcs471/variablestep.pdf) reference, the correct formualtion might be; ```math; G^{n+1} = \frac{1}{2} \left( \left( 2 + \frac{\Delta t^n}{\Delta t^{n - 1}} \right) G^n - \frac{\Delta t^n}{\Delta t^{n - 1}} G^{n-1} \right); ```; However, also in this form, successive tendencies do not cancel out.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738
https://github.com/CliMA/Oceananigans.jl/issues/3738:2484,Modifiability,variab,variablestep,2484,"tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} += \Delta t^{n+1} (1.5 G^{n+1} - 0.5 G^{n}); ```; we remain with a spurious $G^n (1.5\Delta t^{n} - 0.5 \Delta t^{n-1}) - G^n$. . Given [this](https://homepages.math.uic.edu/~jan/mcs471/variablestep.pdf) reference, the correct formualtion might be; ```math; G^{n+1} = \frac{1}{2} \left( \left( 2 + \frac{\Delta t^n}{\Delta t^{n - 1}} \right) G^n - \frac{\Delta t^n}{\Delta t^{n - 1}} G^{n-1} \right); ```; However, also in this form, successive tendencies do not cancel out.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738
https://github.com/CliMA/Oceananigans.jl/issues/3738:159,Usability,simpl,simply,159,"The Adams-Bashforth time stepper relies on an approximate time-integral to calculate the tendencies. ; This time integral, when using a constant time step, is simply approximated as; ```math; G^{n+1} = \left(\frac{3}{2} + \chi \right) G^n - \left( \frac{1}{2} +\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have adde",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738
https://github.com/CliMA/Oceananigans.jl/pull/3741:35,Deployability,update,updated,35,"At the moment, the tendencies were updated at each call of `update_state!`. This PR makes it so that the tendencies are computed only inside the time-stepping where we need them. see [ClimaOcean#164](https://github.com/CliMA/ClimaOcean.jl/issues/164)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3741
https://github.com/CliMA/Oceananigans.jl/issues/3742:76,Availability,ERROR,ERROR,76,"I hit these issues when setting a field on an immersed boundary grid.; ```; ERROR: LoadError: MethodError: no method matching ξname(::ImmersedBoundaryGrid{Float64, Periodic, RightConnected, Bounded, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{OrthogonalSphericalShellGrids.Zipper, Int64}, Nothing, Nothing, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Flux, Nothing}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CUDA.CuArray{Tuple{UInt16, UInt16, UInt16}, 1, CUDA.DeviceMemory}, CUDA.CuArray{Tuple{UInt16, UInt16}, 1, CUDA.DeviceMemory}, GPU}). Closest candidates are:; ξname(!Matched::LatitudeLongitudeGrid); @ Oceananigans ~/.julia/packages/Oceananigans/O8Ult/src/Grids/latitude_longitude_grid.jl:574; ξname(!Match",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742
https://github.com/CliMA/Oceananigans.jl/issues/3742:83,Performance,Load,LoadError,83,"I hit these issues when setting a field on an immersed boundary grid.; ```; ERROR: LoadError: MethodError: no method matching ξname(::ImmersedBoundaryGrid{Float64, Periodic, RightConnected, Bounded, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{OrthogonalSphericalShellGrids.Zipper, Int64}, Nothing, Nothing, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Flux, Nothing}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CUDA.CuArray{Tuple{UInt16, UInt16, UInt16}, 1, CUDA.DeviceMemory}, CUDA.CuArray{Tuple{UInt16, UInt16}, 1, CUDA.DeviceMemory}, GPU}). Closest candidates are:; ξname(!Matched::LatitudeLongitudeGrid); @ Oceananigans ~/.julia/packages/Oceananigans/O8Ult/src/Grids/latitude_longitude_grid.jl:574; ξname(!Match",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742
https://github.com/CliMA/Oceananigans.jl/pull/3744:278,Deployability,update,update,278,The meridional velocity had the wrong sign in the vector rotation operator for switching from extrinsic to intrinsic coordinates in an `OrthogonalSphericalShellGrid`.; The test was also poorly designed (my bad) and conspired to hide the bug. This PR should fix the rotation and update the test to make sure everything is correct.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3744
https://github.com/CliMA/Oceananigans.jl/pull/3744:172,Testability,test,test,172,The meridional velocity had the wrong sign in the vector rotation operator for switching from extrinsic to intrinsic coordinates in an `OrthogonalSphericalShellGrid`.; The test was also poorly designed (my bad) and conspired to hide the bug. This PR should fix the rotation and update the test to make sure everything is correct.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3744
https://github.com/CliMA/Oceananigans.jl/pull/3744:289,Testability,test,test,289,The meridional velocity had the wrong sign in the vector rotation operator for switching from extrinsic to intrinsic coordinates in an `OrthogonalSphericalShellGrid`.; The test was also poorly designed (my bad) and conspired to hide the bug. This PR should fix the rotation and update the test to make sure everything is correct.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3744
https://github.com/CliMA/Oceananigans.jl/issues/3745:416,Availability,ERROR,ERROR,416,"For example. ```julia; using Oceananigans; using OrthogonalSphericalShellGrids; using Oceananigans.Fields: interpolate!. trg = TripolarGrid(size = (10, 10, 10), z = (0, 1)); llg = LatitudeLongitudeGrid(size = (10, 10, 10), latitude = (-75, 75), longitude = (0, 360), z = (0, 1)). ctrg = CenterField(trg); cllg = CenterField(llg). interpolate!(cllg, ctrg); ```. fails with. ```julia; julia> interpolate!(cllg, ctrg); ERROR: MethodError: no method matching fractional_x_index(::Float64, ::Tuple{…}, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}). Closest candidates are:; fractional_x_index(::Any, ::Any, ::ImmersedBoundaryGrid); @ Oceananigans ~/.julia/packages/Oceananigans/A6YUV/src/ImmersedBoundaries/ImmersedBoundaries.jl:283; fractional_x_index(::Any, ::Any, ::Oceananigans.Grids.XRegularLLG); @ Oceananigans ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:74; fractional_x_index(::Any, ::Any, ::LatitudeLongitudeGrid); @ Oceananigans ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:89; ... Stacktrace:; [1] _fractional_indices; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:165 [inlined]; [2] fractional_indices; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:154 [inlined]; [3] interpolate; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:240 [inlined]; [4] macro expansion; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:337 [inlined]; [5] cpu__interpolate!; @ ~/.julia/packages/KernelAbstractions/3B1v2/src/macros.jl:291 [inlined]; [6] cpu__interpolate!(__ctx__::KernelAbstractions.CompilerMetadata{…}, to_field::Field{…}, to_grid::LatitudeLongitudeGrid{…}, to_location::Tuple{…}, from_field::Field{…}, from_grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}, from_location::Tuple{…}); @ Oceananigans.Fields ./none:0; [7] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3745
https://github.com/CliMA/Oceananigans.jl/issues/3747:259,Availability,error,error,259,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747
https://github.com/CliMA/Oceananigans.jl/issues/3747:386,Availability,down,down,386,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747
https://github.com/CliMA/Oceananigans.jl/issues/3747:84,Safety,safe,safely,84,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747
https://github.com/CliMA/Oceananigans.jl/issues/3747:201,Security,access,accesses,201,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747
https://github.com/CliMA/Oceananigans.jl/issues/3747:226,Security,access,accesses,226,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747
https://github.com/CliMA/Oceananigans.jl/issues/3747:126,Testability,test,tests,126,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747
https://github.com/CliMA/Oceananigans.jl/issues/3747:343,Testability,test,tests,343,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747
https://github.com/CliMA/Oceananigans.jl/issues/3748:491,Availability,Error,Error,491,"Right now it seems like output writer file names cannot be 4 characters or shorter (if specified without an extension). MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 2, 3)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""abcd"",; schedule = IterationInterval(1),; overwrite_existing = true; ); ```. Error:. ```; ERROR: BoundsError: attempt to access 4-codeunit String at index [0:4]; Stacktrace:; [1] checkbounds; @ ./strings/basic.jl:216 [inlined]; [2] getindex; @ ./strings/string.jl:468 [inlined]; [3] auto_extension(filename::String, ext::String); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/output_writer_utils.jl:219; [4] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/jld2_output_writer.jl:179; [5] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Also happens with `""a""`, `""ab""`, `""abc""`, but not `""abcde""`. Also an issue with `NetCDFOutputWriter` since it also uses `auto_extension`. I think an easy fix is to use built-in Julia functions instead of manual indexing:. ```diff; """"""; auto_extension(filename, ext); ; If `filename` ends in `ext`, return `filename`. Otherwise return `filename * ext`.; """"""; function auto_extension(filename, ext); - Next = length(ext); - filename[end-Next+1:end] == ext || (filename *= ext); - return filename; + if endswith(filen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748
https://github.com/CliMA/Oceananigans.jl/issues/3748:504,Availability,ERROR,ERROR,504,"Right now it seems like output writer file names cannot be 4 characters or shorter (if specified without an extension). MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 2, 3)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""abcd"",; schedule = IterationInterval(1),; overwrite_existing = true; ); ```. Error:. ```; ERROR: BoundsError: attempt to access 4-codeunit String at index [0:4]; Stacktrace:; [1] checkbounds; @ ./strings/basic.jl:216 [inlined]; [2] getindex; @ ./strings/string.jl:468 [inlined]; [3] auto_extension(filename::String, ext::String); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/output_writer_utils.jl:219; [4] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/jld2_output_writer.jl:179; [5] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Also happens with `""a""`, `""ab""`, `""abc""`, but not `""abcde""`. Also an issue with `NetCDFOutputWriter` since it also uses `auto_extension`. I think an easy fix is to use built-in Julia functions instead of manual indexing:. ```diff; """"""; auto_extension(filename, ext); ; If `filename` ends in `ext`, return `filename`. Otherwise return `filename * ext`.; """"""; function auto_extension(filename, ext); - Next = length(ext); - filename[end-Next+1:end] == ext || (filename *= ext); - return filename; + if endswith(filen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748
https://github.com/CliMA/Oceananigans.jl/issues/3748:422,Energy Efficiency,schedul,schedule,422,"Right now it seems like output writer file names cannot be 4 characters or shorter (if specified without an extension). MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 2, 3)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""abcd"",; schedule = IterationInterval(1),; overwrite_existing = true; ); ```. Error:. ```; ERROR: BoundsError: attempt to access 4-codeunit String at index [0:4]; Stacktrace:; [1] checkbounds; @ ./strings/basic.jl:216 [inlined]; [2] getindex; @ ./strings/string.jl:468 [inlined]; [3] auto_extension(filename::String, ext::String); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/output_writer_utils.jl:219; [4] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/jld2_output_writer.jl:179; [5] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Also happens with `""a""`, `""ab""`, `""abc""`, but not `""abcde""`. Also an issue with `NetCDFOutputWriter` since it also uses `auto_extension`. I think an easy fix is to use built-in Julia functions instead of manual indexing:. ```diff; """"""; auto_extension(filename, ext); ; If `filename` ends in `ext`, return `filename`. Otherwise return `filename * ext`.; """"""; function auto_extension(filename, ext); - Next = length(ext); - filename[end-Next+1:end] == ext || (filename *= ext); - return filename; + if endswith(filen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748
https://github.com/CliMA/Oceananigans.jl/issues/3748:959,Energy Efficiency,schedul,schedule,959,"Right now it seems like output writer file names cannot be 4 characters or shorter (if specified without an extension). MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 2, 3)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""abcd"",; schedule = IterationInterval(1),; overwrite_existing = true; ); ```. Error:. ```; ERROR: BoundsError: attempt to access 4-codeunit String at index [0:4]; Stacktrace:; [1] checkbounds; @ ./strings/basic.jl:216 [inlined]; [2] getindex; @ ./strings/string.jl:468 [inlined]; [3] auto_extension(filename::String, ext::String); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/output_writer_utils.jl:219; [4] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/jld2_output_writer.jl:179; [5] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Also happens with `""a""`, `""ab""`, `""abc""`, but not `""abcde""`. Also an issue with `NetCDFOutputWriter` since it also uses `auto_extension`. I think an easy fix is to use built-in Julia functions instead of manual indexing:. ```diff; """"""; auto_extension(filename, ext); ; If `filename` ends in `ext`, return `filename`. Otherwise return `filename * ext`.; """"""; function auto_extension(filename, ext); - Next = length(ext); - filename[end-Next+1:end] == ext || (filename *= ext); - return filename; + if endswith(filen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748
https://github.com/CliMA/Oceananigans.jl/issues/3748:535,Security,access,access,535,"Right now it seems like output writer file names cannot be 4 characters or shorter (if specified without an extension). MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 2, 3)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""abcd"",; schedule = IterationInterval(1),; overwrite_existing = true; ); ```. Error:. ```; ERROR: BoundsError: attempt to access 4-codeunit String at index [0:4]; Stacktrace:; [1] checkbounds; @ ./strings/basic.jl:216 [inlined]; [2] getindex; @ ./strings/string.jl:468 [inlined]; [3] auto_extension(filename::String, ext::String); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/output_writer_utils.jl:219; [4] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/jld2_output_writer.jl:179; [5] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Also happens with `""a""`, `""ab""`, `""abc""`, but not `""abcde""`. Also an issue with `NetCDFOutputWriter` since it also uses `auto_extension`. I think an easy fix is to use built-in Julia functions instead of manual indexing:. ```diff; """"""; auto_extension(filename, ext); ; If `filename` ends in `ext`, return `filename`. Otherwise return `filename * ext`.; """"""; function auto_extension(filename, ext); - Next = length(ext); - filename[end-Next+1:end] == ext || (filename *= ext); - return filename; + if endswith(filen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748
https://github.com/CliMA/Oceananigans.jl/issues/3750:270,Availability,mask,masking,270,"This also makes `data_summary` and `Base.show` very slow since showing a `FieldTimeSeries` prints its min, mean, and max. So it's harder to work with `FieldTimeSeries` interactively. Seems fine when not on a `ImmersedBoundaryGrid`. I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... A quick quality-of-life fix could be to not call `data_summary` when showing a `FieldTimeSeries`. ## MWE. ```julia; using Oceananigans. arch = CPU(). L = 1; H = 1. underlying_grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (512, 512, 64),; latitude = (-L/2, L/2),; longitude = (-L/2, L/2),; z = (-H, 0),; halo = (4, 4, 4); ). h = L/2; w = L/5 ; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). model = HydrostaticFreeSurfaceModel(; grid). simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""test.jld2"",; schedule = IterationInterval(1),; overwrite_existing = true; ). run!(simulation). u = FieldTimeSeries(""test.jld2"", ""u""); u2 = u[2]; ```. Reduction over the `FieldTimeSeries`:. ```julia; julia> @time minimum(u2); 20.954897 seconds (118.72 M allocations: 130.792 GiB, 25.74% gc time); 0.0; ```. Reduction over the underlying data:. ```julia; julia> @time minimum(u2.data); 0.011304 seconds (3 allocations: 1.562 KiB); 0.0; ```. or almost 2000x faster. ## Environment. Oceananigans.jl `main` branch with. ```; Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interacti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750
https://github.com/CliMA/Oceananigans.jl/issues/3750:1793,Deployability,release,release,1793,"Base.show` very slow since showing a `FieldTimeSeries` prints its min, mean, and max. So it's harder to work with `FieldTimeSeries` interactively. Seems fine when not on a `ImmersedBoundaryGrid`. I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... A quick quality-of-life fix could be to not call `data_summary` when showing a `FieldTimeSeries`. ## MWE. ```julia; using Oceananigans. arch = CPU(). L = 1; H = 1. underlying_grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (512, 512, 64),; latitude = (-L/2, L/2),; longitude = (-L/2, L/2),; z = (-H, 0),; halo = (4, 4, 4); ). h = L/2; w = L/5 ; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). model = HydrostaticFreeSurfaceModel(; grid). simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""test.jld2"",; schedule = IterationInterval(1),; overwrite_existing = true; ). run!(simulation). u = FieldTimeSeries(""test.jld2"", ""u""); u2 = u[2]; ```. Reduction over the `FieldTimeSeries`:. ```julia; julia> @time minimum(u2); 20.954897 seconds (118.72 M allocations: 130.792 GiB, 25.74% gc time); 0.0; ```. Reduction over the underlying data:. ```julia; julia> @time minimum(u2.data); 0.011304 seconds (3 allocations: 1.562 KiB); 0.0; ```. or almost 2000x faster. ## Environment. Oceananigans.jl `main` branch with. ```; Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750
https://github.com/CliMA/Oceananigans.jl/issues/3750:1176,Energy Efficiency,schedul,schedule,1176,"Base.show` very slow since showing a `FieldTimeSeries` prints its min, mean, and max. So it's harder to work with `FieldTimeSeries` interactively. Seems fine when not on a `ImmersedBoundaryGrid`. I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... A quick quality-of-life fix could be to not call `data_summary` when showing a `FieldTimeSeries`. ## MWE. ```julia; using Oceananigans. arch = CPU(). L = 1; H = 1. underlying_grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (512, 512, 64),; latitude = (-L/2, L/2),; longitude = (-L/2, L/2),; z = (-H, 0),; halo = (4, 4, 4); ). h = L/2; w = L/5 ; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). model = HydrostaticFreeSurfaceModel(; grid). simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""test.jld2"",; schedule = IterationInterval(1),; overwrite_existing = true; ). run!(simulation). u = FieldTimeSeries(""test.jld2"", ""u""); u2 = u[2]; ```. Reduction over the `FieldTimeSeries`:. ```julia; julia> @time minimum(u2); 20.954897 seconds (118.72 M allocations: 130.792 GiB, 25.74% gc time); 0.0; ```. Reduction over the underlying data:. ```julia; julia> @time minimum(u2.data); 0.011304 seconds (3 allocations: 1.562 KiB); 0.0; ```. or almost 2000x faster. ## Environment. Oceananigans.jl `main` branch with. ```; Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750
https://github.com/CliMA/Oceananigans.jl/issues/3750:1163,Testability,test,test,1163,"Base.show` very slow since showing a `FieldTimeSeries` prints its min, mean, and max. So it's harder to work with `FieldTimeSeries` interactively. Seems fine when not on a `ImmersedBoundaryGrid`. I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... A quick quality-of-life fix could be to not call `data_summary` when showing a `FieldTimeSeries`. ## MWE. ```julia; using Oceananigans. arch = CPU(). L = 1; H = 1. underlying_grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (512, 512, 64),; latitude = (-L/2, L/2),; longitude = (-L/2, L/2),; z = (-H, 0),; halo = (4, 4, 4); ). h = L/2; w = L/5 ; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). model = HydrostaticFreeSurfaceModel(; grid). simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""test.jld2"",; schedule = IterationInterval(1),; overwrite_existing = true; ). run!(simulation). u = FieldTimeSeries(""test.jld2"", ""u""); u2 = u[2]; ```. Reduction over the `FieldTimeSeries`:. ```julia; julia> @time minimum(u2); 20.954897 seconds (118.72 M allocations: 130.792 GiB, 25.74% gc time); 0.0; ```. Reduction over the underlying data:. ```julia; julia> @time minimum(u2.data); 0.011304 seconds (3 allocations: 1.562 KiB); 0.0; ```. or almost 2000x faster. ## Environment. Oceananigans.jl `main` branch with. ```; Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750
https://github.com/CliMA/Oceananigans.jl/issues/3750:1279,Testability,test,test,1279,"Base.show` very slow since showing a `FieldTimeSeries` prints its min, mean, and max. So it's harder to work with `FieldTimeSeries` interactively. Seems fine when not on a `ImmersedBoundaryGrid`. I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... A quick quality-of-life fix could be to not call `data_summary` when showing a `FieldTimeSeries`. ## MWE. ```julia; using Oceananigans. arch = CPU(). L = 1; H = 1. underlying_grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (512, 512, 64),; latitude = (-L/2, L/2),; longitude = (-L/2, L/2),; z = (-H, 0),; halo = (4, 4, 4); ). h = L/2; w = L/5 ; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). model = HydrostaticFreeSurfaceModel(; grid). simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""test.jld2"",; schedule = IterationInterval(1),; overwrite_existing = true; ). run!(simulation). u = FieldTimeSeries(""test.jld2"", ""u""); u2 = u[2]; ```. Reduction over the `FieldTimeSeries`:. ```julia; julia> @time minimum(u2); 20.954897 seconds (118.72 M allocations: 130.792 GiB, 25.74% gc time); 0.0; ```. Reduction over the underlying data:. ```julia; julia> @time minimum(u2.data); 0.011304 seconds (3 allocations: 1.562 KiB); 0.0; ```. or almost 2000x faster. ## Environment. Oceananigans.jl `main` branch with. ```; Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750
https://github.com/CliMA/Oceananigans.jl/issues/3751:62,Testability,test,test,62,"Maybe this has already been extensively discussed but the GPU test suites on Buildkite fail often, requiring manual intervention to restart them for each PR. The obvious solution is a bigger machine for testing, but I have two suggestions that are much easier to implement:; 1. Updating Buildkite. Newer versions may be more stable. The latest version is 3.79 but Sverdrup is on v3.24.0 (almost 4 years old) and Tartarus is on v3.50.4.; 2. If builds are failing due to too much resource competition, reducing the number of Buildkite agents on Sverdrup may help. Right now there are 16. I wonder if GPU builds will be more stable with 8-12. Some builds may be slower but if no one has to restart a test suite then that would make for a better developer experience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751
https://github.com/CliMA/Oceananigans.jl/issues/3751:203,Testability,test,testing,203,"Maybe this has already been extensively discussed but the GPU test suites on Buildkite fail often, requiring manual intervention to restart them for each PR. The obvious solution is a bigger machine for testing, but I have two suggestions that are much easier to implement:; 1. Updating Buildkite. Newer versions may be more stable. The latest version is 3.79 but Sverdrup is on v3.24.0 (almost 4 years old) and Tartarus is on v3.50.4.; 2. If builds are failing due to too much resource competition, reducing the number of Buildkite agents on Sverdrup may help. Right now there are 16. I wonder if GPU builds will be more stable with 8-12. Some builds may be slower but if no one has to restart a test suite then that would make for a better developer experience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751
https://github.com/CliMA/Oceananigans.jl/issues/3751:697,Testability,test,test,697,"Maybe this has already been extensively discussed but the GPU test suites on Buildkite fail often, requiring manual intervention to restart them for each PR. The obvious solution is a bigger machine for testing, but I have two suggestions that are much easier to implement:; 1. Updating Buildkite. Newer versions may be more stable. The latest version is 3.79 but Sverdrup is on v3.24.0 (almost 4 years old) and Tartarus is on v3.50.4.; 2. If builds are failing due to too much resource competition, reducing the number of Buildkite agents on Sverdrup may help. Right now there are 16. I wonder if GPU builds will be more stable with 8-12. Some builds may be slower but if no one has to restart a test suite then that would make for a better developer experience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751
https://github.com/CliMA/Oceananigans.jl/issues/3752:392,Availability,ERROR,ERROR,392,"There are a couple of issues with reductions on a fts.; Given the following field time series; ```julia; grid = RectilinearGrid(size = (1, 1, 1), extent = (1, 1, 1)); fts = FieldTimeSeries{Center, Center, Center}(grid, 1:10; backend = OnDisk(), path = ""./test.jld2"", name = ""T""); f = CenterField(grid). for i in 1:10; set!(f, i); set!(fts, f, i); end; ```. ```julia; julia> sum(f; dims = 1); ERROR: UndefVarError: `filltype` not defined; Stacktrace:; [1] sum(f::Function, fts::FieldTimeSeries{…}; dims::Int64, kw::@Kwargs{}); @ Oceananigans.OutputReaders ~/development/Oceananigans.jl/src/OutputReaders/field_time_series_reductions.jl:30; [2] sum(fts::FieldTimeSeries{…}; kw::@Kwargs{…}); @ Oceananigans.OutputReaders ~/development/Oceananigans.jl/src/OutputReaders/field_time_series_reductions.jl:38; [3] top-level scope; @ REPL[19]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; Also, I think that the index for the reduction here is wrong, `i` instead of `n`; https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/OutputReaders/field_time_series_reductions.jl#L42-L45",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3752
https://github.com/CliMA/Oceananigans.jl/issues/3752:255,Testability,test,test,255,"There are a couple of issues with reductions on a fts.; Given the following field time series; ```julia; grid = RectilinearGrid(size = (1, 1, 1), extent = (1, 1, 1)); fts = FieldTimeSeries{Center, Center, Center}(grid, 1:10; backend = OnDisk(), path = ""./test.jld2"", name = ""T""); f = CenterField(grid). for i in 1:10; set!(f, i); set!(fts, f, i); end; ```. ```julia; julia> sum(f; dims = 1); ERROR: UndefVarError: `filltype` not defined; Stacktrace:; [1] sum(f::Function, fts::FieldTimeSeries{…}; dims::Int64, kw::@Kwargs{}); @ Oceananigans.OutputReaders ~/development/Oceananigans.jl/src/OutputReaders/field_time_series_reductions.jl:30; [2] sum(fts::FieldTimeSeries{…}; kw::@Kwargs{…}); @ Oceananigans.OutputReaders ~/development/Oceananigans.jl/src/OutputReaders/field_time_series_reductions.jl:38; [3] top-level scope; @ REPL[19]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; Also, I think that the index for the reduction here is wrong, `i` instead of `n`; https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/OutputReaders/field_time_series_reductions.jl#L42-L45",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3752
https://github.com/CliMA/Oceananigans.jl/pull/3753:29,Availability,error,error,29,"Came across a rather cryptic error message that had me puzzled, so I've added this new error message to make sure it doesn't happen to other people.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753
https://github.com/CliMA/Oceananigans.jl/pull/3753:87,Availability,error,error,87,"Came across a rather cryptic error message that had me puzzled, so I've added this new error message to make sure it doesn't happen to other people.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753
https://github.com/CliMA/Oceananigans.jl/pull/3753:35,Integrability,message,message,35,"Came across a rather cryptic error message that had me puzzled, so I've added this new error message to make sure it doesn't happen to other people.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753
https://github.com/CliMA/Oceananigans.jl/pull/3753:93,Integrability,message,message,93,"Came across a rather cryptic error message that had me puzzled, so I've added this new error message to make sure it doesn't happen to other people.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753
https://github.com/CliMA/Oceananigans.jl/pull/3756:155,Testability,test,test,155,required to force the model with a field time series.; This PR adds `update_model_field_time_series!` to the `update_state!` for single column grids and a test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3756
https://github.com/CliMA/Oceananigans.jl/issues/3761:217,Availability,error,error,217,"I realize that https://github.com/CliMA/Oceananigans.jl/issues/3609 exists, but I think this is a different issue. The following MWE, which tries to advect `LagrangianParticle`s over an `ImmersedGrid` fails with this error:. ```; ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{…}, ::StructArrays.StructVector{…}, ::Float64, ::ImmersedBoundaryGrid{…}, ::Int64, ::@NamedTuple{…}). Closest candidates are:; cpu__advect_particles!(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractUnderlyingGrid, ::Any, ::Any); @ Oceananigans none:0. Stacktrace:; [1] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:144; [2] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:111; [3] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:46; [4] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}); ```. This is the MWE:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)); GFB = GridFittedBottom((x, y) -> -1/2); grid = ImmersedBoundaryGrid(grid_base, GFB). n_particles = 3; x₀ = rand(n_particles); y₀ = rand(n_particles); z₀ = .-rand(n_particles). lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀). model = NonhydrostaticModel(; grid, particles=lagrangian_particles); time_step!(model, 1); ```. I'm a bit confused, because, while the function `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3761
https://github.com/CliMA/Oceananigans.jl/issues/3761:230,Availability,ERROR,ERROR,230,"I realize that https://github.com/CliMA/Oceananigans.jl/issues/3609 exists, but I think this is a different issue. The following MWE, which tries to advect `LagrangianParticle`s over an `ImmersedGrid` fails with this error:. ```; ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{…}, ::StructArrays.StructVector{…}, ::Float64, ::ImmersedBoundaryGrid{…}, ::Int64, ::@NamedTuple{…}). Closest candidates are:; cpu__advect_particles!(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractUnderlyingGrid, ::Any, ::Any); @ Oceananigans none:0. Stacktrace:; [1] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:144; [2] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:111; [3] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:46; [4] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}); ```. This is the MWE:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)); GFB = GridFittedBottom((x, y) -> -1/2); grid = ImmersedBoundaryGrid(grid_base, GFB). n_particles = 3; x₀ = rand(n_particles); y₀ = rand(n_particles); z₀ = .-rand(n_particles). lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀). model = NonhydrostaticModel(; grid, particles=lagrangian_particles); time_step!(model, 1); ```. I'm a bit confused, because, while the function `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3761
https://github.com/CliMA/Oceananigans.jl/issues/3761:237,Performance,Load,LoadError,237,"I realize that https://github.com/CliMA/Oceananigans.jl/issues/3609 exists, but I think this is a different issue. The following MWE, which tries to advect `LagrangianParticle`s over an `ImmersedGrid` fails with this error:. ```; ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{…}, ::StructArrays.StructVector{…}, ::Float64, ::ImmersedBoundaryGrid{…}, ::Int64, ::@NamedTuple{…}). Closest candidates are:; cpu__advect_particles!(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractUnderlyingGrid, ::Any, ::Any); @ Oceananigans none:0. Stacktrace:; [1] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:144; [2] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:111; [3] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:46; [4] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}); ```. This is the MWE:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)); GFB = GridFittedBottom((x, y) -> -1/2); grid = ImmersedBoundaryGrid(grid_base, GFB). n_particles = 3; x₀ = rand(n_particles); y₀ = rand(n_particles); z₀ = .-rand(n_particles). lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀). model = NonhydrostaticModel(; grid, particles=lagrangian_particles); time_step!(model, 1); ```. I'm a bit confused, because, while the function `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3761
https://github.com/CliMA/Oceananigans.jl/issues/3762:188,Testability,test,testing,188,"The fix we recently had to put in to get CATKE's parameters up-to-date with [Wagner et al 2024](https://glwagner.github.io/assets/pdf/CATKE.pdf) show that we should probably be regression-testing CATKE results, especially if we are going to make related/surrounding improvements to `TKEDissipationVerticalDiffusivity`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3762
https://github.com/CliMA/Oceananigans.jl/pull/3764:179,Testability,test,tested,179,"This pull request changes the compat entry for the `CubedSphere` package from `0.1, 0.2` to `0.1, 0.2, 0.3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3764
https://github.com/CliMA/Oceananigans.jl/pull/3764:285,Testability,test,tests,285,"This pull request changes the compat entry for the `CubedSphere` package from `0.1, 0.2` to `0.1, 0.2, 0.3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3764
https://github.com/CliMA/Oceananigans.jl/pull/3769:162,Testability,test,tested,162,"This pull request changes the compat entry for the `JLD2` package from `0.4` to `0.4, 0.5`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3769
https://github.com/CliMA/Oceananigans.jl/pull/3769:268,Testability,test,tests,268,"This pull request changes the compat entry for the `JLD2` package from `0.4` to `0.4, 0.5`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3769
https://github.com/CliMA/Oceananigans.jl/issues/3770:274,Availability,error,error,274,"I feel like this impacts usability, especially interactive use, but it's not a bug in the sense that your simulation scripts are fine. Is it worth trying to fix this?. Maybe not. After all, executing `model.velocities.u.data` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/Offs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3770:676,Availability,error,error,676,"I feel like this impacts usability, especially interactive use, but it's not a bug in the sense that your simulation scripts are fine. Is it worth trying to fix this?. Maybe not. After all, executing `model.velocities.u.data` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/Offs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3770:825,Availability,Error,Error,825,"I feel like this impacts usability, especially interactive use, but it's not a bug in the sense that your simulation scripts are fine. Is it worth trying to fix this?. Maybe not. After all, executing `model.velocities.u.data` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/Offs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3770:983,Availability,ERROR,ERROR,983,"I feel like this impacts usability, especially interactive use, but it's not a bug in the sense that your simulation scripts are fine. Is it worth trying to fix this?. Maybe not. After all, executing `model.velocities.u.data` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/Offs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3770:1445,Availability,error,error,1445," a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3770:1472,Availability,error,error,1472,"er without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.TTY}, X::AbstractVecOrMat,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3770:1489,Availability,error,errorscalar,1489,"``julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.TTY}, X::AbstractVecOrMat, rows::Vector{Int64}, cols::Vec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3770:1271,Safety,avoid,avoided,1271,"ta` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3770:1749,Testability,assert,assertscalar,1749," 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.TTY}, X::AbstractVecOrMat, rows::Vector{Int64}, cols::Vector{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64, ncols::Int64); @ Base ./arrayshow.jl:68; [11] _print_matrix(io::IOContext{Base.TTY}, X::AbstractVecOrMat, pre::String, sep::String, post::String, hdots::String, vdots::String, ddots::Strin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3770:25,Usability,usab,usability,25,"I feel like this impacts usability, especially interactive use, but it's not a bug in the sense that your simulation scripts are fine. Is it worth trying to fix this?. Maybe not. After all, executing `model.velocities.u.data` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/Offs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770
https://github.com/CliMA/Oceananigans.jl/issues/3771:892,Availability,Error,Error,892,"Seems to be defined for x, y, z nodes but not λ and φ nodes. Probably just an easy case of defining a couple of extra functions. MWE:. ```julia; using Oceananigans. underlying_grid = RectilinearGrid(size=(12, 12, 12), extent=(1, 1, 1)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). xnodes(grid, Center(), Center(), Center()) # Works :); ynodes(grid, Center(), Center(), Center()) # Works :); znodes(grid, Center(), Center(), Center()) # Works :). underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). λnodes(grid, Center(), Center(), Center()) # Doesn't work :(; φnodes(grid, Center(), Center(), Center()) # Doesn't work :(; znodes(grid, Center(), Center(), Center()) # Works :); ```. Error:. ```; ERROR: MethodError: no method matching λnodes(::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, ::Center, ::Center, ::Center). Closest candidates are:; λnodes(::OrthogonalSphericalShellGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/orthogonal_spherical_shell_grid.jl:1154; λnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:652; λnodes(::Oceananigans.Grids.AbstractCurvilinearGrid, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:129; ... Stacktrace:; [1] top-level scope; @ REPL[18]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3771
https://github.com/CliMA/Oceananigans.jl/issues/3771:905,Availability,ERROR,ERROR,905,"Seems to be defined for x, y, z nodes but not λ and φ nodes. Probably just an easy case of defining a couple of extra functions. MWE:. ```julia; using Oceananigans. underlying_grid = RectilinearGrid(size=(12, 12, 12), extent=(1, 1, 1)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). xnodes(grid, Center(), Center(), Center()) # Works :); ynodes(grid, Center(), Center(), Center()) # Works :); znodes(grid, Center(), Center(), Center()) # Works :). underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). λnodes(grid, Center(), Center(), Center()) # Doesn't work :(; φnodes(grid, Center(), Center(), Center()) # Doesn't work :(; znodes(grid, Center(), Center(), Center()) # Works :); ```. Error:. ```; ERROR: MethodError: no method matching λnodes(::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, ::Center, ::Center, ::Center). Closest candidates are:; λnodes(::OrthogonalSphericalShellGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/orthogonal_spherical_shell_grid.jl:1154; λnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:652; λnodes(::Oceananigans.Grids.AbstractCurvilinearGrid, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:129; ... Stacktrace:; [1] top-level scope; @ REPL[18]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3771
https://github.com/CliMA/Oceananigans.jl/issues/3772:963,Availability,Error,Error,963,"Based on. https://github.com/CliMA/Oceananigans.jl/blob/2e4ba6b36bf012d5dcb89ddc7160a10f774aadbe/src/TurbulenceClosures/turbulence_closure_diagnostics.jl#L67-L69. CATKE should also have an infinite cell diffusion timescale with the default implicit time discretization. When CATKE is run with explicit time discretization I suppose the cell diffusion timescale should be computed from the maximum viscosity/diffusivity in `model.diffusivity_fields`. Happy to add these `cell_diffusion_timescale` methods. I know `CATKEVerticalDiffusivity` is not exported so I'm just opening the issue to document. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=(12, 12, 12), extent=(1, 1, 1)); closure = CATKEVerticalDiffusivity(); buoyancy = SeawaterBuoyancy(); tracers = (:T, :S, :e). model = HydrostaticFreeSurfaceModel(; grid, closure, buoyancy, tracers). DiffusiveCFL(1.23)(model); ```. Error:. ```; ERROR: MethodError: no method matching cell_diffusion_timescale(::CATKEVerticalDiffusivity{…}, ::@NamedTuple{…}, ::RectilinearGrid{…}). Closest candidates are:; cell_diffusion_timescale(::Nothing, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:22; cell_diffusion_timescale(::ScalarBiharmonicDiffusivity{Dir}, ::Any, ::Any) where Dir; @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:40; cell_diffusion_timescale(::SmagorinskyLilly, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:47; ... Stacktrace:; [1] cell_diffusion_timescale(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:21; [2] (::CFL{…})(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.Diagnostics ~/atdepth/Oceananigans.jl/src/Diagnostics/cfl.jl:25; [3] top-level scope",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3772
https://github.com/CliMA/Oceananigans.jl/issues/3772:976,Availability,ERROR,ERROR,976,"anigans.jl/blob/2e4ba6b36bf012d5dcb89ddc7160a10f774aadbe/src/TurbulenceClosures/turbulence_closure_diagnostics.jl#L67-L69. CATKE should also have an infinite cell diffusion timescale with the default implicit time discretization. When CATKE is run with explicit time discretization I suppose the cell diffusion timescale should be computed from the maximum viscosity/diffusivity in `model.diffusivity_fields`. Happy to add these `cell_diffusion_timescale` methods. I know `CATKEVerticalDiffusivity` is not exported so I'm just opening the issue to document. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=(12, 12, 12), extent=(1, 1, 1)); closure = CATKEVerticalDiffusivity(); buoyancy = SeawaterBuoyancy(); tracers = (:T, :S, :e). model = HydrostaticFreeSurfaceModel(; grid, closure, buoyancy, tracers). DiffusiveCFL(1.23)(model); ```. Error:. ```; ERROR: MethodError: no method matching cell_diffusion_timescale(::CATKEVerticalDiffusivity{…}, ::@NamedTuple{…}, ::RectilinearGrid{…}). Closest candidates are:; cell_diffusion_timescale(::Nothing, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:22; cell_diffusion_timescale(::ScalarBiharmonicDiffusivity{Dir}, ::Any, ::Any) where Dir; @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:40; cell_diffusion_timescale(::SmagorinskyLilly, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:47; ... Stacktrace:; [1] cell_diffusion_timescale(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:21; [2] (::CFL{…})(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.Diagnostics ~/atdepth/Oceananigans.jl/src/Diagnostics/cfl.jl:25; [3] top-level scope; @ REPL[24]:1; Some type information wa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3772
https://github.com/CliMA/Oceananigans.jl/issues/3773:499,Deployability,pipeline,pipelines,499,It's common for Buildkite jobs to fail intermittently and require a restart/retry. But so far it seems like we have to manually retry. Does every contributor have the permission to restart a Buildkite job?. Buildkite does support automatic retries. To improve the developer experience it's probably worth enabling automatic retries for jobs?. Happy to modify the Buildkite .yml to add retries!. Buildkite blog post: https://buildkite.com/blog/job-retries; Buildkite docs: https://buildkite.com/docs/pipelines/command-step#retry-attributes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3773
https://github.com/CliMA/Oceananigans.jl/issues/3774:147,Integrability,interface,interface,147,"I think it will be extremely helpful to be able to output boundary conditions and other fields (like fluxes, evaporation, and others) at the ocean interface. Following the discussion from #3081, something on those lines could be implemented, but it ideally it will be nice to have something like `model.boundary_conditions`. ```; using Oceananigans.BoundaryConditions: getbc; using Oceananigans: fields. # Boundary condition extractor in ""kernel function form""; @inline kernel_getbc(i, j, k, grid, boundary_condition, clock, fields) =; getbc(boundary_condition, i, j, grid, clock, fields). # Kernel arguments; grid = model.grid; clock = model.clock; model_fields = merge(fields(model), model.auxiliary_fields); u, v, w = model.velocities; u_bc = u.boundary_conditions.bottom; v_bc = v.boundary_conditions.bottom. # Build operations; u_bc_op = KernelFunctionOperation{Face, Center, Nothing}(kernel_getbc, grid, u_bc, clock, model_fields); v_bc_op = KernelFunctionOperation{Center, Face, Nothing}(kernel_getbc, grid, v_bc, clock, model_fields); ```. However it will be great to have something more general to simplify diagnosing simulations, that outputs the relevant boundary condition, in the example will be the `bottom` boundary.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3774
https://github.com/CliMA/Oceananigans.jl/issues/3774:1107,Usability,simpl,simplify,1107,"I think it will be extremely helpful to be able to output boundary conditions and other fields (like fluxes, evaporation, and others) at the ocean interface. Following the discussion from #3081, something on those lines could be implemented, but it ideally it will be nice to have something like `model.boundary_conditions`. ```; using Oceananigans.BoundaryConditions: getbc; using Oceananigans: fields. # Boundary condition extractor in ""kernel function form""; @inline kernel_getbc(i, j, k, grid, boundary_condition, clock, fields) =; getbc(boundary_condition, i, j, grid, clock, fields). # Kernel arguments; grid = model.grid; clock = model.clock; model_fields = merge(fields(model), model.auxiliary_fields); u, v, w = model.velocities; u_bc = u.boundary_conditions.bottom; v_bc = v.boundary_conditions.bottom. # Build operations; u_bc_op = KernelFunctionOperation{Face, Center, Nothing}(kernel_getbc, grid, u_bc, clock, model_fields); v_bc_op = KernelFunctionOperation{Center, Face, Nothing}(kernel_getbc, grid, v_bc, clock, model_fields); ```. However it will be great to have something more general to simplify diagnosing simulations, that outputs the relevant boundary condition, in the example will be the `bottom` boundary.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3774
https://github.com/CliMA/Oceananigans.jl/issues/3775:105,Availability,error,error,105,"Since it has to do with the `*nodes` functions this might be closely related to issue #3771 although the error is different so I'm opening a separate issue about it. I'll look into both together. MWE:. ```julia; using Oceananigans. underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid). NetCDFOutputWriter(model, model.velocities; filename=""test"", schedule=IterationInterval(1)); ```. Error:. ```; ERROR: MethodError: no method matching xnodes(::LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{…}, Float64, Float64, Float64, Float64, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, CPU}, ::Center; with_halos::Bool). Closest candidates are:; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:655; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:635; xnodes(::Any, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:79; ... Stacktrace:; [1] xnodes(ibg::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, loc::Center; kwargs::@Kwargs{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananig",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775
https://github.com/CliMA/Oceananigans.jl/issues/3775:585,Availability,Error,Error,585,"Since it has to do with the `*nodes` functions this might be closely related to issue #3771 although the error is different so I'm opening a separate issue about it. I'll look into both together. MWE:. ```julia; using Oceananigans. underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid). NetCDFOutputWriter(model, model.velocities; filename=""test"", schedule=IterationInterval(1)); ```. Error:. ```; ERROR: MethodError: no method matching xnodes(::LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{…}, Float64, Float64, Float64, Float64, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, CPU}, ::Center; with_halos::Bool). Closest candidates are:; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:655; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:635; xnodes(::Any, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:79; ... Stacktrace:; [1] xnodes(ibg::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, loc::Center; kwargs::@Kwargs{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananig",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775
https://github.com/CliMA/Oceananigans.jl/issues/3775:598,Availability,ERROR,ERROR,598,"Since it has to do with the `*nodes` functions this might be closely related to issue #3771 although the error is different so I'm opening a separate issue about it. I'll look into both together. MWE:. ```julia; using Oceananigans. underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid). NetCDFOutputWriter(model, model.velocities; filename=""test"", schedule=IterationInterval(1)); ```. Error:. ```; ERROR: MethodError: no method matching xnodes(::LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{…}, Float64, Float64, Float64, Float64, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, CPU}, ::Center; with_halos::Bool). Closest candidates are:; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:655; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:635; xnodes(::Any, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:79; ... Stacktrace:; [1] xnodes(ibg::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, loc::Center; kwargs::@Kwargs{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananig",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775
https://github.com/CliMA/Oceananigans.jl/issues/3775:548,Energy Efficiency,schedul,schedule,548,"Since it has to do with the `*nodes` functions this might be closely related to issue #3771 although the error is different so I'm opening a separate issue about it. I'll look into both together. MWE:. ```julia; using Oceananigans. underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid). NetCDFOutputWriter(model, model.velocities; filename=""test"", schedule=IterationInterval(1)); ```. Error:. ```; ERROR: MethodError: no method matching xnodes(::LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{…}, Float64, Float64, Float64, Float64, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, CPU}, ::Center; with_halos::Bool). Closest candidates are:; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:655; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:635; xnodes(::Any, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:79; ... Stacktrace:; [1] xnodes(ibg::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, loc::Center; kwargs::@Kwargs{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananig",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775
https://github.com/CliMA/Oceananigans.jl/issues/3775:2471,Energy Efficiency,schedul,schedule,2471,"args{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:55; [3] default_dimensions(output::Dict{String, Field{…} where {…}}, grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:126; [4] initialize_nc_file!(filepath::String, outputs::Dict{…}, schedule::IterationInterval, array_type::Type{…}, indices::Tuple{…}, with_halos::Bool, global_attributes::Dict{…}, output_attributes::Dict{…}, dimensions::Dict{…}, overwrite_existing::Bool, deflatelevel::Int64, grid::ImmersedBoundaryGrid{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:755; [5] NetCDFOutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, grid::ImmersedBoundaryGrid{…}, dir::String, array_type::Type, indices::Tuple{…}, with_halos::Bool, global_attributes::Dict{…}, output_attributes::Dict{…}, dimensions::Dict{…}, overwrite_existing::Nothing, deflatelevel::Int64, part::Int64, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, verbose::Bool); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:486; [6] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775
https://github.com/CliMA/Oceananigans.jl/issues/3775:2960,Energy Efficiency,schedul,schedule,2960,"args{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:55; [3] default_dimensions(output::Dict{String, Field{…} where {…}}, grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:126; [4] initialize_nc_file!(filepath::String, outputs::Dict{…}, schedule::IterationInterval, array_type::Type{…}, indices::Tuple{…}, with_halos::Bool, global_attributes::Dict{…}, output_attributes::Dict{…}, dimensions::Dict{…}, overwrite_existing::Bool, deflatelevel::Int64, grid::ImmersedBoundaryGrid{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:755; [5] NetCDFOutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, grid::ImmersedBoundaryGrid{…}, dir::String, array_type::Type, indices::Tuple{…}, with_halos::Bool, global_attributes::Dict{…}, output_attributes::Dict{…}, dimensions::Dict{…}, overwrite_existing::Nothing, deflatelevel::Int64, part::Int64, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, verbose::Bool); @ Oceananigans.OutputWriters ~/atdepth/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:486; [6] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775
https://github.com/CliMA/Oceananigans.jl/issues/3775:541,Testability,test,test,541,"Since it has to do with the `*nodes` functions this might be closely related to issue #3771 although the error is different so I'm opening a separate issue about it. I'll look into both together. MWE:. ```julia; using Oceananigans. underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid). NetCDFOutputWriter(model, model.velocities; filename=""test"", schedule=IterationInterval(1)); ```. Error:. ```; ERROR: MethodError: no method matching xnodes(::LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{…}, Float64, Float64, Float64, Float64, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, CPU}, ::Center; with_halos::Bool). Closest candidates are:; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:655; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:635; xnodes(::Any, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:79; ... Stacktrace:; [1] xnodes(ibg::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, loc::Center; kwargs::@Kwargs{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananig",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775
https://github.com/CliMA/Oceananigans.jl/pull/3776:38,Testability,test,tests,38,Resolves #3771. Not sure where to add tests for this though. Do we need a `test_immersed_grids.jl`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3776
https://github.com/CliMA/Oceananigans.jl/issues/3777:88,Availability,error,errors,88,"Recently, many of my simulations that run on clusters have crashed due to out-of-memory errors. I find that `NetCDFOutputWriter` seems to cause memory leak, which can by reproduced by the code below:. ```Julia; using Printf; using Oceananigans; using Oceananigans.OutputWriters: write_output!. const arch = CPU(). const Nx = 50; const Ny = 50; const Nz = 50. grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (0., 1.),; y = (0., 1.),; z = (0., 1.),; topology = (Bounded, Bounded, Bounded),; ). # Model; model = NonhydrostaticModel(;; grid = grid,; ). output_writer = NetCDFOutputWriter(; model,; model.velocities,; filename = ""output.nc"",; schedule = TimeInterval(1.0),; ). for i in 1:1000; write_output!(output_writer, model); # GC.gc(); @info i; @info Printf.@sprintf ""Max. RSS: %9.3f MiB\n"" Sys.maxrss()/2^20; end; ```. The total memory usage reported by `Sys.maxrss` keeps increasing over time, the rate which is roughly the output data size. Forcing `Gc.gc()` slows down the trend but cannot stop the increase. I believe it is a bug in `NCDatasets`. See Alexander-Barth/NCDatasets.jl#266. The version of `NCDatasets` is 0.14.5 in my case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777
https://github.com/CliMA/Oceananigans.jl/issues/3777:979,Availability,down,down,979,"Recently, many of my simulations that run on clusters have crashed due to out-of-memory errors. I find that `NetCDFOutputWriter` seems to cause memory leak, which can by reproduced by the code below:. ```Julia; using Printf; using Oceananigans; using Oceananigans.OutputWriters: write_output!. const arch = CPU(). const Nx = 50; const Ny = 50; const Nz = 50. grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (0., 1.),; y = (0., 1.),; z = (0., 1.),; topology = (Bounded, Bounded, Bounded),; ). # Model; model = NonhydrostaticModel(;; grid = grid,; ). output_writer = NetCDFOutputWriter(; model,; model.velocities,; filename = ""output.nc"",; schedule = TimeInterval(1.0),; ). for i in 1:1000; write_output!(output_writer, model); # GC.gc(); @info i; @info Printf.@sprintf ""Max. RSS: %9.3f MiB\n"" Sys.maxrss()/2^20; end; ```. The total memory usage reported by `Sys.maxrss` keeps increasing over time, the rate which is roughly the output data size. Forcing `Gc.gc()` slows down the trend but cannot stop the increase. I believe it is a bug in `NCDatasets`. See Alexander-Barth/NCDatasets.jl#266. The version of `NCDatasets` is 0.14.5 in my case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777
https://github.com/CliMA/Oceananigans.jl/issues/3777:648,Energy Efficiency,schedul,schedule,648,"Recently, many of my simulations that run on clusters have crashed due to out-of-memory errors. I find that `NetCDFOutputWriter` seems to cause memory leak, which can by reproduced by the code below:. ```Julia; using Printf; using Oceananigans; using Oceananigans.OutputWriters: write_output!. const arch = CPU(). const Nx = 50; const Ny = 50; const Nz = 50. grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (0., 1.),; y = (0., 1.),; z = (0., 1.),; topology = (Bounded, Bounded, Bounded),; ). # Model; model = NonhydrostaticModel(;; grid = grid,; ). output_writer = NetCDFOutputWriter(; model,; model.velocities,; filename = ""output.nc"",; schedule = TimeInterval(1.0),; ). for i in 1:1000; write_output!(output_writer, model); # GC.gc(); @info i; @info Printf.@sprintf ""Max. RSS: %9.3f MiB\n"" Sys.maxrss()/2^20; end; ```. The total memory usage reported by `Sys.maxrss` keeps increasing over time, the rate which is roughly the output data size. Forcing `Gc.gc()` slows down the trend but cannot stop the increase. I believe it is a bug in `NCDatasets`. See Alexander-Barth/NCDatasets.jl#266. The version of `NCDatasets` is 0.14.5 in my case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777
https://github.com/CliMA/Oceananigans.jl/issues/3779:433,Availability,error,error,433,For example:; https://buildkite.com/clima/oceananigans/builds/17468#0191fc2c-b421-4cf7-80b5-0429336b1d7f; https://buildkite.com/clima/oceananigans/builds/17473#0191fd88-d8b9-48d5-9c7f-18efc6747ea7; I believe this is because we are launching the docs from many different branches on a relatively small GPU. I think it would be best to move this test on the caltech cluster. Since the caltech cluster works with a slurm scheduler this error would never happen (I can open a PR to fix this),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779
https://github.com/CliMA/Oceananigans.jl/issues/3779:418,Energy Efficiency,schedul,scheduler,418,For example:; https://buildkite.com/clima/oceananigans/builds/17468#0191fc2c-b421-4cf7-80b5-0429336b1d7f; https://buildkite.com/clima/oceananigans/builds/17473#0191fd88-d8b9-48d5-9c7f-18efc6747ea7; I believe this is because we are launching the docs from many different branches on a relatively small GPU. I think it would be best to move this test on the caltech cluster. Since the caltech cluster works with a slurm scheduler this error would never happen (I can open a PR to fix this),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779
https://github.com/CliMA/Oceananigans.jl/issues/3779:344,Testability,test,test,344,For example:; https://buildkite.com/clima/oceananigans/builds/17468#0191fc2c-b421-4cf7-80b5-0429336b1d7f; https://buildkite.com/clima/oceananigans/builds/17473#0191fd88-d8b9-48d5-9c7f-18efc6747ea7; I believe this is because we are launching the docs from many different branches on a relatively small GPU. I think it would be best to move this test on the caltech cluster. Since the caltech cluster works with a slurm scheduler this error would never happen (I can open a PR to fix this),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779
https://github.com/CliMA/Oceananigans.jl/pull/3782:173,Testability,test,tested,173,"This pull request changes the compat entry for the `Enzyme` package from `0.12.20` to `0.12.20, 0.13`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3782
https://github.com/CliMA/Oceananigans.jl/pull/3782:279,Testability,test,tests,279,"This pull request changes the compat entry for the `Enzyme` package from `0.12.20` to `0.12.20, 0.13`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3782
https://github.com/CliMA/Oceananigans.jl/pull/3783:136,Performance,race condition,race condition,136,"I noticed that some issues with buildkite have to do with needing to re-resolve the Manifest, so this is yet another attempt to fix the race condition in our CI...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783
https://github.com/CliMA/Oceananigans.jl/issues/3785:39,Availability,error,error,39,"Not sure what the cause is. I get this error with or without a free surface model. The error goes away if I remove CATKE or if I switch to `Float64`. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Periodic, Bounded, Bounded),; size = (32, 32, 8),; longitude = (-180, 180),; latitude = (-80, 80),; z = (-5000, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = SeawaterBuoyancy(),; tracers = (:T, :S, :e),; closure = CATKEVerticalDiffusivity(); ); ```. Error:. ```; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785
https://github.com/CliMA/Oceananigans.jl/issues/3785:87,Availability,error,error,87,"Not sure what the cause is. I get this error with or without a free surface model. The error goes away if I remove CATKE or if I switch to `Float64`. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Periodic, Bounded, Bounded),; size = (32, 32, 8),; longitude = (-180, 180),; latitude = (-80, 80),; z = (-5000, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = SeawaterBuoyancy(),; tracers = (:T, :S, :e),; closure = CATKEVerticalDiffusivity(); ); ```. Error:. ```; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785
https://github.com/CliMA/Oceananigans.jl/issues/3785:580,Availability,Error,Error,580,"Not sure what the cause is. I get this error with or without a free surface model. The error goes away if I remove CATKE or if I switch to `Float64`. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Periodic, Bounded, Bounded),; size = (32, 32, 8),; longitude = (-180, 180),; latitude = (-80, 80),; z = (-5000, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = SeawaterBuoyancy(),; tracers = (:T, :S, :e),; closure = CATKEVerticalDiffusivity(); ); ```. Error:. ```; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785
https://github.com/CliMA/Oceananigans.jl/issues/3785:593,Availability,ERROR,ERROR,593,"Not sure what the cause is. I get this error with or without a free surface model. The error goes away if I remove CATKE or if I switch to `Float64`. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Periodic, Bounded, Bounded),; size = (32, 32, 8),; longitude = (-180, 180),; latitude = (-80, 80),; z = (-5000, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = SeawaterBuoyancy(),; tracers = (:T, :S, :e),; closure = CATKEVerticalDiffusivity(); ); ```. Error:. ```; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785
https://github.com/CliMA/Oceananigans.jl/issues/3785:605,Availability,error,error,605,"Not sure what the cause is. I get this error with or without a free surface model. The error goes away if I remove CATKE or if I switch to `Float64`. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Periodic, Bounded, Bounded),; size = (32, 32, 8),; longitude = (-180, 180),; latitude = (-80, 80),; z = (-5000, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = SeawaterBuoyancy(),; tracers = (:T, :S, :e),; closure = CATKEVerticalDiffusivity(); ); ```. Error:. ```; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785
https://github.com/CliMA/Oceananigans.jl/issues/3785:6429,Deployability,release,release,6429,"ransformation.jl:118 [inlined]; [25] macro expansion; @ ~/atdepth/Oceananigans.jl/src/Utils/multi_region_transformation.jl:206 [inlined]; [26] update_state!(model::HydrostaticFreeSurfaceModel{…}, grid::LatitudeLongitudeGrid{…}, callbacks::Vector{…}; compute_tendencies::Bool); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:43; [27] update_state!; @ ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:32 [inlined]; [28] update_state!; @ ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:29 [inlined]; [29] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::SeawaterBuoyancy{…}, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{…}, tracers::Tuple{…}, forcing::@NamedTuple{}, closure::CATKEVerticalDiffusivity{…}, boundary_conditions::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::@NamedTuple{}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:204; [30] top-level scope; @ REPL[4]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Environment:. Oceananigans main branch with. ```; julia> versioninfo(); Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); Environment:; LD_PRELOAD = /usr/NX/lib/libnxegl.so; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785
https://github.com/CliMA/Oceananigans.jl/issues/3785:1862,Performance,cache,cache,1862,"cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:262; [11] cached_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:151; [12] macro expansion; @ ~/.julia/packages/CUDA/z3j2H/src/compiler/execution.jl:380 [inlined]; [13] macro expansion; @ ./lock.jl:267 [inlined]; [14] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu__update_hydrostatic_pressure!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, LatitudeLongitudeGrid{…}, Buoyancy{…}, @NamedTuple{…}}}; kwargs::@Kwargs{always_inl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785
https://github.com/CliMA/Oceananigans.jl/issues/3785:2183,Performance,cache,cache,2183,"[inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:262; [11] cached_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:151; [12] macro expansion; @ ~/.julia/packages/CUDA/z3j2H/src/compiler/execution.jl:380 [inlined]; [13] macro expansion; @ ./lock.jl:267 [inlined]; [14] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu__update_hydrostatic_pressure!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, LatitudeLongitudeGrid{…}, Buoyancy{…}, @NamedTuple{…}}}; kwargs::@Kwargs{always_inline::Bool, maxthreads::Int64}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/execution.jl:375; [15] macro expansion; @ ~/.julia/packages/CUDA/z3j2H/src/compiler/execution.jl:112 [inlined]; [16] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785
https://github.com/CliMA/Oceananigans.jl/issues/3785:630,Security,access,access,630,"Not sure what the cause is. I get this error with or without a free surface model. The error goes away if I remove CATKE or if I switch to `Float64`. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Periodic, Bounded, Bounded),; size = (32, 32, 8),; longitude = (-180, 180),; latitude = (-80, 80),; z = (-5000, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = SeawaterBuoyancy(),; tracers = (:T, :S, :e),; closure = CATKEVerticalDiffusivity(); ); ```. Error:. ```; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785
https://github.com/CliMA/Oceananigans.jl/issues/3788:398,Availability,error,error,398,"Cause stuff like. ```julia; model = HydrostaticFreeSurfaceModel(; grid, coriolis, boundary_conditions = (; u_bcs)); ```. doesn't fail, it just doesn't actually apply boundary conditions to `u` (which was intended here). In the past we've allowed some fairly complex input. So maybe we can just pass a warning when keys of `boundary_conditions` are not prognostic fields. Even more neutral would be error if _none_ of the keys are prognostic fields (which would still catch the issue above but could miss some other annoying typos).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3788
https://github.com/CliMA/Oceananigans.jl/pull/3789:316,Integrability,interface,interfaced,316,"`IncompleteLU.jl` is unmaintained. I opened a PR a few months ago to add new features (https://github.com/haampie/IncompleteLU.jl/pull/26), but it was never merged. ; I have since included the content of `IncompleteLU.jl` along with my modifications in `KrylovPreconditioners.jl`. Together with @michel2323, we also interfaced **ILU(0)** and **IC(0)** preconditioners for NVIDIA/AMD GPUs, as well as a **block-Jacobi** preconditioner implemented with `KernelAbstractions.jl` for any GPU backend. Related PR: #3778",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3789
https://github.com/CliMA/Oceananigans.jl/issues/3791:204,Availability,mask,mask,204,"Here's an MWE:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size=(2, 2), x = (0, 4), z=(0, 4), topology = (Periodic, Flat, Bounded)); mask = CenterField(grid); mask[1, 1, 1] = 1; grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(mask)). c = CenterField(grid); w = ZFaceField(grid); set!(c, 1); set!(w, 1). @show maximum(c) maximum(w); ```. as might be expected this returns . ```julia; maximum(c) = 1.0; maximum(w) = 1.0; ```. but then writing. ```julia; mask_immersed_field!(c, NaN); mask_immersed_field!(w, NaN). @show maximum(c) maximum(w); ```. leads to. ```julia; maximum(c) = 1.0; maximum(w) = NaN; ```. The reason is because `mask_immersed_field` will touch nodes that `maximum` does not ignore. But we want consistency between the two for many reasons, including analysis. I believe @simone-silvestri's suggestion is to fix `condition_operand` to ignore all `peripheral_nodes` --- not just `inactive` and `immersed_peripheral_node`. The difference between the two are points that lie on non-immersed boundaries, and only affect fields with at least one Face location (like `w` above).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3791
https://github.com/CliMA/Oceananigans.jl/issues/3791:230,Availability,mask,mask,230,"Here's an MWE:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size=(2, 2), x = (0, 4), z=(0, 4), topology = (Periodic, Flat, Bounded)); mask = CenterField(grid); mask[1, 1, 1] = 1; grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(mask)). c = CenterField(grid); w = ZFaceField(grid); set!(c, 1); set!(w, 1). @show maximum(c) maximum(w); ```. as might be expected this returns . ```julia; maximum(c) = 1.0; maximum(w) = 1.0; ```. but then writing. ```julia; mask_immersed_field!(c, NaN); mask_immersed_field!(w, NaN). @show maximum(c) maximum(w); ```. leads to. ```julia; maximum(c) = 1.0; maximum(w) = NaN; ```. The reason is because `mask_immersed_field` will touch nodes that `maximum` does not ignore. But we want consistency between the two for many reasons, including analysis. I believe @simone-silvestri's suggestion is to fix `condition_operand` to ignore all `peripheral_nodes` --- not just `inactive` and `immersed_peripheral_node`. The difference between the two are points that lie on non-immersed boundaries, and only affect fields with at least one Face location (like `w` above).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3791
https://github.com/CliMA/Oceananigans.jl/issues/3791:302,Availability,mask,mask,302,"Here's an MWE:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size=(2, 2), x = (0, 4), z=(0, 4), topology = (Periodic, Flat, Bounded)); mask = CenterField(grid); mask[1, 1, 1] = 1; grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(mask)). c = CenterField(grid); w = ZFaceField(grid); set!(c, 1); set!(w, 1). @show maximum(c) maximum(w); ```. as might be expected this returns . ```julia; maximum(c) = 1.0; maximum(w) = 1.0; ```. but then writing. ```julia; mask_immersed_field!(c, NaN); mask_immersed_field!(w, NaN). @show maximum(c) maximum(w); ```. leads to. ```julia; maximum(c) = 1.0; maximum(w) = NaN; ```. The reason is because `mask_immersed_field` will touch nodes that `maximum` does not ignore. But we want consistency between the two for many reasons, including analysis. I believe @simone-silvestri's suggestion is to fix `condition_operand` to ignore all `peripheral_nodes` --- not just `inactive` and `immersed_peripheral_node`. The difference between the two are points that lie on non-immersed boundaries, and only affect fields with at least one Face location (like `w` above).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3791
https://github.com/CliMA/Oceananigans.jl/pull/3792:119,Availability,down,down,119,I was doing some profiling on a model with no open boundaries and discovered that this function was causing a big slow down. I guess this is because the compiler isn't managing to work out its just a load of nothing operations but this change appears to make it completely go away.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792
https://github.com/CliMA/Oceananigans.jl/pull/3792:200,Performance,load,load,200,I was doing some profiling on a model with no open boundaries and discovered that this function was causing a big slow down. I guess this is because the compiler isn't managing to work out its just a load of nothing operations but this change appears to make it completely go away.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792
https://github.com/CliMA/Oceananigans.jl/pull/3793:603,Energy Efficiency,schedul,schedule,603,"I've long been unsatisfied with how we build output. It requires a lot of typing --- that is, [_boilerplate_](https://en.wikipedia.org/wiki/Boilerplate_text). I often feel a sense of dread when I have to go beyond ""visualizing the final iteration"" of a prototype to defining an output writer. _So much typing_. This PR is an attempt to make output easier and more fun. I use JLD2 as an example but if there is some consensus then I think this PR should extend the same to NetCDF. The main thrust of this PR is a new function called `output!`. It works like this:. ```julia; output!(simulation, outputs; schedule=TimeInterval(1), filename=""low_hanging_fruit""); ```. The default is `JLD2Format()`. For `NetCDF` users would write. ```julia; output!(simulation, outputs, NetCDFFormat(); kw...); ```. The function adds an output writer to `simulation`, choosing a ""generic name"" for the `simulation.output_writers` dictionary. Does this enable one line output writing?. I'd love to hear feedback about this design. I implemented it in the `two_dimensional_turbulence.jl` example for illustration:. https://github.com/CliMA/Oceananigans.jl/blob/6a6853ddf53c53c321c16393682b786e82ef5a8f/examples/two_dimensional_turbulence.jl#L109. There are two more things. First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Simulations are cheap, but life is short!. PS I also want to change `add_callback!` to just `callback!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793
https://github.com/CliMA/Oceananigans.jl/pull/3793:453,Modifiability,extend,extend,453,"I've long been unsatisfied with how we build output. It requires a lot of typing --- that is, [_boilerplate_](https://en.wikipedia.org/wiki/Boilerplate_text). I often feel a sense of dread when I have to go beyond ""visualizing the final iteration"" of a prototype to defining an output writer. _So much typing_. This PR is an attempt to make output easier and more fun. I use JLD2 as an example but if there is some consensus then I think this PR should extend the same to NetCDF. The main thrust of this PR is a new function called `output!`. It works like this:. ```julia; output!(simulation, outputs; schedule=TimeInterval(1), filename=""low_hanging_fruit""); ```. The default is `JLD2Format()`. For `NetCDF` users would write. ```julia; output!(simulation, outputs, NetCDFFormat(); kw...); ```. The function adds an output writer to `simulation`, choosing a ""generic name"" for the `simulation.output_writers` dictionary. Does this enable one line output writing?. I'd love to hear feedback about this design. I implemented it in the `two_dimensional_turbulence.jl` example for illustration:. https://github.com/CliMA/Oceananigans.jl/blob/6a6853ddf53c53c321c16393682b786e82ef5a8f/examples/two_dimensional_turbulence.jl#L109. There are two more things. First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Simulations are cheap, but life is short!. PS I also want to change `add_callback!` to just `callback!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793
https://github.com/CliMA/Oceananigans.jl/pull/3793:982,Usability,feedback,feedback,982,"I've long been unsatisfied with how we build output. It requires a lot of typing --- that is, [_boilerplate_](https://en.wikipedia.org/wiki/Boilerplate_text). I often feel a sense of dread when I have to go beyond ""visualizing the final iteration"" of a prototype to defining an output writer. _So much typing_. This PR is an attempt to make output easier and more fun. I use JLD2 as an example but if there is some consensus then I think this PR should extend the same to NetCDF. The main thrust of this PR is a new function called `output!`. It works like this:. ```julia; output!(simulation, outputs; schedule=TimeInterval(1), filename=""low_hanging_fruit""); ```. The default is `JLD2Format()`. For `NetCDF` users would write. ```julia; output!(simulation, outputs, NetCDFFormat(); kw...); ```. The function adds an output writer to `simulation`, choosing a ""generic name"" for the `simulation.output_writers` dictionary. Does this enable one line output writing?. I'd love to hear feedback about this design. I implemented it in the `two_dimensional_turbulence.jl` example for illustration:. https://github.com/CliMA/Oceananigans.jl/blob/6a6853ddf53c53c321c16393682b786e82ef5a8f/examples/two_dimensional_turbulence.jl#L109. There are two more things. First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Simulations are cheap, but life is short!. PS I also want to change `add_callback!` to just `callback!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793
https://github.com/CliMA/Oceananigans.jl/pull/3793:1535,Usability,simpl,simply,1535,"I've long been unsatisfied with how we build output. It requires a lot of typing --- that is, [_boilerplate_](https://en.wikipedia.org/wiki/Boilerplate_text). I often feel a sense of dread when I have to go beyond ""visualizing the final iteration"" of a prototype to defining an output writer. _So much typing_. This PR is an attempt to make output easier and more fun. I use JLD2 as an example but if there is some consensus then I think this PR should extend the same to NetCDF. The main thrust of this PR is a new function called `output!`. It works like this:. ```julia; output!(simulation, outputs; schedule=TimeInterval(1), filename=""low_hanging_fruit""); ```. The default is `JLD2Format()`. For `NetCDF` users would write. ```julia; output!(simulation, outputs, NetCDFFormat(); kw...); ```. The function adds an output writer to `simulation`, choosing a ""generic name"" for the `simulation.output_writers` dictionary. Does this enable one line output writing?. I'd love to hear feedback about this design. I implemented it in the `two_dimensional_turbulence.jl` example for illustration:. https://github.com/CliMA/Oceananigans.jl/blob/6a6853ddf53c53c321c16393682b786e82ef5a8f/examples/two_dimensional_turbulence.jl#L109. There are two more things. First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Simulations are cheap, but life is short!. PS I also want to change `add_callback!` to just `callback!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793
https://github.com/CliMA/Oceananigans.jl/pull/3794:80,Modifiability,extend,extended,80,This PR greatly simplifies the logic behind `conditional_operation` and how its extended for immersd boundary grid. The end result besides source code clean up seems to be an improvement in type inference. Resolves #3750 I think. But @ali-ramadhan please test. EDIT: I decided not to work on #3791 (here) because this requires fixing a bunch of tests and is a bigger effort.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794
https://github.com/CliMA/Oceananigans.jl/pull/3794:31,Testability,log,logic,31,This PR greatly simplifies the logic behind `conditional_operation` and how its extended for immersd boundary grid. The end result besides source code clean up seems to be an improvement in type inference. Resolves #3750 I think. But @ali-ramadhan please test. EDIT: I decided not to work on #3791 (here) because this requires fixing a bunch of tests and is a bigger effort.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794
https://github.com/CliMA/Oceananigans.jl/pull/3794:255,Testability,test,test,255,This PR greatly simplifies the logic behind `conditional_operation` and how its extended for immersd boundary grid. The end result besides source code clean up seems to be an improvement in type inference. Resolves #3750 I think. But @ali-ramadhan please test. EDIT: I decided not to work on #3791 (here) because this requires fixing a bunch of tests and is a bigger effort.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794
https://github.com/CliMA/Oceananigans.jl/pull/3794:345,Testability,test,tests,345,This PR greatly simplifies the logic behind `conditional_operation` and how its extended for immersd boundary grid. The end result besides source code clean up seems to be an improvement in type inference. Resolves #3750 I think. But @ali-ramadhan please test. EDIT: I decided not to work on #3791 (here) because this requires fixing a bunch of tests and is a bigger effort.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794
https://github.com/CliMA/Oceananigans.jl/pull/3794:16,Usability,simpl,simplifies,16,This PR greatly simplifies the logic behind `conditional_operation` and how its extended for immersd boundary grid. The end result besides source code clean up seems to be an improvement in type inference. Resolves #3750 I think. But @ali-ramadhan please test. EDIT: I decided not to work on #3791 (here) because this requires fixing a bunch of tests and is a bigger effort.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794
https://github.com/CliMA/Oceananigans.jl/issues/3795:216,Deployability,configurat,configuration,216,"In a supposedly quiescent flow with constant temperature and salinity, seeded with tiny random noise in `w`, a large-scale flow develops and is maintained. Thus the flow gains kinetic energy in an otherwise unforced configuration, creating a ""perpetual machine"". Here is a MWE:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; maximum(abs, sim.model.tracers.T),; maximum(abs, sim.model.tracers.S),; maximum(KE_total),; prettytime(sim.Δt)). wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3795
https://github.com/CliMA/Oceananigans.jl/issues/3795:184,Energy Efficiency,energy,energy,184,"In a supposedly quiescent flow with constant temperature and salinity, seeded with tiny random noise in `w`, a large-scale flow develops and is maintained. Thus the flow gains kinetic energy in an otherwise unforced configuration, creating a ""perpetual machine"". Here is a MWE:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; maximum(abs, sim.model.tracers.T),; maximum(abs, sim.model.tracers.S),; maximum(KE_total),; prettytime(sim.Δt)). wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3795
https://github.com/CliMA/Oceananigans.jl/issues/3795:216,Modifiability,config,configuration,216,"In a supposedly quiescent flow with constant temperature and salinity, seeded with tiny random noise in `w`, a large-scale flow develops and is maintained. Thus the flow gains kinetic energy in an otherwise unforced configuration, creating a ""perpetual machine"". Here is a MWE:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; maximum(abs, sim.model.tracers.T),; maximum(abs, sim.model.tracers.S),; maximum(KE_total),; prettytime(sim.Δt)). wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3795
https://github.com/CliMA/Oceananigans.jl/pull/3796:84,Deployability,configurat,configuration,84,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3795 by changing the default configuration of `NonhydrostaticModel` to `hydrostatic_pressure_anomaly = CenterField(grid)`. The spurious large-scale flow is developed due to numerical noise in the buoyancy field when the hydrostatic pressure anomaly is treated explicitly. When hydrostatic pressure anomaly is computed using the implicit integral of the buoyancy field, no spurious kinetic energy is introduced.; Here's the MWE as in https://github.com/CliMA/Oceananigans.jl/issues/3795:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3796
https://github.com/CliMA/Oceananigans.jl/pull/3796:444,Energy Efficiency,energy,energy,444,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3795 by changing the default configuration of `NonhydrostaticModel` to `hydrostatic_pressure_anomaly = CenterField(grid)`. The spurious large-scale flow is developed due to numerical noise in the buoyancy field when the hydrostatic pressure anomaly is treated explicitly. When hydrostatic pressure anomaly is computed using the implicit integral of the buoyancy field, no spurious kinetic energy is introduced.; Here's the MWE as in https://github.com/CliMA/Oceananigans.jl/issues/3795:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3796
https://github.com/CliMA/Oceananigans.jl/pull/3796:4456,Energy Efficiency,energy,energy,4456,"e-07, 0.000e+00, 5.593e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 2.025e-10, next Δt: 1.050 ms; [ Info: ... simulation initialization complete (5.237 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.569 seconds).; [00.00%] i: 1000, t: 27.405 seconds, wall time: 7.989 seconds, max(u): (4.452e-07, 0.000e+00, 5.593e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 2.025e-10, next Δt: 138.076 ms; [00.11%] i: 2000, t: 1.009 hours, wall time: 4.283 seconds, max(u): (4.449e-07, 0.000e+00, 5.591e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 2.023e-10, next Δt: 18.157 seconds; [08.39%] i: 3000, t: 3.354 days, wall time: 4.340 seconds, max(u): (4.195e-07, 0.000e+00, 5.393e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.879e-10, next Δt: 10 minutes; [25.75%] i: 4000, t: 10.299 days, wall time: 4.455 seconds, max(u): (3.739e-07, 0.000e+00, 4.983e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.632e-10, next Δt: 10 minutes; [43.11%] i: 5000, t: 17.243 days, wall time: 4.470 seconds, max(u): (3.365e-07, 0.000e+00, 4.596e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.440e-10, next Δt: 10 minutes; [60.47%] i: 6000, t: 24.188 days, wall time: 4.402 seconds, max(u): (3.049e-07, 0.000e+00, 4.242e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.286e-10, next Δt: 10 minutes; [77.83%] i: 7000, t: 31.132 days, wall time: 4.416 seconds, max(u): (2.779e-07, 0.000e+00, 3.925e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.160e-10, next Δt: 10 minutes; [95.19%] i: 8000, t: 38.077 days, wall time: 4.495 seconds, max(u): (2.545e-07, 0.000e+00, 3.739e-07) m/s, max(T) 2.000e+01, max(S) 3.500e+01, Total KE 1.055e-10, next Δt: 10 minutes; [ Info: Simulation is stopping after running for 45.330 seconds.; [ Info: Simulation time 40 days equals or exceeds stop time 40 days.; ```; This is the expected behavior as no spurious kinetic energy is introduced. @glwagner @simone-silvestri @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3796
https://github.com/CliMA/Oceananigans.jl/pull/3796:84,Modifiability,config,configuration,84,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3795 by changing the default configuration of `NonhydrostaticModel` to `hydrostatic_pressure_anomaly = CenterField(grid)`. The spurious large-scale flow is developed due to numerical noise in the buoyancy field when the hydrostatic pressure anomaly is treated explicitly. When hydrostatic pressure anomaly is computed using the implicit integral of the buoyancy field, no spurious kinetic energy is introduced.; Here's the MWE as in https://github.com/CliMA/Oceananigans.jl/issues/3795:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3796
https://github.com/CliMA/Oceananigans.jl/issues/3800:869,Availability,error,error,869,"Running a simulation with `FT=Float32` is fairly onerous because the number type has to be passed to a huge number of model components individually. Eg we need to write. ```julia; using Oceananigans; using SeawaterPolynomials: TEOS10EquationOfState. FT = Float32; grid = RectilinearGrid(FT, size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(FT, f=1); equation_of_state = TEOS10EquationOfState(FT); buoyancy = SeawaterBuoyancy(FT; equation_of_state); ```. Here are two ideas to make this easier:. ## Use an environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the num",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:2078,Integrability,depend,depend,2078,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:2186,Integrability,depend,depend,2186,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:2287,Integrability,depend,dependency,2287,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:2428,Integrability,depend,depending,2428,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:521,Modifiability,variab,variable,521,"Running a simulation with `FT=Float32` is fairly onerous because the number type has to be passed to a huge number of model components individually. Eg we need to write. ```julia; using Oceananigans; using SeawaterPolynomials: TEOS10EquationOfState. FT = Float32; grid = RectilinearGrid(FT, size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(FT, f=1); equation_of_state = TEOS10EquationOfState(FT); buoyancy = SeawaterBuoyancy(FT; equation_of_state); ```. Here are two ideas to make this easier:. ## Use an environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the num",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:568,Modifiability,variab,variable,568,"Running a simulation with `FT=Float32` is fairly onerous because the number type has to be passed to a huge number of model components individually. Eg we need to write. ```julia; using Oceananigans; using SeawaterPolynomials: TEOS10EquationOfState. FT = Float32; grid = RectilinearGrid(FT, size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(FT, f=1); equation_of_state = TEOS10EquationOfState(FT); buoyancy = SeawaterBuoyancy(FT; equation_of_state); ```. Here are two ideas to make this easier:. ## Use an environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the num",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:892,Modifiability,variab,variable,892,"Running a simulation with `FT=Float32` is fairly onerous because the number type has to be passed to a huge number of model components individually. Eg we need to write. ```julia; using Oceananigans; using SeawaterPolynomials: TEOS10EquationOfState. FT = Float32; grid = RectilinearGrid(FT, size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(FT, f=1); equation_of_state = TEOS10EquationOfState(FT); buoyancy = SeawaterBuoyancy(FT; equation_of_state); ```. Here are two ideas to make this easier:. ## Use an environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the num",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:1500,Modifiability,variab,variables,1500,"environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for Seawater",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:2151,Modifiability,extend,extend,2151,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:2355,Modifiability,variab,variable,2355,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:2547,Modifiability,variab,variable,2547,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:2740,Modifiability,extend,extend,2740,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/issues/3800:1449,Safety,avoid,avoids,1449,"environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for Seawater",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800
https://github.com/CliMA/Oceananigans.jl/pull/3801:96,Testability,test,tests,96,"Resolves https://github.com/CliMA/Oceananigans.jl/issues/3750. Also supercedes #3794 where some tests are failing, not sure why. But that PR goes a bit further to clean up conditional ops. I think we want that too but let's start with this. cc @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3801
https://github.com/CliMA/Oceananigans.jl/issues/3803:671,Performance,perform,performs,671,"With @amontoison. We'd like to implement a Poisson solver that uses [`Krylov`](https://github.com/JuliaSmoothOptimizers/Krylov.jl) under the hood instead of our custom (preconditioned) conjugate gradient solver. This will open the door to [more solvers (that may be more appropriate for our pressure Poisson equation than conjugate gradient)](https://arxiv.org/abs/2310.01757) like conjugate residual, etc. To make this work we need to overload some of Krylov's operators for Oceananigans `Field`:. * [`kaxpby!(n, s, x, dx, y, dy)`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L326C1-L326C8) which performs `y = y + s * x` where `n` is the total length (eg `Nx * Ny * Nz`), `s` is the output, `dx` and `dy` are strides (irrelevant for us); * [`kaxpby!(n, s, x, dx, t, y, dy)`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L326C1-L326C8) which performs `y = t * y + s * x` where `n` is the total length (eg `Nx * Ny * Nz`), `s` is the output, `dx` and `dy` are strides (irrelevant for us); * [`kdot`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L310C1-L310C5); * [`knrm2`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L316C1-L316C6); * Either `kcopy!` or `copyto!`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803
https://github.com/CliMA/Oceananigans.jl/issues/3803:988,Performance,perform,performs,988,"With @amontoison. We'd like to implement a Poisson solver that uses [`Krylov`](https://github.com/JuliaSmoothOptimizers/Krylov.jl) under the hood instead of our custom (preconditioned) conjugate gradient solver. This will open the door to [more solvers (that may be more appropriate for our pressure Poisson equation than conjugate gradient)](https://arxiv.org/abs/2310.01757) like conjugate residual, etc. To make this work we need to overload some of Krylov's operators for Oceananigans `Field`:. * [`kaxpby!(n, s, x, dx, y, dy)`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L326C1-L326C8) which performs `y = y + s * x` where `n` is the total length (eg `Nx * Ny * Nz`), `s` is the output, `dx` and `dy` are strides (irrelevant for us); * [`kaxpby!(n, s, x, dx, t, y, dy)`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L326C1-L326C8) which performs `y = t * y + s * x` where `n` is the total length (eg `Nx * Ny * Nz`), `s` is the output, `dx` and `dy` are strides (irrelevant for us); * [`kdot`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L310C1-L310C5); * [`knrm2`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L316C1-L316C6); * Either `kcopy!` or `copyto!`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803
https://github.com/CliMA/Oceananigans.jl/issues/3804:560,Availability,error,error,560,"```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=128, z=(-128, 0), topology=(Flat, Flat, Bounded)). closure = (VerticalScalarDiffusivity(VerticallyImplicitTimeDiscretization(), κ=1e-4),; CATKEVerticalDiffusivity()). model = HydrostaticFreeSurfaceModel(; grid, closure,; tracers = (:b, :e),; buoyancy = BuoyancyTracer()). bᵢ(z) = 1e-5 * z; set!(model, b = bᵢ); simulation = Simulation(model, Δt=1minute, stop_iteration=10). run!(simulation); ```. generates the error. ```julia; julia> include(""tupled_vertical_diffusion.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.367 seconds); [ Info: Executing initial time step...; ERROR: LoadError: type Tuple has no field κe; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] time_step_catke_equation!(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl:25; [3] compute_diffusivities!(diffusivities::@NamedTuple{…}, closure::CATKEVerticalDiffusivity{…}, model::HydrostaticFreeSurfaceModel{…}; parameters::Symbol); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:197; [4] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:181 [inlined]; [5] #compute_diffusivities!#24; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:79 [inlined]; [6] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:76 [inlined]; [7] update_state!(model::HydrostaticFreeSurfaceModel{…}, grid::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804
https://github.com/CliMA/Oceananigans.jl/issues/3804:765,Availability,ERROR,ERROR,765,"```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=128, z=(-128, 0), topology=(Flat, Flat, Bounded)). closure = (VerticalScalarDiffusivity(VerticallyImplicitTimeDiscretization(), κ=1e-4),; CATKEVerticalDiffusivity()). model = HydrostaticFreeSurfaceModel(; grid, closure,; tracers = (:b, :e),; buoyancy = BuoyancyTracer()). bᵢ(z) = 1e-5 * z; set!(model, b = bᵢ); simulation = Simulation(model, Δt=1minute, stop_iteration=10). run!(simulation); ```. generates the error. ```julia; julia> include(""tupled_vertical_diffusion.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.367 seconds); [ Info: Executing initial time step...; ERROR: LoadError: type Tuple has no field κe; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] time_step_catke_equation!(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl:25; [3] compute_diffusivities!(diffusivities::@NamedTuple{…}, closure::CATKEVerticalDiffusivity{…}, model::HydrostaticFreeSurfaceModel{…}; parameters::Symbol); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:197; [4] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:181 [inlined]; [5] #compute_diffusivities!#24; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:79 [inlined]; [6] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:76 [inlined]; [7] update_state!(model::HydrostaticFreeSurfaceModel{…}, grid::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804
https://github.com/CliMA/Oceananigans.jl/issues/3804:772,Performance,Load,LoadError,772,"```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=128, z=(-128, 0), topology=(Flat, Flat, Bounded)). closure = (VerticalScalarDiffusivity(VerticallyImplicitTimeDiscretization(), κ=1e-4),; CATKEVerticalDiffusivity()). model = HydrostaticFreeSurfaceModel(; grid, closure,; tracers = (:b, :e),; buoyancy = BuoyancyTracer()). bᵢ(z) = 1e-5 * z; set!(model, b = bᵢ); simulation = Simulation(model, Δt=1minute, stop_iteration=10). run!(simulation); ```. generates the error. ```julia; julia> include(""tupled_vertical_diffusion.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.367 seconds); [ Info: Executing initial time step...; ERROR: LoadError: type Tuple has no field κe; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] time_step_catke_equation!(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl:25; [3] compute_diffusivities!(diffusivities::@NamedTuple{…}, closure::CATKEVerticalDiffusivity{…}, model::HydrostaticFreeSurfaceModel{…}; parameters::Symbol); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:197; [4] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:181 [inlined]; [5] #compute_diffusivities!#24; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:79 [inlined]; [6] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:76 [inlined]; [7] update_state!(model::HydrostaticFreeSurfaceModel{…}, grid::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804
https://github.com/CliMA/Oceananigans.jl/issues/3804:3565,Security,validat,validation,3565,"odel::HydrostaticFreeSurfaceModel{…}, grid::RectilinearGrid{…}, callbacks::Tuple{}; compute_tendencies::Bool); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl:72; [8] update_state!; @ ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl:64 [inlined]; [9] update_state!; @ ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:29 [inlined]; [10] time_step!(model::HydrostaticFreeSurfaceModel{…}, Δt::Float64; callbacks::Tuple{}, euler::Bool); @ Oceananigans.TimeSteppers ~/Projects/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:123; [11] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:122; [12] run!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}; pickup::Bool); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:97; [13] run!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:85; [14] top-level scope; @ ~/Projects/Oceananigans.jl/validation/vertical_mixing_closures/tupled_vertical_diffusion.jl:20; [15] include(fname::String); @ Base.MainInclude ./client.jl:489; [16] top-level scope; @ REPL[1]:1; in expression starting at /Users/gregorywagner/Projects/Oceananigans.jl/validation/vertical_mixing_closures/tupled_vertical_diffusion.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804
https://github.com/CliMA/Oceananigans.jl/issues/3804:3806,Security,validat,validation,3806,"odel::HydrostaticFreeSurfaceModel{…}, grid::RectilinearGrid{…}, callbacks::Tuple{}; compute_tendencies::Bool); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl:72; [8] update_state!; @ ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl:64 [inlined]; [9] update_state!; @ ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:29 [inlined]; [10] time_step!(model::HydrostaticFreeSurfaceModel{…}, Δt::Float64; callbacks::Tuple{}, euler::Bool); @ Oceananigans.TimeSteppers ~/Projects/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:123; [11] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:122; [12] run!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}; pickup::Bool); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:97; [13] run!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:85; [14] top-level scope; @ ~/Projects/Oceananigans.jl/validation/vertical_mixing_closures/tupled_vertical_diffusion.jl:20; [15] include(fname::String); @ Base.MainInclude ./client.jl:489; [16] top-level scope; @ REPL[1]:1; in expression starting at /Users/gregorywagner/Projects/Oceananigans.jl/validation/vertical_mixing_closures/tupled_vertical_diffusion.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804
https://github.com/CliMA/Oceananigans.jl/issues/3806:37,Availability,error,error,37,"I was actually expecting a different error. But this isn't a good one either. ```julia; julia> using Oceananigans. julia> using OrthogonalSphericalShellGrids. julia> grid = TripolarGrid(size=(4, 4, 4), z=(-1, 0)); 4×4×4 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806
https://github.com/CliMA/Oceananigans.jl/issues/3806:857,Availability,ERROR,ERROR,857,"I was actually expecting a different error. But this isn't a good one either. ```julia; julia> using Oceananigans. julia> using OrthogonalSphericalShellGrids. julia> grid = TripolarGrid(size=(4, 4, 4), z=(-1, 0)); 4×4×4 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806
https://github.com/CliMA/Oceananigans.jl/issues/3806:1311,Availability,error,error,1311,"PU with 4×4×4 halo and with precomputed metrics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(; grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{…}, tracers::Nothing, forcing::@NamedTuple{}, closure::Nothing, boundary_co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806
https://github.com/CliMA/Oceananigans.jl/issues/3806:1338,Availability,error,error,1338,"rics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(; grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{…}, tracers::Nothing, forcing::@NamedTuple{}, closure::Nothing, boundary_conditions::@NamedTuple{}, particles::Nothing,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806
https://github.com/CliMA/Oceananigans.jl/issues/3806:434,Modifiability,variab,variably,434,"I was actually expecting a different error. But this isn't a good one either. ```julia; julia> using Oceananigans. julia> using OrthogonalSphericalShellGrids. julia> grid = TripolarGrid(size=(4, 4, 4), z=(-1, 0)); 4×4×4 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806
https://github.com/CliMA/Oceananigans.jl/issues/3806:539,Modifiability,variab,variably,539,"I was actually expecting a different error. But this isn't a good one either. ```julia; julia> using Oceananigans. julia> using OrthogonalSphericalShellGrids. julia> grid = TripolarGrid(size=(4, 4, 4), z=(-1, 0)); 4×4×4 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806
https://github.com/CliMA/Oceananigans.jl/issues/3807:2151,Availability,down,down,2151,"_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk about how these parameterizations might be implemented in Oceananigans... ## Constant roughness case. For an isotropic grid, _constant roughness length_ case --- a lot of simplification! --- we have to write something like. ```julia; using Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:780,Deployability,integrat,integrated,780,"I think it's time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often tak",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:780,Integrability,integrat,integrated,780,"I think it's time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often tak",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:1359,Integrability,depend,depends,1359," from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:2243,Integrability,interface,interface,2243,"_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk about how these parameterizations might be implemented in Oceananigans... ## Constant roughness case. For an isotropic grid, _constant roughness length_ case --- a lot of simplification! --- we have to write something like. ```julia; using Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:5077,Integrability,interface,interface,5077,"ually construct `ImmersedBoundaryCondition`. Even with the simplifications we've made, it's still a lot of code that has to be repeated every time somebody wants to implemented a drag law on an immersed boundary. So we could easily motivate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:5589,Integrability,depend,dependence,5589,"(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use ClimaOcean (tools for building coupled and realistic air-sea, air-ice-sea models) for that. But ClimaOcean is not going to support the algorithmically simpler, yet geometrically more complicated case of computing momentum fluxes into complex solid objects. I think this is in scope for Oceananigans since it is not a concept in coupling between two fluids, like the air-sea case handled by ClimaOcean is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:6096,Integrability,interface,interface,6096,"(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use ClimaOcean (tools for building coupled and realistic air-sea, air-ice-sea models) for that. But ClimaOcean is not going to support the algorithmically simpler, yet geometrically more complicated case of computing momentum fluxes into complex solid objects. I think this is in scope for Oceananigans since it is not a concept in coupling between two fluids, like the air-sea case handled by ClimaOcean is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:2450,Modifiability,parameteriz,parameterizations,2450,"he context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk about how these parameterizations might be implemented in Oceananigans... ## Constant roughness case. For an isotropic grid, _constant roughness length_ case --- a lot of simplification! --- we have to write something like. ```julia; using Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², v)); @inline u_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_d",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:6463,Modifiability,coupling,coupling,6463,"(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use ClimaOcean (tools for building coupled and realistic air-sea, air-ice-sea models) for that. But ClimaOcean is not going to support the algorithmically simpler, yet geometrically more complicated case of computing momentum fluxes into complex solid objects. I think this is in scope for Oceananigans since it is not a concept in coupling between two fluids, like the air-sea case handled by ClimaOcean is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:1020,Testability,log,log,1020," time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:1258,Testability,log,log,1258," from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:3762,Testability,log,log,3762,"ng Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², v)); @inline u_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.w[i, j, k] * speedᶜᶜᶠ(i, j, k, grid, f.u, f.v, f.w). ϰ = 0.4 # ""Von Karman"" constant; ℓ = 1e-4 # simply an estimated roughness length; d = minimum_xspacing(grid) / 2 # assuming an isotropic grid, using half cell-width as ""distance to the wall""; cᴰ = (ϰ / log(d / ℓ))^2. u_drag_bc = FluxBoundaryCondition(u_drag, discrete_form=true, parameters=cᴰ); v_drag_bc = FluxBoundaryCondition(v_drag, discrete_form=true, parameters=cᴰ); w_drag_bc = FluxBoundaryCondition(w_drag, discrete_form=true, parameters=cᴰ); ```. Note, this only really makes sense on an isotropic grid and I think to strictly treat anisotropic grids we need to manually construct `ImmersedBoundaryCondition`. Even with the simplifications we've made, it's still a lot of code that has to be repeated every time somebody wants to implemented a drag law on an immersed boundary. So we could easily motivate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe om",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:134,Usability,feedback,feedback,134,"I think it's time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often tak",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:528,Usability,simpl,simple,528,"I think it's time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often tak",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:2605,Usability,simpl,simplification,2605,"d in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk about how these parameterizations might be implemented in Oceananigans... ## Constant roughness case. For an isotropic grid, _constant roughness length_ case --- a lot of simplification! --- we have to write something like. ```julia; using Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², v)); @inline u_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.w[i, j, k] * speedᶜᶜᶠ(i, j, k, grid, f.u, f.v, f.w). ϰ = 0.4 # ""Von Karman"" constant; ℓ =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:3604,Usability,simpl,simply,3604,"ng Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², v)); @inline u_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.w[i, j, k] * speedᶜᶜᶠ(i, j, k, grid, f.u, f.v, f.w). ϰ = 0.4 # ""Von Karman"" constant; ℓ = 1e-4 # simply an estimated roughness length; d = minimum_xspacing(grid) / 2 # assuming an isotropic grid, using half cell-width as ""distance to the wall""; cᴰ = (ϰ / log(d / ℓ))^2. u_drag_bc = FluxBoundaryCondition(u_drag, discrete_form=true, parameters=cᴰ); v_drag_bc = FluxBoundaryCondition(v_drag, discrete_form=true, parameters=cᴰ); w_drag_bc = FluxBoundaryCondition(w_drag, discrete_form=true, parameters=cᴰ); ```. Note, this only really makes sense on an isotropic grid and I think to strictly treat anisotropic grids we need to manually construct `ImmersedBoundaryCondition`. Even with the simplifications we've made, it's still a lot of code that has to be repeated every time somebody wants to implemented a drag law on an immersed boundary. So we could easily motivate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe om",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:4193,Usability,simpl,simplifications,4193,"- cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.w[i, j, k] * speedᶜᶜᶠ(i, j, k, grid, f.u, f.v, f.w). ϰ = 0.4 # ""Von Karman"" constant; ℓ = 1e-4 # simply an estimated roughness length; d = minimum_xspacing(grid) / 2 # assuming an isotropic grid, using half cell-width as ""distance to the wall""; cᴰ = (ϰ / log(d / ℓ))^2. u_drag_bc = FluxBoundaryCondition(u_drag, discrete_form=true, parameters=cᴰ); v_drag_bc = FluxBoundaryCondition(v_drag, discrete_form=true, parameters=cᴰ); w_drag_bc = FluxBoundaryCondition(w_drag, discrete_form=true, parameters=cᴰ); ```. Note, this only really makes sense on an isotropic grid and I think to strictly treat anisotropic grids we need to manually construct `ImmersedBoundaryCondition`. Even with the simplifications we've made, it's still a lot of code that has to be repeated every time somebody wants to implemented a drag law on an immersed boundary. So we could easily motivate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:5309,Usability,simpl,simply,5309,"vate implementing an abstraction `drag_boundary_conditions` that returns the bcs for `u, v, w`, eg:. ```julia; u_drag_bc, v_drag_bc, w_drag_bc = drag_boundary_conditions(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use ClimaOcean (tools for building coupled and realistic air-sea, air-ice-sea models) for that. But ClimaOcean is not going to support the algorithmically simpler, yet geometrically more complicated case of computing momentum fluxes into co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3807:6286,Usability,simpl,simpler,6286,"(grid; roughness_length=1e-4, von_karman_constant=0.4); ```. The utility could also property deal with grid stretching. And maybe omit `Flat` directions. ## Roughness length computed from similarity theory?. In the case that we would like to use the smooth wall approximation $\ell = c_\nu \nu / u_\star$, we have to _solve_ a transcendental equation to find the drag coefficient coefficient at every grid point (one could also formulate this as computing the flux). This could be implemented with callbacks, etc, but to formulate a nice interface for users for this we might actually have to add some kind of `update_boundary_conditions!` feature to `update_state!` that could precompute the drag coefficient and/or fluxes. In terms of a path forward, I think we could simply start with the constant roughness length case, and perhaps make the utility a bit general so that users could also directly specify a drag coefficient if desired. For example in hydrostatic cases we often specify the drag coefficient directly, and we also usually omit the dependence on `w`. There are even more considerations one might consider... for example, in a finite volume model (and in the code above) the distance to the wall is taken as the ""center of the cell"", ie half the cell thickness. But this is not really consistent with the finite volume framework, and better approaches have been proposed (eg see [Nishizawa and Kitamura 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001534)). Note that if we want to compute fluxes across the air-sea interface, it's probably better to use ClimaOcean (tools for building coupled and realistic air-sea, air-ice-sea models) for that. But ClimaOcean is not going to support the algorithmically simpler, yet geometrically more complicated case of computing momentum fluxes into complex solid objects. I think this is in scope for Oceananigans since it is not a concept in coupling between two fluids, like the air-sea case handled by ClimaOcean is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807
https://github.com/CliMA/Oceananigans.jl/issues/3808:291,Modifiability,variab,variably,291,"For example for the tripolar grid it looks like this. ```julia; 2160×1080×60 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on GPU with 7×7×7 halo and with precomputed metrics; ├── centered at (λ, φ) = (75.0, 1.8005); ├── longitude: Periodic extent 360.167 degrees variably spaced with min(Δλ)=0.000208433, max(Δλ)=0.175625; ├── latitude: RightConnected extent 170.157 degrees variably spaced with min(Δφ)=0.000312453, max(Δφ)=0.157553; └── z: Bounded z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=5.24961, max(Δz)=438.409; ```. This claims that whatever grid I've constructed is ""RightConnected"" in latitude. This doesn't really make sense to me... but let's set that aside (it's a separate issue with the tripolar grid). The bigger issue is that the y-topology is NOT the ""latitude topology"" --- on an orthogonal spherical shell grid, ""y"" and ""latitude"" are different (that's the whole point, when they do coincide we are on a LatitudeLongitudeGrid). We should design a good show method for this grid type. My impression is that the show method was copied from LatitudeLongitudeGrid. But we need to work a bit harder for OrthogonalSphericalShellGrid because it is more general. I think we should give information both about the coordinate system (lat, lon, z), and in addition to that and separately, give information about the logical arrangement of the grid (x, y, z), including the topology. The former is important for understanding the geography of the grid and the latter is important for understanding the discretization, and the two are distinct from one another. So the show method for this grid is going to be more involved than the others. I don't think we need to indicate whether the x, y directions are ""variably spaced"". That is useful for rectilinear and lat-lon grids, but not for general grids. . cc @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3808
https://github.com/CliMA/Oceananigans.jl/issues/3808:403,Modifiability,variab,variably,403,"For example for the tripolar grid it looks like this. ```julia; 2160×1080×60 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on GPU with 7×7×7 halo and with precomputed metrics; ├── centered at (λ, φ) = (75.0, 1.8005); ├── longitude: Periodic extent 360.167 degrees variably spaced with min(Δλ)=0.000208433, max(Δλ)=0.175625; ├── latitude: RightConnected extent 170.157 degrees variably spaced with min(Δφ)=0.000312453, max(Δφ)=0.157553; └── z: Bounded z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=5.24961, max(Δz)=438.409; ```. This claims that whatever grid I've constructed is ""RightConnected"" in latitude. This doesn't really make sense to me... but let's set that aside (it's a separate issue with the tripolar grid). The bigger issue is that the y-topology is NOT the ""latitude topology"" --- on an orthogonal spherical shell grid, ""y"" and ""latitude"" are different (that's the whole point, when they do coincide we are on a LatitudeLongitudeGrid). We should design a good show method for this grid type. My impression is that the show method was copied from LatitudeLongitudeGrid. But we need to work a bit harder for OrthogonalSphericalShellGrid because it is more general. I think we should give information both about the coordinate system (lat, lon, z), and in addition to that and separately, give information about the logical arrangement of the grid (x, y, z), including the topology. The former is important for understanding the geography of the grid and the latter is important for understanding the discretization, and the two are distinct from one another. So the show method for this grid is going to be more involved than the others. I don't think we need to indicate whether the x, y directions are ""variably spaced"". That is useful for rectilinear and lat-lon grids, but not for general grids. . cc @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3808
https://github.com/CliMA/Oceananigans.jl/issues/3808:497,Modifiability,variab,variably,497,"For example for the tripolar grid it looks like this. ```julia; 2160×1080×60 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on GPU with 7×7×7 halo and with precomputed metrics; ├── centered at (λ, φ) = (75.0, 1.8005); ├── longitude: Periodic extent 360.167 degrees variably spaced with min(Δλ)=0.000208433, max(Δλ)=0.175625; ├── latitude: RightConnected extent 170.157 degrees variably spaced with min(Δφ)=0.000312453, max(Δφ)=0.157553; └── z: Bounded z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=5.24961, max(Δz)=438.409; ```. This claims that whatever grid I've constructed is ""RightConnected"" in latitude. This doesn't really make sense to me... but let's set that aside (it's a separate issue with the tripolar grid). The bigger issue is that the y-topology is NOT the ""latitude topology"" --- on an orthogonal spherical shell grid, ""y"" and ""latitude"" are different (that's the whole point, when they do coincide we are on a LatitudeLongitudeGrid). We should design a good show method for this grid type. My impression is that the show method was copied from LatitudeLongitudeGrid. But we need to work a bit harder for OrthogonalSphericalShellGrid because it is more general. I think we should give information both about the coordinate system (lat, lon, z), and in addition to that and separately, give information about the logical arrangement of the grid (x, y, z), including the topology. The former is important for understanding the geography of the grid and the latter is important for understanding the discretization, and the two are distinct from one another. So the show method for this grid is going to be more involved than the others. I don't think we need to indicate whether the x, y directions are ""variably spaced"". That is useful for rectilinear and lat-lon grids, but not for general grids. . cc @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3808
https://github.com/CliMA/Oceananigans.jl/issues/3808:1748,Modifiability,variab,variably,1748,"For example for the tripolar grid it looks like this. ```julia; 2160×1080×60 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on GPU with 7×7×7 halo and with precomputed metrics; ├── centered at (λ, φ) = (75.0, 1.8005); ├── longitude: Periodic extent 360.167 degrees variably spaced with min(Δλ)=0.000208433, max(Δλ)=0.175625; ├── latitude: RightConnected extent 170.157 degrees variably spaced with min(Δφ)=0.000312453, max(Δφ)=0.157553; └── z: Bounded z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=5.24961, max(Δz)=438.409; ```. This claims that whatever grid I've constructed is ""RightConnected"" in latitude. This doesn't really make sense to me... but let's set that aside (it's a separate issue with the tripolar grid). The bigger issue is that the y-topology is NOT the ""latitude topology"" --- on an orthogonal spherical shell grid, ""y"" and ""latitude"" are different (that's the whole point, when they do coincide we are on a LatitudeLongitudeGrid). We should design a good show method for this grid type. My impression is that the show method was copied from LatitudeLongitudeGrid. But we need to work a bit harder for OrthogonalSphericalShellGrid because it is more general. I think we should give information both about the coordinate system (lat, lon, z), and in addition to that and separately, give information about the logical arrangement of the grid (x, y, z), including the topology. The former is important for understanding the geography of the grid and the latter is important for understanding the discretization, and the two are distinct from one another. So the show method for this grid is going to be more involved than the others. I don't think we need to indicate whether the x, y directions are ""variably spaced"". That is useful for rectilinear and lat-lon grids, but not for general grids. . cc @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3808
https://github.com/CliMA/Oceananigans.jl/issues/3808:1358,Testability,log,logical,1358,"For example for the tripolar grid it looks like this. ```julia; 2160×1080×60 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on GPU with 7×7×7 halo and with precomputed metrics; ├── centered at (λ, φ) = (75.0, 1.8005); ├── longitude: Periodic extent 360.167 degrees variably spaced with min(Δλ)=0.000208433, max(Δλ)=0.175625; ├── latitude: RightConnected extent 170.157 degrees variably spaced with min(Δφ)=0.000312453, max(Δφ)=0.157553; └── z: Bounded z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=5.24961, max(Δz)=438.409; ```. This claims that whatever grid I've constructed is ""RightConnected"" in latitude. This doesn't really make sense to me... but let's set that aside (it's a separate issue with the tripolar grid). The bigger issue is that the y-topology is NOT the ""latitude topology"" --- on an orthogonal spherical shell grid, ""y"" and ""latitude"" are different (that's the whole point, when they do coincide we are on a LatitudeLongitudeGrid). We should design a good show method for this grid type. My impression is that the show method was copied from LatitudeLongitudeGrid. But we need to work a bit harder for OrthogonalSphericalShellGrid because it is more general. I think we should give information both about the coordinate system (lat, lon, z), and in addition to that and separately, give information about the logical arrangement of the grid (x, y, z), including the topology. The former is important for understanding the geography of the grid and the latter is important for understanding the discretization, and the two are distinct from one another. So the show method for this grid is going to be more involved than the others. I don't think we need to indicate whether the x, y directions are ""variably spaced"". That is useful for rectilinear and lat-lon grids, but not for general grids. . cc @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3808
https://github.com/CliMA/Oceananigans.jl/pull/3809:179,Testability,test,tests,179,"This will be useful for doing mixed precision stuff, like using single-precision FFT-based preconditioners for Poisson solvers in double-precision simulations. cc @xkykai . TODO: tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3809
https://github.com/CliMA/Oceananigans.jl/issues/3810:584,Testability,test,testing,584,"Hi all,. I think there's been a mistake in the open boundary filling that's only becoming a problem now that we're trying to fill non-zero value. https://github.com/CliMA/Oceananigans.jl/blob/3ea2545331d9910d8b467dd8eb31074fb426af5b/src/BoundaryConditions/fill_halo_regions_open.jl#L86-L91. The open fill has always set point at index `1` on the right hand side and `grid.N+1` on the right hand side, but `1` is part of the prognostic domain and halo points we need are just for computing gradients at the face point, which should be at `0`. I came across this because I've only been testing open boundaries on the right side, but was checking it worked in the other directions and realised it always failed when I just switched the direction and sides for a simple case. Am I missing something here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810
https://github.com/CliMA/Oceananigans.jl/issues/3810:759,Usability,simpl,simple,759,"Hi all,. I think there's been a mistake in the open boundary filling that's only becoming a problem now that we're trying to fill non-zero value. https://github.com/CliMA/Oceananigans.jl/blob/3ea2545331d9910d8b467dd8eb31074fb426af5b/src/BoundaryConditions/fill_halo_regions_open.jl#L86-L91. The open fill has always set point at index `1` on the right hand side and `grid.N+1` on the right hand side, but `1` is part of the prognostic domain and halo points we need are just for computing gradients at the face point, which should be at `0`. I came across this because I've only been testing open boundaries on the right side, but was checking it worked in the other directions and realised it always failed when I just switched the direction and sides for a simple case. Am I missing something here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810
https://github.com/CliMA/Oceananigans.jl/issues/3811:17,Modifiability,extend,extending,17,"This may require extending `heatmap!` directly, probably using the utilities developed for Imaginocean. Another possibility is to generate heatmaps in ""array coordinates"" rather than making heatmaps in geographic coordinates. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3811
https://github.com/CliMA/Oceananigans.jl/pull/3812:47,Testability,test,test,47,This PR adds support for Krylov.jl and aims to test it out for solving the Poisson equation. cc @xkykai @amontoison. Closes #3803,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812
https://github.com/CliMA/Oceananigans.jl/issues/3816:1233,Availability,ERROR,ERROR,1233,"nicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816
https://github.com/CliMA/Oceananigans.jl/issues/3816:1251,Availability,ERROR,ERROR,1251,"nicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816
https://github.com/CliMA/Oceananigans.jl/issues/3816:1284,Availability,ERROR,ERROR,1284,"nicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816
https://github.com/CliMA/Oceananigans.jl/issues/3816:1393,Availability,ERROR,ERROR,1393,"nicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816
https://github.com/CliMA/Oceananigans.jl/issues/3816:6459,Availability,error,error,6459,"tedComputations.HaloCommunicationRanks{Int64, Int64}}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{@NamedTuple{send::Array{Float64, 3}, recv::Array{Float64, 3}}, @NamedTuple{send::Array{Float64, 3}, recv::Array{Float64, 3}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, v::Array{Float64, 3}); @ Oceananigans.DistributedComputations ~/Projects/Oceananigans.jl/src/DistributedComputations/distributed_fields.jl:53; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, ib::GridFittedBottom{Array{Float64, 3}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/Projects/Oceananigans.jl/src/ImmersedBoundaries/grid_fitted_bottom.jl:89; [3] top-level scope; @ ~/Projects/Oceananigans.jl/mwe.jl:24; in expression starting at /Users/gregorywagner/Projects/Oceananigans.jl/mwe.jl:24; ```. I think `set!` should be able to understand whether an array has a global size or local size and do the right thing accordingly. It should only error if the array has neither of those sizes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816
https://github.com/CliMA/Oceananigans.jl/issues/3816:381,Performance,load,load,381,"Here's an example:. ```julia; using Oceananigans; using MPI; using JLD2. arch = Distributed(); @show arch. x = y = z = (0, 1); global_size = (8, 2, 2); grid = RectilinearGrid(arch, size=global_size; x, y, z); @show size(grid). rank = arch.local_rank; if rank === 0; bathymetry = 0.1 * rand(global_size...); @save ""bathymetry.jld2"" bathymetry; end. MPI.Barrier(arch.communicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, fal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816
https://github.com/CliMA/Oceananigans.jl/issues/3816:1240,Performance,Load,LoadError,1240,"nicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816
https://github.com/CliMA/Oceananigans.jl/issues/3816:1258,Performance,Load,LoadError,1258,"nicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816
https://github.com/CliMA/Oceananigans.jl/pull/3818:117,Availability,checkpoint,checkpoint,117,"Hello, . I've worked implementing this automatic concatenation for the output, when a simulation is picked up from a checkpoint, with the flag splitting_files on. This feature addresses the fact that otherwise the simulation output filename needs to be changed manually each time the simulation is restarted. . In other words, if a simulation is run to output in a `file.nc` with the flag splitting_files, different files will be created such as `file_part1.nc`, `file_part2.nc`. If the overwrite_output is true, these files will be rewritten and the data will be deleted. If the overwrite_output is false, the simulation will crash since it will not find the original `file.nc`. The new code ensures that if overwrite_output is false, then the model will append the output to the last file. i.e. `file_part2.nc`. . Before working more on this (i.e. including joining output in jld2), I'm wondering if this will be useful to implement in the other schedulers and merge to master. What do you think @glwagner @tomchor @navidcy ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818
https://github.com/CliMA/Oceananigans.jl/pull/3818:948,Energy Efficiency,schedul,schedulers,948,"Hello, . I've worked implementing this automatic concatenation for the output, when a simulation is picked up from a checkpoint, with the flag splitting_files on. This feature addresses the fact that otherwise the simulation output filename needs to be changed manually each time the simulation is restarted. . In other words, if a simulation is run to output in a `file.nc` with the flag splitting_files, different files will be created such as `file_part1.nc`, `file_part2.nc`. If the overwrite_output is true, these files will be rewritten and the data will be deleted. If the overwrite_output is false, the simulation will crash since it will not find the original `file.nc`. The new code ensures that if overwrite_output is false, then the model will append the output to the last file. i.e. `file_part2.nc`. . Before working more on this (i.e. including joining output in jld2), I'm wondering if this will be useful to implement in the other schedulers and merge to master. What do you think @glwagner @tomchor @navidcy ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818
https://github.com/CliMA/Oceananigans.jl/pull/3819:165,Modifiability,parameteriz,parameterization,165,"This PR aims to incorporate trained neural networks that represent the entrainment process due to turbulent convection in the upper ocean into Oceananigans.jl. This parameterization is designed to work using the TEOS-10 nonlinear equation of state, hence it works only in typical oceanographic conditions on Earth.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3819
https://github.com/CliMA/Oceananigans.jl/pull/3820:103,Availability,Checkpoint,Checkpointer,103,"This PR completes the output_helpers.jl to support different output_writers: ; - NetCDFOutputWriter; - Checkpointer. Additionally, it ensures that the output of `NetCDFOutputWriter` and `JLD2OutputWriter` are created during the simulation `run!` instead of when the writer is instantiated. . I don't particularly like the fact that the `NetCDFOutputWriter` struct requires to parametric value for the dataset, which requires to open a dataset to instantiate it. I solved this by opening a temporal netCDF the first time it's called (""a hack""), i.e. `Dataset(Base.Filesystem.tempname(),""c"")`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3820
https://github.com/CliMA/Oceananigans.jl/pull/3822:12,Testability,test,test,12,This adds a test for Enzyme AD applied to a hydrostatic free surface model with `ExplicitFreeSurface` momentum advection.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3822
https://github.com/CliMA/Oceananigans.jl/pull/3825:177,Integrability,depend,depends,177,"I'm not sure why this was added, so we will see if something breaks. But through usage I've realized that its inconvenient (and unexpected) that the length of `FieldTimeSeries` depends on the backend. My intuition is that the length stays the same regardless of _where_ the data is (in memory, or on disk, or a combination of the two). It's also helpful that behavior is the same between backends, which makes switching backends for performance reasons painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3825
https://github.com/CliMA/Oceananigans.jl/pull/3825:433,Performance,perform,performance,433,"I'm not sure why this was added, so we will see if something breaks. But through usage I've realized that its inconvenient (and unexpected) that the length of `FieldTimeSeries` depends on the backend. My intuition is that the length stays the same regardless of _where_ the data is (in memory, or on disk, or a combination of the two). It's also helpful that behavior is the same between backends, which makes switching backends for performance reasons painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3825
https://github.com/CliMA/Oceananigans.jl/pull/3825:204,Usability,intuit,intuition,204,"I'm not sure why this was added, so we will see if something breaks. But through usage I've realized that its inconvenient (and unexpected) that the length of `FieldTimeSeries` depends on the backend. My intuition is that the length stays the same regardless of _where_ the data is (in memory, or on disk, or a combination of the two). It's also helpful that behavior is the same between backends, which makes switching backends for performance reasons painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3825
https://github.com/CliMA/Oceananigans.jl/issues/3826:25,Usability,simpl,simply,25,"It seems it was put here simply for ""historical reasons"", ie it is the most recent parameter to be added. But that is not a good way to motivate design:. https://github.com/CliMA/Oceananigans.jl/blob/9c6ed92edf212daaa4c709c4441ce770cdd0bae3/src/Grids/orthogonal_spherical_shell_grid.jl#L46. I think it belongs second, after `architecture`. Also, the type parameter should be 5th, after TZ:. https://github.com/CliMA/Oceananigans.jl/blob/9c6ed92edf212daaa4c709c4441ce770cdd0bae3/src/Grids/orthogonal_spherical_shell_grid.jl#L12. This will help with silly constructs like. https://github.com/CliMA/OrthogonalSphericalShellGrids.jl/blob/379d0de985a0927c026e6c3e43b2ebd163e054aa/src/tripolar_grid.jl#L13. cc @simone-silvestri @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3826
https://github.com/CliMA/Oceananigans.jl/pull/3827:30,Modifiability,refactor,refactoring,30,proabably because of previous refactoring,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3827
https://github.com/CliMA/Oceananigans.jl/issues/3828:785,Integrability,depend,depend,785,"Currently open boundary conditions only work correctly for non-hydrostatic models. To work correctly with hydrostatic models with a free surface, the free surface needs to know about the open boundary conditions in order for the barotropic fluxes to be correct. Some refactoring needs to take place to support this as the split-explicit free surface has difference operators that need to be topologically-aware:. https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L35-L42. @simone-silvestri's suggestion in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203 was to move the topologically-aware operators to the `Operators` module and have them depend on boundary conditions. See PR #3268. But having operators depend on boundary conditions seems messy and breaks the chain of dependence Oceananigans has (architectures -> grids -> operators -> boundary conditions -> fields, etc.). So maybe this isn't the approach we want to take. After looking through https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl and some discussion with @tomchor we came to the conclusion that the need to impose boundary conditions in this way suggests that something needs to be a `Field`. I think that something is `η★` `U★`, and `V★`. If these became `Field`s and lived in `SplitExplicitState` then they could have their own boundary conditions and not we wouldn't need the topologically-aware operators?. And their boundary conditions could be inferred/computed from the boundary conditions on `u` and `v` using vertical integrals. For `η` I think it's prescribed. See https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353142608 and https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930. **Note**: This issue is only for the split-explicit free surface. I thin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828
https://github.com/CliMA/Oceananigans.jl/issues/3828:851,Integrability,depend,depend,851,"Currently open boundary conditions only work correctly for non-hydrostatic models. To work correctly with hydrostatic models with a free surface, the free surface needs to know about the open boundary conditions in order for the barotropic fluxes to be correct. Some refactoring needs to take place to support this as the split-explicit free surface has difference operators that need to be topologically-aware:. https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L35-L42. @simone-silvestri's suggestion in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203 was to move the topologically-aware operators to the `Operators` module and have them depend on boundary conditions. See PR #3268. But having operators depend on boundary conditions seems messy and breaks the chain of dependence Oceananigans has (architectures -> grids -> operators -> boundary conditions -> fields, etc.). So maybe this isn't the approach we want to take. After looking through https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl and some discussion with @tomchor we came to the conclusion that the need to impose boundary conditions in this way suggests that something needs to be a `Field`. I think that something is `η★` `U★`, and `V★`. If these became `Field`s and lived in `SplitExplicitState` then they could have their own boundary conditions and not we wouldn't need the topologically-aware operators?. And their boundary conditions could be inferred/computed from the boundary conditions on `u` and `v` using vertical integrals. For `η` I think it's prescribed. See https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353142608 and https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930. **Note**: This issue is only for the split-explicit free surface. I thin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828
https://github.com/CliMA/Oceananigans.jl/issues/3828:917,Integrability,depend,dependence,917,"Currently open boundary conditions only work correctly for non-hydrostatic models. To work correctly with hydrostatic models with a free surface, the free surface needs to know about the open boundary conditions in order for the barotropic fluxes to be correct. Some refactoring needs to take place to support this as the split-explicit free surface has difference operators that need to be topologically-aware:. https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L35-L42. @simone-silvestri's suggestion in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203 was to move the topologically-aware operators to the `Operators` module and have them depend on boundary conditions. See PR #3268. But having operators depend on boundary conditions seems messy and breaks the chain of dependence Oceananigans has (architectures -> grids -> operators -> boundary conditions -> fields, etc.). So maybe this isn't the approach we want to take. After looking through https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl and some discussion with @tomchor we came to the conclusion that the need to impose boundary conditions in this way suggests that something needs to be a `Field`. I think that something is `η★` `U★`, and `V★`. If these became `Field`s and lived in `SplitExplicitState` then they could have their own boundary conditions and not we wouldn't need the topologically-aware operators?. And their boundary conditions could be inferred/computed from the boundary conditions on `u` and `v` using vertical integrals. For `η` I think it's prescribed. See https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353142608 and https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930. **Note**: This issue is only for the split-explicit free surface. I thin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828
https://github.com/CliMA/Oceananigans.jl/issues/3828:267,Modifiability,refactor,refactoring,267,"Currently open boundary conditions only work correctly for non-hydrostatic models. To work correctly with hydrostatic models with a free surface, the free surface needs to know about the open boundary conditions in order for the barotropic fluxes to be correct. Some refactoring needs to take place to support this as the split-explicit free surface has difference operators that need to be topologically-aware:. https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L35-L42. @simone-silvestri's suggestion in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203 was to move the topologically-aware operators to the `Operators` module and have them depend on boundary conditions. See PR #3268. But having operators depend on boundary conditions seems messy and breaks the chain of dependence Oceananigans has (architectures -> grids -> operators -> boundary conditions -> fields, etc.). So maybe this isn't the approach we want to take. After looking through https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl and some discussion with @tomchor we came to the conclusion that the need to impose boundary conditions in this way suggests that something needs to be a `Field`. I think that something is `η★` `U★`, and `V★`. If these became `Field`s and lived in `SplitExplicitState` then they could have their own boundary conditions and not we wouldn't need the topologically-aware operators?. And their boundary conditions could be inferred/computed from the boundary conditions on `u` and `v` using vertical integrals. For `η` I think it's prescribed. See https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353142608 and https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930. **Note**: This issue is only for the split-explicit free surface. I thin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828
https://github.com/CliMA/Oceananigans.jl/issues/3829:339,Availability,Error,Error,339,"I'll open a PR to add a test that covers this. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.Solvers: ConjugateGradientPoissonSolver. grid = RectilinearGrid(; CPU(),; Float64,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0); ). ConjugateGradientPoissonSolver(grid); ```. Error:. ```; ERROR: UndefVarError: `ImmersedBoundaryGrid` not defined; Stacktrace:; [1] ConjugateGradientPoissonSolver(grid::RectilinearGrid{…}; preconditioner::Oceananigans.Solvers.DefaultPreconditioner, reltol::Float64, abstol::Float64, kw::@Kwargs{}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:54; [2] ConjugateGradientPoissonSolver(grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, CPU}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:47; [3] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3829
https://github.com/CliMA/Oceananigans.jl/issues/3829:352,Availability,ERROR,ERROR,352,"I'll open a PR to add a test that covers this. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.Solvers: ConjugateGradientPoissonSolver. grid = RectilinearGrid(; CPU(),; Float64,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0); ). ConjugateGradientPoissonSolver(grid); ```. Error:. ```; ERROR: UndefVarError: `ImmersedBoundaryGrid` not defined; Stacktrace:; [1] ConjugateGradientPoissonSolver(grid::RectilinearGrid{…}; preconditioner::Oceananigans.Solvers.DefaultPreconditioner, reltol::Float64, abstol::Float64, kw::@Kwargs{}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:54; [2] ConjugateGradientPoissonSolver(grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, CPU}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:47; [3] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3829
https://github.com/CliMA/Oceananigans.jl/issues/3829:24,Testability,test,test,24,"I'll open a PR to add a test that covers this. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.Solvers: ConjugateGradientPoissonSolver. grid = RectilinearGrid(; CPU(),; Float64,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0); ). ConjugateGradientPoissonSolver(grid); ```. Error:. ```; ERROR: UndefVarError: `ImmersedBoundaryGrid` not defined; Stacktrace:; [1] ConjugateGradientPoissonSolver(grid::RectilinearGrid{…}; preconditioner::Oceananigans.Solvers.DefaultPreconditioner, reltol::Float64, abstol::Float64, kw::@Kwargs{}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:54; [2] ConjugateGradientPoissonSolver(grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, CPU}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:47; [3] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3829
https://github.com/CliMA/Oceananigans.jl/pull/3830:348,Integrability,depend,depend,348,"I added a test that fails due to #3829. I should also test the non-FFT case and test that the proper pre-conditioner was initialized. So the test could be better but it does fail as it should. What we need is a `using Oceananigans.ImmersedBoundaries` but the solvers module is defined well before the immersed boundaries module. So for a solver to depend on the immersed boundaries module, and really just the `ImmersedBoundaryGrid` type then the immersed boundaries module needs to be included first. Based on these comments maybe it's desirable to change the order of inclusion? But maybe it'll take some work. So otherwise we probably need to define another abstract type in `src/Oceananigans.jl` but this solution isn't ideal. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Oceananigans.jl#L214-L228. Resolves #3829",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830
https://github.com/CliMA/Oceananigans.jl/pull/3830:10,Testability,test,test,10,"I added a test that fails due to #3829. I should also test the non-FFT case and test that the proper pre-conditioner was initialized. So the test could be better but it does fail as it should. What we need is a `using Oceananigans.ImmersedBoundaries` but the solvers module is defined well before the immersed boundaries module. So for a solver to depend on the immersed boundaries module, and really just the `ImmersedBoundaryGrid` type then the immersed boundaries module needs to be included first. Based on these comments maybe it's desirable to change the order of inclusion? But maybe it'll take some work. So otherwise we probably need to define another abstract type in `src/Oceananigans.jl` but this solution isn't ideal. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Oceananigans.jl#L214-L228. Resolves #3829",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830
https://github.com/CliMA/Oceananigans.jl/pull/3830:54,Testability,test,test,54,"I added a test that fails due to #3829. I should also test the non-FFT case and test that the proper pre-conditioner was initialized. So the test could be better but it does fail as it should. What we need is a `using Oceananigans.ImmersedBoundaries` but the solvers module is defined well before the immersed boundaries module. So for a solver to depend on the immersed boundaries module, and really just the `ImmersedBoundaryGrid` type then the immersed boundaries module needs to be included first. Based on these comments maybe it's desirable to change the order of inclusion? But maybe it'll take some work. So otherwise we probably need to define another abstract type in `src/Oceananigans.jl` but this solution isn't ideal. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Oceananigans.jl#L214-L228. Resolves #3829",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830
https://github.com/CliMA/Oceananigans.jl/pull/3830:80,Testability,test,test,80,"I added a test that fails due to #3829. I should also test the non-FFT case and test that the proper pre-conditioner was initialized. So the test could be better but it does fail as it should. What we need is a `using Oceananigans.ImmersedBoundaries` but the solvers module is defined well before the immersed boundaries module. So for a solver to depend on the immersed boundaries module, and really just the `ImmersedBoundaryGrid` type then the immersed boundaries module needs to be included first. Based on these comments maybe it's desirable to change the order of inclusion? But maybe it'll take some work. So otherwise we probably need to define another abstract type in `src/Oceananigans.jl` but this solution isn't ideal. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Oceananigans.jl#L214-L228. Resolves #3829",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830
https://github.com/CliMA/Oceananigans.jl/pull/3830:141,Testability,test,test,141,"I added a test that fails due to #3829. I should also test the non-FFT case and test that the proper pre-conditioner was initialized. So the test could be better but it does fail as it should. What we need is a `using Oceananigans.ImmersedBoundaries` but the solvers module is defined well before the immersed boundaries module. So for a solver to depend on the immersed boundaries module, and really just the `ImmersedBoundaryGrid` type then the immersed boundaries module needs to be included first. Based on these comments maybe it's desirable to change the order of inclusion? But maybe it'll take some work. So otherwise we probably need to define another abstract type in `src/Oceananigans.jl` but this solution isn't ideal. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Oceananigans.jl#L214-L228. Resolves #3829",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830
https://github.com/CliMA/Oceananigans.jl/issues/3831:29,Testability,test,test,29,"I'm trying to set up a small test where a zonal velocity forced by open boundary conditions goes around an immersed sea mount, using the new immersed pressure solver. Unfortunately I get immediate NaNs on iteration 1. Maybe there's a bug somewhere? I know I'm using a bunch of _experimental_ features together so perhaps this is not surprising. My setup could also be bad though. Curious if anyone has any insights on what's going wrong here. Does the pressure solver need to be modified to account for non-zero velocities at the boundaries? I guess the FFT pressure solver assumes either periodic or no-penetration at the boundaries, but then shouldn't the conjugate gradient solver converge on the correct pressure with enough iterations? Or maybe not if the pre-conditioner is very wrong?. ""MWE"" setup:. ```julia; using Printf; using Oceananigans; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver. L = 100; H = 100. underlying_grid = RectilinearGrid(; CPU(),; Float64,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; x = (0, L),; y = (0, L),; z = (-H, 0); ). h = H/2; w = L/5; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). @inline u_inflow(y, z, t) = 0.01. u_bcs = FieldBoundaryConditions(; west = OpenBoundaryCondition(u_inflow),; east = OpenBoundaryCondition(u_inflow); ). boundary_conditions = (; u=u_bcs). model = NonhydrostaticModel(;; grid,; boundary_conditions,; timestepper = :RungeKutta3,; pressure_solver = ConjugateGradientPoissonSolver(; grid;; preconditioner = fft_poisson_solver(grid.underlying_grid); ); ). simulation = Simulation(model; Δt=0.1, stop_time=60). progress(sim) = @printf(; ""iteration: %d, time: %.4f, U_max=(%.2e, %.2e, %.2e)\n"",; iteration(simulation),; time(simulation),; maximum(abs, model.velocities.u),; maximum(abs, model.velocities.v),; maximum(abs, model.velocities.w); ). simulation.callbacks[:progre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831
https://github.com/CliMA/Oceananigans.jl/pull/3832:92,Deployability,update,updates,92,"This PR introduces a new `ConformalMapping` type for the `OrthogonalSphericalShellGrid` and updates the grid construction to incorporate this type as a parameter. The goal is to enable dispatch over various conformal mapping types (e.g., cubed sphere and tripolar) and embed these mappings directly within the `OrthogonalSphericalShellGrid` structure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3832
https://github.com/CliMA/Oceananigans.jl/pull/3834:86,Testability,test,tests,86,"Should close #3833. Probably, we can wait to merge #3792 before this one and add some tests for fill halo regions here",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3834
https://github.com/CliMA/Oceananigans.jl/issues/3835:405,Availability,ERROR,ERROR,405,"MWE ; ```julia; grid = RectilinearGrid(size = (5, 5, 5), extent = (1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); c = CenterField(grid; indices = (:, :, grid.Nz)); d = CenterField(grid); JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ```; fails with ; ```julia; julia> JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:2225,Availability,ERROR,ERROR,2225,"ns.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; It looks like there are problems also if trying to save the windowed field by itself; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test1"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticF",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:249,Energy Efficiency,schedul,schedule,249,"MWE ; ```julia; grid = RectilinearGrid(size = (5, 5, 5), extent = (1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); c = CenterField(grid; indices = (:, :, grid.Nz)); d = CenterField(grid); JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ```; fails with ; ```julia; julia> JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:371,Energy Efficiency,schedul,schedule,371,"MWE ; ```julia; grid = RectilinearGrid(size = (5, 5, 5), extent = (1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); c = CenterField(grid; indices = (:, :, grid.Nz)); d = CenterField(grid); JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ```; fails with ; ```julia; julia> JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:1516,Energy Efficiency,schedul,schedule,1516,"; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; It looks like there are problems also if trying to save the windowed field by itself; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test1"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:2191,Energy Efficiency,schedul,schedule,2191,"ns.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; It looks like there are problems also if trying to save the windowed field by itself; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test1"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticF",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:3386,Energy Efficiency,schedul,schedule,3386,"tacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[11]:1; Some type information was truncated. Use `show(err)` to see complete types. ```; However, by specifying the indices it works; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test1"", schedule = IterationInterval(1), indices = (:, :, grid.Nz)); JLD2OutputWriter scheduled on IterationInterval(1):; ├── filepath: ./test1.jld2; ├── 1 outputs: c; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; ├── file_splitting: NoFileSplitting; └── file size: 20.0 KiB. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:4020,Energy Efficiency,schedul,schedule,4020,"tacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[11]:1; Some type information was truncated. Use `show(err)` to see complete types. ```; However, by specifying the indices it works; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test1"", schedule = IterationInterval(1), indices = (:, :, grid.Nz)); JLD2OutputWriter scheduled on IterationInterval(1):; ├── filepath: ./test1.jld2; ├── 1 outputs: c; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; ├── file_splitting: NoFileSplitting; └── file size: 20.0 KiB. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:4098,Energy Efficiency,schedul,scheduled,4098,"tacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[11]:1; Some type information was truncated. Use `show(err)` to see complete types. ```; However, by specifying the indices it works; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test1"", schedule = IterationInterval(1), indices = (:, :, grid.Nz)); JLD2OutputWriter scheduled on IterationInterval(1):; ├── filepath: ./test1.jld2; ├── 1 outputs: c; ├── array type: Array{Float64}; ├── including: [:grid, :coriolis, :buoyancy, :closure]; ├── file_splitting: NoFileSplitting; └── file size: 20.0 KiB. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:242,Testability,test,test,242,"MWE ; ```julia; grid = RectilinearGrid(size = (5, 5, 5), extent = (1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); c = CenterField(grid; indices = (:, :, grid.Nz)); d = CenterField(grid); JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ```; fails with ; ```julia; julia> JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/issues/3835:364,Testability,test,test,364,"MWE ; ```julia; grid = RectilinearGrid(size = (5, 5, 5), extent = (1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); c = CenterField(grid; indices = (:, :, grid.Nz)); d = CenterField(grid); JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ```; fails with ; ```julia; julia> JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835
https://github.com/CliMA/Oceananigans.jl/pull/3838:48,Deployability,update,update,48,🤖 Beep boop. I am GabrieleBOT. 🤖. I received an update so that I can inform you directly of the changes (but feel free to check the [release notes](https://github.com/CliMA/ClimaModules/blob/main/NEWS.md)). The most recent version of climacommon uses the newly released Julia 1.11.0.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3838
https://github.com/CliMA/Oceananigans.jl/pull/3838:133,Deployability,release,release,133,🤖 Beep boop. I am GabrieleBOT. 🤖. I received an update so that I can inform you directly of the changes (but feel free to check the [release notes](https://github.com/CliMA/ClimaModules/blob/main/NEWS.md)). The most recent version of climacommon uses the newly released Julia 1.11.0.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3838
https://github.com/CliMA/Oceananigans.jl/pull/3838:261,Deployability,release,released,261,🤖 Beep boop. I am GabrieleBOT. 🤖. I received an update so that I can inform you directly of the changes (but feel free to check the [release notes](https://github.com/CliMA/ClimaModules/blob/main/NEWS.md)). The most recent version of climacommon uses the newly released Julia 1.11.0.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3838
https://github.com/CliMA/Oceananigans.jl/issues/3840:97,Availability,error,error,97,"I believe the below MWE should work according to the `ScalarDiffusivity` docstring, but from the error it seems to be expecting `funky_diffusion(x, y, z, t)` instead of `funky_diffusion(x, y, z, t, p)`. https://github.com/CliMA/Oceananigans.jl/blob/fe056fb44ce7173ce9e7eaa4f5c349d6ee2b61a4/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L12-L67. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(CPU(), size=(3, 4, 5), extent=(1, 1, 1)). @inline funky_diffusion(x, y, z, t, p) = p.A + p.M * (x+y+z+t). params = (; A=1.2, M=0.7). closure = ScalarDiffusivity(;; ν = funky_diffusion,; κ = funky_diffusion,; parameters = params; ). model = NonhydrostaticModel(; grid, closure). time_step!(model, 0.1); ```. Error:. ```julia; ERROR: MethodError: no method matching funky_diffusion(::Float64, ::Float64, ::Float64, ::Float64). Closest candidates are:; funky_diffusion(::Any, ::Any, ::Any, ::Any, ::Any); @ Main REPL[2]:1. Stacktrace:; [1] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:309 [inlined]; [2] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:84 [inlined]; [3] ν_σᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:154 [inlined]; [4] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:159 [inlined]; [5] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/implicit_explicit_time_discretization.jl:43 [inlined]; [6] _viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:4 [inlined]; [7] Ax_qᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/Operators/products_between_fields_and_grid_metrics.jl:12 [inlined]; [8] δxᶠᵃᵃ; @ ~/atdepth/Oceananigans.jl/src/Operators/difference_operators.jl:21 [inlined]; [9] ∂ⱼ_τ₁ⱼ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:24 [inlined]; [10] u_v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840
https://github.com/CliMA/Oceananigans.jl/issues/3840:745,Availability,Error,Error,745,"I believe the below MWE should work according to the `ScalarDiffusivity` docstring, but from the error it seems to be expecting `funky_diffusion(x, y, z, t)` instead of `funky_diffusion(x, y, z, t, p)`. https://github.com/CliMA/Oceananigans.jl/blob/fe056fb44ce7173ce9e7eaa4f5c349d6ee2b61a4/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L12-L67. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(CPU(), size=(3, 4, 5), extent=(1, 1, 1)). @inline funky_diffusion(x, y, z, t, p) = p.A + p.M * (x+y+z+t). params = (; A=1.2, M=0.7). closure = ScalarDiffusivity(;; ν = funky_diffusion,; κ = funky_diffusion,; parameters = params; ). model = NonhydrostaticModel(; grid, closure). time_step!(model, 0.1); ```. Error:. ```julia; ERROR: MethodError: no method matching funky_diffusion(::Float64, ::Float64, ::Float64, ::Float64). Closest candidates are:; funky_diffusion(::Any, ::Any, ::Any, ::Any, ::Any); @ Main REPL[2]:1. Stacktrace:; [1] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:309 [inlined]; [2] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:84 [inlined]; [3] ν_σᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:154 [inlined]; [4] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:159 [inlined]; [5] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/implicit_explicit_time_discretization.jl:43 [inlined]; [6] _viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:4 [inlined]; [7] Ax_qᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/Operators/products_between_fields_and_grid_metrics.jl:12 [inlined]; [8] δxᶠᵃᵃ; @ ~/atdepth/Oceananigans.jl/src/Operators/difference_operators.jl:21 [inlined]; [9] ∂ⱼ_τ₁ⱼ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:24 [inlined]; [10] u_v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840
https://github.com/CliMA/Oceananigans.jl/issues/3840:763,Availability,ERROR,ERROR,763,"I believe the below MWE should work according to the `ScalarDiffusivity` docstring, but from the error it seems to be expecting `funky_diffusion(x, y, z, t)` instead of `funky_diffusion(x, y, z, t, p)`. https://github.com/CliMA/Oceananigans.jl/blob/fe056fb44ce7173ce9e7eaa4f5c349d6ee2b61a4/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L12-L67. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(CPU(), size=(3, 4, 5), extent=(1, 1, 1)). @inline funky_diffusion(x, y, z, t, p) = p.A + p.M * (x+y+z+t). params = (; A=1.2, M=0.7). closure = ScalarDiffusivity(;; ν = funky_diffusion,; κ = funky_diffusion,; parameters = params; ). model = NonhydrostaticModel(; grid, closure). time_step!(model, 0.1); ```. Error:. ```julia; ERROR: MethodError: no method matching funky_diffusion(::Float64, ::Float64, ::Float64, ::Float64). Closest candidates are:; funky_diffusion(::Any, ::Any, ::Any, ::Any, ::Any); @ Main REPL[2]:1. Stacktrace:; [1] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:309 [inlined]; [2] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:84 [inlined]; [3] ν_σᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:154 [inlined]; [4] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:159 [inlined]; [5] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/implicit_explicit_time_discretization.jl:43 [inlined]; [6] _viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:4 [inlined]; [7] Ax_qᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/Operators/products_between_fields_and_grid_metrics.jl:12 [inlined]; [8] δxᶠᵃᵃ; @ ~/atdepth/Oceananigans.jl/src/Operators/difference_operators.jl:21 [inlined]; [9] ∂ⱼ_τ₁ⱼ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:24 [inlined]; [10] u_v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840
https://github.com/CliMA/Oceananigans.jl/pull/3841:22,Integrability,interface,interface,22,"This PR introduces an interface for `column_height` that returns the height of the water column. ; This is simply `grid.Lz` in regular grids. For `AbstractGridFittedBottom` immersed grids, the column height is readily read from the immersed boundary, provided that the immersed boundary represents the _numerical_ bottom rather than the _physical_ bottom. ; Therefore, this PR changes the constructor of the `ImmersedBoundaryGrid` to store the z-coordinate of the last immersed cell. In this way, the bottom height is also uniquely defined for `GridFittedBottom`, removing the necessity of having a`CenterImmersedCondition` and a `InterfaceImmersedCondition`. . An immediate application of this interface is in the `SplitExplicitFreeSurface` where the bottom_height was previously stored.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841
https://github.com/CliMA/Oceananigans.jl/pull/3841:631,Integrability,Interface,InterfaceImmersedCondition,631,"This PR introduces an interface for `column_height` that returns the height of the water column. ; This is simply `grid.Lz` in regular grids. For `AbstractGridFittedBottom` immersed grids, the column height is readily read from the immersed boundary, provided that the immersed boundary represents the _numerical_ bottom rather than the _physical_ bottom. ; Therefore, this PR changes the constructor of the `ImmersedBoundaryGrid` to store the z-coordinate of the last immersed cell. In this way, the bottom height is also uniquely defined for `GridFittedBottom`, removing the necessity of having a`CenterImmersedCondition` and a `InterfaceImmersedCondition`. . An immediate application of this interface is in the `SplitExplicitFreeSurface` where the bottom_height was previously stored.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841
https://github.com/CliMA/Oceananigans.jl/pull/3841:695,Integrability,interface,interface,695,"This PR introduces an interface for `column_height` that returns the height of the water column. ; This is simply `grid.Lz` in regular grids. For `AbstractGridFittedBottom` immersed grids, the column height is readily read from the immersed boundary, provided that the immersed boundary represents the _numerical_ bottom rather than the _physical_ bottom. ; Therefore, this PR changes the constructor of the `ImmersedBoundaryGrid` to store the z-coordinate of the last immersed cell. In this way, the bottom height is also uniquely defined for `GridFittedBottom`, removing the necessity of having a`CenterImmersedCondition` and a `InterfaceImmersedCondition`. . An immediate application of this interface is in the `SplitExplicitFreeSurface` where the bottom_height was previously stored.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841
https://github.com/CliMA/Oceananigans.jl/pull/3841:107,Usability,simpl,simply,107,"This PR introduces an interface for `column_height` that returns the height of the water column. ; This is simply `grid.Lz` in regular grids. For `AbstractGridFittedBottom` immersed grids, the column height is readily read from the immersed boundary, provided that the immersed boundary represents the _numerical_ bottom rather than the _physical_ bottom. ; Therefore, this PR changes the constructor of the `ImmersedBoundaryGrid` to store the z-coordinate of the last immersed cell. In this way, the bottom height is also uniquely defined for `GridFittedBottom`, removing the necessity of having a`CenterImmersedCondition` and a `InterfaceImmersedCondition`. . An immediate application of this interface is in the `SplitExplicitFreeSurface` where the bottom_height was previously stored.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841
https://github.com/CliMA/Oceananigans.jl/issues/3845:37,Availability,checkpoint,checkpoint,37,"It looks like that restarting from a checkpoint is not bit-for-bit? I think the issue is that when restarting from a checkpoint the time step is not restored -- it is still using the initial time step defined in `Simulation()`, not the `last_Δt` from the saved `Clock` object in the checkpoint file. See the example below, which is the output of the attached test case. . In the pickup run I changed the onscreen output from every 10 iterations to every 1 iterations to see the time step. Rather than using the previous time step (5.973 s) from the checkpoint, the pickup run is using a time step of 10 s which is the value when defining `simulation = Simulation(model, Δt=10, stop_iteration=220)`. I’m using v0.91.5. Initial run; ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, max(|u|) = 2.5e-01 ms⁻¹, wall time: 0 seconds; [ Info: ... simulation initialization complete (13.909 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.696 seconds).; Iteration: 0010, time: 1.833 minutes, Δt: 11.212 seconds, max(|u|) = 2.6e-01 ms⁻¹, wall time: 19.116 seconds; Iteration: 0020, time: 3.702 minutes, Δt: 10.681 seconds, max(|u|) = 2.8e-01 ms⁻¹, wall time: 19.345 seconds; Iteration: 0030, time: 5.482 minutes, Δt: 10.215 seconds, max(|u|) = 2.9e-01 ms⁻¹, wall time: 19.629 seconds; Iteration: 0040, time: 7.185 minutes, Δt: 9.802 seconds, max(|u|) = 3.0e-01 ms⁻¹, wall time: 19.854 seconds; Iteration: 0050, time: 8.819 minutes, Δt: 9.433 seconds, max(|u|) = 3.1e-01 ms⁻¹, wall time: 20.082 seconds; Iteration: 0060, time: 10.391 minutes, Δt: 9.100 seconds, max(|u|) = 3.2e-01 ms⁻¹, wall time: 20.306 seconds; Iteration: 0070, time: 11.907 minutes, Δt: 8.798 seconds, max(|u|) = 3.3e-01 ms⁻¹, wall time: 20.559 seconds; Iteration: 0080, time: 13.374 minutes, Δt: 8.523 seconds, max(|u|) = 3.4e-01 ms⁻¹, wall time: 20.773 seconds; Iteration: 0090, time: 14.794 minutes, Δt: 8.270 seconds, max(|u|) = 3.5e-01 ms⁻¹, wall time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845
https://github.com/CliMA/Oceananigans.jl/issues/3845:117,Availability,checkpoint,checkpoint,117,"It looks like that restarting from a checkpoint is not bit-for-bit? I think the issue is that when restarting from a checkpoint the time step is not restored -- it is still using the initial time step defined in `Simulation()`, not the `last_Δt` from the saved `Clock` object in the checkpoint file. See the example below, which is the output of the attached test case. . In the pickup run I changed the onscreen output from every 10 iterations to every 1 iterations to see the time step. Rather than using the previous time step (5.973 s) from the checkpoint, the pickup run is using a time step of 10 s which is the value when defining `simulation = Simulation(model, Δt=10, stop_iteration=220)`. I’m using v0.91.5. Initial run; ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, max(|u|) = 2.5e-01 ms⁻¹, wall time: 0 seconds; [ Info: ... simulation initialization complete (13.909 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.696 seconds).; Iteration: 0010, time: 1.833 minutes, Δt: 11.212 seconds, max(|u|) = 2.6e-01 ms⁻¹, wall time: 19.116 seconds; Iteration: 0020, time: 3.702 minutes, Δt: 10.681 seconds, max(|u|) = 2.8e-01 ms⁻¹, wall time: 19.345 seconds; Iteration: 0030, time: 5.482 minutes, Δt: 10.215 seconds, max(|u|) = 2.9e-01 ms⁻¹, wall time: 19.629 seconds; Iteration: 0040, time: 7.185 minutes, Δt: 9.802 seconds, max(|u|) = 3.0e-01 ms⁻¹, wall time: 19.854 seconds; Iteration: 0050, time: 8.819 minutes, Δt: 9.433 seconds, max(|u|) = 3.1e-01 ms⁻¹, wall time: 20.082 seconds; Iteration: 0060, time: 10.391 minutes, Δt: 9.100 seconds, max(|u|) = 3.2e-01 ms⁻¹, wall time: 20.306 seconds; Iteration: 0070, time: 11.907 minutes, Δt: 8.798 seconds, max(|u|) = 3.3e-01 ms⁻¹, wall time: 20.559 seconds; Iteration: 0080, time: 13.374 minutes, Δt: 8.523 seconds, max(|u|) = 3.4e-01 ms⁻¹, wall time: 20.773 seconds; Iteration: 0090, time: 14.794 minutes, Δt: 8.270 seconds, max(|u|) = 3.5e-01 ms⁻¹, wall time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845
https://github.com/CliMA/Oceananigans.jl/issues/3845:283,Availability,checkpoint,checkpoint,283,"It looks like that restarting from a checkpoint is not bit-for-bit? I think the issue is that when restarting from a checkpoint the time step is not restored -- it is still using the initial time step defined in `Simulation()`, not the `last_Δt` from the saved `Clock` object in the checkpoint file. See the example below, which is the output of the attached test case. . In the pickup run I changed the onscreen output from every 10 iterations to every 1 iterations to see the time step. Rather than using the previous time step (5.973 s) from the checkpoint, the pickup run is using a time step of 10 s which is the value when defining `simulation = Simulation(model, Δt=10, stop_iteration=220)`. I’m using v0.91.5. Initial run; ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, max(|u|) = 2.5e-01 ms⁻¹, wall time: 0 seconds; [ Info: ... simulation initialization complete (13.909 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.696 seconds).; Iteration: 0010, time: 1.833 minutes, Δt: 11.212 seconds, max(|u|) = 2.6e-01 ms⁻¹, wall time: 19.116 seconds; Iteration: 0020, time: 3.702 minutes, Δt: 10.681 seconds, max(|u|) = 2.8e-01 ms⁻¹, wall time: 19.345 seconds; Iteration: 0030, time: 5.482 minutes, Δt: 10.215 seconds, max(|u|) = 2.9e-01 ms⁻¹, wall time: 19.629 seconds; Iteration: 0040, time: 7.185 minutes, Δt: 9.802 seconds, max(|u|) = 3.0e-01 ms⁻¹, wall time: 19.854 seconds; Iteration: 0050, time: 8.819 minutes, Δt: 9.433 seconds, max(|u|) = 3.1e-01 ms⁻¹, wall time: 20.082 seconds; Iteration: 0060, time: 10.391 minutes, Δt: 9.100 seconds, max(|u|) = 3.2e-01 ms⁻¹, wall time: 20.306 seconds; Iteration: 0070, time: 11.907 minutes, Δt: 8.798 seconds, max(|u|) = 3.3e-01 ms⁻¹, wall time: 20.559 seconds; Iteration: 0080, time: 13.374 minutes, Δt: 8.523 seconds, max(|u|) = 3.4e-01 ms⁻¹, wall time: 20.773 seconds; Iteration: 0090, time: 14.794 minutes, Δt: 8.270 seconds, max(|u|) = 3.5e-01 ms⁻¹, wall time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845
https://github.com/CliMA/Oceananigans.jl/issues/3845:549,Availability,checkpoint,checkpoint,549,"It looks like that restarting from a checkpoint is not bit-for-bit? I think the issue is that when restarting from a checkpoint the time step is not restored -- it is still using the initial time step defined in `Simulation()`, not the `last_Δt` from the saved `Clock` object in the checkpoint file. See the example below, which is the output of the attached test case. . In the pickup run I changed the onscreen output from every 10 iterations to every 1 iterations to see the time step. Rather than using the previous time step (5.973 s) from the checkpoint, the pickup run is using a time step of 10 s which is the value when defining `simulation = Simulation(model, Δt=10, stop_iteration=220)`. I’m using v0.91.5. Initial run; ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, max(|u|) = 2.5e-01 ms⁻¹, wall time: 0 seconds; [ Info: ... simulation initialization complete (13.909 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.696 seconds).; Iteration: 0010, time: 1.833 minutes, Δt: 11.212 seconds, max(|u|) = 2.6e-01 ms⁻¹, wall time: 19.116 seconds; Iteration: 0020, time: 3.702 minutes, Δt: 10.681 seconds, max(|u|) = 2.8e-01 ms⁻¹, wall time: 19.345 seconds; Iteration: 0030, time: 5.482 minutes, Δt: 10.215 seconds, max(|u|) = 2.9e-01 ms⁻¹, wall time: 19.629 seconds; Iteration: 0040, time: 7.185 minutes, Δt: 9.802 seconds, max(|u|) = 3.0e-01 ms⁻¹, wall time: 19.854 seconds; Iteration: 0050, time: 8.819 minutes, Δt: 9.433 seconds, max(|u|) = 3.1e-01 ms⁻¹, wall time: 20.082 seconds; Iteration: 0060, time: 10.391 minutes, Δt: 9.100 seconds, max(|u|) = 3.2e-01 ms⁻¹, wall time: 20.306 seconds; Iteration: 0070, time: 11.907 minutes, Δt: 8.798 seconds, max(|u|) = 3.3e-01 ms⁻¹, wall time: 20.559 seconds; Iteration: 0080, time: 13.374 minutes, Δt: 8.523 seconds, max(|u|) = 3.4e-01 ms⁻¹, wall time: 20.773 seconds; Iteration: 0090, time: 14.794 minutes, Δt: 8.270 seconds, max(|u|) = 3.5e-01 ms⁻¹, wall time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845
https://github.com/CliMA/Oceananigans.jl/issues/3845:359,Testability,test,test,359,"It looks like that restarting from a checkpoint is not bit-for-bit? I think the issue is that when restarting from a checkpoint the time step is not restored -- it is still using the initial time step defined in `Simulation()`, not the `last_Δt` from the saved `Clock` object in the checkpoint file. See the example below, which is the output of the attached test case. . In the pickup run I changed the onscreen output from every 10 iterations to every 1 iterations to see the time step. Rather than using the previous time step (5.973 s) from the checkpoint, the pickup run is using a time step of 10 s which is the value when defining `simulation = Simulation(model, Δt=10, stop_iteration=220)`. I’m using v0.91.5. Initial run; ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, max(|u|) = 2.5e-01 ms⁻¹, wall time: 0 seconds; [ Info: ... simulation initialization complete (13.909 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.696 seconds).; Iteration: 0010, time: 1.833 minutes, Δt: 11.212 seconds, max(|u|) = 2.6e-01 ms⁻¹, wall time: 19.116 seconds; Iteration: 0020, time: 3.702 minutes, Δt: 10.681 seconds, max(|u|) = 2.8e-01 ms⁻¹, wall time: 19.345 seconds; Iteration: 0030, time: 5.482 minutes, Δt: 10.215 seconds, max(|u|) = 2.9e-01 ms⁻¹, wall time: 19.629 seconds; Iteration: 0040, time: 7.185 minutes, Δt: 9.802 seconds, max(|u|) = 3.0e-01 ms⁻¹, wall time: 19.854 seconds; Iteration: 0050, time: 8.819 minutes, Δt: 9.433 seconds, max(|u|) = 3.1e-01 ms⁻¹, wall time: 20.082 seconds; Iteration: 0060, time: 10.391 minutes, Δt: 9.100 seconds, max(|u|) = 3.2e-01 ms⁻¹, wall time: 20.306 seconds; Iteration: 0070, time: 11.907 minutes, Δt: 8.798 seconds, max(|u|) = 3.3e-01 ms⁻¹, wall time: 20.559 seconds; Iteration: 0080, time: 13.374 minutes, Δt: 8.523 seconds, max(|u|) = 3.4e-01 ms⁻¹, wall time: 20.773 seconds; Iteration: 0090, time: 14.794 minutes, Δt: 8.270 seconds, max(|u|) = 3.5e-01 ms⁻¹, wall time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845
https://github.com/CliMA/Oceananigans.jl/pull/3848:2464,Energy Efficiency,schedul,schedule,2464,"bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); reduced_precision_grid = with_number_type(Float32, grid.underlying_grid); preconditioner = fft_poisson_solver(reduced_precision_grid); pressure_solver = ConjugateGradientPoissonSolver(grid; preconditioner, maxiter=1000, regularization=1/N^3). model = NonhydrostaticModel(; grid, boundary_conditions, pressure_solver); simulation = Simulation(model; Δt=0.1, stop_iteration=1000); conjure_time_step_wizard!(simulation, cfl=0.5). u, v, w = model.velocities; δ = ∂x(u) + ∂y(v) + ∂z(w). function progress(sim); model = sim.model; u, v, w = model.velocities; @printf(""Iter: %d, time: %.1f, Δt: %.2e, max|δ|: %.2e"",; iteration(sim), time(sim), sim.Δt, maximum(abs, δ)). r = model.pressure_solver.conjugate_gradient_solver.residual; @printf("", solver iterations: %d, max|r|: %.2e\n"",; iteration(model.pressure_solver), maximum(abs, r)); end. add_callback!(simulation, progress). simulation.output_writers[:fields] =; JLD2OutputWriter(model, model.velocities; filename=""3831.jld2"", schedule=IterationInterval(10), overwrite_existing=true). run!(simulation). using GLMakie. ds = FieldDataset(""3831.jld2""); fig = Figure(size=(1000, 500)). n = Observable(1); times = ds[""u""].times; title = @lift @sprintf(""time = %s"", prettytime(times[$n])). Nx, Ny, Nz = size(grid); j = round(Int, Ny/2); k = round(Int, Nz/2); u_surface = @lift view(ds[""u""][$n], :, :, k); u_slice = @lift view(ds[""u""][$n], :, j, :). ax1 = Axis(fig[1, 1]; title = ""u (xy)"", xlabel=""x"", ylabel=""y""); hm1 = heatmap!(ax1, u_surface, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 2], hm1, label=""m/s""). ax2 = Axis(fig[1, 3]; title = ""u (xz)"", xlabel=""x"", ylabel=""z""); hm2 = heatmap!(ax2, u_slice, colorrange=(-0.01, 0.01), colormap=:balance); Colorbar(fig[1, 4], hm2, label=""m/s""). fig[0, :] = Label(fig, title). record(fig, ""3831.mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3848
https://github.com/CliMA/Oceananigans.jl/issues/3851:1081,Availability,ERROR,ERROR,1081,"This may be harmless as all tests passed anyways, e.g. see the log from the last test of PR #3847: https://buildkite.com/clima/oceananigans/builds/18103#0192adf8-82f6-48e6-b72e-131502fdfcfc/26-746. But maybe there are some performance implications?. Output when running `using Oceananigans`:; ```; julia> using Oceananigans; Precompiling Oceananigans; Info Given Oceananigans was explicitly requested, output will be shown live ; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; ? Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851
https://github.com/CliMA/Oceananigans.jl/issues/3851:1847,Availability,ERROR,ERROR,1847,"This may be harmless as all tests passed anyways, e.g. see the log from the last test of PR #3847: https://buildkite.com/clima/oceananigans/builds/18103#0192adf8-82f6-48e6-b72e-131502fdfcfc/26-746. But maybe there are some performance implications?. Output when running `using Oceananigans`:; ```; julia> using Oceananigans; Precompiling Oceananigans; Info Given Oceananigans was explicitly requested, output will be shown live ; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; ? Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851
https://github.com/CliMA/Oceananigans.jl/issues/3851:330,Performance,perform,performance,330,"Probably as a result of PR #3847, on the `main` branch precompiation fails due to some method overwriting. This may be harmless as all tests passed anyways, e.g. see the log from the last test of PR #3847: https://buildkite.com/clima/oceananigans/builds/18103#0192adf8-82f6-48e6-b72e-131502fdfcfc/26-746. But maybe there are some performance implications?. Output when running `using Oceananigans`:; ```; julia> using Oceananigans; Precompiling Oceananigans; Info Given Oceananigans was explicitly requested, output will be shown live ; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; ? Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; [ Info: Skipping preco",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851
https://github.com/CliMA/Oceananigans.jl/issues/3851:135,Testability,test,tests,135,"Probably as a result of PR #3847, on the `main` branch precompiation fails due to some method overwriting. This may be harmless as all tests passed anyways, e.g. see the log from the last test of PR #3847: https://buildkite.com/clima/oceananigans/builds/18103#0192adf8-82f6-48e6-b72e-131502fdfcfc/26-746. But maybe there are some performance implications?. Output when running `using Oceananigans`:; ```; julia> using Oceananigans; Precompiling Oceananigans; Info Given Oceananigans was explicitly requested, output will be shown live ; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; ? Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; [ Info: Skipping preco",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851
https://github.com/CliMA/Oceananigans.jl/issues/3851:170,Testability,log,log,170,"Probably as a result of PR #3847, on the `main` branch precompiation fails due to some method overwriting. This may be harmless as all tests passed anyways, e.g. see the log from the last test of PR #3847: https://buildkite.com/clima/oceananigans/builds/18103#0192adf8-82f6-48e6-b72e-131502fdfcfc/26-746. But maybe there are some performance implications?. Output when running `using Oceananigans`:; ```; julia> using Oceananigans; Precompiling Oceananigans; Info Given Oceananigans was explicitly requested, output will be shown live ; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; ? Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; [ Info: Skipping preco",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851
https://github.com/CliMA/Oceananigans.jl/issues/3851:188,Testability,test,test,188,"Probably as a result of PR #3847, on the `main` branch precompiation fails due to some method overwriting. This may be harmless as all tests passed anyways, e.g. see the log from the last test of PR #3847: https://buildkite.com/clima/oceananigans/builds/18103#0192adf8-82f6-48e6-b72e-131502fdfcfc/26-746. But maybe there are some performance implications?. Output when running `using Oceananigans`:; ```; julia> using Oceananigans; Precompiling Oceananigans; Info Given Oceananigans was explicitly requested, output will be shown live ; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; ? Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; [ Info: Skipping preco",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851
https://github.com/CliMA/Oceananigans.jl/issues/3852:128,Availability,down,down,128,"I'm trying to add some particles to a hydrostatic model on a lat-lon grid, but ran into some CUDA memory issues. After reducing down to a MWE I noticed that it also segfaults on the CPU. The MWE seems to be sensitive to the exact grid. Some lat-lon ranges lead to illegal memory accesses and others do not. I could not find a pattern though. On the CPU the segfault seems to occur after ~2 iterations. On the GPU after ~29 iterations. The particles are initialized within the domain and without any dynamics the particles should stay perfectly still. So I'm not sure where the illegal memory access is happening, but should be easy to debug on the CPU?. MWE:. ```julia; using Oceananigans; using Oceananigans.Architectures: on_architecture. arch = GPU(). H = 100. Nλ = 100; Nφ = 200; Nz = 60. grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (Nλ, Nφ, Nz),; longitude = (0.79, 1.23),; latitude = (-1.96, -1.12),; z = (-H, 0),; halo = (4, 4, 4); ). Np = 100 # Number of particles. particles = LagrangianParticles(; x = on_architecture(arch, 1 * ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:1425,Availability,fault,fault,1425,"are initialized within the domain and without any dynamics the particles should stay perfectly still. So I'm not sure where the illegal memory access is happening, but should be easy to debug on the CPU?. MWE:. ```julia; using Oceananigans; using Oceananigans.Architectures: on_architecture. arch = GPU(). H = 100. Nλ = 100; Nφ = 200; Nz = 60. grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (Nλ, Nφ, Nz),; longitude = (0.79, 1.23),; latitude = (-1.96, -1.12),; z = (-H, 0),; halo = (4, 4, 4); ). Np = 100 # Number of particles. particles = LagrangianParticles(; x = on_architecture(arch, 1 * ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-do",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:9408,Availability,error,error,9408,"entials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA er",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:10295,Availability,ERROR,ERROR,10295,"ted by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.Dev",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:10318,Availability,error,error,10318,"ted by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.Dev",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:2120,Deployability,release,release-,2120,"* ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:2229,Deployability,release,release-,2229,"ostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:2437,Deployability,release,release-,2437,] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.j,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:2546,Deployability,release,release-,2546, advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:2714,Deployability,release,release-,2714,Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Mo,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:2823,Deployability,release,release-,2823,; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /h,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:2913,Deployability,release,release-,2913,lined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:3016,Deployability,release,release-,3016,tions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip:,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:3190,Deployability,release,release-,3190,ply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:3299,Deployability,release,release-,3299,t /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/par,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:4071,Deployability,release,release-,4071,10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:4180,Deployability,release,release-,4180,e/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:4360,Deployability,release,release-,4360,t_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:4468,Deployability,release,release-,4468,an_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-re,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:4575,Deployability,release,release-,4575,agrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-relea,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:4742,Deployability,release,release-,4742,eModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_th,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:4851,Deployability,release,release-,4851,ns.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_tople,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5041,Deployability,release,release-,5041,0a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5150,Deployability,release,release-,5150,ply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5240,Deployability,release,release-,5240,l scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5342,Deployability,release,release-,5342,build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-releas,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5442,Deployability,release,release-,5442,che/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5547,Deployability,release,release-,5547,t /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backe,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5656,Deployability,release,release-,5656,[inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5773,Deployability,release,release-,5773,se-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/sh,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5884,Deployability,release,release-,5884,-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:5992,Deployability,release,release-,5992,00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdc,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:6100,Deployability,release,release-,6100,ined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amd,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:6208,Deployability,release,release-,6208,_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialan,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:6315,Deployability,release,release-,6315,l at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:6450,Deployability,release,release-,6450,alang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:6585,Deployability,release,release-,6585,nterpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:6725,Deployability,release,release-,6725,et_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:6861,Deployability,release,release-,6861,/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_i,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:6989,Deployability,release,release-,6989,amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cac,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:7098,Deployability,release,release-,7098,builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/bu,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:7192,Deployability,release,release-,7192,lder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/b,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:7318,Deployability,release,release-,7318,ng/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelat,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:7560,Deployability,release,release-,7560,oop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.s,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:7669,Deployability,release,release-,7669,c/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:28,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:7900,Deployability,release,release-,7900,ot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cach,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:8009,Deployability,release,release-,8009,lang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/bu,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:8099,Deployability,release,release-,8099,-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:8211,Deployability,release,release-,8211,ng/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __l,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:8611,Deployability,release,release-,8611,".c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Inf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:8720,Deployability,release,release-,8720,"/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iterati",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:8810,Deployability,release,release-,8810,"+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:8914,Deployability,release,release-,8914,"lang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:9016,Deployability,release,release-,9016,"/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17..",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:9104,Deployability,release,release-,9104,"ang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11570,Energy Efficiency,Adapt,Adapt,11570,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11586,Energy Efficiency,Adapt,Adapt,11586,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11614,Energy Efficiency,adapt,adapt,11614,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11641,Energy Efficiency,Adapt,Adapt,11641,"ckages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407 [inlined]; [23] initialize_free_sur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11657,Energy Efficiency,Adapt,Adapt,11657,"ckages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407 [inlined]; [23] initialize_free_sur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11570,Modifiability,Adapt,Adapt,11570,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11586,Modifiability,Adapt,Adapt,11586,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11614,Modifiability,adapt,adapt,11614,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11641,Modifiability,Adapt,Adapt,11641,"ckages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407 [inlined]; [23] initialize_free_sur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:11657,Modifiability,Adapt,Adapt,11657,"ckages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407 [inlined]; [23] initialize_free_sur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:2075,Performance,cache,cache,2075,"* ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
https://github.com/CliMA/Oceananigans.jl/issues/3852:2184,Performance,cache,cache,2184,"ostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852
