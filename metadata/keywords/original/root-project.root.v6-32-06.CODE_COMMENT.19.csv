id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:66,Testability,assert,assertions,66,"// While globals are generally bad, this one allows us to perform assertions; // liberally and somehow still trace them back to the def they indirectly; // came from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:3,Testability,Log,Logical,3,// Logical instructions which are op instructions; // but we need to not emit any suffix for in our; // tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:104,Testability,test,tests,104,// Logical instructions which are op instructions; // but we need to not emit any suffix for in our; // tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:32,Testability,test,test,32,// Instructions which we do not test since they are; // not TRUE instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:209,Integrability,wrap,wrapper,209,"//===----------------------------------------------------------------------===//; // TypeSpec; //===----------------------------------------------------------------------===//; /// A TypeSpec is just a simple wrapper around a string, but gets its own type; /// for strong typing purposes.; ///; /// A TypeSpec can be used to create a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:202,Usability,simpl,simple,202,"//===----------------------------------------------------------------------===//; // TypeSpec; //===----------------------------------------------------------------------===//; /// A TypeSpec is just a simple wrapper around a string, but gets its own type; /// for strong typing purposes.; ///; /// A TypeSpec can be used to create a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:85,Modifiability,Variab,Variable,85,//===----------------------------------------------------------------------===//; // Variable; //===----------------------------------------------------------------------===//; /// A variable is a simple class that just has a type and a name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:183,Modifiability,variab,variable,183,//===----------------------------------------------------------------------===//; // Variable; //===----------------------------------------------------------------------===//; /// A variable is a simple class that just has a type and a name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:197,Usability,simpl,simple,197,//===----------------------------------------------------------------------===//; // Variable; //===----------------------------------------------------------------------===//; /// A variable is a simple class that just has a type and a name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:22,Safety,safe,safe,22,/// Is this intrinsic safe for big-endian? or does it need its arguments; /// reversing?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:58,Modifiability,polymorphi,polymorphic,58,/// The index of the key type passed to CGBuiltin.cpp for polymorphic calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:14,Modifiability,variab,variables,14,/// The local variables defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:45,Integrability,depend,depends,45,/// NeededEarly - set if any other intrinsic depends on this intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:15,Modifiability,variab,variable,15,/// The return variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:32,Modifiability,variab,variable,32,"/// A postfix to apply to every variable. Defaults to """".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:81,Modifiability,variab,variables,81,"// Modify the TypeSpec per-argument to get a concrete Type, and create; // known variables for each.; // Types[0] is the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:233,Safety,avoid,avoid,233,"// If this builtin takes an immediate argument, we need to #define it rather; // than use a standard declaration, so that SemaChecking can range check; // the immediate passed by the user.; // Pointer arguments need to use macros to avoid hiding aligned attributes; // from the pointer type.; // It is not permitted to pass or return an __fp16 by value, so intrinsics; // taking a scalar float16_t must be implemented as macros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:91,Integrability,depend,dependencies,91,"/// Get the set of Intrinsics that this intrinsic calls.; /// this is the set of immediate dependencies, NOT the; /// transitive closure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:43,Integrability,depend,dependency,43,"/// Perform type checking and populate the dependency graph, but; /// don't generate code yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:4,Performance,Perform,Perform,4,"/// Perform type checking and populate the dependency graph, but; /// don't generate code yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:81,Modifiability,variab,variables,81,"// Modify the TypeSpec per-argument to get a concrete Type, and create; // known variables for each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:19,Modifiability,variab,variable,19,"// Create a return variable, if we're not void.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:72,Modifiability,variab,variable,72,"// MOD can take several forms:; // 1. $X - take the type of parameter / variable X.; // 2. The value ""R"" - take the type of the return type.; // 3. a type string; // 4. The value ""U"" or ""S"" to switch the signedness.; // 5. The value ""H"" or ""D"" to half or double the bitwidth.; // 6. The value ""8"" to convert to 8-bit (signed) integer lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:3,Safety,Avoid,Avoid,3,// Avoid duplicated code for big and little endian,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:32,Usability,simpl,simple,32,// Little endian intrinsics are simple and don't require any argument; // swapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:113,Performance,load,loaded,113,"// Big endian intrinsics are more complex. The user intended these; // intrinsics to operate on a vector ""as-if"" loaded by (V)LDR,; // but we load as-if (V)LD1. So we should swap all arguments and; // swap the return value too.; //; // If we call sub-intrinsics, we should call a version that does; // not re-swap the arguments!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:142,Performance,load,load,142,"// Big endian intrinsics are more complex. The user intended these; // intrinsics to operate on a vector ""as-if"" loaded by (V)LDR,; // but we load as-if (V)LD1. So we should swap all arguments and; // swap the return value too.; //; // If we call sub-intrinsics, we should call a version that does; // not re-swap the arguments!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:203,Integrability,Depend,Dependencies,203,"// If we call a macro, our local variables may be corrupted due to; // lack of proper lexical scoping. So, add a globally unique postfix; // to every variable.; //; // indexBody() should have set up the Dependencies set by now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:33,Modifiability,variab,variables,33,"// If we call a macro, our local variables may be corrupted due to; // lack of proper lexical scoping. So, add a globally unique postfix; // to every variable.; //; // indexBody() should have set up the Dependencies set by now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:150,Modifiability,variab,variable,150,"// If we call a macro, our local variables may be corrupted due to; // lack of proper lexical scoping. So, add a globally unique postfix; // to every variable.; //; // indexBody() should have set up the Dependencies set by now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:15,Modifiability,variab,variable,15,// Emit return variable declaration first as to not trigger; // -Wdeclaration-after-statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:15,Modifiability,variab,variable,15,// Emit return variable declaration first as to not trigger; // -Wdeclaration-after-statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:157,Availability,Mask,Mask,157,// We record each overload check line before emitting because subsequent Inst; // definitions may extend the number of permitted types (i.e. augment the; // Mask). Use std::map to avoid sorting the table by hash number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:98,Modifiability,extend,extend,98,// We record each overload check line before emitting because subsequent Inst; // definitions may extend the number of permitted types (i.e. augment the; // Mask). Use std::map to avoid sorting the table by hash number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:180,Safety,avoid,avoid,180,// We record each overload check line before emitting because subsequent Inst; // definitions may extend the number of permitted types (i.e. augment the; // Mask). Use std::map to avoid sorting the table by hash number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:207,Security,hash,hash,207,// We record each overload check line before emitting because subsequent Inst; // definitions may extend the number of permitted types (i.e. augment the; // Mask). Use std::map to avoid sorting the table by hash number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:243,Performance,load,load,243,"// Omit type checking for the pointer arguments of vld1_lane, vld1_dup,; // vst1_lane, vldap1_lane, and vstl1_lane intrinsics. Using a pointer to; // the vector element type with one of those operations causes codegen to; // select an aligned load/store instruction. If you want an unaligned; // operation, the pointer argument needs to have less alignment than element; // type, so just accept any pointer type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:217,Security,validat,validation,217,/// runHeader - Emit a file with sections defining:; /// 1. the NEON section of BuiltinsARM.def and BuiltinsAArch64.def.; /// 2. the SemaChecking code for the type overload checking.; /// 3. the SemaChecking code for validation of intrinsic immediate arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:43,Integrability,depend,depends,43,"// For now, signedness of polynomial types depends on target",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp:19,Availability,mask,mask,19,"// Supported type, mask of BasicType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp:49,Performance,load,load,49,"// Number of field, large than 1 if it's segment load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp:3,Availability,Mask,Masked,3,// Masked reduction cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp:134,Energy Efficiency,reduce,reduce,134,"// Sort signature entries by length, let longer signature insert first, to; // make it more possible to reuse table entries, that can reduce ~10% table; // size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp:12,Availability,mask,masked,12,// Create a masked intrinsic,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/SveEmitter.cpp:50,Availability,mask,mask,50,// Returns the SVETypeFlags for a given value and mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/SveEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/SveEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/TableGen.cpp:132,Security,sanitiz,sanitizer,132,// Disable LeakSanitizer for this binary as it has too many leaks that are not; // very interesting to fix. See compiler-rt/include/sanitizer/lsan_interface.h .,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/TableGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/TableGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/TableGenBackends.h:267,Modifiability,inherit,inherit,267,"/**; @param PriorizeIfSubclassOf These classes should be prioritized in the output.; This is useful to force enum generation/jump tables/lookup tables to be more; compact in both size and surrounding code in hot functions. An example use is; in Decl for classes that inherit from DeclContext, for functions like; castFromDeclContext.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/TableGen/TableGenBackends.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/TableGenBackends.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc:58,Testability,test,testcase,58,// The return type for each function when doing covariant testcase generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/VtableTest/gen.cc,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc:56,Modifiability,polymorphi,polymorphic,56,"// We have a vtable and rtti, but technically we're not polymorphic; // polymorphic = true;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/VtableTest/gen.cc,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc:72,Modifiability,polymorphi,polymorphic,72,"// We have a vtable and rtti, but technically we're not polymorphic; // polymorphic = true;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/VtableTest/gen.cc,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc:48,Deployability,update,update,48,"// The previous base dominates the new base, no update necessary",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/VtableTest/gen.cc,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc:24,Testability,test,testcases,24,// PARAM: Randomly size testcases or large testcases?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/VtableTest/gen.cc,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc:43,Testability,test,testcases,43,// PARAM: Randomly size testcases or large testcases?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/utils/VtableTest/gen.cc,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/VtableTest/gen.cc
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/builtins.py:98,Integrability,depend,depending,98,"# Special unhandled cases:; # __builtin_ia32_vec_ext_*(__P, idx) -> _mm_store_sd/_mm_storeh_pd; # depending on index. No abstract insert/extract for these oddly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/www/builtins.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/builtins.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js:18,Integrability,wrap,wrapping,18,// We found a div wrapping a cell content whose height exceeds ; // CLIP_HEIGHT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js:40,Integrability,wrap,wrapper,40,// Create an expander and an additional wrapper for a cell content.; //; // --- expandableDiv ----; // --- expandableDiv --- | ------ data ------ |; // | cell content | -> | | cell content | | ; // --------------------- | ------------------ |; // | ---- expander ---- |; // ----------------------,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js:3,Deployability,Update,Update,3,// Update all cells (height and expanded/collapsed state) in a row according ; // to the new height of the row.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scripts/expandcollapse.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:55,Deployability,configurat,configuration,55,# -*- coding: utf-8 -*-; #; # LLVM documentation build configuration file.; #; # This file is execfile()d with the current directory set to its containing dir.; #; # Note that not all possible configuration values are present in this; # autogenerated file.; #; # All configuration values have a default; values that are commented out; # serve to show the default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:193,Deployability,configurat,configuration,193,# -*- coding: utf-8 -*-; #; # LLVM documentation build configuration file.; #; # This file is execfile()d with the current directory set to its containing dir.; #; # Note that not all possible configuration values are present in this; # autogenerated file.; #; # All configuration values have a default; values that are commented out; # serve to show the default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:267,Deployability,configurat,configuration,267,# -*- coding: utf-8 -*-; #; # LLVM documentation build configuration file.; #; # This file is execfile()d with the current directory set to its containing dir.; #; # Note that not all possible configuration values are present in this; # autogenerated file.; #; # All configuration values have a default; values that are commented out; # serve to show the default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:55,Modifiability,config,configuration,55,# -*- coding: utf-8 -*-; #; # LLVM documentation build configuration file.; #; # This file is execfile()d with the current directory set to its containing dir.; #; # Note that not all possible configuration values are present in this; # autogenerated file.; #; # All configuration values have a default; values that are commented out; # serve to show the default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:193,Modifiability,config,configuration,193,# -*- coding: utf-8 -*-; #; # LLVM documentation build configuration file.; #; # This file is execfile()d with the current directory set to its containing dir.; #; # Note that not all possible configuration values are present in this; # autogenerated file.; #; # All configuration values have a default; values that are commented out; # serve to show the default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:267,Modifiability,config,configuration,267,# -*- coding: utf-8 -*-; #; # LLVM documentation build configuration file.; #; # This file is execfile()d with the current directory set to its containing dir.; #; # Note that not all possible configuration values are present in this; # autogenerated file.; #; # All configuration values have a default; values that are commented out; # serve to show the default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:13,Deployability,configurat,configuration,13,"# -- General configuration -----------------------------------------------------; # If your documentation needs a minimal Sphinx version, state it here.; # needs_sphinx = '1.0'; # Add any Sphinx extension module names here, as strings. They can be extensions; # coming with Sphinx (named 'sphinx.ext.*') or your custom ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:13,Modifiability,config,configuration,13,"# -- General configuration -----------------------------------------------------; # If your documentation needs a minimal Sphinx version, state it here.; # needs_sphinx = '1.0'; # Add any Sphinx extension module names here, as strings. They can be extensions; # coming with Sphinx (named 'sphinx.ext.*') or your custom ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:112,Availability,avail,available,112,"# Theme options are theme-specific and customize the look and feel of a theme; # further. For a list of options available for each theme, see the; # documentation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:85,Deployability,release,release,85,"# The name for this set of Sphinx documents. If None, it defaults to; # ""<project> v<release> documentation"".; # html_title = None; # A shorter title for the navigation bar. Default is the same as html_title.; # html_short_title = None; # The name of an image file (relative to this directory) to place at the top; # of the sidebar.; # html_logo = None; # The name of an image file (within the static path) to use as favicon of the; # docs. This file should be a Windows icon file (.ico) being 16x16 or 32x32; # pixels large.; # html_favicon = None; # Add any paths that contain custom static files (such as style sheets) here,; # relative to this directory. They are copied after the builtin static files,; # so a file named ""default.css"" will overwrite the builtin ""default.css"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:21,Deployability,update,updated,21,"# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,; # using the given strftime format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:81,Usability,guid,guide,81,# Automatically derive the list of man pages from the contents of the command; # guide subdirectory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:106,Deployability,configurat,configuration,106,"# If true, show URL addresses after external links.; # man_show_urls = False; # FIXME: Define intersphinx configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:106,Modifiability,config,configuration,106,"# If true, show URL addresses after external links.; # man_show_urls = False; # FIXME: Define intersphinx configuration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:129,Safety,abort,abort,129,# Pygment lexer are sometimes out of date (when parsing LLVM for example) or; # wrong. Suppress the warning so the build doesn't abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/docs/conf.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:2,Availability,Error,Error,2,//Error block for array out of bounds,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:13,Performance,load,load,13,//%tape.%d = load i8 *%head.%d,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:2,Availability,Error,Error,2,//Error block for array out of bounds,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:3,Testability,test,test,3,"//%test.%d = icmp uge i8 *%head.%d, %arrmax",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:3,Testability,test,test,3,"//%test.%d = icmp ult i8 *%head.%d, %arr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:3,Testability,test,test,3,"//%test.%d = or i1 %test.%d, %test.%d",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:20,Testability,test,test,20,"//%test.%d = or i1 %test.%d, %test.%d",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:30,Testability,test,test,30,"//%test.%d = or i1 %test.%d, %test.%d",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:9,Testability,test,test,9,"//br i1 %test.%d, label %main.%d, label %main.%d",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:13,Performance,load,load,13,//%tape.%d = load i8 *%head.%d,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:14,Testability,test,test,14,// Write loop test,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:13,Performance,load,load,13,//%tape.%d = load i8 *%head.%d,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:3,Testability,test,test,3,"//%test.%d = icmp eq i8 %tape.%d, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:9,Testability,test,test,9,"//br i1 %test.%d, label %main.%d, label %main.%d",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h:162,Availability,error,error,162,"/// This is the main method. It parses BrainF from in1; /// and returns the module with a function; /// void brainf(); /// containing the resulting code.; /// On error, it calls abort.; /// The caller must delete the returned module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h:178,Safety,abort,abort,178,"/// This is the main method. It parses BrainF from in1; /// and returns the module with a function; /// void brainf(); /// containing the resulting code.; /// On error, it calls abort.; /// The caller must delete the returned module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h:213,Testability,test,testreg,213,/// Names of the different parts of the language.; /// Tape is used for reading and writing the tape.; /// headreg is used for the position of the head.; /// label is used for the labels for the BasicBlocks.; /// testreg is used for testing the loop exit condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h:233,Testability,test,testing,233,/// Names of the different parts of the language.; /// Tape is used for reading and writing the tape.; /// headreg is used for the position of the head.; /// label is used for the labels for the BasicBlocks.; /// testreg is used for testing the loop exit condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h:4,Modifiability,Variab,Variables,4,/// Variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainFDriver.cpp:794,Safety,safe,safely,794,"//===-- BrainFDriver.cpp - BrainF compiler driver -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program converts the BrainF language into LLVM assembly,; // which it can then run using the JIT or output as BitCode.; //; // This implementation has a tape of 65536 bytes,; // with the head starting in the middle.; // Range checking is off by default, so be careful.; // It can be enabled with -abc.; //; // Use:; // ./BrainF -jit prog.bf #Run program now; // ./BrainF -jit -abc prog.bf #Run program now safely; // ./BrainF prog.bf #Write as BitCode; //; // lli prog.bf.bc #Run generated BitCode; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainFDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainFDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainFDriver.cpp:208,Integrability,depend,depends,208,"// Genereated code calls putchar, and output is not guaranteed without fflush.; // The better place for fflush(stdout) call would be the generated code, but it; // is unmanageable because stdout linkage name depends on stdlib implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/BrainF/BrainFDriver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainFDriver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:477,Testability,test,test,477,"//===-- ExceptionDemo.cpp - An example using llvm Exceptions --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Demo program which implements an example LLVM exception implementation, and; // shows several test cases including the handling of foreign exceptions.; // It is run with type info types arguments to throw. A test will; // be run for each given type info type. While type info types with the value; // of -1 will trigger a foreign C++ exception to be thrown; type info types; // <= 6 and >= 1 will cause the associated generated exceptions to be thrown; // and caught by generated test functions; and type info types > 6; // will result in exceptions which pass through to the test harness. All other; // type info types are not supported and could cause a crash. In all cases,; // the ""finally"" blocks of every generated test functions will executed; // regardless of whether or not that test function ignores or catches the; // thrown exception.; //; // examples:; //; // ExceptionDemo; //; // causes a usage to be printed to stderr; //; // ExceptionDemo 2 3 7 -1; //; // results in the following cases:; // - Value 2 causes an exception with a type info type of 2 to be; // thrown and caught by an inner generated test function.; // - Value 3 causes an exception with a type info type of 3 to be; // thrown and caught by an outer generated test function.; // - Value 7 causes an exception with a type info type of 7 to be; // thrown and NOT be caught by any generated function.; // - Value -1 causes a foreign C++ exception to be thrown and not be; // caught by any generated function; //; // Cases -1 and 7 are caught by a C++ test harness where the validity of; // of a C++ catch(...) clause catching a generated e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:591,Testability,test,test,591,"//===-- ExceptionDemo.cpp - An example using llvm Exceptions --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Demo program which implements an example LLVM exception implementation, and; // shows several test cases including the handling of foreign exceptions.; // It is run with type info types arguments to throw. A test will; // be run for each given type info type. While type info types with the value; // of -1 will trigger a foreign C++ exception to be thrown; type info types; // <= 6 and >= 1 will cause the associated generated exceptions to be thrown; // and caught by generated test functions; and type info types > 6; // will result in exceptions which pass through to the test harness. All other; // type info types are not supported and could cause a crash. In all cases,; // the ""finally"" blocks of every generated test functions will executed; // regardless of whether or not that test function ignores or catches the; // thrown exception.; //; // examples:; //; // ExceptionDemo; //; // causes a usage to be printed to stderr; //; // ExceptionDemo 2 3 7 -1; //; // results in the following cases:; // - Value 2 causes an exception with a type info type of 2 to be; // thrown and caught by an inner generated test function.; // - Value 3 causes an exception with a type info type of 3 to be; // thrown and caught by an outer generated test function.; // - Value 7 causes an exception with a type info type of 7 to be; // thrown and NOT be caught by any generated function.; // - Value -1 causes a foreign C++ exception to be thrown and not be; // caught by any generated function; //; // Cases -1 and 7 are caught by a C++ test harness where the validity of; // of a C++ catch(...) clause catching a generated e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:863,Testability,test,test,863,"//===-- ExceptionDemo.cpp - An example using llvm Exceptions --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Demo program which implements an example LLVM exception implementation, and; // shows several test cases including the handling of foreign exceptions.; // It is run with type info types arguments to throw. A test will; // be run for each given type info type. While type info types with the value; // of -1 will trigger a foreign C++ exception to be thrown; type info types; // <= 6 and >= 1 will cause the associated generated exceptions to be thrown; // and caught by generated test functions; and type info types > 6; // will result in exceptions which pass through to the test harness. All other; // type info types are not supported and could cause a crash. In all cases,; // the ""finally"" blocks of every generated test functions will executed; // regardless of whether or not that test function ignores or catches the; // thrown exception.; //; // examples:; //; // ExceptionDemo; //; // causes a usage to be printed to stderr; //; // ExceptionDemo 2 3 7 -1; //; // results in the following cases:; // - Value 2 causes an exception with a type info type of 2 to be; // thrown and caught by an inner generated test function.; // - Value 3 causes an exception with a type info type of 3 to be; // thrown and caught by an outer generated test function.; // - Value 7 causes an exception with a type info type of 7 to be; // thrown and NOT be caught by any generated function.; // - Value -1 causes a foreign C++ exception to be thrown and not be; // caught by any generated function; //; // Cases -1 and 7 are caught by a C++ test harness where the validity of; // of a C++ catch(...) clause catching a generated e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:959,Testability,test,test,959,"//===-- ExceptionDemo.cpp - An example using llvm Exceptions --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Demo program which implements an example LLVM exception implementation, and; // shows several test cases including the handling of foreign exceptions.; // It is run with type info types arguments to throw. A test will; // be run for each given type info type. While type info types with the value; // of -1 will trigger a foreign C++ exception to be thrown; type info types; // <= 6 and >= 1 will cause the associated generated exceptions to be thrown; // and caught by generated test functions; and type info types > 6; // will result in exceptions which pass through to the test harness. All other; // type info types are not supported and could cause a crash. In all cases,; // the ""finally"" blocks of every generated test functions will executed; // regardless of whether or not that test function ignores or catches the; // thrown exception.; //; // examples:; //; // ExceptionDemo; //; // causes a usage to be printed to stderr; //; // ExceptionDemo 2 3 7 -1; //; // results in the following cases:; // - Value 2 causes an exception with a type info type of 2 to be; // thrown and caught by an inner generated test function.; // - Value 3 causes an exception with a type info type of 3 to be; // thrown and caught by an outer generated test function.; // - Value 7 causes an exception with a type info type of 7 to be; // thrown and NOT be caught by any generated function.; // - Value -1 causes a foreign C++ exception to be thrown and not be; // caught by any generated function; //; // Cases -1 and 7 are caught by a C++ test harness where the validity of; // of a C++ catch(...) clause catching a generated e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:1104,Testability,test,test,1104,"se v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Demo program which implements an example LLVM exception implementation, and; // shows several test cases including the handling of foreign exceptions.; // It is run with type info types arguments to throw. A test will; // be run for each given type info type. While type info types with the value; // of -1 will trigger a foreign C++ exception to be thrown; type info types; // <= 6 and >= 1 will cause the associated generated exceptions to be thrown; // and caught by generated test functions; and type info types > 6; // will result in exceptions which pass through to the test harness. All other; // type info types are not supported and could cause a crash. In all cases,; // the ""finally"" blocks of every generated test functions will executed; // regardless of whether or not that test function ignores or catches the; // thrown exception.; //; // examples:; //; // ExceptionDemo; //; // causes a usage to be printed to stderr; //; // ExceptionDemo 2 3 7 -1; //; // results in the following cases:; // - Value 2 causes an exception with a type info type of 2 to be; // thrown and caught by an inner generated test function.; // - Value 3 causes an exception with a type info type of 3 to be; // thrown and caught by an outer generated test function.; // - Value 7 causes an exception with a type info type of 7 to be; // thrown and NOT be caught by any generated function.; // - Value -1 causes a foreign C++ exception to be thrown and not be; // caught by any generated function; //; // Cases -1 and 7 are caught by a C++ test harness where the validity of; // of a C++ catch(...) clause catching a generated exception with a; // type info type of 7 is explained by: example in rules 1.6.4 in; // http://itanium-cxx-abi.github.io/cxx-abi/abi-eh.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:1171,Testability,test,test,1171,"se v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Demo program which implements an example LLVM exception implementation, and; // shows several test cases including the handling of foreign exceptions.; // It is run with type info types arguments to throw. A test will; // be run for each given type info type. While type info types with the value; // of -1 will trigger a foreign C++ exception to be thrown; type info types; // <= 6 and >= 1 will cause the associated generated exceptions to be thrown; // and caught by generated test functions; and type info types > 6; // will result in exceptions which pass through to the test harness. All other; // type info types are not supported and could cause a crash. In all cases,; // the ""finally"" blocks of every generated test functions will executed; // regardless of whether or not that test function ignores or catches the; // thrown exception.; //; // examples:; //; // ExceptionDemo; //; // causes a usage to be printed to stderr; //; // ExceptionDemo 2 3 7 -1; //; // results in the following cases:; // - Value 2 causes an exception with a type info type of 2 to be; // thrown and caught by an inner generated test function.; // - Value 3 causes an exception with a type info type of 3 to be; // thrown and caught by an outer generated test function.; // - Value 7 causes an exception with a type info type of 7 to be; // thrown and NOT be caught by any generated function.; // - Value -1 causes a foreign C++ exception to be thrown and not be; // caught by any generated function; //; // Cases -1 and 7 are caught by a C++ test harness where the validity of; // of a C++ catch(...) clause catching a generated exception with a; // type info type of 7 is explained by: example in rules 1.6.4 in; // http://itanium-cxx-abi.github.io/cxx-abi/abi-eh.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:1499,Testability,test,test,1499,"----------------------------------===//; //; // Demo program which implements an example LLVM exception implementation, and; // shows several test cases including the handling of foreign exceptions.; // It is run with type info types arguments to throw. A test will; // be run for each given type info type. While type info types with the value; // of -1 will trigger a foreign C++ exception to be thrown; type info types; // <= 6 and >= 1 will cause the associated generated exceptions to be thrown; // and caught by generated test functions; and type info types > 6; // will result in exceptions which pass through to the test harness. All other; // type info types are not supported and could cause a crash. In all cases,; // the ""finally"" blocks of every generated test functions will executed; // regardless of whether or not that test function ignores or catches the; // thrown exception.; //; // examples:; //; // ExceptionDemo; //; // causes a usage to be printed to stderr; //; // ExceptionDemo 2 3 7 -1; //; // results in the following cases:; // - Value 2 causes an exception with a type info type of 2 to be; // thrown and caught by an inner generated test function.; // - Value 3 causes an exception with a type info type of 3 to be; // thrown and caught by an outer generated test function.; // - Value 7 causes an exception with a type info type of 7 to be; // thrown and NOT be caught by any generated function.; // - Value -1 causes a foreign C++ exception to be thrown and not be; // caught by any generated function; //; // Cases -1 and 7 are caught by a C++ test harness where the validity of; // of a C++ catch(...) clause catching a generated exception with a; // type info type of 7 is explained by: example in rules 1.6.4 in; // http://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html (v1.22); //; // This code uses code from the llvm compiler-rt project and the llvm; // Kaleidoscope project.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:1625,Testability,test,test,1625,"----------------------------------===//; //; // Demo program which implements an example LLVM exception implementation, and; // shows several test cases including the handling of foreign exceptions.; // It is run with type info types arguments to throw. A test will; // be run for each given type info type. While type info types with the value; // of -1 will trigger a foreign C++ exception to be thrown; type info types; // <= 6 and >= 1 will cause the associated generated exceptions to be thrown; // and caught by generated test functions; and type info types > 6; // will result in exceptions which pass through to the test harness. All other; // type info types are not supported and could cause a crash. In all cases,; // the ""finally"" blocks of every generated test functions will executed; // regardless of whether or not that test function ignores or catches the; // thrown exception.; //; // examples:; //; // ExceptionDemo; //; // causes a usage to be printed to stderr; //; // ExceptionDemo 2 3 7 -1; //; // results in the following cases:; // - Value 2 causes an exception with a type info type of 2 to be; // thrown and caught by an inner generated test function.; // - Value 3 causes an exception with a type info type of 3 to be; // thrown and caught by an outer generated test function.; // - Value 7 causes an exception with a type info type of 7 to be; // thrown and NOT be caught by any generated function.; // - Value -1 causes a foreign C++ exception to be thrown and not be; // caught by any generated function; //; // Cases -1 and 7 are caught by a C++ test harness where the validity of; // of a C++ catch(...) clause catching a generated exception with a; // type info type of 7 is explained by: example in rules 1.6.4 in; // http://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html (v1.22); //; // This code uses code from the llvm compiler-rt project and the llvm; // Kaleidoscope project.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:1913,Testability,test,test,1913,"----------------------------------===//; //; // Demo program which implements an example LLVM exception implementation, and; // shows several test cases including the handling of foreign exceptions.; // It is run with type info types arguments to throw. A test will; // be run for each given type info type. While type info types with the value; // of -1 will trigger a foreign C++ exception to be thrown; type info types; // <= 6 and >= 1 will cause the associated generated exceptions to be thrown; // and caught by generated test functions; and type info types > 6; // will result in exceptions which pass through to the test harness. All other; // type info types are not supported and could cause a crash. In all cases,; // the ""finally"" blocks of every generated test functions will executed; // regardless of whether or not that test function ignores or catches the; // thrown exception.; //; // examples:; //; // ExceptionDemo; //; // causes a usage to be printed to stderr; //; // ExceptionDemo 2 3 7 -1; //; // results in the following cases:; // - Value 2 causes an exception with a type info type of 2 to be; // thrown and caught by an inner generated test function.; // - Value 3 causes an exception with a type info type of 3 to be; // thrown and caught by an outer generated test function.; // - Value 7 causes an exception with a type info type of 7 to be; // thrown and NOT be caught by any generated function.; // - Value -1 causes a foreign C++ exception to be thrown and not be; // caught by any generated function; //; // Cases -1 and 7 are caught by a C++ test harness where the validity of; // of a C++ catch(...) clause catching a generated exception with a; // type info type of 7 is explained by: example in rules 1.6.4 in; // http://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html (v1.22); //; // This code uses code from the llvm compiler-rt project and the llvm; // Kaleidoscope project.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:318,Availability,redundant,redundant,318,"// FIXME: Although all systems tested with (Linux, OS X), do not need this; // header file included. A user on ubuntu reported, undefined symbols; // for stderr, and fprintf, and the addition of this include fixed the; // issue for them. Given that LLVM's best practices include the goal; // of reducing the number of redundant header files included, the; // correct solution would be to find out why these symbols are not; // defined for the system in question, and fix the issue by finding out; // which LLVM header file, if any, would include these symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:318,Safety,redund,redundant,318,"// FIXME: Although all systems tested with (Linux, OS X), do not need this; // header file included. A user on ubuntu reported, undefined symbols; // for stderr, and fprintf, and the addition of this include fixed the; // issue for them. Given that LLVM's best practices include the goal; // of reducing the number of redundant header files included, the; // correct solution would be to find out why these symbols are not; // defined for the system in question, and fix the issue by finding out; // which LLVM header file, if any, would include these symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:31,Testability,test,tested,31,"// FIXME: Although all systems tested with (Linux, OS X), do not need this; // header file included. A user on ubuntu reported, undefined symbols; // for stderr, and fprintf, and the addition of this include fixed the; // issue for them. Given that LLVM's best practices include the goal; // of reducing the number of redundant header files included, the; // correct solution would be to find out why these symbols are not; // defined for the system in question, and fix the issue by finding out; // which LLVM header file, if any, would include these symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:42,Usability,simpl,simplistic,42,//; // Example types; //; /// This is our simplistic type info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:106,Modifiability,variab,variables,106,/// Create an alloca instruction in the entry block of; /// the parent function. This is used for mutable variables etc.; /// @param function parent instance; /// @param varName stack variable name; /// @param type stack variable type; /// @param initWith optional constant initialization value; /// @returns AllocaInst instance,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:184,Modifiability,variab,variable,184,/// Create an alloca instruction in the entry block of; /// the parent function. This is used for mutable variables etc.; /// @param function parent instance; /// @param varName stack variable name; /// @param type stack variable type; /// @param initWith optional constant initialization value; /// @returns AllocaInst instance,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:221,Modifiability,variab,variable,221,/// Create an alloca instruction in the entry block of; /// the parent function. This is used for mutable variables etc.; /// @param function parent instance; /// @param varName stack variable name; /// @param type stack variable type; /// @param initWith optional constant initialization value; /// @returns AllocaInst instance,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:32,Energy Efficiency,allocate,allocated,32,"/// Deletes the true previously allocated exception whose address; /// is calculated from the supplied OurBaseException_t::unwindException; /// member address. Handles (ignores), NULL pointers.; /// @param expToDelete exception to delete",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:13,Energy Efficiency,allocate,allocates,13,"/// Creates (allocates on the heap), an exception (OurException instance),; /// of the supplied type info type.; /// @param type type info type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:62,Modifiability,Variab,Variable,62,/// Read a uleb128 encoded value and advance pointer; /// See Variable Length Data in:; /// @link http://dwarfstd.org/Dwarf3.pdf @unlink; /// @param data reference variable holding memory pointer to decode from; /// @returns decoded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:164,Modifiability,variab,variable,164,/// Read a uleb128 encoded value and advance pointer; /// See Variable Length Data in:; /// @link http://dwarfstd.org/Dwarf3.pdf @unlink; /// @param data reference variable holding memory pointer to decode from; /// @returns decoded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:62,Modifiability,Variab,Variable,62,/// Read a sleb128 encoded value and advance pointer; /// See Variable Length Data in:; /// @link http://dwarfstd.org/Dwarf3.pdf @unlink; /// @param data reference variable holding memory pointer to decode from; /// @returns decoded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:164,Modifiability,variab,variable,164,/// Read a sleb128 encoded value and advance pointer; /// See Variable Length Data in:; /// @link http://dwarfstd.org/Dwarf3.pdf @unlink; /// @param data reference variable holding memory pointer to decode from; /// @returns decoded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:62,Modifiability,Variab,Variable,62,/// Read a pointer encoded value and advance pointer; /// See Variable Length Data in:; /// @link http://dwarfstd.org/Dwarf3.pdf @unlink; /// @param data reference variable holding memory pointer to decode from; /// @param encoding dwarf encoding type; /// @returns decoded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:164,Modifiability,variab,variable,164,/// Read a pointer encoded value and advance pointer; /// See Variable Length Data in:; /// @link http://dwarfstd.org/Dwarf3.pdf @unlink; /// @param data reference variable holding memory pointer to decode from; /// @param encoding dwarf encoding type; /// @returns decoded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:32,Testability,test,tested,32,// Note: This case has not been tested,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:405,Modifiability,Variab,Variable,405,"/// Deals with Dwarf actions matching our type infos; /// (OurExceptionType_t instances). Returns whether or not a dwarf emitted; /// action matches the supplied exception type. If such a match succeeds,; /// the resultAction argument will be set with > 0 index value. Only; /// corresponding llvm.eh.selector type info arguments, cleanup arguments; /// are supported. Filters are not supported.; /// See Variable Length Data in:; /// @link http://dwarfstd.org/Dwarf3.pdf @unlink; /// Also see @link http://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html @unlink; /// @param resultAction reference variable which will be set with result; /// @param classInfo our array of type info pointers (to globals); /// @param actionEntry index into above type info array or 0 (clean up).; /// We do not support filters.; /// @param exceptionClass exception class (_Unwind_Exception::exception_class); /// of thrown exception.; /// @param exceptionObject thrown _Unwind_Exception instance.; /// @returns whether or not a type info was found. False is returned if only; /// a cleanup was found",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:596,Modifiability,variab,variable,596,"/// Deals with Dwarf actions matching our type infos; /// (OurExceptionType_t instances). Returns whether or not a dwarf emitted; /// action matches the supplied exception type. If such a match succeeds,; /// the resultAction argument will be set with > 0 index value. Only; /// corresponding llvm.eh.selector type info arguments, cleanup arguments; /// are supported. Filters are not supported.; /// See Variable Length Data in:; /// @link http://dwarfstd.org/Dwarf3.pdf @unlink; /// Also see @link http://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html @unlink; /// @param resultAction reference variable which will be set with result; /// @param classInfo our array of type info pointers (to globals); /// @param actionEntry index into above type info array or 0 (clean up).; /// We do not support filters.; /// @param exceptionClass exception class (_Unwind_Exception::exception_class); /// of thrown exception.; /// @param exceptionObject thrown _Unwind_Exception instance.; /// @returns whether or not a type info was found. False is returned if only; /// a cleanup was found",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:167,Usability,simpl,simply,167,"/// Generates code to handle finally block type semantics: always runs; /// regardless of whether a thrown exception is passing through or the; /// parent function is simply exiting. In addition to printing some state; /// to stderr, this code will resume the exception handling--runs the; /// unwind resume block, if the exception has not been previously caught; /// by a catch clause, and will otherwise execute the end block (terminator; /// block). In addition this function creates the corresponding function's; /// stack storage for the exception pointer and catch flag status.; /// @param context llvm context; /// @param module code for module instance; /// @param builder builder instance; /// @param toAddTo parent function to add block to; /// @param blockName block name of new ""finally"" block.; /// @param functionId output id used for printing; /// @param terminatorBlock terminator ""end"" block; /// @param unwindResumeBlock unwind resume block; /// @param exceptionCaughtFlag reference exception caught/thrown status storage; /// @param exceptionStorage reference to exception pointer storage; /// @param caughtResultStorage reference to landingpad result storage; /// @returns newly created block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:249,Usability,resume,resume,249,"/// Generates code to handle finally block type semantics: always runs; /// regardless of whether a thrown exception is passing through or the; /// parent function is simply exiting. In addition to printing some state; /// to stderr, this code will resume the exception handling--runs the; /// unwind resume block, if the exception has not been previously caught; /// by a catch clause, and will otherwise execute the end block (terminator; /// block). In addition this function creates the corresponding function's; /// stack storage for the exception pointer and catch flag status.; /// @param context llvm context; /// @param module code for module instance; /// @param builder builder instance; /// @param toAddTo parent function to add block to; /// @param blockName block name of new ""finally"" block.; /// @param functionId output id used for printing; /// @param terminatorBlock terminator ""end"" block; /// @param unwindResumeBlock unwind resume block; /// @param exceptionCaughtFlag reference exception caught/thrown status storage; /// @param exceptionStorage reference to exception pointer storage; /// @param caughtResultStorage reference to landingpad result storage; /// @returns newly created block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:301,Usability,resume,resume,301,"/// Generates code to handle finally block type semantics: always runs; /// regardless of whether a thrown exception is passing through or the; /// parent function is simply exiting. In addition to printing some state; /// to stderr, this code will resume the exception handling--runs the; /// unwind resume block, if the exception has not been previously caught; /// by a catch clause, and will otherwise execute the end block (terminator; /// block). In addition this function creates the corresponding function's; /// stack storage for the exception pointer and catch flag status.; /// @param context llvm context; /// @param module code for module instance; /// @param builder builder instance; /// @param toAddTo parent function to add block to; /// @param blockName block name of new ""finally"" block.; /// @param functionId output id used for printing; /// @param terminatorBlock terminator ""end"" block; /// @param unwindResumeBlock unwind resume block; /// @param exceptionCaughtFlag reference exception caught/thrown status storage; /// @param exceptionStorage reference to exception pointer storage; /// @param caughtResultStorage reference to landingpad result storage; /// @returns newly created block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:946,Usability,resume,resume,946,"/// Generates code to handle finally block type semantics: always runs; /// regardless of whether a thrown exception is passing through or the; /// parent function is simply exiting. In addition to printing some state; /// to stderr, this code will resume the exception handling--runs the; /// unwind resume block, if the exception has not been previously caught; /// by a catch clause, and will otherwise execute the end block (terminator; /// block). In addition this function creates the corresponding function's; /// stack storage for the exception pointer and catch flag status.; /// @param context llvm context; /// @param module code for module instance; /// @param builder builder instance; /// @param toAddTo parent function to add block to; /// @param blockName block name of new ""finally"" block.; /// @param functionId output id used for printing; /// @param terminatorBlock terminator ""end"" block; /// @param unwindResumeBlock unwind resume block; /// @param exceptionCaughtFlag reference exception caught/thrown status storage; /// @param exceptionStorage reference to exception pointer storage; /// @param caughtResultStorage reference to landingpad result storage; /// @returns newly created block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:15,Integrability,rout,routes,15,// Block which routes exception to correct catch handler block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:100,Energy Efficiency,allocate,allocates,100,// Finally block which will branch to unwindResumeBlock if; // exception is not caught. Initializes/allocates stack locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:10,Usability,Resume,Resume,10,// Unwind Resume Block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:10,Availability,Redundant,Redundant,10,"// FIXME: Redundant storage which, beyond utilizing value of; // caughtResultStore for unwindException storage, may be alleviated; // altogether with a block rearrangement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:10,Safety,Redund,Redundant,10,"// FIXME: Redundant storage which, beyond utilizing value of; // caughtResultStore for unwindException storage, may be alleviated; // altogether with a block rearrangement",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:86,Integrability,rout,router,86,// Branch to the externalExceptionBlock if the exception is foreign or; // to a catch router if not. Either way the finally block will be run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:13,Integrability,Rout,Route,13,// Exception Route Block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:3,Integrability,Rout,Route,3,// Route to matched type info catch block or run cleanup finally block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:64,Integrability,depend,depending,64,// Throws either one of our exception or a native C++ exception depending; // on a runtime argument value containing a type info type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:514,Modifiability,config,configured,514,"/// Creates test code by generating and organizing these functions into the; /// test case. The test case consists of an outer function setup to invoke; /// an inner function within an environment having multiple catch and single; /// finally blocks. This inner function is also setup to invoke a throw; /// function within an evironment similar in nature to the outer function's; /// catch and finally blocks. Each of these two functions catch mutually; /// exclusive subsets (even or odd) of the type info types configured; /// for this this. All generated functions have a runtime argument which; /// holds a type info type to throw that each function takes and passes it; /// to the inner one if such a inner function exists. This type info type is; /// looked at by the generated throw function to see whether or not it should; /// throw a generated exception with the same type info type, or instead call; /// a supplied a function which in turn will throw a foreign exception.; /// @param module code for module instance; /// @param builder builder instance; /// @param fpm a function pass manager holding optional IR to IR; /// transformations; /// @param nativeThrowFunctName name of external function which will throw; /// a foreign exception; /// @returns outermost generated test function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:12,Testability,test,test,12,"/// Creates test code by generating and organizing these functions into the; /// test case. The test case consists of an outer function setup to invoke; /// an inner function within an environment having multiple catch and single; /// finally blocks. This inner function is also setup to invoke a throw; /// function within an evironment similar in nature to the outer function's; /// catch and finally blocks. Each of these two functions catch mutually; /// exclusive subsets (even or odd) of the type info types configured; /// for this this. All generated functions have a runtime argument which; /// holds a type info type to throw that each function takes and passes it; /// to the inner one if such a inner function exists. This type info type is; /// looked at by the generated throw function to see whether or not it should; /// throw a generated exception with the same type info type, or instead call; /// a supplied a function which in turn will throw a foreign exception.; /// @param module code for module instance; /// @param builder builder instance; /// @param fpm a function pass manager holding optional IR to IR; /// transformations; /// @param nativeThrowFunctName name of external function which will throw; /// a foreign exception; /// @returns outermost generated test function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:81,Testability,test,test,81,"/// Creates test code by generating and organizing these functions into the; /// test case. The test case consists of an outer function setup to invoke; /// an inner function within an environment having multiple catch and single; /// finally blocks. This inner function is also setup to invoke a throw; /// function within an evironment similar in nature to the outer function's; /// catch and finally blocks. Each of these two functions catch mutually; /// exclusive subsets (even or odd) of the type info types configured; /// for this this. All generated functions have a runtime argument which; /// holds a type info type to throw that each function takes and passes it; /// to the inner one if such a inner function exists. This type info type is; /// looked at by the generated throw function to see whether or not it should; /// throw a generated exception with the same type info type, or instead call; /// a supplied a function which in turn will throw a foreign exception.; /// @param module code for module instance; /// @param builder builder instance; /// @param fpm a function pass manager holding optional IR to IR; /// transformations; /// @param nativeThrowFunctName name of external function which will throw; /// a foreign exception; /// @returns outermost generated test function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:96,Testability,test,test,96,"/// Creates test code by generating and organizing these functions into the; /// test case. The test case consists of an outer function setup to invoke; /// an inner function within an environment having multiple catch and single; /// finally blocks. This inner function is also setup to invoke a throw; /// function within an evironment similar in nature to the outer function's; /// catch and finally blocks. Each of these two functions catch mutually; /// exclusive subsets (even or odd) of the type info types configured; /// for this this. All generated functions have a runtime argument which; /// holds a type info type to throw that each function takes and passes it; /// to the inner one if such a inner function exists. This type info type is; /// looked at by the generated throw function to see whether or not it should; /// throw a generated exception with the same type info type, or instead call; /// a supplied a function which in turn will throw a foreign exception.; /// @param module code for module instance; /// @param builder builder instance; /// @param fpm a function pass manager holding optional IR to IR; /// transformations; /// @param nativeThrowFunctName name of external function which will throw; /// a foreign exception; /// @returns outermost generated test function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:1287,Testability,test,test,1287,"/// Creates test code by generating and organizing these functions into the; /// test case. The test case consists of an outer function setup to invoke; /// an inner function within an environment having multiple catch and single; /// finally blocks. This inner function is also setup to invoke a throw; /// function within an evironment similar in nature to the outer function's; /// catch and finally blocks. Each of these two functions catch mutually; /// exclusive subsets (even or odd) of the type info types configured; /// for this this. All generated functions have a runtime argument which; /// holds a type info type to throw that each function takes and passes it; /// to the inner one if such a inner function exists. This type info type is; /// looked at by the generated throw function to see whether or not it should; /// throw a generated exception with the same type info type, or instead call; /// a supplied a function which in turn will throw a foreign exception.; /// @param module code for module instance; /// @param builder builder instance; /// @param fpm a function pass manager holding optional IR to IR; /// transformations; /// @param nativeThrowFunctName name of external function which will throw; /// a foreign exception; /// @returns outermost generated test function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:162,Integrability,contract,contract,162,// end anonymous namespace; /// Throws foreign C++ exception.; /// @param ignoreIt unused parameter that allows function to match implied; /// generated function contract.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:120,Integrability,wrap,wraps,120,"/// This is a test harness which runs test by executing generated; /// function with a type info type to throw. Harness wraps the execution; /// of generated function in a C++ try catch clause.; /// @param engine execution engine to use for executing generated function.; /// This demo program expects this to be a JIT instance for demo; /// purposes.; /// @param function generated test function to run; /// @param typeToThrow type info type of generated exception to throw, or; /// indicator to cause foreign exception to be thrown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:14,Testability,test,test,14,"/// This is a test harness which runs test by executing generated; /// function with a type info type to throw. Harness wraps the execution; /// of generated function in a C++ try catch clause.; /// @param engine execution engine to use for executing generated function.; /// This demo program expects this to be a JIT instance for demo; /// purposes.; /// @param function generated test function to run; /// @param typeToThrow type info type of generated exception to throw, or; /// indicator to cause foreign exception to be thrown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:38,Testability,test,test,38,"/// This is a test harness which runs test by executing generated; /// function with a type info type to throw. Harness wraps the execution; /// of generated function in a C++ try catch clause.; /// @param engine execution engine to use for executing generated function.; /// This demo program expects this to be a JIT instance for demo; /// purposes.; /// @param function generated test function to run; /// @param typeToThrow type info type of generated exception to throw, or; /// indicator to cause foreign exception to be thrown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:383,Testability,test,test,383,"/// This is a test harness which runs test by executing generated; /// function with a type info type to throw. Harness wraps the execution; /// of generated function in a C++ try catch clause.; /// @param engine execution engine to use for executing generated function.; /// This demo program expects this to be a JIT instance for demo; /// purposes.; /// @param function generated test function to run; /// @param typeToThrow type info type of generated exception to throw, or; /// indicator to cause foreign exception to be thrown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:8,Testability,test,test,8,// Find test's function pointer,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:7,Testability,test,test,7,// Run test,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:11,Testability,test,test,11,//; // End test functions; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:24,Integrability,rout,routine,24,"/// This initialization routine creates type info globals and; /// adds external function declarations to module.; /// @param numTypeInfos number of linear type info associated type info types; /// to create as GlobalVariable instances, starting with the value 1.; /// @param module code for module instance; /// @param builder builder instance",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:205,Integrability,rout,routine,205,//===----------------------------------------------------------------------===//; // Main test driver code.; //===----------------------------------------------------------------------===//; /// Demo main routine which takes the type info types to throw. A test will; /// be run for each given type info type. While type info types with the value; /// of -1 will trigger a foreign C++ exception to be thrown; type info types; /// <= 6 and >= 1 will be caught by test functions; and type info types > 6; /// will result in exceptions which pass through to the test harness. All other; /// type info types are not supported and could cause a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:90,Testability,test,test,90,//===----------------------------------------------------------------------===//; // Main test driver code.; //===----------------------------------------------------------------------===//; /// Demo main routine which takes the type info types to throw. A test will; /// be run for each given type info type. While type info types with the value; /// of -1 will trigger a foreign C++ exception to be thrown; type info types; /// <= 6 and >= 1 will be caught by test functions; and type info types > 6; /// will result in exceptions which pass through to the test harness. All other; /// type info types are not supported and could cause a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:257,Testability,test,test,257,//===----------------------------------------------------------------------===//; // Main test driver code.; //===----------------------------------------------------------------------===//; /// Demo main routine which takes the type info types to throw. A test will; /// be run for each given type info type. While type info types with the value; /// of -1 will trigger a foreign C++ exception to be thrown; type info types; /// <= 6 and >= 1 will be caught by test functions; and type info types > 6; /// will result in exceptions which pass through to the test harness. All other; /// type info types are not supported and could cause a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:462,Testability,test,test,462,//===----------------------------------------------------------------------===//; // Main test driver code.; //===----------------------------------------------------------------------===//; /// Demo main routine which takes the type info types to throw. A test will; /// be run for each given type info type. While type info types with the value; /// of -1 will trigger a foreign C++ exception to be thrown; type info types; /// <= 6 and >= 1 will be caught by test functions; and type info types > 6; /// will result in exceptions which pass through to the test harness. All other; /// type info types are not supported and could cause a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:559,Testability,test,test,559,//===----------------------------------------------------------------------===//; // Main test driver code.; //===----------------------------------------------------------------------===//; /// Demo main routine which takes the type info types to throw. A test will; /// be run for each given type info type. While type info types with the value; /// of -1 will trigger a foreign C++ exception to be thrown; type info types; /// <= 6 and >= 1 will be caught by test functions; and type info types > 6; /// will result in exceptions which pass through to the test harness. All other; /// type info types are not supported and could cause a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:24,Deployability,pipeline,pipeline,24,// Set up the optimizer pipeline.; // Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:14,Performance,optimiz,optimizer,14,// Set up the optimizer pipeline.; // Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:3,Performance,Optimiz,Optimizations,3,// Optimizations turned on,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:24,Performance,optimiz,optimizations,24,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:6,Usability,simpl,simple,6,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable; // blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:12,Testability,test,test,12,// Generate test code using function throwCppException(...) as; // the function which throws foreign exceptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:7,Testability,test,test,7,// Run test for each argument whose value is the exception; // type to throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:941,Availability,avail,available,941,"//===- SimplifyCFG.cpp ----------------------------------------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the control flow graph (CFG) simplifications; // presented as part of the 'Getting Started With LLVM: Basics' tutorial at the; // US LLVM Developers Meeting 2019. It also contains additional material.; //; // The current file contains three different CFG simplifications. There are; // multiple versions of each implementation (e.g. _v1 and _v2), which implement; // additional functionality (e.g. preserving analysis like the DominatorTree) or; // use additional utilities to simplify the code (e.g. LLVM's PatternMatch.h).; // The available simplifications are:; // 1. Trivially Dead block Removal (removeDeadBlocks_v[1,2]).; // This simplifications removes all blocks without predecessors in the CFG; // from a function.; // 2. Conditional Branch Elimination (eliminateCondBranches_v[1,2,3]); // This simplification replaces conditional branches with constant integer; // conditions with unconditional branches.; // 3. Single Predecessor Block Merging (mergeIntoSinglePredecessor_v[1,2]); // This simplification merges blocks with a single predecessor into the; // predecessor, if that block has a single successor.; //; // TODOs; // * Preserve LoopInfo.; // * Add fixed point iteration to delete all dead blocks; // * Add implementation using reachability to discover dead blocks.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:7,Usability,Simpl,SimplifyCFG,7,"//===- SimplifyCFG.cpp ----------------------------------------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the control flow graph (CFG) simplifications; // presented as part of the 'Getting Started With LLVM: Basics' tutorial at the; // US LLVM Developers Meeting 2019. It also contains additional material.; //; // The current file contains three different CFG simplifications. There are; // multiple versions of each implementation (e.g. _v1 and _v2), which implement; // additional functionality (e.g. preserving analysis like the DominatorTree) or; // use additional utilities to simplify the code (e.g. LLVM's PatternMatch.h).; // The available simplifications are:; // 1. Trivially Dead block Removal (removeDeadBlocks_v[1,2]).; // This simplifications removes all blocks without predecessors in the CFG; // from a function.; // 2. Conditional Branch Elimination (eliminateCondBranches_v[1,2,3]); // This simplification replaces conditional branches with constant integer; // conditions with unconditional branches.; // 3. Single Predecessor Block Merging (mergeIntoSinglePredecessor_v[1,2]); // This simplification merges blocks with a single predecessor into the; // predecessor, if that block has a single successor.; //; // TODOs; // * Preserve LoopInfo.; // * Add fixed point iteration to delete all dead blocks; // * Add implementation using reachability to discover dead blocks.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:437,Usability,simpl,simplifications,437,"//===- SimplifyCFG.cpp ----------------------------------------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the control flow graph (CFG) simplifications; // presented as part of the 'Getting Started With LLVM: Basics' tutorial at the; // US LLVM Developers Meeting 2019. It also contains additional material.; //; // The current file contains three different CFG simplifications. There are; // multiple versions of each implementation (e.g. _v1 and _v2), which implement; // additional functionality (e.g. preserving analysis like the DominatorTree) or; // use additional utilities to simplify the code (e.g. LLVM's PatternMatch.h).; // The available simplifications are:; // 1. Trivially Dead block Removal (removeDeadBlocks_v[1,2]).; // This simplifications removes all blocks without predecessors in the CFG; // from a function.; // 2. Conditional Branch Elimination (eliminateCondBranches_v[1,2,3]); // This simplification replaces conditional branches with constant integer; // conditions with unconditional branches.; // 3. Single Predecessor Block Merging (mergeIntoSinglePredecessor_v[1,2]); // This simplification merges blocks with a single predecessor into the; // predecessor, if that block has a single successor.; //; // TODOs; // * Preserve LoopInfo.; // * Add fixed point iteration to delete all dead blocks; // * Add implementation using reachability to discover dead blocks.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:663,Usability,simpl,simplifications,663,"//===- SimplifyCFG.cpp ----------------------------------------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the control flow graph (CFG) simplifications; // presented as part of the 'Getting Started With LLVM: Basics' tutorial at the; // US LLVM Developers Meeting 2019. It also contains additional material.; //; // The current file contains three different CFG simplifications. There are; // multiple versions of each implementation (e.g. _v1 and _v2), which implement; // additional functionality (e.g. preserving analysis like the DominatorTree) or; // use additional utilities to simplify the code (e.g. LLVM's PatternMatch.h).; // The available simplifications are:; // 1. Trivially Dead block Removal (removeDeadBlocks_v[1,2]).; // This simplifications removes all blocks without predecessors in the CFG; // from a function.; // 2. Conditional Branch Elimination (eliminateCondBranches_v[1,2,3]); // This simplification replaces conditional branches with constant integer; // conditions with unconditional branches.; // 3. Single Predecessor Block Merging (mergeIntoSinglePredecessor_v[1,2]); // This simplification merges blocks with a single predecessor into the; // predecessor, if that block has a single successor.; //; // TODOs; // * Preserve LoopInfo.; // * Add fixed point iteration to delete all dead blocks; // * Add implementation using reachability to discover dead blocks.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:885,Usability,simpl,simplify,885,"//===- SimplifyCFG.cpp ----------------------------------------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the control flow graph (CFG) simplifications; // presented as part of the 'Getting Started With LLVM: Basics' tutorial at the; // US LLVM Developers Meeting 2019. It also contains additional material.; //; // The current file contains three different CFG simplifications. There are; // multiple versions of each implementation (e.g. _v1 and _v2), which implement; // additional functionality (e.g. preserving analysis like the DominatorTree) or; // use additional utilities to simplify the code (e.g. LLVM's PatternMatch.h).; // The available simplifications are:; // 1. Trivially Dead block Removal (removeDeadBlocks_v[1,2]).; // This simplifications removes all blocks without predecessors in the CFG; // from a function.; // 2. Conditional Branch Elimination (eliminateCondBranches_v[1,2,3]); // This simplification replaces conditional branches with constant integer; // conditions with unconditional branches.; // 3. Single Predecessor Block Merging (mergeIntoSinglePredecessor_v[1,2]); // This simplification merges blocks with a single predecessor into the; // predecessor, if that block has a single successor.; //; // TODOs; // * Preserve LoopInfo.; // * Add fixed point iteration to delete all dead blocks; // * Add implementation using reachability to discover dead blocks.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:951,Usability,simpl,simplifications,951,"//===- SimplifyCFG.cpp ----------------------------------------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the control flow graph (CFG) simplifications; // presented as part of the 'Getting Started With LLVM: Basics' tutorial at the; // US LLVM Developers Meeting 2019. It also contains additional material.; //; // The current file contains three different CFG simplifications. There are; // multiple versions of each implementation (e.g. _v1 and _v2), which implement; // additional functionality (e.g. preserving analysis like the DominatorTree) or; // use additional utilities to simplify the code (e.g. LLVM's PatternMatch.h).; // The available simplifications are:; // 1. Trivially Dead block Removal (removeDeadBlocks_v[1,2]).; // This simplifications removes all blocks without predecessors in the CFG; // from a function.; // 2. Conditional Branch Elimination (eliminateCondBranches_v[1,2,3]); // This simplification replaces conditional branches with constant integer; // conditions with unconditional branches.; // 3. Single Predecessor Block Merging (mergeIntoSinglePredecessor_v[1,2]); // This simplification merges blocks with a single predecessor into the; // predecessor, if that block has a single successor.; //; // TODOs; // * Preserve LoopInfo.; // * Add fixed point iteration to delete all dead blocks; // * Add implementation using reachability to discover dead blocks.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:1044,Usability,simpl,simplifications,1044,"//===- SimplifyCFG.cpp ----------------------------------------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the control flow graph (CFG) simplifications; // presented as part of the 'Getting Started With LLVM: Basics' tutorial at the; // US LLVM Developers Meeting 2019. It also contains additional material.; //; // The current file contains three different CFG simplifications. There are; // multiple versions of each implementation (e.g. _v1 and _v2), which implement; // additional functionality (e.g. preserving analysis like the DominatorTree) or; // use additional utilities to simplify the code (e.g. LLVM's PatternMatch.h).; // The available simplifications are:; // 1. Trivially Dead block Removal (removeDeadBlocks_v[1,2]).; // This simplifications removes all blocks without predecessors in the CFG; // from a function.; // 2. Conditional Branch Elimination (eliminateCondBranches_v[1,2,3]); // This simplification replaces conditional branches with constant integer; // conditions with unconditional branches.; // 3. Single Predecessor Block Merging (mergeIntoSinglePredecessor_v[1,2]); // This simplification merges blocks with a single predecessor into the; // predecessor, if that block has a single successor.; //; // TODOs; // * Preserve LoopInfo.; // * Add fixed point iteration to delete all dead blocks; // * Add implementation using reachability to discover dead blocks.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:1212,Usability,simpl,simplification,1212,"//===- SimplifyCFG.cpp ----------------------------------------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the control flow graph (CFG) simplifications; // presented as part of the 'Getting Started With LLVM: Basics' tutorial at the; // US LLVM Developers Meeting 2019. It also contains additional material.; //; // The current file contains three different CFG simplifications. There are; // multiple versions of each implementation (e.g. _v1 and _v2), which implement; // additional functionality (e.g. preserving analysis like the DominatorTree) or; // use additional utilities to simplify the code (e.g. LLVM's PatternMatch.h).; // The available simplifications are:; // 1. Trivially Dead block Removal (removeDeadBlocks_v[1,2]).; // This simplifications removes all blocks without predecessors in the CFG; // from a function.; // 2. Conditional Branch Elimination (eliminateCondBranches_v[1,2,3]); // This simplification replaces conditional branches with constant integer; // conditions with unconditional branches.; // 3. Single Predecessor Block Merging (mergeIntoSinglePredecessor_v[1,2]); // This simplification merges blocks with a single predecessor into the; // predecessor, if that block has a single successor.; //; // TODOs; // * Preserve LoopInfo.; // * Add fixed point iteration to delete all dead blocks; // * Add implementation using reachability to discover dead blocks.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:1408,Usability,simpl,simplification,1408,"//===- SimplifyCFG.cpp ----------------------------------------------------===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the control flow graph (CFG) simplifications; // presented as part of the 'Getting Started With LLVM: Basics' tutorial at the; // US LLVM Developers Meeting 2019. It also contains additional material.; //; // The current file contains three different CFG simplifications. There are; // multiple versions of each implementation (e.g. _v1 and _v2), which implement; // additional functionality (e.g. preserving analysis like the DominatorTree) or; // use additional utilities to simplify the code (e.g. LLVM's PatternMatch.h).; // The available simplifications are:; // 1. Trivially Dead block Removal (removeDeadBlocks_v[1,2]).; // This simplifications removes all blocks without predecessors in the CFG; // from a function.; // 2. Conditional Branch Elimination (eliminateCondBranches_v[1,2,3]); // This simplification replaces conditional branches with constant integer; // conditions with unconditional branches.; // 3. Single Predecessor Block Merging (mergeIntoSinglePredecessor_v[1,2]); // This simplification merges blocks with a single predecessor into the; // predecessor, if that block has a single successor.; //; // TODOs; // * Preserve LoopInfo.; // * Add fixed point iteration to delete all dead blocks; // * Add implementation using reachability to discover dead blocks.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:85,Deployability,update,update,85,"// TODO: Find a better place to put such small variations.; // Alternatively, we can update the PHI nodes manually:; // for (PHINode &PN : make_early_inc_range(Succ->phis())); // PN.removeIncomingValue(&BB);; // Replace all instructions in BB with a poison constant. The block is; // unreachable, so the results of the instructions should never get used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:11,Deployability,update,updates,11,// Collect updates that need to be applied to the dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:9,Deployability,update,updates,9,"// Apply updates permissively, to remove duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:9,Deployability,update,updates,9,"// Apply updates permissively, to remove duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:9,Deployability,update,updates,9,"// Apply updates permissively, to remove duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp:9,Deployability,update,updates,9,"// Apply updates permissively, to remove duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h:29,Usability,simpl,simple,29,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h:394,Usability,simpl,simple,394,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:225,Availability,error,error,225,// Assignment requires the LHS to be an identifier.; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:225,Performance,load,load,225,"// Output for-loop as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:50,Energy Efficiency,allocate,allocated,50,// Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h:29,Usability,simpl,simple,29,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h:394,Usability,simpl,simple,394,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h:12,Performance,optimiz,optimizations,12,// Add some optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h:11,Performance,optimiz,optimizations,11,// Run the optimizations over all functions in the module being added to; // the JIT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:225,Availability,error,error,225,// Assignment requires the LHS to be an identifier.; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:225,Performance,load,load,225,"// Output for-loop as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:50,Energy Efficiency,allocate,allocated,50,// Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h:29,Usability,simpl,simple,29,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h:394,Usability,simpl,simple,394,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h:12,Performance,optimiz,optimizations,12,// Add some optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h:11,Performance,optimiz,optimizations,11,// Run the optimizations over all functions in the module being added to; // the JIT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:225,Availability,error,error,225,// Assignment requires the LHS to be an identifier.; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:225,Performance,load,load,225,"// Output for-loop as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:50,Energy Efficiency,allocate,allocated,50,// Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h:29,Usability,simpl,simple,29,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h:394,Usability,simpl,simple,394,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h:136,Testability,stub,stub,136,"/// This will compile FnAST to IR, rename the function to add the given; /// suffix (needed to prevent a name-clash with the function's stub),; /// and then take ownership of the module that the function was compiled; /// into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h:12,Performance,optimiz,optimizations,12,// Add some optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h:11,Performance,optimiz,optimizations,11,// Run the optimizations over all functions in the module being added to; // the JIT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:348,Deployability,update,updates,348,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:211,Usability,simpl,simple,211,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:225,Availability,error,error,225,// Assignment requires the LHS to be an identifier.; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:225,Performance,load,load,225,"// Output for-loop as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:50,Energy Efficiency,allocate,allocated,50,// Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter2/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter3/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:11,Performance,optimiz,optimizer,11,// Run the optimizer on the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:50,Performance,optimiz,optimizations,50,"// Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:32,Usability,simpl,simple,32,"// Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:50,Energy Efficiency,allocate,allocated,50,// Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:81,Modifiability,variab,variable,81,"// Output for-loop as:; // ...; // start = startexpr; // goto loop; // loop:; // variable = phi [start, loopheader], [nextvariable, loopend]; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // nextvariable = variable + step; // endcond = endexpr; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:222,Modifiability,variab,variable,222,"// Output for-loop as:; // ...; // start = startexpr; // goto loop; // loop:; // variable = phi [start, loopheader], [nextvariable, loopend]; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // nextvariable = variable + step; // endcond = endexpr; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:11,Performance,optimiz,optimizer,11,// Run the optimizer on the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:50,Performance,optimiz,optimizations,50,"// Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:32,Usability,simpl,simple,32,"// Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:50,Energy Efficiency,allocate,allocated,50,// Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter5/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:4,Availability,Error,Error,4,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:51,Availability,error,error,51,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:81,Modifiability,variab,variable,81,"// Output for-loop as:; // ...; // start = startexpr; // goto loop; // loop:; // variable = phi [start, loopheader], [nextvariable, loopend]; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // nextvariable = variable + step; // endcond = endexpr; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:222,Modifiability,variab,variable,222,"// Output for-loop as:; // ...; // start = startexpr; // goto loop; // loop:; // variable = phi [start, loopheader], [nextvariable, loopend]; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // nextvariable = variable + step; // endcond = endexpr; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:11,Performance,optimiz,optimizer,11,// Run the optimizer on the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:50,Performance,optimiz,optimizations,50,"// Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:32,Usability,simpl,simple,32,"// Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:50,Energy Efficiency,allocate,allocated,50,// Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter6/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:225,Availability,error,error,225,// Assignment requires the LHS to be an identifier.; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:225,Performance,load,load,225,"// Output for-loop as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:11,Performance,optimiz,optimizer,11,// Run the optimizer on the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:50,Performance,optimiz,optimizations,50,"// Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:32,Usability,simpl,simple,32,"// Add transform passes.; // Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:50,Energy Efficiency,allocate,allocated,50,// Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter7/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:225,Availability,error,error,225,// Assignment requires the LHS to be an identifier.; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:225,Performance,load,load,225,"// Output for-loop as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp:12,Availability,error,error,12,// Print an error and exit if we couldn't find the requested target.; // This generally occurs if we've forgotten to initialise the; // TargetRegistry or we have a bogus target triple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter8/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:376,Deployability,update,updates,376,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:239,Usability,simpl,simple,239,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:54,Availability,error,error,54,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:4,Testability,Log,LogError,4,/// LogError* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:225,Availability,error,error,225,// Assignment requires the LHS to be an identifier.; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:225,Performance,load,load,225,"// Output for-loop as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:37,Modifiability,variab,variable,37,// Create a debug descriptor for the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp:57,Availability,down,down,57,"// Create the compile unit for the module.; // Currently down as ""fib.ks"" as a filename since we're redirecting stdin; // but we'd like actual source locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter9/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h:29,Usability,simpl,simple,29,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h:394,Usability,simpl,simple,394,"//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Contains a simple JIT definition for use in the kaleidoscope tutorials.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py:3,Availability,Echo,Echo,3,"""""""Echo some comments and invoke both versions of toy""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py:2,Deployability,Update,Update,2,# Update the total call count,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py:17,Modifiability,variab,variable,17,# Initialize the variable names to be rotated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py:13,Modifiability,variab,variables,13,# Rotate the variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/split-lib.py:3,Availability,Echo,Echo,3,"""""""Echo some comments and invoke both versions of toy""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/split-lib.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/split-lib.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:348,Deployability,update,updates,348,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:211,Usability,simpl,simple,211,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:4,Availability,Error,Error,4,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:51,Availability,error,error,51,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:222,Performance,load,load,222,"// Output this as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop: ; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Deployability,pipeline,pipeline,24,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:14,Performance,optimiz,optimizer,14,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:24,Performance,optimiz,optimizations,24,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:6,Usability,simpl,simple,6,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:348,Deployability,update,updates,348,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:211,Usability,simpl,simple,211,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:4,Availability,Error,Error,4,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:51,Availability,error,error,51,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:98,Performance,cache,cache,98,//===----------------------------------------------------------------------===//; // MCJIT object cache class; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:10,Performance,cache,cache,10,// Set IR cache directory,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:40,Performance,cache,cache,40,"// If we've flagged this as an IR file, cache it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:40,Performance,cache,cache,40,"// If we've flagged this as an IR file, cache it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:26,Performance,cache,cache,26,// This file isn't in our cache,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:181,Deployability,release,released,181,"// MCJIT will want to write into this buffer, and we don't want that; // because the file has probably just been mmapped. Instead we make; // a copy. The filed-based buffer will be released when it goes; // out of scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:396,Integrability,message,message,396,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:255,Safety,Abort,AbortOnFailure,255,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:418,Safety,abort,aborts,418,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:63,Safety,abort,abort,63,"// Try the standard symbol resolution first, but ask it not to abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Deployability,pipeline,pipeline,24,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:14,Performance,optimiz,optimizer,14,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Performance,optimiz,optimizations,24,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:6,Usability,simpl,simple,6,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:221,Performance,load,load,221,"// Output this as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py:3,Availability,Echo,Echo,3,"""""""Echo some comments and invoke both versions of toy""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py:2,Deployability,Update,Update,2,# Update the total call count,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py:17,Modifiability,variab,variable,17,# Initialize the variable names to be rotated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py:13,Modifiability,variab,variables,13,# Rotate the variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/split-lib.py:3,Availability,Echo,Echo,3,"""""""Echo some comments and invoke both versions of toy""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/split-lib.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/split-lib.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:348,Deployability,update,updates,348,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:211,Usability,simpl,simple,211,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:4,Availability,Error,Error,4,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:51,Availability,error,error,51,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:98,Performance,cache,cache,98,//===----------------------------------------------------------------------===//; // MCJIT object cache class; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:10,Performance,cache,cache,10,// Set IR cache directory,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:40,Performance,cache,cache,40,"// If we've flagged this as an IR file, cache it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:40,Performance,cache,cache,40,"// If we've flagged this as an IR file, cache it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:26,Performance,cache,cache,26,// This file isn't in our cache,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:181,Deployability,release,released,181,"// MCJIT will want to write into this buffer, and we don't want that; // because the file has probably just been mmapped. Instead we make; // a copy. The filed-based buffer will be released when it goes; // out of scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:396,Integrability,message,message,396,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:255,Safety,Abort,AbortOnFailure,255,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:418,Safety,abort,aborts,418,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:63,Safety,abort,abort,63,"// Try the standard symbol resolution first, but ask it not to abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Deployability,pipeline,pipeline,24,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:14,Performance,optimiz,optimizer,14,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Performance,optimiz,optimizations,24,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:6,Usability,simpl,simple,6,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:225,Availability,error,error,225,// Assignment requires the LHS to be an identifier.; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:221,Performance,load,load,221,"// Output this as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:39,Safety,detect,detection,39,"// FIXME: Implement duplicate function detection.; // The check below will only work if the duplicate is in the open module.; // If F conflicted, there was already something named 'Name'. If it has a; // body, don't allow redefinition or reextern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:348,Deployability,update,updates,348,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:211,Usability,simpl,simple,211,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:4,Availability,Error,Error,4,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:51,Availability,error,error,51,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:396,Integrability,message,message,396,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:255,Safety,Abort,AbortOnFailure,255,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:418,Safety,abort,aborts,418,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:63,Safety,abort,abort,63,"// Try the standard symbol resolution first, but ask it not to abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Deployability,pipeline,pipeline,24,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:14,Performance,optimiz,optimizer,14,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Performance,optimiz,optimizations,24,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:6,Usability,simpl,simple,6,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:221,Performance,load,load,221,"// Output this as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/initial/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py:3,Availability,Echo,Echo,3,"""""""Echo some comments and invoke both versions of toy""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py:2,Deployability,Update,Update,2,# Update the total call count,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py:17,Modifiability,variab,variable,17,# Initialize the variable names to be rotated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py:13,Modifiability,variab,variables,13,# Rotate the variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/genk-timing.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:348,Deployability,update,updates,348,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:211,Usability,simpl,simple,211,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:4,Availability,Error,Error,4,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:51,Availability,error,error,51,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:222,Performance,load,load,222,"// Output this as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop: ; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Deployability,pipeline,pipeline,24,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:14,Performance,optimiz,optimizer,14,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:24,Performance,optimiz,optimizations,24,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:6,Usability,simpl,simple,6,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy-jit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:4,Modifiability,Variab,VariableExprAST,4,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:57,Modifiability,variab,variable,57,"/// VariableExprAST - Expression class for referencing a variable, like ""a"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:348,Deployability,update,updates,348,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:211,Usability,simpl,simple,211,//===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:4,Availability,Error,Error,4,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:51,Availability,error,error,51,/// Error* - These are little helper functions for error handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:10,Modifiability,variab,variable,10,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:3,Usability,Simpl,Simple,3,// Simple variable ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:16,Modifiability,variab,variable,16,// At least one variable name is required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:396,Integrability,message,message,396,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:255,Safety,Abort,AbortOnFailure,255,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:418,Safety,abort,aborts,418,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:63,Safety,abort,abort,63,"// Try the standard symbol resolution first, but ask it not to abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Deployability,pipeline,pipeline,24,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:14,Performance,optimiz,optimizer,14,// Set up the optimizer pipeline. Start with registering info about how the; // target lays out data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Performance,optimiz,optimizations,24,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:6,Usability,simpl,simple,6,"// Do simple ""peephole"" optimizations and bit-twiddling optzns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:124,Modifiability,variab,variables,124,/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:13,Modifiability,variab,variable,13,// Look this variable up in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Availability,error,error,24,// If argument mismatch error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Then' can change the current block, update ThenBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:51,Deployability,update,update,51,"// Codegen of 'Else' can change the current block, update ElseBB for the PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:221,Performance,load,load,221,"// Output this as:; // var = alloca double; // ...; // start = startexpr; // store start -> var; // goto loop; // loop:; // ...; // bodyexpr; // ...; // loopend:; // step = stepexpr; // endcond = endexpr; //; // curvar = load var; // nextvar = curvar + step; // store nextvar -> var; // br endcond, loop, endloop; // outloop:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:28,Modifiability,variab,variable,28,// Create an alloca for the variable in the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:39,Modifiability,variab,variable,39,"// Emit the start code first, without 'variable' in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Modifiability,variab,variable,24,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:97,Modifiability,variab,variable,97,"// Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:163,Availability,error,error,163,"// Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:111,Modifiability,variab,variable,111,"// Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:26,Modifiability,variab,variable,26,// Restore the unshadowed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:16,Modifiability,variab,variables,16,// Register all variables and emit their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:42,Modifiability,variab,variable,42,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:116,Modifiability,variab,variable,116,"// Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:20,Modifiability,variab,variable,20,// Remember the old variable binding so that we can restore the binding when; // we unrecurse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:15,Modifiability,variab,variables,15,// Pop all our variables from scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:29,Modifiability,variab,variable,29,// Create an alloca for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:20,Modifiability,variab,variable,20,// Add arguments to variable symbol table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:27,Deployability,install,install,27,"// If this is an operator, install it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:3,Security,Validat,Validate,3,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:3,Availability,Error,Error,3,"// Error reading body, remove function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:18,Availability,error,error,18,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Availability,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:24,Safety,recover,recovery,24,// Skip token for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp:3,Deployability,Install,Install,3,// Install standard binary operators.; // 1 is lowest precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/lazy/toy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ModuleMaker/ModuleMaker.cpp:402,Usability,simpl,simple,402,"//===- examples/ModuleMaker/ModuleMaker.cpp - Example project ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This programs is a simple example that creates an LLVM module ""from scratch"",; // emitting it as a bitcode file to standard out. This is just to show how; // LLVM projects work and to demonstrate some of the LLVM APIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ModuleMaker/ModuleMaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ModuleMaker/ModuleMaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITRemovableCode/LLJITRemovableCode.cpp:235,Usability,clear,clear,235,"// (3) Add the 'foo' module with no explicit resource tracker. The resources; // for 'foo' will be tracked by the default tracker for JD. We will not be; // able to free it separately, but its resources will still be freed when we; // clear or remove JD.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITRemovableCode/LLJITRemovableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITRemovableCode/LLJITRemovableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITRemovableCode/LLJITRemovableCode.cpp:7,Usability,Clear,Clear,7,// (9) Clear JD. This should remove all symbols currently in the JITDylib.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITRemovableCode/LLJITRemovableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITRemovableCode/LLJITRemovableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithCustomObjectLinkingLayer/LLJITWithCustomObjectLinkingLayer.cpp:3,Safety,Detect,Detect,3,// Detect the host and set code model to small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithCustomObjectLinkingLayer/LLJITWithCustomObjectLinkingLayer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithCustomObjectLinkingLayer/LLJITWithCustomObjectLinkingLayer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:549,Deployability,Install,Install,549,"//===- LLJITWithExecutorProcessControl.cpp - LLJIT example with EPC utils -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use the lazy re-exports utility to lazily compile; // IR modules. We will do this in seven steps:; //; // 1. Create an LLJIT instance.; // 2. Install a transform so that we can see what is being compiled.; // 3. Create an indirect stubs manager and lazy call-through manager.; // 4. Add two modules that will be conditionally compiled, plus a main module.; // 5. Add lazy-rexports of the symbols in the conditionally compiled modules.; // 6. Dump the ExecutionSession state to see the symbol table prior to; // executing any code.; // 7. Verify that only modules containing executed code are compiled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:638,Testability,stub,stubs,638,"//===- LLJITWithExecutorProcessControl.cpp - LLJIT example with EPC utils -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use the lazy re-exports utility to lazily compile; // IR modules. We will do this in seven steps:; //; // 1. Create an LLJIT instance.; // 2. Install a transform so that we can see what is being compiled.; // 3. Create an indirect stubs manager and lazy call-through manager.; // 4. Add two modules that will be conditionally compiled, plus a main module.; // 5. Add lazy-rexports of the symbols in the conditionally compiled modules.; // 6. Dump the ExecutionSession state to see the symbol table prior to; // executing any code.; // 7. Verify that only modules containing executed code are compiled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:321,Performance,cache,cached,321,"// Example IR modules.; //; // Note that in the conditionally compiled modules, FooMod and BarMod, functions; // have been given an _body suffix. This is to ensure that their names do not; // clash with their lazy-reexports.; // For clients who do not wish to rename function bodies (e.g. because they want; // to re-use cached objects between static and JIT compiles) techniques exist to; // avoid renaming. See the lazy-reexports section of the ORCv2 design doc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:393,Safety,avoid,avoid,393,"// Example IR modules.; //; // Note that in the conditionally compiled modules, FooMod and BarMod, functions; // have been given an _body suffix. This is to ensure that their names do not; // clash with their lazy-reexports.; // For clients who do not wish to rename function bodies (e.g. because they want; // to re-use cached objects between static and JIT compiles) techniques exist to; // avoid renaming. See the lazy-reexports section of the ORCv2 design doc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:7,Deployability,Install,Install,7,// (2) Install transform to print modules as they are compiled:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:9,Availability,redundant,redundant,9,// Not a redundant move: fix build on gcc-7.5,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:9,Safety,redund,redundant,9,// Not a redundant move: fix build on gcc-7.5,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:14,Testability,stub,stubs,14,// (3) Create stubs and call-through managers:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:204,Integrability,depend,depending,204,"// (7) Execute the JIT'd main function and pass the example's command line; // arguments unmodified. This should cause either ExampleMod1 or ExampleMod2; // to be compiled, and either ""1"" or ""2"" returned depending on the number of; // arguments passed.; // Look up the JIT'd function, cast it to a function pointer, then call it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithGDBRegistrationListener/LLJITWithGDBRegistrationListener.cpp:3,Safety,Detect,Detect,3,// Detect the host and set code model to small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithGDBRegistrationListener/LLJITWithGDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithGDBRegistrationListener/LLJITWithGDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithGDBRegistrationListener/LLJITWithGDBRegistrationListener.cpp:3,Performance,Load,Load,3,// Load the input modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithGDBRegistrationListener/LLJITWithGDBRegistrationListener.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithGDBRegistrationListener/LLJITWithGDBRegistrationListener.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithInitializers/LLJITWithInitializers.cpp:3,Performance,Load,Load,3,// Load the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithInitializers/LLJITWithInitializers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithInitializers/LLJITWithInitializers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp:549,Deployability,Install,Install,549,"//===--- LLJITWithLazyReexports.cpp - LLJIT example with custom laziness --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use the lazy re-exports utility to lazily compile; // IR modules. We will do this in seven steps:; //; // 1. Create an LLJIT instance.; // 2. Install a transform so that we can see what is being compiled.; // 3. Create an indirect stubs manager and lazy call-through manager.; // 4. Add two modules that will be conditionally compiled, plus a main module.; // 5. Add lazy-rexports of the symbols in the conditionally compiled modules.; // 6. Dump the ExecutionSession state to see the symbol table prior to; // executing any code.; // 7. Verify that only modules containing executed code are compiled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp:638,Testability,stub,stubs,638,"//===--- LLJITWithLazyReexports.cpp - LLJIT example with custom laziness --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use the lazy re-exports utility to lazily compile; // IR modules. We will do this in seven steps:; //; // 1. Create an LLJIT instance.; // 2. Install a transform so that we can see what is being compiled.; // 3. Create an indirect stubs manager and lazy call-through manager.; // 4. Add two modules that will be conditionally compiled, plus a main module.; // 5. Add lazy-rexports of the symbols in the conditionally compiled modules.; // 6. Dump the ExecutionSession state to see the symbol table prior to; // executing any code.; // 7. Verify that only modules containing executed code are compiled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp:321,Performance,cache,cached,321,"// Example IR modules.; //; // Note that in the conditionally compiled modules, FooMod and BarMod, functions; // have been given an _body suffix. This is to ensure that their names do not; // clash with their lazy-reexports.; // For clients who do not wish to rename function bodies (e.g. because they want; // to re-use cached objects between static and JIT compiles) techniques exist to; // avoid renaming. See the lazy-reexports section of the ORCv2 design doc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp:393,Safety,avoid,avoid,393,"// Example IR modules.; //; // Note that in the conditionally compiled modules, FooMod and BarMod, functions; // have been given an _body suffix. This is to ensure that their names do not; // clash with their lazy-reexports.; // For clients who do not wish to rename function bodies (e.g. because they want; // to re-use cached objects between static and JIT compiles) techniques exist to; // avoid renaming. See the lazy-reexports section of the ORCv2 design doc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp:7,Deployability,Install,Install,7,// (2) Install transform to print modules as they are compiled:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp:9,Availability,redundant,redundant,9,// Not a redundant move: fix build on gcc-7.5,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp:9,Safety,redund,redundant,9,// Not a redundant move: fix build on gcc-7.5,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp:14,Testability,stub,stubs,14,// (3) Create stubs and call-through managers:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp:204,Integrability,depend,depending,204,"// (7) Execute the JIT'd main function and pass the example's command line; // arguments unmodified. This should cause either ExampleMod1 or ExampleMod2; // to be compiled, and either ""1"" or ""2"" returned depending on the number of; // arguments passed.; // Look up the JIT'd function, cast it to a function pointer, then call it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithLazyReexports/LLJITWithLazyReexports.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:285,Availability,Error,Error,285,"// The modifyPassConfig callback gives us a chance to inspect the; // MaterializationResponsibility and target triple for the object being; // linked, then add any JITLink passes that we would like to run on the; // link graph. A pass is just a function object that is callable as; // Error(jitlink::LinkGraph&). In this case we will add two passes; // defined as lambdas that call the printLinkerGraph method on our; // plugin: One to run before the linker applies fixups and another to; // run afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:421,Modifiability,plugin,plugin,421,"// The modifyPassConfig callback gives us a chance to inspect the; // MaterializationResponsibility and target triple for the object being; // linked, then add any JITLink passes that we would like to run on the; // link graph. A pass is just a function object that is callable as; // Error(jitlink::LinkGraph&). In this case we will add two passes; // defined as lambdas that call the printLinkerGraph method on our; // plugin: One to run before the linker applies fixups and another to; // run afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:330,Deployability,pipeline,pipeline,330,"// Print sections, symbol names and addresses, and any edges for the; // associated blocks at the 'PostPrune' phase of JITLink (after; // dead-stripping, but before addresses are allocated in the target; // address space. See llvm/docs/JITLink.rst).; //; // Experiment with adding the 'printGraph' pass at other points in the; // pipeline. E.g. PrePrunePasses, PostAllocationPasses, and; // PostFixupPasses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:179,Energy Efficiency,allocate,allocated,179,"// Print sections, symbol names and addresses, and any edges for the; // associated blocks at the 'PostPrune' phase of JITLink (after; // dead-stripping, but before addresses are allocated in the target; // address space. See llvm/docs/JITLink.rst).; //; // Experiment with adding the 'printGraph' pass at other points in the; // pipeline. E.g. PrePrunePasses, PostAllocationPasses, and; // PostFixupPasses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:3,Safety,Detect,Detect,3,// Detect the host and set code model to small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:92,Modifiability,plugin,plugin,92,// Create an LLJIT instance with an ObjectLinkingLayer as the base layer.; // We attach our plugin in to the newly created ObjectLinkingLayer before; // returning it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:26,Modifiability,plugin,plugin,26,// Add an instance of our plugin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:3,Performance,Load,Load,3,// Load the input objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp:60,Performance,optimiz,optimization,60,"//===-- LLJITWithOptimizingIRTransform.cpp -- LLJIT with IR optimization --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use an IR transform to optimize a module as it; // passes through LLJIT's IRTransformLayer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp:430,Performance,optimiz,optimize,430,"//===-- LLJITWithOptimizingIRTransform.cpp -- LLJIT with IR optimization --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use an IR transform to optimize a module as it; // passes through LLJIT's IRTransformLayer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp:291,Performance,optimiz,optimization,291,"// Example IR module.; //; // This IR contains a recursive definition of the factorial function:; //; // fac(n) | n == 0 = 1; // | otherwise = n * fac(n - 1); //; // It also contains an entry function which calls the factorial function with; // an input value of 5.; //; // We expect the IR optimization transform that we build below to transform; // this into a non-recursive factorial function and an entry function that; // returns a constant value of 5!, or 120.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp:48,Deployability,pipeline,pipeline,48,// A function object that creates a simple pass pipeline to apply to each; // module as it passes through the IRTransformLayer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp:36,Usability,simpl,simple,36,// A function object that creates a simple pass pipeline to apply to each; // module as it passes through the IRTransformLayer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp:7,Deployability,Install,Install,7,// (2) Install transform to optimize modules when they're materialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp:28,Performance,optimiz,optimize,28,// (2) Install transform to optimize modules when they're materialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:555,Integrability,interface,interface,555,"//===--- LLJITWithRemoteDebugging.cpp - LLJIT targeting a child process ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This example shows how to use LLJIT and JITLink for out-of-process execution; // with debug support. A few notes beforehand:; //; // * Debuggers must implement the GDB JIT interface (gdb, udb, lldb 12+).; // * Debug support is currently limited to ELF on x86-64 platforms that run; // Unix-like systems.; // * There is a test for this example and it ships an IR file that is prepared; // for the instructions below.; //; //; // The following command line session provides a complete walkthrough of the; // feature using LLDB 12:; //; // [Terminal 1] Prepare a debuggable out-of-process JIT session:; //; // > cd llvm-project/build; // > ninja LLJITWithRemoteDebugging llvm-jitlink-executor; // > cp ../llvm/test/Examples/OrcV2Examples/Inputs/argc_sub1_elf.ll .; // > bin/LLJITWithRemoteDebugging --wait-for-debugger argc_sub1_elf.ll; // Found out-of-process executor: bin/llvm-jitlink-executor; // Launched executor in subprocess: 65535; // Attach a debugger and press any key to continue.; //; //; // [Terminal 2] Attach a debugger to the child process:; //; // (lldb) log enable lldb jit; // (lldb) settings set plugin.jit-loader.gdb.enable on; // (lldb) settings set target.source-map Inputs/ \; // /path/to/llvm-project/llvm/test/Examples/OrcV2Examples/Inputs/; // (lldb) attach -p 65535; // JITLoaderGDB::SetJITBreakpoint looking for JIT register hook; // JITLoaderGDB::SetJITBreakpoint setting JIT breakpoint; // Process 65535 stopped; // (lldb) b sub1; // Breakpoint 1: no locations (pending).; // WARNING: Unable to resolve breakpoint to any actual locations.; // (lldb) c; // Process 65535 resuming; //; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:1497,Modifiability,plugin,plugin,1497,"-of-process execution; // with debug support. A few notes beforehand:; //; // * Debuggers must implement the GDB JIT interface (gdb, udb, lldb 12+).; // * Debug support is currently limited to ELF on x86-64 platforms that run; // Unix-like systems.; // * There is a test for this example and it ships an IR file that is prepared; // for the instructions below.; //; //; // The following command line session provides a complete walkthrough of the; // feature using LLDB 12:; //; // [Terminal 1] Prepare a debuggable out-of-process JIT session:; //; // > cd llvm-project/build; // > ninja LLJITWithRemoteDebugging llvm-jitlink-executor; // > cp ../llvm/test/Examples/OrcV2Examples/Inputs/argc_sub1_elf.ll .; // > bin/LLJITWithRemoteDebugging --wait-for-debugger argc_sub1_elf.ll; // Found out-of-process executor: bin/llvm-jitlink-executor; // Launched executor in subprocess: 65535; // Attach a debugger and press any key to continue.; //; //; // [Terminal 2] Attach a debugger to the child process:; //; // (lldb) log enable lldb jit; // (lldb) settings set plugin.jit-loader.gdb.enable on; // (lldb) settings set target.source-map Inputs/ \; // /path/to/llvm-project/llvm/test/Examples/OrcV2Examples/Inputs/; // (lldb) attach -p 65535; // JITLoaderGDB::SetJITBreakpoint looking for JIT register hook; // JITLoaderGDB::SetJITBreakpoint setting JIT breakpoint; // Process 65535 stopped; // (lldb) b sub1; // Breakpoint 1: no locations (pending).; // WARNING: Unable to resolve breakpoint to any actual locations.; // (lldb) c; // Process 65535 resuming; //; //; // [Terminal 1] Press a key to start code generation and execution:; //; // Parsed input IR code from: argc_sub1_elf.ll; // Initialized LLJIT for remote executor; // Running: argc_sub1_elf.ll; //; //; // [Terminal 2] Breakpoint hits; we change the argc value from 1 to 42:; //; // (lldb) JITLoaderGDB::JITDebugBreakpointHit hit JIT breakpoint; // JITLoaderGDB::ReadJITDescriptorImpl registering JIT entry at 0x106b34000; // 1 location add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:1508,Performance,load,loader,1508,"//; // * Debuggers must implement the GDB JIT interface (gdb, udb, lldb 12+).; // * Debug support is currently limited to ELF on x86-64 platforms that run; // Unix-like systems.; // * There is a test for this example and it ships an IR file that is prepared; // for the instructions below.; //; //; // The following command line session provides a complete walkthrough of the; // feature using LLDB 12:; //; // [Terminal 1] Prepare a debuggable out-of-process JIT session:; //; // > cd llvm-project/build; // > ninja LLJITWithRemoteDebugging llvm-jitlink-executor; // > cp ../llvm/test/Examples/OrcV2Examples/Inputs/argc_sub1_elf.ll .; // > bin/LLJITWithRemoteDebugging --wait-for-debugger argc_sub1_elf.ll; // Found out-of-process executor: bin/llvm-jitlink-executor; // Launched executor in subprocess: 65535; // Attach a debugger and press any key to continue.; //; //; // [Terminal 2] Attach a debugger to the child process:; //; // (lldb) log enable lldb jit; // (lldb) settings set plugin.jit-loader.gdb.enable on; // (lldb) settings set target.source-map Inputs/ \; // /path/to/llvm-project/llvm/test/Examples/OrcV2Examples/Inputs/; // (lldb) attach -p 65535; // JITLoaderGDB::SetJITBreakpoint looking for JIT register hook; // JITLoaderGDB::SetJITBreakpoint setting JIT breakpoint; // Process 65535 stopped; // (lldb) b sub1; // Breakpoint 1: no locations (pending).; // WARNING: Unable to resolve breakpoint to any actual locations.; // (lldb) c; // Process 65535 resuming; //; //; // [Terminal 1] Press a key to start code generation and execution:; //; // Parsed input IR code from: argc_sub1_elf.ll; // Initialized LLJIT for remote executor; // Running: argc_sub1_elf.ll; //; //; // [Terminal 2] Breakpoint hits; we change the argc value from 1 to 42:; //; // (lldb) JITLoaderGDB::JITDebugBreakpointHit hit JIT breakpoint; // JITLoaderGDB::ReadJITDescriptorImpl registering JIT entry at 0x106b34000; // 1 location added to breakpoint 1; // Process 65535 stopped; // * thread #1, queue = 'c",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:2500,Performance,queue,queue,2500," cd llvm-project/build; // > ninja LLJITWithRemoteDebugging llvm-jitlink-executor; // > cp ../llvm/test/Examples/OrcV2Examples/Inputs/argc_sub1_elf.ll .; // > bin/LLJITWithRemoteDebugging --wait-for-debugger argc_sub1_elf.ll; // Found out-of-process executor: bin/llvm-jitlink-executor; // Launched executor in subprocess: 65535; // Attach a debugger and press any key to continue.; //; //; // [Terminal 2] Attach a debugger to the child process:; //; // (lldb) log enable lldb jit; // (lldb) settings set plugin.jit-loader.gdb.enable on; // (lldb) settings set target.source-map Inputs/ \; // /path/to/llvm-project/llvm/test/Examples/OrcV2Examples/Inputs/; // (lldb) attach -p 65535; // JITLoaderGDB::SetJITBreakpoint looking for JIT register hook; // JITLoaderGDB::SetJITBreakpoint setting JIT breakpoint; // Process 65535 stopped; // (lldb) b sub1; // Breakpoint 1: no locations (pending).; // WARNING: Unable to resolve breakpoint to any actual locations.; // (lldb) c; // Process 65535 resuming; //; //; // [Terminal 1] Press a key to start code generation and execution:; //; // Parsed input IR code from: argc_sub1_elf.ll; // Initialized LLJIT for remote executor; // Running: argc_sub1_elf.ll; //; //; // [Terminal 2] Breakpoint hits; we change the argc value from 1 to 42:; //; // (lldb) JITLoaderGDB::JITDebugBreakpointHit hit JIT breakpoint; // JITLoaderGDB::ReadJITDescriptorImpl registering JIT entry at 0x106b34000; // 1 location added to breakpoint 1; // Process 65535 stopped; // * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1; // frame #0: JIT(0x106b34000)`sub1(x=1) at argc_sub1.c:1:28; // -> 1 	int sub1(int x) { return x - 1; }; // 2 	int main(int argc, char **argv) { return sub1(argc); }; // (lldb) p x; // (int) $0 = 1; // (lldb) expr x = 42; // (int) $1 = 42; // (lldb) c; //; //; // [Terminal 1] Example output reflects the modified value:; //; // Exit code: 41; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:704,Testability,test,test,704,"//===--- LLJITWithRemoteDebugging.cpp - LLJIT targeting a child process ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This example shows how to use LLJIT and JITLink for out-of-process execution; // with debug support. A few notes beforehand:; //; // * Debuggers must implement the GDB JIT interface (gdb, udb, lldb 12+).; // * Debug support is currently limited to ELF on x86-64 platforms that run; // Unix-like systems.; // * There is a test for this example and it ships an IR file that is prepared; // for the instructions below.; //; //; // The following command line session provides a complete walkthrough of the; // feature using LLDB 12:; //; // [Terminal 1] Prepare a debuggable out-of-process JIT session:; //; // > cd llvm-project/build; // > ninja LLJITWithRemoteDebugging llvm-jitlink-executor; // > cp ../llvm/test/Examples/OrcV2Examples/Inputs/argc_sub1_elf.ll .; // > bin/LLJITWithRemoteDebugging --wait-for-debugger argc_sub1_elf.ll; // Found out-of-process executor: bin/llvm-jitlink-executor; // Launched executor in subprocess: 65535; // Attach a debugger and press any key to continue.; //; //; // [Terminal 2] Attach a debugger to the child process:; //; // (lldb) log enable lldb jit; // (lldb) settings set plugin.jit-loader.gdb.enable on; // (lldb) settings set target.source-map Inputs/ \; // /path/to/llvm-project/llvm/test/Examples/OrcV2Examples/Inputs/; // (lldb) attach -p 65535; // JITLoaderGDB::SetJITBreakpoint looking for JIT register hook; // JITLoaderGDB::SetJITBreakpoint setting JIT breakpoint; // Process 65535 stopped; // (lldb) b sub1; // Breakpoint 1: no locations (pending).; // WARNING: Unable to resolve breakpoint to any actual locations.; // (lldb) c; // Process 65535 resuming; //; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:1090,Testability,test,test,1090,"ct, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This example shows how to use LLJIT and JITLink for out-of-process execution; // with debug support. A few notes beforehand:; //; // * Debuggers must implement the GDB JIT interface (gdb, udb, lldb 12+).; // * Debug support is currently limited to ELF on x86-64 platforms that run; // Unix-like systems.; // * There is a test for this example and it ships an IR file that is prepared; // for the instructions below.; //; //; // The following command line session provides a complete walkthrough of the; // feature using LLDB 12:; //; // [Terminal 1] Prepare a debuggable out-of-process JIT session:; //; // > cd llvm-project/build; // > ninja LLJITWithRemoteDebugging llvm-jitlink-executor; // > cp ../llvm/test/Examples/OrcV2Examples/Inputs/argc_sub1_elf.ll .; // > bin/LLJITWithRemoteDebugging --wait-for-debugger argc_sub1_elf.ll; // Found out-of-process executor: bin/llvm-jitlink-executor; // Launched executor in subprocess: 65535; // Attach a debugger and press any key to continue.; //; //; // [Terminal 2] Attach a debugger to the child process:; //; // (lldb) log enable lldb jit; // (lldb) settings set plugin.jit-loader.gdb.enable on; // (lldb) settings set target.source-map Inputs/ \; // /path/to/llvm-project/llvm/test/Examples/OrcV2Examples/Inputs/; // (lldb) attach -p 65535; // JITLoaderGDB::SetJITBreakpoint looking for JIT register hook; // JITLoaderGDB::SetJITBreakpoint setting JIT breakpoint; // Process 65535 stopped; // (lldb) b sub1; // Breakpoint 1: no locations (pending).; // WARNING: Unable to resolve breakpoint to any actual locations.; // (lldb) c; // Process 65535 resuming; //; //; // [Terminal 1] Press a key to start code generation and execution:; //; // Parsed input IR code from: argc_sub1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:1453,Testability,log,log,1453,"-of-process execution; // with debug support. A few notes beforehand:; //; // * Debuggers must implement the GDB JIT interface (gdb, udb, lldb 12+).; // * Debug support is currently limited to ELF on x86-64 platforms that run; // Unix-like systems.; // * There is a test for this example and it ships an IR file that is prepared; // for the instructions below.; //; //; // The following command line session provides a complete walkthrough of the; // feature using LLDB 12:; //; // [Terminal 1] Prepare a debuggable out-of-process JIT session:; //; // > cd llvm-project/build; // > ninja LLJITWithRemoteDebugging llvm-jitlink-executor; // > cp ../llvm/test/Examples/OrcV2Examples/Inputs/argc_sub1_elf.ll .; // > bin/LLJITWithRemoteDebugging --wait-for-debugger argc_sub1_elf.ll; // Found out-of-process executor: bin/llvm-jitlink-executor; // Launched executor in subprocess: 65535; // Attach a debugger and press any key to continue.; //; //; // [Terminal 2] Attach a debugger to the child process:; //; // (lldb) log enable lldb jit; // (lldb) settings set plugin.jit-loader.gdb.enable on; // (lldb) settings set target.source-map Inputs/ \; // /path/to/llvm-project/llvm/test/Examples/OrcV2Examples/Inputs/; // (lldb) attach -p 65535; // JITLoaderGDB::SetJITBreakpoint looking for JIT register hook; // JITLoaderGDB::SetJITBreakpoint setting JIT breakpoint; // Process 65535 stopped; // (lldb) b sub1; // Breakpoint 1: no locations (pending).; // WARNING: Unable to resolve breakpoint to any actual locations.; // (lldb) c; // Process 65535 resuming; //; //; // [Terminal 1] Press a key to start code generation and execution:; //; // Parsed input IR code from: argc_sub1_elf.ll; // Initialized LLJIT for remote executor; // Running: argc_sub1_elf.ll; //; //; // [Terminal 2] Breakpoint hits; we change the argc value from 1 to 42:; //; // (lldb) JITLoaderGDB::JITDebugBreakpointHit hit JIT breakpoint; // JITLoaderGDB::ReadJITDescriptorImpl registering JIT entry at 0x106b34000; // 1 location add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:1612,Testability,test,test,1612,"mple and it ships an IR file that is prepared; // for the instructions below.; //; //; // The following command line session provides a complete walkthrough of the; // feature using LLDB 12:; //; // [Terminal 1] Prepare a debuggable out-of-process JIT session:; //; // > cd llvm-project/build; // > ninja LLJITWithRemoteDebugging llvm-jitlink-executor; // > cp ../llvm/test/Examples/OrcV2Examples/Inputs/argc_sub1_elf.ll .; // > bin/LLJITWithRemoteDebugging --wait-for-debugger argc_sub1_elf.ll; // Found out-of-process executor: bin/llvm-jitlink-executor; // Launched executor in subprocess: 65535; // Attach a debugger and press any key to continue.; //; //; // [Terminal 2] Attach a debugger to the child process:; //; // (lldb) log enable lldb jit; // (lldb) settings set plugin.jit-loader.gdb.enable on; // (lldb) settings set target.source-map Inputs/ \; // /path/to/llvm-project/llvm/test/Examples/OrcV2Examples/Inputs/; // (lldb) attach -p 65535; // JITLoaderGDB::SetJITBreakpoint looking for JIT register hook; // JITLoaderGDB::SetJITBreakpoint setting JIT breakpoint; // Process 65535 stopped; // (lldb) b sub1; // Breakpoint 1: no locations (pending).; // WARNING: Unable to resolve breakpoint to any actual locations.; // (lldb) c; // Process 65535 resuming; //; //; // [Terminal 1] Press a key to start code generation and execution:; //; // Parsed input IR code from: argc_sub1_elf.ll; // Initialized LLJIT for remote executor; // Running: argc_sub1_elf.ll; //; //; // [Terminal 2] Breakpoint hits; we change the argc value from 1 to 42:; //; // (lldb) JITLoaderGDB::JITDebugBreakpointHit hit JIT breakpoint; // JITLoaderGDB::ReadJITDescriptorImpl registering JIT entry at 0x106b34000; // 1 location added to breakpoint 1; // Process 65535 stopped; // * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1; // frame #0: JIT(0x106b34000)`sub1(x=1) at argc_sub1.c:1:28; // -> 1 	int sub1(int x) { return x - 1; }; // 2 	int main(int argc, char **argv) { return sub1(ar",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:3,Performance,Load,Load,3,// Load the given IR files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:7,Modifiability,plugin,plugin,7,// Add plugin for debug support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:3,Performance,Load,Load,3,"// Load required shared libraries on the remote target and add a generator; // for each of it, so the compiler can lookup their symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:11,Performance,load,loaded,11,// Add the loaded IR module to the JIT. This will set up symbol tables and; // prepare for materialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:39,Usability,simpl,simplicity,39,"// The example uses a non-lazy JIT for simplicity. Thus, looking up the main; // function will materialize all reachable code. It also triggers debug; // registration in the remote target process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp:990,Testability,test,test,990,"//===--- LLJITWithThinLTOSummaries.cpp - Module summaries as LLJIT input --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use a module summary index file produced for ThinLTO; // to (A) find the module that defines the main entry point and (B) find all; // extra modules that we need. We will do this in five steps:; //; // (1) Read the index file and parse the module summary index.; // (2) Find the path of the module that defines ""main"".; // (3) Parse the main module and create a matching LLJIT.; // (4) Add all modules to the LLJIT that are covered by the index.; // (5) Look up and run the JIT'd function.; //; // The index file name must be passed in as command line argument. Please find; // this test for instructions on creating the index file:; //; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; // If you use ""build"" as the build directory, you can run the test from the root; // of the monorepo like this:; //; // > build/bin/llvm-lit -a \; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp:1053,Testability,test,test,1053,"//===--- LLJITWithThinLTOSummaries.cpp - Module summaries as LLJIT input --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use a module summary index file produced for ThinLTO; // to (A) find the module that defines the main entry point and (B) find all; // extra modules that we need. We will do this in five steps:; //; // (1) Read the index file and parse the module summary index.; // (2) Find the path of the module that defines ""main"".; // (3) Parse the main module and create a matching LLJIT.; // (4) Add all modules to the LLJIT that are covered by the index.; // (5) Look up and run the JIT'd function.; //; // The index file name must be passed in as command line argument. Please find; // this test for instructions on creating the index file:; //; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; // If you use ""build"" as the build directory, you can run the test from the root; // of the monorepo like this:; //; // > build/bin/llvm-lit -a \; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp:1110,Testability,test,test,1110,"//===--- LLJITWithThinLTOSummaries.cpp - Module summaries as LLJIT input --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use a module summary index file produced for ThinLTO; // to (A) find the module that defines the main entry point and (B) find all; // extra modules that we need. We will do this in five steps:; //; // (1) Read the index file and parse the module summary index.; // (2) Find the path of the module that defines ""main"".; // (3) Parse the main module and create a matching LLJIT.; // (4) Add all modules to the LLJIT that are covered by the index.; // (5) Look up and run the JIT'd function.; //; // The index file name must be passed in as command line argument. Please find; // this test for instructions on creating the index file:; //; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; // If you use ""build"" as the build directory, you can run the test from the root; // of the monorepo like this:; //; // > build/bin/llvm-lit -a \; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp:1182,Testability,test,test,1182,"//===--- LLJITWithThinLTOSummaries.cpp - Module summaries as LLJIT input --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use a module summary index file produced for ThinLTO; // to (A) find the module that defines the main entry point and (B) find all; // extra modules that we need. We will do this in five steps:; //; // (1) Read the index file and parse the module summary index.; // (2) Find the path of the module that defines ""main"".; // (3) Parse the main module and create a matching LLJIT.; // (4) Add all modules to the LLJIT that are covered by the index.; // (5) Look up and run the JIT'd function.; //; // The index file name must be passed in as command line argument. Please find; // this test for instructions on creating the index file:; //; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; // If you use ""build"" as the build directory, you can run the test from the root; // of the monorepo like this:; //; // > build/bin/llvm-lit -a \; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp:1275,Testability,test,test,1275,"//===--- LLJITWithThinLTOSummaries.cpp - Module summaries as LLJIT input --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use a module summary index file produced for ThinLTO; // to (A) find the module that defines the main entry point and (B) find all; // extra modules that we need. We will do this in five steps:; //; // (1) Read the index file and parse the module summary index.; // (2) Find the path of the module that defines ""main"".; // (3) Parse the main module and create a matching LLJIT.; // (4) Add all modules to the LLJIT that are covered by the index.; // (5) Look up and run the JIT'd function.; //; // The index file name must be passed in as command line argument. Please find; // this test for instructions on creating the index file:; //; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; // If you use ""build"" as the build directory, you can run the test from the root; // of the monorepo like this:; //; // > build/bin/llvm-lit -a \; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp:1332,Testability,test,test,1332,"//===--- LLJITWithThinLTOSummaries.cpp - Module summaries as LLJIT input --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use a module summary index file produced for ThinLTO; // to (A) find the module that defines the main entry point and (B) find all; // extra modules that we need. We will do this in five steps:; //; // (1) Read the index file and parse the module summary index.; // (2) Find the path of the module that defines ""main"".; // (3) Parse the main module and create a matching LLJIT.; // (4) Add all modules to the LLJIT that are covered by the index.; // (5) Look up and run the JIT'd function.; //; // The index file name must be passed in as command line argument. Please find; // this test for instructions on creating the index file:; //; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; // If you use ""build"" as the build directory, you can run the test from the root; // of the monorepo like this:; //; // > build/bin/llvm-lit -a \; // llvm/test/Examples/OrcV2Examples/lljit-with-thinlto-summaries.test; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp:165,Usability,GUID,GUID,165,// Describe a fail state that is caused by the given ModuleSummaryIndex; // providing multiple definitions of the given global value name. It will dump; // name and GUID for the global value and list the paths of the modules covered; // by the index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp:132,Usability,GUID,GUID,132,// Describe a fail state where the given global value name was not found in the; // given ModuleSummaryIndex. It will dump name and GUID for the global value and; // list the paths of the modules covered by the index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithThinLTOSummaries/LLJITWithThinLTOSummaries.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c:237,Availability,error,error,237,"// Destroy our JIT instance. This will clean up any memory that the JIT has; // taken ownership of. This operation is non-trivial (e.g. it may need to; // JIT static destructors) and may also fail. In that case we want to render; // the error to stderr, but not overwrite any existing return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c:8,Availability,down,down,8,// Shut down LLVM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsAddObjectFile/OrcV2CBindingsAddObjectFile.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c:36,Integrability,Wrap,Wrap,36,// Our demo module is now complete. Wrap it and our ThreadSafeContext in a; // ThreadSafeModule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c:93,Availability,alive,alive,93,"// Dispose of our local ThreadSafeContext value. The underlying LLVMContext; // will be kept alive by our ThreadSafeModule, TSM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c:237,Availability,error,error,237,"// Destroy our JIT instance. This will clean up any memory that the JIT has; // taken ownership of. This operation is non-trivial (e.g. it may need to; // JIT static destructors) and may also fail. In that case we want to render; // the error to stderr, but not overwrite any existing return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c:8,Availability,down,down,8,// Shut down LLVM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsDumpObjects/OrcV2CBindingsDumpObjects.c:8,Availability,down,down,8,// Shut down LLVM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsDumpObjects/OrcV2CBindingsDumpObjects.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsDumpObjects/OrcV2CBindingsDumpObjects.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsIRTransforms/OrcV2CBindingsIRTransforms.c:8,Availability,down,down,8,// Shut down LLVM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsIRTransforms/OrcV2CBindingsIRTransforms.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsIRTransforms/OrcV2CBindingsIRTransforms.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c:321,Performance,cache,cached,321,"// Example IR modules.; //; // Note that in the conditionally compiled modules, FooMod and BarMod, functions; // have been given an _body suffix. This is to ensure that their names do not; // clash with their lazy-reexports.; // For clients who do not wish to rename function bodies (e.g. because they want; // to re-use cached objects between static and JIT compiles) techniques exist to; // avoid renaming. See the lazy-reexports section of the ORCv2 design doc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c:393,Safety,avoid,avoid,393,"// Example IR modules.; //; // Note that in the conditionally compiled modules, FooMod and BarMod, functions; // have been given an _body suffix. This is to ensure that their names do not; // clash with their lazy-reexports.; // For clients who do not wish to rename function bodies (e.g. because they want; // to re-use cached objects between static and JIT compiles) techniques exist to; // avoid renaming. See the lazy-reexports section of the ORCv2 design doc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c:3,Integrability,Wrap,Wrap,3,// Wrap Source in a MemoryBuffer,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c:31,Integrability,Wrap,Wrap,31,// Our module is now complete. Wrap it and our ThreadSafeContext in a; // ThreadSafeModule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c:93,Availability,alive,alive,93,"// Dispose of our local ThreadSafeContext value. The underlying LLVMContext; // will be kept alive by our ThreadSafeModule, TSM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c:237,Availability,error,error,237,"// Destroy our JIT instance. This will clean up any memory that the JIT has; // taken ownership of. This operation is non-trivial (e.g. it may need to; // JIT static destructors) and may also fail. In that case we want to render; // the error to stderr, but not overwrite any existing return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c:8,Availability,down,down,8,// Shut down LLVM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c:522,Energy Efficiency,allocate,allocated,522,"//=== OrcV2CBindingsMemoryManager.c - OrcV2 Memory Manager C Bindings Demo ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This demo illustrates the C-API bindings for custom memory managers in; // ORCv2. They are used here to place generated code into manually allocated; // buffers that are subsequently marked as executable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c:36,Integrability,Wrap,Wrap,36,// Our demo module is now complete. Wrap it and our ThreadSafeContext in a; // ThreadSafeModule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c:93,Availability,alive,alive,93,"// Dispose of our local ThreadSafeContext value. The underlying LLVMContext; // will be kept alive by our ThreadSafeModule, TSM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c:237,Availability,error,error,237,"// Destroy our JIT instance. This will clean up any memory that the JIT has; // taken ownership of. This operation is non-trivial (e.g. it may need to; // JIT static destructors) and may also fail. In that case we want to render; // the error to stderr, but not overwrite any existing return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c:8,Availability,down,down,8,// Shut down LLVM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsMCJITLikeMemoryManager/OrcV2CBindingsMCJITLikeMemoryManager.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c:36,Integrability,Wrap,Wrap,36,// Our demo module is now complete. Wrap it and our ThreadSafeContext in a; // ThreadSafeModule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c:93,Availability,alive,alive,93,"// Dispose of our local ThreadSafeContext value. The underlying LLVMContext; // will be kept alive by our ThreadSafeModule, TSM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c:46,Availability,error,error,46,// Attempt a second lookup. Here we expect an error as the code and symbols; // should have been removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c:237,Availability,error,error,237,"// Destroy our JIT instance. This will clean up any memory that the JIT has; // taken ownership of. This operation is non-trivial (e.g. it may need to; // JIT static destructors) and may also fail. In that case we want to render; // the error to stderr, but not overwrite any existing return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c:8,Availability,down,down,8,// Shut down LLVM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsRemovableCode/OrcV2CBindingsRemovableCode.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c:321,Performance,cache,cached,321,"// Example IR modules.; //; // Note that in the conditionally compiled modules, FooMod and BarMod, functions; // have been given an _body suffix. This is to ensure that their names do not; // clash with their lazy-reexports.; // For clients who do not wish to rename function bodies (e.g. because they want; // to re-use cached objects between static and JIT compiles) techniques exist to; // avoid renaming. See the lazy-reexports section of the ORCv2 design doc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c:393,Safety,avoid,avoid,393,"// Example IR modules.; //; // Note that in the conditionally compiled modules, FooMod and BarMod, functions; // have been given an _body suffix. This is to ensure that their names do not; // clash with their lazy-reexports.; // For clients who do not wish to rename function bodies (e.g. because they want; // to re-use cached objects between static and JIT compiles) techniques exist to; // avoid renaming. See the lazy-reexports section of the ORCv2 design doc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c:3,Integrability,Wrap,Wrap,3,// Wrap Source in a MemoryBuffer,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c:31,Integrability,Wrap,Wrap,31,// Our module is now complete. Wrap it and our ThreadSafeContext in a; // ThreadSafeModule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c:93,Availability,alive,alive,93,"// Dispose of our local ThreadSafeContext value. The underlying LLVMContext; // will be kept alive by our ThreadSafeModule, TSM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c:237,Availability,error,error,237,"// Destroy our JIT instance. This will clean up any memory that the JIT has; // taken ownership of. This operation is non-trivial (e.g. it may need to; // JIT static destructors) and may also fail. In that case we want to render; // the error to stderr, but not overwrite any existing return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c:8,Availability,down,down,8,// Shut down LLVM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsVeryLazy/OrcV2CBindingsVeryLazy.c
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:894,Availability,error,errors,894,"//===-- examples/ParallelJIT/ParallelJIT.cpp - Exercise threaded-safe JIT -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Parallel JIT; //; // This test program creates two LLVM functions then calls them from three; // separate threads. It requires the pthreads library.; // The three threads are created and then block waiting on a condition variable.; // Once all threads are blocked on the conditional variable, the main thread; // wakes them up. This complicated work is performed so that all three threads; // call into the JIT at the same time (or the best possible approximation of the; // same time). This test had assertion errors until I got the locking right.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:604,Modifiability,variab,variable,604,"//===-- examples/ParallelJIT/ParallelJIT.cpp - Exercise threaded-safe JIT -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Parallel JIT; //; // This test program creates two LLVM functions then calls them from three; // separate threads. It requires the pthreads library.; // The three threads are created and then block waiting on a condition variable.; // Once all threads are blocked on the conditional variable, the main thread; // wakes them up. This complicated work is performed so that all three threads; // call into the JIT at the same time (or the best possible approximation of the; // same time). This test had assertion errors until I got the locking right.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:666,Modifiability,variab,variable,666,"//===-- examples/ParallelJIT/ParallelJIT.cpp - Exercise threaded-safe JIT -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Parallel JIT; //; // This test program creates two LLVM functions then calls them from three; // separate threads. It requires the pthreads library.; // The three threads are created and then block waiting on a condition variable.; // Once all threads are blocked on the conditional variable, the main thread; // wakes them up. This complicated work is performed so that all three threads; // call into the JIT at the same time (or the best possible approximation of the; // same time). This test had assertion errors until I got the locking right.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:736,Performance,perform,performed,736,"//===-- examples/ParallelJIT/ParallelJIT.cpp - Exercise threaded-safe JIT -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Parallel JIT; //; // This test program creates two LLVM functions then calls them from three; // separate threads. It requires the pthreads library.; // The three threads are created and then block waiting on a condition variable.; // Once all threads are blocked on the conditional variable, the main thread; // wakes them up. This complicated work is performed so that all three threads; // call into the JIT at the same time (or the best possible approximation of the; // same time). This test had assertion errors until I got the locking right.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:65,Safety,safe,safe,65,"//===-- examples/ParallelJIT/ParallelJIT.cpp - Exercise threaded-safe JIT -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Parallel JIT; //; // This test program creates two LLVM functions then calls them from three; // separate threads. It requires the pthreads library.; // The three threads are created and then block waiting on a condition variable.; // Once all threads are blocked on the conditional variable, the main thread; // wakes them up. This complicated work is performed so that all three threads; // call into the JIT at the same time (or the best possible approximation of the; // same time). This test had assertion errors until I got the locking right.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:409,Testability,test,test,409,"//===-- examples/ParallelJIT/ParallelJIT.cpp - Exercise threaded-safe JIT -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Parallel JIT; //; // This test program creates two LLVM functions then calls them from three; // separate threads. It requires the pthreads library.; // The three threads are created and then block waiting on a condition variable.; // Once all threads are blocked on the conditional variable, the main thread; // wakes them up. This complicated work is performed so that all three threads; // call into the JIT at the same time (or the best possible approximation of the; // same time). This test had assertion errors until I got the locking right.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:875,Testability,test,test,875,"//===-- examples/ParallelJIT/ParallelJIT.cpp - Exercise threaded-safe JIT -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Parallel JIT; //; // This test program creates two LLVM functions then calls them from three; // separate threads. It requires the pthreads library.; // The three threads are created and then block waiting on a condition variable.; // Once all threads are blocked on the conditional variable, the main thread; // wakes them up. This complicated work is performed so that all three threads; // call into the JIT at the same time (or the best possible approximation of the; // same time). This test had assertion errors until I got the locking right.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:884,Testability,assert,assertion,884,"//===-- examples/ParallelJIT/ParallelJIT.cpp - Exercise threaded-safe JIT -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Parallel JIT; //; // This test program creates two LLVM functions then calls them from three; // separate threads. It requires the pthreads library.; // The three threads are created and then block waiting on a condition variable.; // Once all threads are blocked on the conditional variable, the main thread; // wakes them up. This complicated work is performed so that all three threads; // call into the JIT at the same time (or the best possible approximation of the; // same time). This test had assertion errors until I got the locking right.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:57,Deployability,release,releaseThreads,57,// All threads will stop here until another thread calls releaseThreads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:48,Deployability,release,release,48,// There are enough threads blocked that we can release all of them,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:145,Deployability,release,release,145,"// Reset the counters to zero: this way, if any new threads; // enter while threads are exiting, they will block instead; // of triggering a new release of threads",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:140,Deployability,release,release,140,"// Reset waitFor to zero: this way, if waitFor threads enter; // while threads are exiting, they will block instead of; // triggering a new release of threads",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/SpeculativeJIT/SpeculativeJIT.cpp:7,Modifiability,Layers,Layers,7,// Add Layers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/SpeculativeJIT/SpeculativeJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/SpeculativeJIT/SpeculativeJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/SpeculativeJIT/SpeculativeJIT.cpp:3,Performance,Load,Load,3,// Load the IR inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/examples/SpeculativeJIT/SpeculativeJIT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/SpeculativeJIT/SpeculativeJIT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InitializePasses.h:447,Integrability,rout,routines,447,"//===- llvm/InitializePasses.h - Initialize All Passes ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declarations for the pass initialization routines; // for the entire LLVM project.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/InitializePasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InitializePasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LinkAllIR.h:122,Performance,optimiz,optimization,122,"// We must reference VMCore in such a way that compilers will not; // delete it all as dead code, even with whole program optimization,; // yet is effectively a NO-OP. As the compiler isn't smart enough; // to know that getenv() never returns -1, this will do the job.; // This is so that globals in the translation units where these functions; // are defined are forced to be initialized, populating various; // registries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/LinkAllIR.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LinkAllIR.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LinkAllPasses.h:126,Performance,optimiz,optimization,126,"// We must reference the passes in such a way that compilers will not; // delete it all as dead code, even with whole program optimization,; // yet is effectively a NO-OP. As the compiler isn't smart enough; // to know that getenv() never returns -1, this will do the job.; // This is so that globals in the translation units where these functions; // are defined are forced to be initialized, populating various; // registries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/LinkAllPasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LinkAllPasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:1253,Availability,avail,available,1253,"//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a base class that indicates that a specified class is a; // transformation pass implementation.; //; // Passes are designed this way so that it is possible to run passes in a cache; // and organizationally optimal order without having to specify it at the front; // end. This allows arbitrary passes to be strung together and have them; // executed as efficiently as possible.; //; // Passes should extend one of the classes below, depending on the guarantees; // that it can make about what will be modified as it is run. For example, most; // global optimizations should derive from FunctionPass, because they do not add; // or delete functions, they operate on the internals of the function.; //; // Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the; // bottom), so the APIs exposed by these files are also automatically available; // to all users of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:753,Energy Efficiency,efficient,efficiently,753,"//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a base class that indicates that a specified class is a; // transformation pass implementation.; //; // Passes are designed this way so that it is possible to run passes in a cache; // and organizationally optimal order without having to specify it at the front; // end. This allows arbitrary passes to be strung together and have them; // executed as efficiently as possible.; //; // Passes should extend one of the classes below, depending on the guarantees; // that it can make about what will be modified as it is run. For example, most; // global optimizations should derive from FunctionPass, because they do not add; // or delete functions, they operate on the internals of the function.; //; // Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the; // bottom), so the APIs exposed by these files are also automatically available; // to all users of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:833,Integrability,depend,depending,833,"//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a base class that indicates that a specified class is a; // transformation pass implementation.; //; // Passes are designed this way so that it is possible to run passes in a cache; // and organizationally optimal order without having to specify it at the front; // end. This allows arbitrary passes to be strung together and have them; // executed as efficiently as possible.; //; // Passes should extend one of the classes below, depending on the guarantees; // that it can make about what will be modified as it is run. For example, most; // global optimizations should derive from FunctionPass, because they do not add; // or delete functions, they operate on the internals of the function.; //; // Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the; // bottom), so the APIs exposed by these files are also automatically available; // to all users of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:800,Modifiability,extend,extend,800,"//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a base class that indicates that a specified class is a; // transformation pass implementation.; //; // Passes are designed this way so that it is possible to run passes in a cache; // and organizationally optimal order without having to specify it at the front; // end. This allows arbitrary passes to be strung together and have them; // executed as efficiently as possible.; //; // Passes should extend one of the classes below, depending on the guarantees; // that it can make about what will be modified as it is run. For example, most; // global optimizations should derive from FunctionPass, because they do not add; // or delete functions, they operate on the internals of the function.; //; // Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the; // bottom), so the APIs exposed by these files are also automatically available; // to all users of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:576,Performance,cache,cache,576,"//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a base class that indicates that a specified class is a; // transformation pass implementation.; //; // Passes are designed this way so that it is possible to run passes in a cache; // and organizationally optimal order without having to specify it at the front; // end. This allows arbitrary passes to be strung together and have them; // executed as efficiently as possible.; //; // Passes should extend one of the classes below, depending on the guarantees; // that it can make about what will be modified as it is run. For example, most; // global optimizations should derive from FunctionPass, because they do not add; // or delete functions, they operate on the internals of the function.; //; // Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the; // bottom), so the APIs exposed by these files are also automatically available; // to all users of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:953,Performance,optimiz,optimizations,953,"//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a base class that indicates that a specified class is a; // transformation pass implementation.; //; // Passes are designed this way so that it is possible to run passes in a cache; // and organizationally optimal order without having to specify it at the front; // end. This allows arbitrary passes to be strung together and have them; // executed as efficiently as possible.; //; // Passes should extend one of the classes below, depending on the guarantees; // that it can make about what will be modified as it is run. For example, most; // global optimizations should derive from FunctionPass, because they do not add; // or delete functions, they operate on the internals of the function.; //; // Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the; // bottom), so the APIs exposed by these files are also automatically available; // to all users of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:1207,Security,expose,exposed,1207,"//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a base class that indicates that a specified class is a; // transformation pass implementation.; //; // Passes are designed this way so that it is possible to run passes in a cache; // and organizationally optimal order without having to specify it at the front; // end. This allows arbitrary passes to be strung together and have them; // executed as efficiently as possible.; //; // Passes should extend one of the classes below, depending on the guarantees; // that it can make about what will be modified as it is run. For example, most; // global optimizations should derive from FunctionPass, because they do not add; // or delete functions, they operate on the internals of the function.; //; // Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the; // bottom), so the APIs exposed by these files are also automatically available; // to all users of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:49,Performance,optimiz,optimization,49,/// This enumerates the LLVM full LTO or ThinLTO optimization phases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:91,Integrability,interface,interface,91,//===----------------------------------------------------------------------===//; /// Pass interface - Implemented by all 'passes'. Subclass this if you are an; /// interprocedural optimization or you do not fit into any of the more; /// constrained passes described below.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:181,Performance,optimiz,optimization,181,//===----------------------------------------------------------------------===//; /// Pass interface - Implemented by all 'passes'. Subclass this if you are an; /// interprocedural optimization or you do not fit into any of the more; /// constrained passes described below.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:94,Availability,avail,available,94,/// Each pass is responsible for assigning a pass manager to itself.; /// PMS is the stack of available pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:13,Availability,avail,available,13,/// Check if available pass managers are suitable for this pass or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:3,Security,Access,Access,3,// Access AnalysisResolver,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:4,Deployability,release,releaseMemory,4,"/// releaseMemory() - This member can be implemented by a pass if it wants to; /// be able to release its memory when it is no longer needed. The default; /// behavior of passes is to hold onto memory for the entire duration of their; /// lifetime (which is the entire compile time). For pipelined passes, this; /// is not a big deal because that memory gets recycled every time the pass is; /// invoked on another program unit. For IP passes, it is more important to; /// free memory when it is unused.; ///; /// Optionally implement this function to release pass memory when it is no; /// longer used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:94,Deployability,release,release,94,"/// releaseMemory() - This member can be implemented by a pass if it wants to; /// be able to release its memory when it is no longer needed. The default; /// behavior of passes is to hold onto memory for the entire duration of their; /// lifetime (which is the entire compile time). For pipelined passes, this; /// is not a big deal because that memory gets recycled every time the pass is; /// invoked on another program unit. For IP passes, it is more important to; /// free memory when it is unused.; ///; /// Optionally implement this function to release pass memory when it is no; /// longer used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:288,Deployability,pipeline,pipelined,288,"/// releaseMemory() - This member can be implemented by a pass if it wants to; /// be able to release its memory when it is no longer needed. The default; /// behavior of passes is to hold onto memory for the entire duration of their; /// lifetime (which is the entire compile time). For pipelined passes, this; /// is not a big deal because that memory gets recycled every time the pass is; /// invoked on another program unit. For IP passes, it is more important to; /// free memory when it is unused.; ///; /// Optionally implement this function to release pass memory when it is no; /// longer used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:552,Deployability,release,release,552,"/// releaseMemory() - This member can be implemented by a pass if it wants to; /// be able to release its memory when it is no longer needed. The default; /// behavior of passes is to hold onto memory for the entire duration of their; /// lifetime (which is the entire compile time). For pipelined passes, this; /// is not a big deal because that memory gets recycled every time the pass is; /// invoked on another program unit. For IP passes, it is more important to; /// free memory when it is unused.; ///; /// Optionally implement this function to release pass memory when it is no; /// longer used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:93,Integrability,interface,interface,93,"/// getAdjustedAnalysisPointer - This method is used when a pass implements; /// an analysis interface through multiple inheritance. If needed, it should; /// override this to adjust the this pointer as needed for the specified pass; /// info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:120,Modifiability,inherit,inheritance,120,"/// getAdjustedAnalysisPointer - This method is used when a pass implements; /// an analysis interface through multiple inheritance. If needed, it should; /// override this to adjust the this pointer as needed for the specified pass; /// info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:349,Availability,avail,available,349,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:144,Deployability,update,update,144,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:417,Deployability,update,update,417,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:491,Performance,perform,performed,491,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:290,Availability,avail,available,290,"// Defined in PassAnalysisSupport.h; /// mustPreserveAnalysisID - This method serves the same function as; /// getAnalysisIfAvailable, but works if you just have an AnalysisID. This; /// obviously cannot give you a properly typed instance of the class if you; /// don't have the class name available (use getAnalysisIfAvailable if you; /// do), but it can tell you if you need to preserve the pass at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:30,Safety,detect,detect,30,/// Hash a module in order to detect when a module (or more specific) pass has; /// modified it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:4,Security,Hash,Hash,4,/// Hash a module in order to detect when a module (or more specific) pass has; /// modified it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:32,Safety,detect,detect,32,/// Hash a function in order to detect when a function (or more specific) pass; /// has modified it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:4,Security,Hash,Hash,4,/// Hash a function in order to detect when a function (or more specific) pass; /// has modified it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:171,Performance,optimiz,optimizations,171,//===----------------------------------------------------------------------===//; /// ModulePass class - This class is used to implement unstructured; /// interprocedural optimizations and analyses. ModulePasses may do anything; /// they want to the program.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:111,Performance,optimiz,optimization,111,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:92,Performance,perform,perform,92,"/// initializePass - This method may be overriden by immutable passes to allow; /// them to perform various initialization actions they require. This is; /// primarily because an ImmutablePass can ""require"" another ImmutablePass,; /// and if it does, the overloaded version of initializePass may get access to; /// these passes with getAnalysis<>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:300,Security,access,access,300,"/// initializePass - This method may be overriden by immutable passes to allow; /// them to perform various initialization actions they require. This is; /// primarily because an ImmutablePass can ""require"" another ImmutablePass,; /// and if it does, the overloaded version of initializePass may get access to; /// these passes with getAnalysis<>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:156,Performance,optimiz,optimizations,156,"//===----------------------------------------------------------------------===//; /// FunctionPass class - This class is used to implement most global; /// optimizations. Optimizations should subclass this class if they meet the; /// following constraints:; ///; /// 1. Optimizations are organized globally, i.e., a function at a time; /// 2. Optimizing a function does not cause the addition or removal of any; /// functions in the module; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:171,Performance,Optimiz,Optimizations,171,"//===----------------------------------------------------------------------===//; /// FunctionPass class - This class is used to implement most global; /// optimizations. Optimizations should subclass this class if they meet the; /// following constraints:; ///; /// 1. Optimizations are organized globally, i.e., a function at a time; /// 2. Optimizing a function does not cause the addition or removal of any; /// functions in the module; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:270,Performance,Optimiz,Optimizations,270,"//===----------------------------------------------------------------------===//; /// FunctionPass class - This class is used to implement most global; /// optimizations. Optimizations should subclass this class if they meet the; /// following constraints:; ///; /// 1. Optimizations are organized globally, i.e., a function at a time; /// 2. Optimizing a function does not cause the addition or removal of any; /// functions in the module; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:343,Performance,Optimiz,Optimizing,343,"//===----------------------------------------------------------------------===//; /// FunctionPass class - This class is used to implement most global; /// optimizations. Optimizations should subclass this class if they meet the; /// following constraints:; ///; /// 1. Optimizations are organized globally, i.e., a function at a time; /// 2. Optimizing a function does not cause the addition or removal of any; /// functions in the module; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:122,Performance,Optimiz,OptimizeNone,122,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when Attribute::OptimizeNone is set or when; /// optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:155,Performance,optimiz,optimization,155,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when Attribute::OptimizeNone is set or when; /// optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Pass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:196,Availability,avail,available,196,"//===----------------------------------------------------------------------===//; /// Represent the analysis usage information of a pass. This tracks analyses; /// that the pass REQUIRES (must be available when the pass runs), REQUIRES; /// TRANSITIVE (must be available throughout the lifetime of the pass), and; /// analyses that the pass PRESERVES (the pass does not invalidate the results; /// of these analyses). This information is provided by a pass to the Pass; /// infrastructure through the getAnalysisUsage virtual function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:261,Availability,avail,available,261,"//===----------------------------------------------------------------------===//; /// Represent the analysis usage information of a pass. This tracks analyses; /// that the pass REQUIRES (must be available when the pass runs), REQUIRES; /// TRANSITIVE (must be available throughout the lifetime of the pass), and; /// analyses that the pass PRESERVES (the pass does not invalidate the results; /// of these analyses). This information is provided by a pass to the Pass; /// infrastructure through the getAnalysisUsage virtual function.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:73,Usability,clear,clear,73,"/// Sets of analyses required and preserved by a pass; // TODO: It's not clear that SmallVector is an appropriate data structure for; // this usecase. The sizes were picked to minimize wasted space, but are; // otherwise fairly meaningless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:97,Availability,avail,available,97,///@}; ///@{; /// Add the specified ID to the set of analyses used by this pass if they are; /// available..,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:274,Integrability,depend,depend,274,"/// This function should be called by the pass, iff they do not:; ///; /// 1. Add or remove basic blocks from the function; /// 2. Modify terminator instructions in any way.; ///; /// This function annotates the AnalysisUsage info object to say that analyses; /// that only depend on the CFG are preserved by this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:112,Integrability,interface,interface,112,//===----------------------------------------------------------------------===//; /// AnalysisResolver - Simple interface used by Pass objects to pull all; /// analysis information out of pass manager that is responsible to manage; /// the pass.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:105,Usability,Simpl,Simple,105,//===----------------------------------------------------------------------===//; /// AnalysisResolver - Simple interface used by Pass objects to pull all; /// analysis information out of pass manager that is responsible to manage; /// the pass.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:10,Performance,cache,cache,10,/// Clear cache that is used to connect a pass to the analysis (PassInfo).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:4,Usability,Clear,Clear,4,/// Clear cache that is used to connect a pass to the analysis (PassInfo).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:52,Integrability,interface,interfaces,52,/// This keeps track of which passes implements the interfaces that are; /// required by the current pass (to implement getAnalysis()).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:349,Availability,avail,available,349,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:144,Deployability,update,update,144,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:417,Deployability,update,update,417,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:491,Performance,perform,performed,491,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:200,Modifiability,inherit,inherit,200,"// Because the AnalysisType may not be a subclass of pass (for; // AnalysisGroups), we use getAdjustedAnalysisPointer here to potentially; // adjust the return pointer (because the class may multiply inherit, once; // from pass, once from AnalysisType).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:200,Modifiability,inherit,inherit,200,"// Because the AnalysisType may not be a subclass of pass (for; // AnalysisGroups), we use getAdjustedAnalysisPointer here to potentially; // adjust the return pointer (because the class may multiply inherit, once; // from pass, once from AnalysisType).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:353,Deployability,update,updated,353,"/// getAnalysis<AnalysisType>() - This function is used by subclasses to get; /// to the analysis information that they claim to use by overriding the; /// getAnalysisUsage function. If as part of the dependencies, an IR; /// transformation is triggered (e.g. because the analysis requires; /// BreakCriticalEdges), and Changed is non null, *Changed is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:201,Integrability,depend,dependencies,201,"/// getAnalysis<AnalysisType>() - This function is used by subclasses to get; /// to the analysis information that they claim to use by overriding the; /// getAnalysisUsage function. If as part of the dependencies, an IR; /// transformation is triggered (e.g. because the analysis requires; /// BreakCriticalEdges), and Changed is non null, *Changed is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:200,Modifiability,inherit,inherit,200,"// Because the AnalysisType may not be a subclass of pass (for; // AnalysisGroups), we use getAdjustedAnalysisPointer here to potentially; // adjust the return pointer (because the class may multiply inherit, once; // from pass, once from AnalysisType).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassInfo.h:3,Integrability,Interface,Interfaces,3,// Interfaces implemented by this pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassInfo.h:79,Integrability,interface,interfaces,79,/// getInterfacesImplemented - Return a list of all of the analysis group; /// interfaces implemented by this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h:614,Integrability,depend,dependency,614,"//===- llvm/PassRegistry.h - Pass Information Registry ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines PassRegistry, a class that is used in the initialization; // and registration of passes. At application startup, passes are registered; // with the PassRegistry, which is later provided to the PassManager for; // dependency resolution and similar tasks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h:177,Integrability,depend,dependencies,177,"/// PassRegistry - This class manages the registration and intitialization of; /// the pass subsystem as application startup, and assists the PassManager; /// in resolving pass dependencies.; /// NOTE: PassRegistry is NOT thread-safe. If you want to use LLVM on multiple; /// threads simultaneously, you will need to use a separate PassRegistry on; /// each thread.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h:229,Safety,safe,safe,229,"/// PassRegistry - This class manages the registration and intitialization of; /// the pass subsystem as application startup, and assists the PassManager; /// in resolving pass dependencies.; /// NOTE: PassRegistry is NOT thread-safe. If you want to use LLVM on multiple; /// threads simultaneously, you will need to use a separate PassRegistry on; /// each thread.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h:22,Security,Access,Access,22,"/// getPassRegistry - Access the global registry object, which is; /// automatically initialized at application launch and destroyed by; /// llvm_shutdown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:38,Testability,test,testable,38,"// Some codegen passes should only be testable via; // `llc -{start|stop}-{before|after}=<passname>`, not via `opt -<passname>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:182,Availability,avail,available,182,"//===---------------------------------------------------------------------------; /// RegisterPass<t> template - This template class is used to notify the system; /// that a Pass is available for use, and registers it into the internal; /// database maintained by the PassManager. Unless this template is used, opt,; /// for example will not be able to see the pass and attempts to create the pass; /// will fail. This template is used in the follow manner (at global scope, in; /// your .cpp file):; ///; /// static RegisterPass<YourPassClassName> tmp(""passopt"", ""My Pass Name"");; ///; /// This statement will cause your pass to be created by calling the default; /// constructor exposed by the pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:681,Security,expose,exposed,681,"//===---------------------------------------------------------------------------; /// RegisterPass<t> template - This template class is used to notify the system; /// that a Pass is available for use, and registers it into the internal; /// database maintained by the PassManager. Unless this template is used, opt,; /// for example will not be able to see the pass and attempts to create the pass; /// will fail. This template is used in the follow manner (at global scope, in; /// your .cpp file):; ///; /// static RegisterPass<YourPassClassName> tmp(""passopt"", ""My Pass Name"");; ///; /// This statement will cause your pass to be created by calling the default; /// constructor exposed by the pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:277,Availability,avail,available,277,"/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.; /// Analysis groups are used to define an interface (which need not derive from; /// Pass) that is required by passes to do their job. Analysis Groups differ; /// from normal analyses because any available implementation of the group will; /// be used if it is available.; ///; /// If no analysis implementing the interface is available, a default; /// implementation is created and added. A pass registers itself as the default; /// implementation by specifying 'true' as the second template argument of this; /// class.; ///; /// In addition to registering itself as an analysis group member, a pass must; /// register itself normally as well. Passes may be members of multiple groups; /// and may still be ""required"" specifically by name.; ///; /// The actual interface may also be registered as well (by not specifying the; /// second template argument). The interface should be registered to associate; /// a nice name with the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:342,Availability,avail,available,342,"/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.; /// Analysis groups are used to define an interface (which need not derive from; /// Pass) that is required by passes to do their job. Analysis Groups differ; /// from normal analyses because any available implementation of the group will; /// be used if it is available.; ///; /// If no analysis implementing the interface is available, a default; /// implementation is created and added. A pass registers itself as the default; /// implementation by specifying 'true' as the second template argument of this; /// class.; ///; /// In addition to registering itself as an analysis group member, a pass must; /// register itself normally as well. Passes may be members of multiple groups; /// and may still be ""required"" specifically by name.; ///; /// The actual interface may also be registered as well (by not specifying the; /// second template argument). The interface should be registered to associate; /// a nice name with the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:408,Availability,avail,available,408,"/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.; /// Analysis groups are used to define an interface (which need not derive from; /// Pass) that is required by passes to do their job. Analysis Groups differ; /// from normal analyses because any available implementation of the group will; /// be used if it is available.; ///; /// If no analysis implementing the interface is available, a default; /// implementation is created and added. A pass registers itself as the default; /// implementation by specifying 'true' as the second template argument of this; /// class.; ///; /// In addition to registering itself as an analysis group member, a pass must; /// register itself normally as well. Passes may be members of multiple groups; /// and may still be ""required"" specifically by name.; ///; /// The actual interface may also be registered as well (by not specifying the; /// second template argument). The interface should be registered to associate; /// a nice name with the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:123,Integrability,interface,interface,123,"/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.; /// Analysis groups are used to define an interface (which need not derive from; /// Pass) that is required by passes to do their job. Analysis Groups differ; /// from normal analyses because any available implementation of the group will; /// be used if it is available.; ///; /// If no analysis implementing the interface is available, a default; /// implementation is created and added. A pass registers itself as the default; /// implementation by specifying 'true' as the second template argument of this; /// class.; ///; /// In addition to registering itself as an analysis group member, a pass must; /// register itself normally as well. Passes may be members of multiple groups; /// and may still be ""required"" specifically by name.; ///; /// The actual interface may also be registered as well (by not specifying the; /// second template argument). The interface should be registered to associate; /// a nice name with the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:395,Integrability,interface,interface,395,"/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.; /// Analysis groups are used to define an interface (which need not derive from; /// Pass) that is required by passes to do their job. Analysis Groups differ; /// from normal analyses because any available implementation of the group will; /// be used if it is available.; ///; /// If no analysis implementing the interface is available, a default; /// implementation is created and added. A pass registers itself as the default; /// implementation by specifying 'true' as the second template argument of this; /// class.; ///; /// In addition to registering itself as an analysis group member, a pass must; /// register itself normally as well. Passes may be members of multiple groups; /// and may still be ""required"" specifically by name.; ///; /// The actual interface may also be registered as well (by not specifying the; /// second template argument). The interface should be registered to associate; /// a nice name with the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:844,Integrability,interface,interface,844,"/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.; /// Analysis groups are used to define an interface (which need not derive from; /// Pass) that is required by passes to do their job. Analysis Groups differ; /// from normal analyses because any available implementation of the group will; /// be used if it is available.; ///; /// If no analysis implementing the interface is available, a default; /// implementation is created and added. A pass registers itself as the default; /// implementation by specifying 'true' as the second template argument of this; /// class.; ///; /// In addition to registering itself as an analysis group member, a pass must; /// register itself normally as well. Passes may be members of multiple groups; /// and may still be ""required"" specifically by name.; ///; /// The actual interface may also be registered as well (by not specifying the; /// second template argument). The interface should be registered to associate; /// a nice name with the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:944,Integrability,interface,interface,944,"/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.; /// Analysis groups are used to define an interface (which need not derive from; /// Pass) that is required by passes to do their job. Analysis Groups differ; /// from normal analyses because any available implementation of the group will; /// be used if it is available.; ///; /// If no analysis implementing the interface is available, a default; /// implementation is created and added. A pass registers itself as the default; /// implementation by specifying 'true' as the second template argument of this; /// class.; ///; /// In addition to registering itself as an analysis group member, a pass must; /// register itself normally as well. Passes may be members of multiple groups; /// and may still be ""required"" specifically by name.; ///; /// The actual interface may also be registered as well (by not specifying the; /// second template argument). The interface should be registered to associate; /// a nice name with the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:1014,Integrability,interface,interface,1014,"/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.; /// Analysis groups are used to define an interface (which need not derive from; /// Pass) that is required by passes to do their job. Analysis Groups differ; /// from normal analyses because any available implementation of the group will; /// be used if it is available.; ///; /// If no analysis implementing the interface is available, a default; /// implementation is created and added. A pass registers itself as the default; /// implementation by specifying 'true' as the second template argument of this; /// class.; ///; /// In addition to registering itself as an analysis group member, a pass must; /// register itself normally as well. Passes may be members of multiple groups; /// and may still be ""required"" specifically by name.; ///; /// The actual interface may also be registered as well (by not specifying the; /// second template argument). The interface should be registered to associate; /// a nice name with the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:402,Performance,load,loaded,402,"//===---------------------------------------------------------------------------; /// PassRegistrationListener class - This class is meant to be derived from by; /// clients that are interested in which passes get registered and unregistered; /// at runtime (which can be because of the RegisterPass constructors being run; /// as the program starts up, or may be because a shared object just got; /// loaded).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:72,Performance,load,loaded,72,/// Callback functions - These functions are invoked whenever a pass is loaded; /// or removed from the current executable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:207,Energy Efficiency,efficient,efficiently,207,"/// The AddressRangesBase class presents the base functionality for the; /// normalized address ranges collection. This class keeps a sorted vector; /// of AddressRange-like objects and can perform searches efficiently.; /// The address ranges are always sorted and never contain any invalid,; /// empty or intersected address ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:190,Performance,perform,perform,190,"/// The AddressRangesBase class presents the base functionality for the; /// normalized address ranges collection. This class keeps a sorted vector; /// of AddressRange-like objects and can perform searches efficiently.; /// The address ranges are always sorted and never contain any invalid,; /// empty or intersected address ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:178,Energy Efficiency,efficient,efficiently,178,"/// The AddressRanges class helps normalize address range collections.; /// This class keeps a sorted vector of AddressRange objects and can perform; /// insertions and searches efficiently. Intersecting([100,200), [150,300)); /// and adjacent([100,200), [200,300)) address ranges are combined during; /// insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:141,Performance,perform,perform,141,"/// The AddressRanges class helps normalize address range collections.; /// This class keeps a sorted vector of AddressRange objects and can perform; /// insertions and searches efficiently. Intersecting([100,200), [150,300)); /// and adjacent([100,200), [200,300)) address ranges are combined during; /// insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:244,Energy Efficiency,efficient,efficiently,244,"/// AddressRangesMap class maps values to the address ranges.; /// It keeps normalized address ranges and corresponding values.; /// This class keeps a sorted vector of AddressRangeValuePair objects; /// and can perform insertions and searches efficiently.; /// Intersecting([100,200), [150,300)) ranges splitted into non-conflicting; /// parts([100,200), [200,300)). Adjacent([100,200), [200,300)) address; /// ranges are not combined during insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:212,Performance,perform,perform,212,"/// AddressRangesMap class maps values to the address ranges.; /// It keeps normalized address ranges and corresponding values.; /// This class keeps a sorted vector of AddressRangeValuePair objects; /// and can perform insertions and searches efficiently.; /// Intersecting([100,200), [150,300)) ranges splitted into non-conflicting; /// parts([100,200), [200,300)). Adjacent([100,200), [200,300)) address; /// ranges are not combined during insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h:33,Integrability,depend,dependent,33,"//===- llvm/ADT/ADL.h - Argument dependent lookup utilities -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h:94,Testability,test,test,94,// Only used by compiler if both template types are the same. Useful when; // using SFINAE to test for the existence of member functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h:132,Integrability,Depend,Dependent,132,// end namespace adl_detail; /// Returns the begin iterator to \p range using `std::begin` and; /// function found through Argument-Dependent Lookup (ADL).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h:100,Integrability,Depend,Dependent,100,/// Returns the end iterator to \p range using `std::end` and; /// functions found through Argument-Dependent Lookup (ADL).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h:89,Integrability,Depend,Dependent,89,/// Swaps \p lhs with \p rhs using `std::swap` and functions found through; /// Argument-Dependent Lookup (ADL).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h:93,Integrability,Depend,Dependent,93,/// Returns the size of \p range using `std::size` and functions found through; /// Argument-Dependent Lookup (ADL).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ADL.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h:84,Integrability,interface,interface,84,"/// A linked-list with a custom, local allocator.; ///; /// Expose a std::list-like interface that owns and uses a custom LLVM-style; /// allocator (e.g., BumpPtrAllocator), leveraging \a simple_ilist for the; /// implementation details.; ///; /// Because this list owns the allocator, calling \a splice() with a different; /// list isn't generally safe. As such, \a splice has been left out of the; /// interface entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h:404,Integrability,interface,interface,404,"/// A linked-list with a custom, local allocator.; ///; /// Expose a std::list-like interface that owns and uses a custom LLVM-style; /// allocator (e.g., BumpPtrAllocator), leveraging \a simple_ilist for the; /// implementation details.; ///; /// Because this list owns the allocator, calling \a splice() with a different; /// list isn't generally safe. As such, \a splice has been left out of the; /// interface entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h:349,Safety,safe,safe,349,"/// A linked-list with a custom, local allocator.; ///; /// Expose a std::list-like interface that owns and uses a custom LLVM-style; /// allocator (e.g., BumpPtrAllocator), leveraging \a simple_ilist for the; /// implementation details.; ///; /// Because this list owns the allocator, calling \a splice() with a different; /// list isn't generally safe. As such, \a splice has been left out of the; /// interface entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h:60,Security,Expose,Expose,60,"/// A linked-list with a custom, local allocator.; ///; /// Expose a std::list-like interface that owns and uses a custom LLVM-style; /// allocator (e.g., BumpPtrAllocator), leveraging \a simple_ilist for the; /// implementation details.; ///; /// Because this list owns the allocator, calling \a splice() with a different; /// list isn't generally safe. As such, \a splice has been left out of the; /// interface entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h:511,Safety,safe,safe,511,"//===- Any.h - Generic type erased holder of any type -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file provides Any, a non-template class modeled in the spirit of; /// std::any. The idea is to provide a type-safe replacement for C's void*.; /// It can hold a value of any copy-constructible copy-assignable type; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Any.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h:202,Performance,load,loader,202,"// The `Typeid<T>::Id` static data member below is a globally unique; // identifier for the type `T`. It is explicitly marked with default; // visibility so that when `-fvisibility=hidden` is used, the loader still; // merges duplicate definitions across DSO boundaries.; // We also cannot mark it as `const`, otherwise msvc merges all definitions; // when lto is enabled, making any comparison return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Any.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h:214,Availability,error,errors,214,"// Define the type id and initialize with a non-zero value.; // Initializing with a zero value means the variable can end up in either the; // .data or the .bss section. This can lead to multiple definition linker errors; // when some object files are compiled with a compiler that puts the variable; // into .data but they are linked to object files from a different compiler that; // put the variable into .bss. To prevent this issue from happening, initialize; // the variable with a non-zero value, which forces it to land in .data (because; // .bss is zero-initialized).; // See also https://github.com/llvm/llvm-project/issues/62270",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Any.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h:105,Modifiability,variab,variable,105,"// Define the type id and initialize with a non-zero value.; // Initializing with a zero value means the variable can end up in either the; // .data or the .bss section. This can lead to multiple definition linker errors; // when some object files are compiled with a compiler that puts the variable; // into .data but they are linked to object files from a different compiler that; // put the variable into .bss. To prevent this issue from happening, initialize; // the variable with a non-zero value, which forces it to land in .data (because; // .bss is zero-initialized).; // See also https://github.com/llvm/llvm-project/issues/62270",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Any.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h:291,Modifiability,variab,variable,291,"// Define the type id and initialize with a non-zero value.; // Initializing with a zero value means the variable can end up in either the; // .data or the .bss section. This can lead to multiple definition linker errors; // when some object files are compiled with a compiler that puts the variable; // into .data but they are linked to object files from a different compiler that; // put the variable into .bss. To prevent this issue from happening, initialize; // the variable with a non-zero value, which forces it to land in .data (because; // .bss is zero-initialized).; // See also https://github.com/llvm/llvm-project/issues/62270",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Any.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h:394,Modifiability,variab,variable,394,"// Define the type id and initialize with a non-zero value.; // Initializing with a zero value means the variable can end up in either the; // .data or the .bss section. This can lead to multiple definition linker errors; // when some object files are compiled with a compiler that puts the variable; // into .data but they are linked to object files from a different compiler that; // put the variable into .bss. To prevent this issue from happening, initialize; // the variable with a non-zero value, which forces it to land in .data (because; // .bss is zero-initialized).; // See also https://github.com/llvm/llvm-project/issues/62270",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Any.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h:471,Modifiability,variab,variable,471,"// Define the type id and initialize with a non-zero value.; // Initializing with a zero value means the variable can end up in either the; // .data or the .bss section. This can lead to multiple definition linker errors; // when some object files are compiled with a compiler that puts the variable; // into .data but they are linked to object files from a different compiler that; // put the variable into .bss. To prevent this issue from happening, initialize; // the variable with a non-zero value, which forces it to land in .data (because; // .bss is zero-initialized).; // See also https://github.com/llvm/llvm-project/issues/62270",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Any.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Any.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h:427,Integrability,interface,interface,427,"//===- APFixedPoint.h - Fixed point constant handling -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the fixed point number interface.; /// This is a class for abstracting various operations performed on fixed point; /// types.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h:494,Performance,perform,performed,494,"//===- APFixedPoint.h - Fixed point constant handling -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the fixed point number interface.; /// This is a class for abstracting various operations performed on fixed point; /// types.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h:386,Performance,perform,performed,386,"/// The APFixedPoint class works similarly to APInt/APSInt in that it is a; /// functional replacement for a scaled integer. It supports a wide range of; /// semantics including the one used by fixed point types proposed in ISO/IEC; /// JTC1 SC22 WG14 N1169. The class carries the value and semantics of; /// a fixed point, and provides different operations that would normally be; /// performed on fixed point types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h:3,Performance,Perform,Perform,3,"// Perform binary operations on a fixed point type. The resulting fixed point; // value will be in the common, full precision semantics that can represent; // the precision and ranges of both input values. See convert() for an; // explanation of the Overflow parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h:3,Performance,Perform,Perform,3,"// Perform shift operations on a fixed point type. Unlike the other binary; // operations, the resulting fixed point value will be in the original; // semantic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h:4,Performance,Perform,Perform,4,"/// Perform a unary negation (-X) on this fixed point type, taking into; /// account saturation if applicable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:1548,Availability,mask,mask,1548,"ance should nonetheless be reasonable,; /// particularly for its intended use. It may be useful as a base; /// implementation for a run-time library during development of a faster; /// target-specific one.; ///; /// All 5 rounding modes in the IEEE-754R draft are handled correctly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detected after rounding; it should be; /// straight forward to add support for the before-rounding case too.; ///; /// The library reads hexadecimal floating point numbers as per C99, and; /// correctly rounds if necessary according to the specified rounding mode.; /// Syntax is required to have been validated by the caller. It also converts; /// floating point numbers to hexadecimal text as per the C99 %a and %A; /// conversions. The output precision (or alternatively the natural minimal; /// precision) can be specified; if the requested precision is less ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:1259,Modifiability,extend,extended,1259," will work with bignum integers whose parts are; /// any unsigned type at least 16 bits wide, but 64 bits is recommended.; ///; /// Written for clarity rather than speed, in particular with a view to use in; /// the front-end of a cross compiler so that target arithmetic can be correctly; /// performed on the host. Performance should nonetheless be reasonable,; /// particularly for its intended use. It may be useful as a base; /// implementation for a run-time library during development of a faster; /// target-specific one.; ///; /// All 5 rounding modes in the IEEE-754R draft are handled correctly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detected after rounding; it should be; /// straight forward to add support for the before-rounding case too.; ///; /// The library reads hexadecimal floating point numbers as per C99, and; /// correctly rounds if necessary according to the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:1306,Modifiability,extend,extended,1306," will work with bignum integers whose parts are; /// any unsigned type at least 16 bits wide, but 64 bits is recommended.; ///; /// Written for clarity rather than speed, in particular with a view to use in; /// the front-end of a cross compiler so that target arithmetic can be correctly; /// performed on the host. Performance should nonetheless be reasonable,; /// particularly for its intended use. It may be useful as a base; /// implementation for a run-time library during development of a faster; /// target-specific one.; ///; /// All 5 rounding modes in the IEEE-754R draft are handled correctly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detected after rounding; it should be; /// straight forward to add support for the before-rounding case too.; ///; /// The library reads hexadecimal floating point numbers as per C99, and; /// correctly rounds if necessary according to the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:4413,Modifiability,extend,extended,4413,"imal floating point numbers and correctly rounds according; /// to the specified rounding mode.; ///; /// Conversion to decimal text is not currently implemented.; ///; /// Non-zero finite numbers are represented internally as a sign bit, a 16-bit; /// signed exponent, and the significand as an array of integer parts. After; /// normalization of a number of precision P the exponent is within the range of; /// the format, and if the number is not denormal the P-th bit of the; /// significand is set as an explicit integer bit. For denormals the most; /// significant bit is shifted right so that the exponent is maintained at the; /// format's minimum, so that the smallest denormal has just the least; /// significant bit of the significand set. The sign of zeroes and infinities; /// is significant; the exponent and significand of such numbers is not stored,; /// but has a known implicit (deterministic) value: 0 for the significands, 0; /// for zero exponent, all 1 bits for infinity exponent. For NaNs the sign and; /// significand are deterministic, although not really meaningful, and preserved; /// in non-conversion operations. The exponent is implicitly all 1 bits.; ///; /// APFloat does not provide any exception handling beyond default exception; /// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause; /// by encoding Signaling NaNs with the first bit of its trailing significand as; /// 0.; ///; /// TODO; /// ====; ///; /// Some features that may or may not be worth adding:; ///; /// Binary to decimal conversion (hard).; ///; /// Optional ability to detect underflow tininess before rounding.; ///; /// New formats: x87 in single and double precision mode (IEEE apart from; /// extended exponent range) (hard).; ///; /// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.; ///; // This is the common type definitions shared by APFloat and its internal; // implementation classes. This struct should not define any non-static data; // members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:526,Performance,perform,performed,526,"/// A self-contained host- and target-independent arbitrary-precision; /// floating-point software implementation.; ///; /// APFloat uses bignum integer arithmetic as provided by static functions in; /// the APInt class. The library will work with bignum integers whose parts are; /// any unsigned type at least 16 bits wide, but 64 bits is recommended.; ///; /// Written for clarity rather than speed, in particular with a view to use in; /// the front-end of a cross compiler so that target arithmetic can be correctly; /// performed on the host. Performance should nonetheless be reasonable,; /// particularly for its intended use. It may be useful as a base; /// implementation for a run-time library during development of a faster; /// target-specific one.; ///; /// All 5 rounding modes in the IEEE-754R draft are handled correctly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detecte",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:549,Performance,Perform,Performance,549,"/// A self-contained host- and target-independent arbitrary-precision; /// floating-point software implementation.; ///; /// APFloat uses bignum integer arithmetic as provided by static functions in; /// the APInt class. The library will work with bignum integers whose parts are; /// any unsigned type at least 16 bits wide, but 64 bits is recommended.; ///; /// Written for clarity rather than speed, in particular with a view to use in; /// the front-end of a cross compiler so that target arithmetic can be correctly; /// performed on the host. Performance should nonetheless be reasonable,; /// particularly for its intended use. It may be useful as a base; /// implementation for a run-time library during development of a faster; /// target-specific one.; ///; /// All 5 rounding modes in the IEEE-754R draft are handled correctly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detecte",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:1814,Performance,optimiz,optimizers,1814,"rrectly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detected after rounding; it should be; /// straight forward to add support for the before-rounding case too.; ///; /// The library reads hexadecimal floating point numbers as per C99, and; /// correctly rounds if necessary according to the specified rounding mode.; /// Syntax is required to have been validated by the caller. It also converts; /// floating point numbers to hexadecimal text as per the C99 %a and %A; /// conversions. The output precision (or alternatively the natural minimal; /// precision) can be specified; if the requested precision is less than the; /// natural precision the output is correctly rounded for the specified rounding; /// mode.; ///; /// It also reads decimal floating point numbers and correctly rounds according; /// to the specified rounding mode.; ///; /// Conversion to decimal text is not curre",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:1902,Performance,optimiz,optimize,1902,"rrectly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detected after rounding; it should be; /// straight forward to add support for the before-rounding case too.; ///; /// The library reads hexadecimal floating point numbers as per C99, and; /// correctly rounds if necessary according to the specified rounding mode.; /// Syntax is required to have been validated by the caller. It also converts; /// floating point numbers to hexadecimal text as per the C99 %a and %A; /// conversions. The output precision (or alternatively the natural minimal; /// precision) can be specified; if the requested precision is less than the; /// natural precision the output is correctly rounded for the specified rounding; /// mode.; ///; /// It also reads decimal floating point numbers and correctly rounds according; /// to the specified rounding mode.; ///; /// Conversion to decimal text is not curre",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:1927,Performance,optimiz,optimize,1927,"rrectly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detected after rounding; it should be; /// straight forward to add support for the before-rounding case too.; ///; /// The library reads hexadecimal floating point numbers as per C99, and; /// correctly rounds if necessary according to the specified rounding mode.; /// Syntax is required to have been validated by the caller. It also converts; /// floating point numbers to hexadecimal text as per the C99 %a and %A; /// conversions. The output precision (or alternatively the natural minimal; /// precision) can be specified; if the requested precision is less than the; /// natural precision the output is correctly rounded for the specified rounding; /// mode.; ///; /// It also reads decimal floating point numbers and correctly rounds according; /// to the specified rounding mode.; ///; /// Conversion to decimal text is not curre",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:1994,Safety,detect,detected,1994,"version-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detected after rounding; it should be; /// straight forward to add support for the before-rounding case too.; ///; /// The library reads hexadecimal floating point numbers as per C99, and; /// correctly rounds if necessary according to the specified rounding mode.; /// Syntax is required to have been validated by the caller. It also converts; /// floating point numbers to hexadecimal text as per the C99 %a and %A; /// conversions. The output precision (or alternatively the natural minimal; /// precision) can be specified; if the requested precision is less than the; /// natural precision the output is correctly rounded for the specified rounding; /// mode.; ///; /// It also reads decimal floating point numbers and correctly rounds according; /// to the specified rounding mode.; ///; /// Conversion to decimal text is not currently implemented.; ///; /// Non-zero finite numbers are represented internally as a sign bit, a 16-bit; /// signed exponent, and the significand as an array of integer parts. After; /// normaliza",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:4285,Safety,detect,detect,4285,"imal floating point numbers and correctly rounds according; /// to the specified rounding mode.; ///; /// Conversion to decimal text is not currently implemented.; ///; /// Non-zero finite numbers are represented internally as a sign bit, a 16-bit; /// signed exponent, and the significand as an array of integer parts. After; /// normalization of a number of precision P the exponent is within the range of; /// the format, and if the number is not denormal the P-th bit of the; /// significand is set as an explicit integer bit. For denormals the most; /// significant bit is shifted right so that the exponent is maintained at the; /// format's minimum, so that the smallest denormal has just the least; /// significant bit of the significand set. The sign of zeroes and infinities; /// is significant; the exponent and significand of such numbers is not stored,; /// but has a known implicit (deterministic) value: 0 for the significands, 0; /// for zero exponent, all 1 bits for infinity exponent. For NaNs the sign and; /// significand are deterministic, although not really meaningful, and preserved; /// in non-conversion operations. The exponent is implicitly all 1 bits.; ///; /// APFloat does not provide any exception handling beyond default exception; /// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause; /// by encoding Signaling NaNs with the first bit of its trailing significand as; /// 0.; ///; /// TODO; /// ====; ///; /// Some features that may or may not be worth adding:; ///; /// Binary to decimal conversion (hard).; ///; /// Optional ability to detect underflow tininess before rounding.; ///; /// New formats: x87 in single and double precision mode (IEEE apart from; /// extended exponent range) (hard).; ///; /// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.; ///; // This is the common type definitions shared by APFloat and its internal; // implementation classes. This struct should not define any non-static data; // members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:2296,Security,validat,validated,2296,"g with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detected after rounding; it should be; /// straight forward to add support for the before-rounding case too.; ///; /// The library reads hexadecimal floating point numbers as per C99, and; /// correctly rounds if necessary according to the specified rounding mode.; /// Syntax is required to have been validated by the caller. It also converts; /// floating point numbers to hexadecimal text as per the C99 %a and %A; /// conversions. The output precision (or alternatively the natural minimal; /// precision) can be specified; if the requested precision is less than the; /// natural precision the output is correctly rounded for the specified rounding; /// mode.; ///; /// It also reads decimal floating point numbers and correctly rounds according; /// to the specified rounding mode.; ///; /// Conversion to decimal text is not currently implemented.; ///; /// Non-zero finite numbers are represented internally as a sign bit, a 16-bit; /// signed exponent, and the significand as an array of integer parts. After; /// normalization of a number of precision P the exponent is within the range of; /// the format, and if the number is not denormal the P-th bit of the; /// significand is set as an explicit integer bit. For denormals the most; /// significant bit is shifted right so that the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:160,Performance,throughput,throughput,160,"// Floating point number that occupies 32 bits or less of storage, providing; // improved range compared to half (16-bit) formats, at (potentially); // greater throughput than single precision (32-bit) formats.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:28,Availability,error,error,28,/// Enumeration of \c ilogb error results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:42,Energy Efficiency,allocate,allocated,42,/// @}; /// Returns whether this instance allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:18,Usability,Simpl,Simple,18,/// @}; /// \name Simple Queries; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:26,Security,hash,hash,26,"/// Overload to compute a hash code for an APFloat value.; ///; /// Note that the use of hash codes for floating point values is in general; /// frought with peril. Equality is hard to define for these values. For; /// example, should negative and positive zero hash to different codes? Are; /// they equal or not? This hash value implementation specifically; /// emphasizes producing different codes for different inputs in order to; /// be used in canonicalization and memoization. As such, equality is; /// bitwiseIsEqual, and 0 != -0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:89,Security,hash,hash,89,"/// Overload to compute a hash code for an APFloat value.; ///; /// Note that the use of hash codes for floating point values is in general; /// frought with peril. Equality is hard to define for these values. For; /// example, should negative and positive zero hash to different codes? Are; /// they equal or not? This hash value implementation specifically; /// emphasizes producing different codes for different inputs in order to; /// be used in canonicalization and memoization. As such, equality is; /// bitwiseIsEqual, and 0 != -0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:262,Security,hash,hash,262,"/// Overload to compute a hash code for an APFloat value.; ///; /// Note that the use of hash codes for floating point values is in general; /// frought with peril. Equality is hard to define for these values. For; /// example, should negative and positive zero hash to different codes? Are; /// they equal or not? This hash value implementation specifically; /// emphasizes producing different codes for different inputs in order to; /// be used in canonicalization and memoization. As such, equality is; /// bitwiseIsEqual, and 0 != -0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:320,Security,hash,hash,320,"/// Overload to compute a hash code for an APFloat value.; ///; /// Note that the use of hash codes for floating point values is in general; /// frought with peril. Equality is hard to define for these values. For; /// example, should negative and positive zero hash to different codes? Are; /// they equal or not? This hash value implementation specifically; /// emphasizes producing different codes for different inputs in order to; /// be used in canonicalization and memoization. As such, equality is; /// bitwiseIsEqual, and 0 != -0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:164,Availability,avail,available,164,"/// Converts this value into a decimal string.; ///; /// \param FormatPrecision The maximum number of digits of; /// precision to output. If there are fewer digits available,; /// zero padding will not be used unless the value is; /// integral and small enough to be expressed in; /// FormatPrecision digits. 0 means to use the natural; /// precision of the number.; /// \param FormatMaxPadding The maximum number of zeros to; /// consider inserting before falling back to scientific; /// notation. 0 means to always use scientific notation.; ///; /// \param TruncateZero Indicate whether to remove the trailing zero in; /// fraction part or not. Also setting this parameter to false forcing; /// producing of output more similar to default printf behavior.; /// Specifically the lower e is used as exponent delimiter and exponent; /// always contains no less than two digits.; ///; /// Number Precision MaxPadding Result; /// ------ --------- ---------- ------; /// 1.01E+4 5 2 10100; /// 1.01E+4 4 2 1.01E+4; /// 1.01E+4 5 1 1.01E+4; /// 1.01E-2 5 2 0.0101; /// 1.01E-2 4 2 0.0101; /// 1.01E-2 4 1 1.01E-2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:23,Energy Efficiency,power,power,23,"// If this is an exact power of two, return the exponent while ignoring the; // sign bit. If it's not an exact power of 2, return INT_MIN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:111,Energy Efficiency,power,power,111,"// If this is an exact power of two, return the exponent while ignoring the; // sign bit. If it's not an exact power of 2, return INT_MIN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:23,Energy Efficiency,power,power,23,"// If this is an exact power of two, return the exponent. If it's not an exact; // power of 2, return INT_MIN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:83,Energy Efficiency,power,power,83,"// If this is an exact power of two, return the exponent. If it's not an exact; // power of 2, return INT_MIN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:209,Availability,error,error,209,"/// Returns the exponent of the internal representation of the APFloat.; ///; /// Because the radix of APFloat is 2, this is equivalent to floor(log2(x)).; /// For special APFloat values, this returns special error codes:; ///; /// NaN -> \c IEK_NaN; /// 0 -> \c IEK_Zero; /// Inf -> \c IEK_Inf; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:10,Usability,Simpl,Simple,10,/// \name Simple Queries; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:118,Modifiability,extend,extends,118,"/// What kind of floating point number this is.; ///; /// Only 2 bits are required, but VisualStudio incorrectly sign extends it.; /// Using the extra bit keeps it from failing under VisualStudio.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:77,Integrability,interface,interface,77,"// This mode implements more precise float in terms of two APFloats.; // The interface and layout is designed for arbitrary underlying semantics,; // though currently only PPCDoubleDouble semantics are supported, whose; // corresponding underlying semantics are IEEEdouble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:38,Integrability,interface,interface,38,// End detail namespace; // This is a interface class that is currently forwarding functionalities from; // detail::IEEEFloat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:65,Availability,error,error,65,"/// Add two APFloats, rounding ties to the nearest even.; /// No error checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:70,Availability,error,error,70,"/// Subtract two APFloats, rounding ties to the nearest even.; /// No error checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:70,Availability,error,error,70,"/// Multiply two APFloats, rounding ties to the nearest even.; /// No error checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:87,Availability,error,error,87,"/// Divide the first APFloat by the second, rounding ties to the nearest even.; /// No error checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:432,Testability,log,logic,432,"/// We don't rely on operator== working on double values, as; /// it returns true for things that are clearly not equal, like -0.0 and 0.0.; /// As such, this method can be used to do an exact bit-for-bit comparison of; /// two floating point values.; ///; /// We leave the version with the double argument here because it's just so; /// convenient to write ""2.0"" and the like. Without this function we'd; /// have to duplicate its logic everywhere it's called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:102,Usability,clear,clearly,102,"/// We don't rely on operator== working on double values, as; /// it returns true for things that are clearly not equal, like -0.0 and 0.0.; /// As such, this method can be used to do an exact bit-for-bit comparison of; /// two floating point values.; ///; /// We leave the version with the double argument here because it's just so; /// convenient to write ""2.0"" and the like. Without this function we'd; /// have to duplicate its logic everywhere it's called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:41,Availability,avail,available,41,"// We want the following functions to be available in the header for inlining.; // We cannot define them inline in the class definition of `DoubleAPFloat`; // because doing so would instantiate `std::unique_ptr<APFloat[]>` before; // `APFloat` is defined, and that would be undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:2002,Security,hash,hash,2002,"----------===//; // APInt Class; //===----------------------------------------------------------------------===//; /// Class for arbitrary precision integers.; ///; /// APInt is a functional replacement for common case unsigned integer type like; /// ""unsigned"", ""unsigned long"" or ""uint64_t"", but also allows non-byte-width; /// integer sizes and large integer value types such as 3-bits, 15-bits, or more; /// than 64-bits of precision. APInt provides a variety of arithmetic operators; /// and methods to manipulate integer values of any bit-width. It supports both; /// the typical integer arithmetic and comparison operations as well as bitwise; /// manipulation.; ///; /// The class has several invariants worth noting:; /// * All bit, byte, and word positions are zero-based.; /// * Once the bit width is set, it doesn't change except by the Truncate,; /// SignExtend, or ZeroExtend operations.; /// * All binary operators must be on APInt instances of the same bit width.; /// Attempting to use these operators on instances with different bit; /// widths will yield an assertion.; /// * The value is stored canonically as an unsigned value. For operations; /// where it makes a difference, there are both signed and unsigned variants; /// of the operation. For example, sdiv and udiv. However, because the bit; /// widths must be the same, operations such as Mul and Add produce the same; /// results regardless of whether the values are interpreted as signed or; /// not.; /// * In general, the class tries to follow the style of computation that LLVM; /// uses in its IR. This simplifies its use for LLVM.; /// * APInt supports zero-bit-width values, but operations that require bits; /// are not defined on it (e.g. you cannot ask for the sign of a zero-bit; /// integer). This means that operations like zero extension and logical; /// shifts are defined, but sign extension and ashr is not. Zero bit values; /// compare and hash equal to themselves, and countLeadingZeros returns 0.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:1142,Testability,assert,assertion,1142,"----------===//; // APInt Class; //===----------------------------------------------------------------------===//; /// Class for arbitrary precision integers.; ///; /// APInt is a functional replacement for common case unsigned integer type like; /// ""unsigned"", ""unsigned long"" or ""uint64_t"", but also allows non-byte-width; /// integer sizes and large integer value types such as 3-bits, 15-bits, or more; /// than 64-bits of precision. APInt provides a variety of arithmetic operators; /// and methods to manipulate integer values of any bit-width. It supports both; /// the typical integer arithmetic and comparison operations as well as bitwise; /// manipulation.; ///; /// The class has several invariants worth noting:; /// * All bit, byte, and word positions are zero-based.; /// * Once the bit width is set, it doesn't change except by the Truncate,; /// SignExtend, or ZeroExtend operations.; /// * All binary operators must be on APInt instances of the same bit width.; /// Attempting to use these operators on instances with different bit; /// widths will yield an assertion.; /// * The value is stored canonically as an unsigned value. For operations; /// where it makes a difference, there are both signed and unsigned variants; /// of the operation. For example, sdiv and udiv. However, because the bit; /// widths must be the same, operations such as Mul and Add produce the same; /// results regardless of whether the values are interpreted as signed or; /// not.; /// * In general, the class tries to follow the style of computation that LLVM; /// uses in its IR. This simplifies its use for LLVM.; /// * APInt supports zero-bit-width values, but operations that require bits; /// are not defined on it (e.g. you cannot ask for the sign of a zero-bit; /// integer). This means that operations like zero extension and logical; /// shifts are defined, but sign extension and ashr is not. Zero bit values; /// compare and hash equal to themselves, and countLeadingZeros returns 0.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:1900,Testability,log,logical,1900,"----------===//; // APInt Class; //===----------------------------------------------------------------------===//; /// Class for arbitrary precision integers.; ///; /// APInt is a functional replacement for common case unsigned integer type like; /// ""unsigned"", ""unsigned long"" or ""uint64_t"", but also allows non-byte-width; /// integer sizes and large integer value types such as 3-bits, 15-bits, or more; /// than 64-bits of precision. APInt provides a variety of arithmetic operators; /// and methods to manipulate integer values of any bit-width. It supports both; /// the typical integer arithmetic and comparison operations as well as bitwise; /// manipulation.; ///; /// The class has several invariants worth noting:; /// * All bit, byte, and word positions are zero-based.; /// * Once the bit width is set, it doesn't change except by the Truncate,; /// SignExtend, or ZeroExtend operations.; /// * All binary operators must be on APInt instances of the same bit width.; /// Attempting to use these operators on instances with different bit; /// widths will yield an assertion.; /// * The value is stored canonically as an unsigned value. For operations; /// where it makes a difference, there are both signed and unsigned variants; /// of the operation. For example, sdiv and udiv. However, because the bit; /// widths must be the same, operations such as Mul and Add produce the same; /// results regardless of whether the values are interpreted as signed or; /// not.; /// * In general, the class tries to follow the style of computation that LLVM; /// uses in its IR. This simplifies its use for LLVM.; /// * APInt supports zero-bit-width values, but operations that require bits; /// are not defined on it (e.g. you cannot ask for the sign of a zero-bit; /// integer). This means that operations like zero extension and logical; /// shifts are defined, but sign extension and ashr is not. Zero bit values; /// compare and hash equal to themselves, and countLeadingZeros returns 0.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:1652,Usability,simpl,simplifies,1652,"----------===//; // APInt Class; //===----------------------------------------------------------------------===//; /// Class for arbitrary precision integers.; ///; /// APInt is a functional replacement for common case unsigned integer type like; /// ""unsigned"", ""unsigned long"" or ""uint64_t"", but also allows non-byte-width; /// integer sizes and large integer value types such as 3-bits, 15-bits, or more; /// than 64-bits of precision. APInt provides a variety of arithmetic operators; /// and methods to manipulate integer values of any bit-width. It supports both; /// the typical integer arithmetic and comparison operations as well as bitwise; /// manipulation.; ///; /// The class has several invariants worth noting:; /// * All bit, byte, and word positions are zero-based.; /// * Once the bit width is set, it doesn't change except by the Truncate,; /// SignExtend, or ZeroExtend operations.; /// * All binary operators must be on APInt instances of the same bit width.; /// Attempting to use these operators on instances with different bit; /// widths will yield an assertion.; /// * The value is stored canonically as an unsigned value. For operations; /// where it makes a difference, there are both signed and unsigned variants; /// of the operation. For example, sdiv and udiv. However, because the bit; /// widths must be the same, operations such as Mul and Add produce the same; /// results regardless of whether the values are interpreted as signed or; /// not.; /// * In general, the class tries to follow the style of computation that LLVM; /// uses in its IR. This simplifies its use for LLVM.; /// * APInt supports zero-bit-width values, but operations that require bits; /// are not defined on it (e.g. you cannot ask for the sign of a zero-bit; /// integer). This means that operations like zero extension and logical; /// shifts are defined, but sign extension and ashr is not. Zero bit values; /// compare and hash equal to themselves, and countLeadingZeros returns 0.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:330,Availability,error,error,330,"/// Construct an APInt from a string representation.; ///; /// This constructor interprets the string \p str in the given radix. The; /// interpretation stops when the first character that is not suitable for the; /// radix is encountered, or the end of the string. Acceptable radix values; /// are 2, 8, 10, 16, and 36. It is an error for the value implied by the; /// string to require more bits than numBits.; ///; /// \param numBits the bit width of the constructed APInt; /// \param str the string to be interpreted; /// \param radix the radix to use for the conversion",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:72,Integrability,wrap,wrapper,72,"/// Get the SignMask for a specific bit width.; ///; /// This is just a wrapper function of getSignedMinValue(), and it helps code; /// readability when we want to get a SignMask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Integrability,Wrap,Wrap,4,"/// Wrap version of getBitsSet.; /// If \p hiBit is bigger than \p loBit, this is same with getBitsSet.; /// If \p hiBit is not bigger than \p loBit, the set bits ""wrap"". For example,; /// with parameters (32, 28, 4), you would get 0xF000000F.; /// If \p hiBit is equal to \p loBit, you would get a result with all bits; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:164,Integrability,wrap,wrap,164,"/// Wrap version of getBitsSet.; /// If \p hiBit is bigger than \p loBit, this is same with getBitsSet.; /// If \p hiBit is not bigger than \p loBit, the set bits ""wrap"". For example,; /// with parameters (32, 28, 4), you would get 0xF000000F.; /// If \p hiBit is equal to \p loBit, you would get a result with all bits; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:24,Testability,Test,Tests,24,"/// @}; /// \name Value Tests; /// @{; /// Determine if this APInt just has one word to store value.; ///; /// \returns true if the number of bits <= 64, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:49,Testability,test,tests,49,"/// Determine sign of this APInt.; ///; /// This tests the high bit of this APInt to determine if it is set.; ///; /// \returns true if this APInt is negative, false otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:72,Testability,test,tests,72,/// Determine if this APInt Value is non-negative (>= 0); ///; /// This tests the high bit of the APInt to determine if it is unset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:63,Testability,test,tests,63,"/// Determine if sign bit of this APInt is set.; ///; /// This tests the high bit of this APInt to determine if it is set.; ///; /// \returns true if this APInt has its sign bit set, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:65,Testability,test,tests,65,"/// Determine if sign bit of this APInt is clear.; ///; /// This tests the high bit of this APInt to determine if it is clear.; ///; /// \returns true if this APInt has its sign bit clear, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:43,Usability,clear,clear,43,"/// Determine if sign bit of this APInt is clear.; ///; /// This tests the high bit of this APInt to determine if it is clear.; ///; /// \returns true if this APInt has its sign bit clear, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:120,Usability,clear,clear,120,"/// Determine if sign bit of this APInt is clear.; ///; /// This tests the high bit of this APInt to determine if it is clear.; ///; /// \returns true if this APInt has its sign bit clear, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:182,Usability,clear,clear,182,"/// Determine if sign bit of this APInt is clear.; ///; /// This tests the high bit of this APInt to determine if it is clear.; ///; /// \returns true if this APInt has its sign bit clear, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:62,Testability,test,tests,62,/// Determine if this APInt Value is positive.; ///; /// This tests if the value of this APInt is positive (> 0). Note; /// that 0 is not a positive value.; ///; /// \returns true if this APInt is positive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:55,Usability,clear,clear,55,"/// Determine if this value is zero, i.e. all bits are clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:37,Energy Efficiency,power,power,37,/// Check if this APInt's value is a power of two greater than zero.; ///; /// \returns true if the argument APInt value is a power of two > 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:126,Energy Efficiency,power,power,126,/// Check if this APInt's value is a power of two greater than zero.; ///; /// \returns true if the argument APInt value is a power of two > 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:45,Energy Efficiency,power,power,45,/// Check if this APInt's negated value is a power of two greater than zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:29,Availability,mask,mask,29,// NegatedPowerOf2 - shifted mask in the top bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:96,Testability,test,test,96,/// Convert APInt to a boolean value.; ///; /// This converts the APInt to a boolean value as a test against zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:116,Availability,Mask,MaskIdx,116,"/// Return true if this APInt value contains a non-empty sequence of ones with; /// the remainder zero. If true, \p MaskIdx will specify the index of the; /// lowest set bit and \p MaskLen is updated to specify the length of the; /// mask, else neither are updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:181,Availability,Mask,MaskLen,181,"/// Return true if this APInt value contains a non-empty sequence of ones with; /// the remainder zero. If true, \p MaskIdx will specify the index of the; /// lowest set bit and \p MaskLen is updated to specify the length of the; /// mask, else neither are updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:234,Availability,mask,mask,234,"/// Return true if this APInt value contains a non-empty sequence of ones with; /// the remainder zero. If true, \p MaskIdx will specify the index of the; /// lowest set bit and \p MaskLen is updated to specify the length of the; /// mask, else neither are updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:192,Deployability,update,updated,192,"/// Return true if this APInt value contains a non-empty sequence of ones with; /// the remainder zero. If true, \p MaskIdx will specify the index of the; /// lowest set bit and \p MaskLen is updated to specify the length of the; /// mask, else neither are updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:257,Deployability,update,updated,257,"/// Return true if this APInt value contains a non-empty sequence of ones with; /// the remainder zero. If true, \p MaskIdx will specify the index of the; /// lowest set bit and \p MaskLen is updated to specify the length of the; /// mask, else neither are updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:137,Availability,mask,mask,137,"/// Compute an APInt containing numBits highbits from this APInt.; ///; /// Get an APInt with the same BitWidth as this APInt, just zero mask the low; /// bits and right shift to the least significant bit.; ///; /// \returns the high ""numBits"" bits of this APInt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:136,Availability,mask,mask,136,"/// Compute an APInt containing numBits lowbits from this APInt.; ///; /// Get an APInt with the same BitWidth as this APInt, just zero mask the high; /// bits.; ///; /// \returns the low ""numBits"" bits of this APInt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:60,Modifiability,extend,extending,60,"/// Determine if two APInts have the same value, after zero-extending; /// one of them (if needed!) to ensure that the bit-widths match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Testability,Log,Logical,4,"/// Logical negation operation on this APInt returns true if zero, like normal; /// integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:47,Performance,Perform,Performs,47,/// Bitwise AND assignment operator.; ///; /// Performs a bitwise AND operation on this APInt and RHS. The result is; /// assigned to *this.; ///; /// \returns *this after ANDing with RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:130,Modifiability,extend,extended,130,/// Bitwise AND assignment operator.; ///; /// Performs a bitwise AND operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:47,Performance,Perform,Performs,47,/// Bitwise AND assignment operator.; ///; /// Performs a bitwise AND operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:115,Testability,log,logically,115,/// Bitwise AND assignment operator.; ///; /// Performs a bitwise AND operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:46,Performance,Perform,Performs,46,/// Bitwise OR assignment operator.; ///; /// Performs a bitwise OR operation on this APInt and RHS. The result is; /// assigned *this;; ///; /// \returns *this after ORing with RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:128,Modifiability,extend,extended,128,/// Bitwise OR assignment operator.; ///; /// Performs a bitwise OR operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:46,Performance,Perform,Performs,46,/// Bitwise OR assignment operator.; ///; /// Performs a bitwise OR operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:113,Testability,log,logically,113,/// Bitwise OR assignment operator.; ///; /// Performs a bitwise OR operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:47,Performance,Perform,Performs,47,/// Bitwise XOR assignment operator.; ///; /// Performs a bitwise XOR operation on this APInt and RHS. The result is; /// assigned to *this.; ///; /// \returns *this after XORing with RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:130,Modifiability,extend,extended,130,/// Bitwise XOR assignment operator.; ///; /// Performs a bitwise XOR operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:47,Performance,Perform,Performs,47,/// Bitwise XOR assignment operator.; ///; /// Performs a bitwise XOR operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:115,Testability,log,logically,115,/// Bitwise XOR assignment operator.; ///; /// Performs a bitwise XOR operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:9,Testability,log,logical,9,/// Left logical shift operator.; ///; /// Shifts this APInt left by \p Bits and returns the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:9,Testability,log,logical,9,/// Left logical shift operator.; ///; /// Shifts this APInt left by \p Bits and returns the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Testability,Log,Logical,4,/// Logical right-shift function.; ///; /// Logical right-shift this APInt by shiftAmt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:44,Testability,Log,Logical,44,/// Logical right-shift function.; ///; /// Logical right-shift this APInt by shiftAmt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Testability,Log,Logical,4,/// Logical right-shift this APInt by ShiftAmt in place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:13,Testability,log,logical,13,/// relative logical shift right,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:13,Testability,log,logical,13,/// relative logical shift left,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Testability,Log,Logical,4,/// Logical right-shift function.; ///; /// Logical right-shift this APInt by shiftAmt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:44,Testability,Log,Logical,44,/// Logical right-shift function.; ///; /// Logical right-shift this APInt by shiftAmt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Testability,Log,Logical,4,/// Logical right-shift this APInt by ShiftAmt in place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:43,Performance,Perform,Perform,43,"/// Unsigned division operation.; ///; /// Perform an unsigned divide operation on this APInt by RHS. Both this and; /// RHS are treated as unsigned quantities for purposes of this division.; ///; /// \returns a new APInt value containing the division result, rounded towards; /// zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:44,Performance,Perform,Perform,44,/// Unsigned remainder operation.; ///; /// Perform an unsigned remainder operation on this APInt with RHS being the; /// divisor. Both this and RHS are treated as unsigned quantities for purposes; /// of this operation.; ///; /// \returns a new APInt value containing the remainder result,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:240,Energy Efficiency,efficient,efficient,240,"/// Dual division/remainder interface.; ///; /// Sometimes it is convenient to divide two APInt values and obtain both the; /// quotient and remainder. This function does both operations in the same; /// computation making it a little more efficient. The pair of input arguments; /// may overlap with the pair of output arguments. It is safe to call; /// udivrem(X, Y, X, Y), for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:28,Integrability,interface,interface,28,"/// Dual division/remainder interface.; ///; /// Sometimes it is convenient to divide two APInt values and obtain both the; /// quotient and remainder. This function does both operations in the same; /// computation making it a little more efficient. The pair of input arguments; /// may overlap with the pair of output arguments. It is safe to call; /// udivrem(X, Y, X, Y), for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:337,Safety,safe,safe,337,"/// Dual division/remainder interface.; ///; /// Sometimes it is convenient to divide two APInt values and obtain both the; /// quotient and remainder. This function does both operations in the same; /// computation making it a little more efficient. The pair of input arguments; /// may overlap with the pair of output arguments. It is safe to call; /// udivrem(X, Y, X, Y), for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:19,Testability,test,tests,19,/// This operation tests if there are any pairs of corresponding bits; /// between this APInt and RHS that are both set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:133,Availability,error,error,133,/// @}; /// \name Resizing Operators; /// @{; /// Truncate to new width.; ///; /// Truncate the APInt to a specified width. It is an error to specify a width; /// that is greater than the current width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:208,Availability,error,error,208,"/// Sign extend to a new width.; ///; /// This operation sign extends the APInt to a new width. If the high order; /// bit is set, the fill on the left will be done with 1 bits, otherwise zero.; /// It is an error to specify a width that is less than the; /// current width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:9,Modifiability,extend,extend,9,"/// Sign extend to a new width.; ///; /// This operation sign extends the APInt to a new width. If the high order; /// bit is set, the fill on the left will be done with 1 bits, otherwise zero.; /// It is an error to specify a width that is less than the; /// current width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:62,Modifiability,extend,extends,62,"/// Sign extend to a new width.; ///; /// This operation sign extends the APInt to a new width. If the high order; /// bit is set, the fill on the left will be done with 1 bits, otherwise zero.; /// It is an error to specify a width that is less than the; /// current width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:154,Availability,error,error,154,/// Zero extend to a new width.; ///; /// This operation zero extends the APInt to a new width. The high order bits; /// are filled with 0 bits. It is an error to specify a width that is less; /// than the current width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:9,Modifiability,extend,extend,9,/// Zero extend to a new width.; ///; /// This operation zero extends the APInt to a new width. The high order bits; /// are filled with 0 bits. It is an error to specify a width that is less; /// than the current width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:62,Modifiability,extend,extends,62,/// Zero extend to a new width.; ///; /// This operation zero extends the APInt to a new width. The high order bits; /// are filled with 0 bits. It is an error to specify a width that is less; /// than the current width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:9,Modifiability,extend,extend,9,"/// Sign extend or truncate to width; ///; /// Make this APInt have the bit width given by \p width. The value is sign; /// extended, truncated, or left alone to make it that width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:124,Modifiability,extend,extended,124,"/// Sign extend or truncate to width; ///; /// Make this APInt have the bit width given by \p width. The value is sign; /// extended, truncated, or left alone to make it that width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:9,Modifiability,extend,extend,9,"/// Zero extend or truncate to width; ///; /// Make this APInt have the bit width given by \p width. The value is zero; /// extended, truncated, or left alone to make it that width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:124,Modifiability,extend,extended,124,"/// Zero extend or truncate to width; ///; /// Make this APInt have the bit width given by \p width. The value is zero; /// extended, truncated, or left alone to make it that width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:3,Usability,Clear,Clear,3,// Clear the unused ones,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:95,Integrability,wrap,wrap,95,"/// Set the bits from loBit (inclusive) to hiBit (exclusive) to 1.; /// This function handles ""wrap"" case when \p loBit >= \p hiBit, and calls; /// setBits when \p loBit < \p hiBit.; /// For \p loBit == \p hiBit wrap case, set every bit to 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:212,Integrability,wrap,wrap,212,"/// Set the bits from loBit (inclusive) to hiBit (exclusive) to 1.; /// This function handles ""wrap"" case when \p loBit >= \p hiBit, and calls; /// setBits when \p loBit < \p hiBit.; /// For \p loBit == \p hiBit wrap case, set every bit to 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Deployability,Toggle,Toggle,4,/// Toggle every bit to its opposite value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Deployability,Toggle,Toggles,4,"/// Toggles a given bit to its opposite value.; ///; /// Toggle a given bit to its opposite value whose position is given; /// as ""bitPosition"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:57,Deployability,Toggle,Toggle,57,"/// Toggles a given bit to its opposite value.; ///; /// Toggle a given bit to its opposite value whose position is given; /// as ""bitPosition"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:13,Modifiability,extend,extended,13,/// Get zero extended value; ///; /// This method attempts to return the value of this APInt as a zero extended; /// uint64_t. The bitwidth must be <= 64 or the value must fit within a; /// uint64_t. Otherwise an assertion will result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:103,Modifiability,extend,extended,103,/// Get zero extended value; ///; /// This method attempts to return the value of this APInt as a zero extended; /// uint64_t. The bitwidth must be <= 64 or the value must fit within a; /// uint64_t. Otherwise an assertion will result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:213,Testability,assert,assertion,213,/// Get zero extended value; ///; /// This method attempts to return the value of this APInt as a zero extended; /// uint64_t. The bitwidth must be <= 64 or the value must fit within a; /// uint64_t. Otherwise an assertion will result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:13,Modifiability,extend,extended,13,/// Get zero extended value if possible; ///; /// This method attempts to return the value of this APInt as a zero extended; /// uint64_t. The bitwidth must be <= 64 or the value must fit within a; /// uint64_t. Otherwise no value is returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:115,Modifiability,extend,extended,115,/// Get zero extended value if possible; ///; /// This method attempts to return the value of this APInt as a zero extended; /// uint64_t. The bitwidth must be <= 64 or the value must fit within a; /// uint64_t. Otherwise no value is returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:13,Modifiability,extend,extended,13,/// Get sign extended value; ///; /// This method attempts to return the value of this APInt as a sign extended; /// int64_t. The bit width must be <= 64 or the value must fit within an; /// int64_t. Otherwise an assertion will result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:103,Modifiability,extend,extended,103,/// Get sign extended value; ///; /// This method attempts to return the value of this APInt as a sign extended; /// int64_t. The bit width must be <= 64 or the value must fit within an; /// int64_t. Otherwise an assertion will result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:213,Testability,assert,assertion,213,/// Get sign extended value; ///; /// This method attempts to return the value of this APInt as a sign extended; /// int64_t. The bit width must be <= 64 or the value must fit within an; /// int64_t. Otherwise an assertion will result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:13,Modifiability,extend,extended,13,/// Get sign extended value if possible; ///; /// This method attempts to return the value of this APInt as a sign extended; /// int64_t. The bitwidth must be <= 64 or the value must fit within an; /// int64_t. Otherwise no value is returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:115,Modifiability,extend,extended,115,/// Get sign extended value if possible; ///; /// This method attempts to return the value of this APInt as a sign extended; /// int64_t. The bitwidth must be <= 64 or the value must fit within an; /// int64_t. Otherwise no value is returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:73,Testability,log,log,73,/// @}; /// \name Mathematics Operations; /// @{; /// \returns the floor log base 2 of this APInt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:22,Testability,log,log,22,/// \returns the ceil log base 2 of this APInt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:25,Testability,log,log,25,"/// \returns the nearest log base 2 of this APInt. Ties round up.; ///; /// NOTE: When we have a BitWidth of 1, we define:; ///; /// log2(0) = UINT32_MAX; /// log2(1) = 0; ///; /// to get around any mathematical concerns resulting from; /// referencing 2 in a space where 2 does no exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:58,Energy Efficiency,power,power,58,"/// \returns the log base 2 of this APInt if its an exact power of two, -1; /// otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:17,Testability,log,log,17,"/// \returns the log base 2 of this APInt if its an exact power of two, -1; /// otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Usability,Clear,Clear,4,/// Clear the given bit of a bignum. Zero-based.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:332,Integrability,rout,routine,332,"/// If RHS is zero LHS and REMAINDER are left unchanged, return one.; /// Otherwise set LHS to LHS / RHS with the fractional part discarded, set; /// REMAINDER to the remainder, return zero. i.e.; ///; /// OLD_LHS = RHS * LHS + REMAINDER; ///; /// SCRATCH is a bignum of the same size as the operands and result for use by; /// the routine; its contents need not be initialized and are destroyed. LHS,; /// REMAINDER and SCRATCH must be distinct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:34,Energy Efficiency,allocate,allocated,34,/// Returns whether this instance allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:98,Safety,unsafe,unsafe,98,"/// This constructor is used only internally for speed of construction of; /// temporaries. It is unsafe since it takes ownership of the pointer, so it; /// is not public.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:21,Availability,mask,mask,21,"/// Get a single bit mask.; ///; /// \returns a uint64_t with only bit at ""whichBit(bitPosition)"" set; /// This method generates and returns a uint64_t (word) mask for a single; /// bit at a specific bit position. This is used to mask the bit in the; /// corresponding word.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:159,Availability,mask,mask,159,"/// Get a single bit mask.; ///; /// \returns a uint64_t with only bit at ""whichBit(bitPosition)"" set; /// This method generates and returns a uint64_t (word) mask for a single; /// bit at a specific bit position. This is used to mask the bit in the; /// corresponding word.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:230,Availability,mask,mask,230,"/// Get a single bit mask.; ///; /// \returns a uint64_t with only bit at ""whichBit(bitPosition)"" set; /// This method generates and returns a uint64_t (word) mask for a single; /// bit at a specific bit position. This is used to mask the bit in the; /// corresponding word.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Usability,Clear,Clear,4,"/// Clear unused high order bits; ///; /// This method is used internally to clear the top ""N"" bits in the high order; /// word that are not used by the APInt. This is needed after the most; /// significant word is assigned a value to ensure that those bits are; /// zero'd out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:77,Usability,clear,clear,77,"/// Clear unused high order bits; ///; /// This method is used internally to clear the top ""N"" bits in the high order; /// word that are not used by the APInt. This is needed after the most; /// significant word is assigned a value to ensure that those bits are; /// zero'd out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:3,Availability,Mask,Mask,3,// Mask out the high bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:128,Usability,simpl,simply,128,/// An internal division function for dividing APInts.; ///; /// This is used by the toString method to divide by the radix. It simply; /// provides a more convenient form of divide for internal use since KnuthDiv; /// has specific constraints on its inputs. If those constraints are not met; /// then it provides a simpler form of divide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:316,Usability,simpl,simpler,316,/// An internal division function for dividing APInts.; ///; /// This is used by the toString method to divide by the radix. It simply; /// provides a more convenient form of divide for internal use since KnuthDiv; /// has specific constraints on its inputs. If those constraints are not met; /// then it provides a simpler form of divide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Performance,Load,LoadIntFromMemory,4,"/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting; /// from Src into IntVal, which is assumed to be wide enough and to hold zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:24,Performance,Load,Loads,24,"/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting; /// from Src into IntVal, which is assumed to be wide enough and to hold zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:56,Performance,Load,LoadBytes,56,"/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting; /// from Src into IntVal, which is assumed to be wide enough and to hold zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h:446,Usability,simpl,simple,446,"//===-- llvm/ADT/APSInt.h - Arbitrary Precision Signed Int -----*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the APSInt class, which is a simple class that; /// represents an arbitrary sized integer that knows its signedness.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h:63,Testability,test,tests,63,/// Determine if this APSInt Value is positive.; ///; /// This tests if the value of this APSInt is positive (> 0). Note; /// that 0 is not a positive value.; ///; /// \returns true if this APSInt is positive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h:22,Modifiability,extend,extended,22,/// Get the correctly-extended \c int64_t value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h:32,Integrability,wrap,wrap,32,"// The remaining operators just wrap the logic of APInt, but retain the; // signedness information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h:41,Testability,log,logic,41,"// The remaining operators just wrap the logic of APInt, but retain the; // signedness information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h:69,Modifiability,extend,extending,69,"/// Determine if two APSInts have the same value, zero- or; /// sign-extending as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:36,Integrability,Wrap,Wrapper,36,"//===- ArrayRef.h - Array Reference Wrapper ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:391,Modifiability,extend,extends,391,"/// ArrayRef - Represent a constant reference to an array (0 or more elements; /// consecutively in memory), i.e. a start pointer and a length. It allows; /// various APIs to take consecutive elements easily and conveniently.; ///; /// This class does not own the underlying data, it is expected to be used in; /// situations where the data resides in some other buffer, whose lifetime; /// extends past that of the ArrayRef. For this reason, it is not in general; /// safe to store an ArrayRef.; ///; /// This is intended to be trivially copyable, so it should be passed by; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:469,Safety,safe,safe,469,"/// ArrayRef - Represent a constant reference to an array (0 or more elements; /// consecutively in memory), i.e. a start pointer and a length. It allows; /// various APIs to take consecutive elements easily and conveniently.; ///; /// This class does not own the underlying data, it is expected to be used in; /// situations where the data resides in some other buffer, whose lifetime; /// extends past that of the ArrayRef. For this reason, it is not in general; /// safe to store an ArrayRef.; ///; /// This is intended to be trivially copyable, so it should be passed by; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:81,Safety,avoid,avoid,81,/// Construct an ArrayRef from a SmallVector. This is templated in order to; /// avoid instantiating SmallVectorTemplateCommon<T> whenever we; /// copy-construct an ArrayRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:87,Integrability,message,messages,87,// Disable gcc's warning in this constructor as it generates an enormous amount; // of messages. Anyone using ArrayRef should already be aware of the fact that; // it does not do lifetime extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:95,Safety,avoid,avoid,95,/// Construct an ArrayRef<const T*> from a SmallVector<T*>. This is; /// templated in order to avoid instantiating SmallVectorTemplateCommon<T>; /// whenever we copy-construct an ArrayRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:18,Usability,Simpl,Simple,18,/// @}; /// @name Simple Operations; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:10,Energy Efficiency,Allocate,Allocate,10,// copy - Allocate copy in Allocator and return ArrayRef<T> to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:413,Modifiability,extend,extends,413,"/// MutableArrayRef - Represent a mutable reference to an array (0 or more; /// elements consecutively in memory), i.e. a start pointer and a length. It; /// allows various APIs to take and modify consecutive elements easily and; /// conveniently.; ///; /// This class does not own the underlying data, it is expected to be used in; /// situations where the data resides in some other buffer, whose lifetime; /// extends past that of the MutableArrayRef. For this reason, it is not in; /// general safe to store a MutableArrayRef.; ///; /// This is intended to be trivially copyable, so it should be passed by; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:498,Safety,safe,safe,498,"/// MutableArrayRef - Represent a mutable reference to an array (0 or more; /// elements consecutively in memory), i.e. a start pointer and a length. It; /// allows various APIs to take and modify consecutive elements easily and; /// conveniently.; ///; /// This class does not own the underlying data, it is expected to be used in; /// situations where the data resides in some other buffer, whose lifetime; /// extends past that of the MutableArrayRef. For this reason, it is not in; /// general safe to store a MutableArrayRef.; ///; /// This is intended to be trivially copyable, so it should be passed by; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:29,Usability,guid,guides,29,/// @name ArrayRef Deduction guides; /// @{; /// Deduction guide to construct an ArrayRef from a single element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:59,Usability,guid,guide,59,/// @name ArrayRef Deduction guides; /// @{; /// Deduction guide to construct an ArrayRef from a single element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct an ArrayRef from a pointer and length,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct an ArrayRef from a range,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct an ArrayRef from a SmallVector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct an ArrayRef from a SmallVector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct an ArrayRef from a std::vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct an ArrayRef from a std::array,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct an ArrayRef from an ArrayRef (const),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct an ArrayRef from an ArrayRef,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct an ArrayRef from a C array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:36,Usability,guid,guides,36,/// @name MutableArrayRef Deduction guides; /// @{; /// Deduction guide to construct a `MutableArrayRef` from a single element,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:66,Usability,guid,guide,66,/// @name MutableArrayRef Deduction guides; /// @{; /// Deduction guide to construct a `MutableArrayRef` from a single element,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct a `MutableArrayRef` from a pointer and; /// length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct a `MutableArrayRef` from a `SmallVector`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct a `MutableArrayRef` from a `std::vector`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct a `MutableArrayRef` from a `std::array`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:14,Usability,guid,guide,14,/// Deduction guide to construct a `MutableArrayRef` from a C array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h:194,Safety,avoid,avoid,194,"// This implementation of bit_cast is different from the C++20 one in two ways:; // - It isn't constexpr because that requires compiler support.; // - It requires trivially-constructible To, to avoid UB in the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/bit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h:78,Deployability,release,release,78,"// The DLL version of the runtime lacks these functions (bug!?), but in a; // release build they're replaced with BSWAP instructions anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/bit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h:33,Energy Efficiency,power,power,33,/// Returns the largest integral power of two no greater than Value if Value is; /// nonzero. Returns 0 otherwise.; ///; /// Ex. bit_floor(5) == 4.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/bit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h:34,Energy Efficiency,power,power,34,/// Returns the smallest integral power of two no smaller than Value if Value is; /// nonzero. Returns 1 otherwise.; ///; /// Ex. bit_ceil(5) == 8.; ///; /// The return value is undefined if the input is larger than the largest power; /// of two representable in T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/bit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h:228,Energy Efficiency,power,power,228,/// Returns the smallest integral power of two no smaller than Value if Value is; /// nonzero. Returns 1 otherwise.; ///; /// Ex. bit_ceil(5) == 8.; ///; /// The return value is undefined if the input is larger than the largest power; /// of two representable in T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/bit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h:2421,Energy Efficiency,efficient,efficiently,2421,";; ///; /// // Store and retrieve a single bit as bool.; /// using Bool = Bitfield::Element<bool, 0, 1>;; /// Bitfield::set<Bool>(Storage, true);; /// EXPECT_EQ(Storage, 0b00000001);; /// // ^; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), true);; ///; /// // Store and retrieve a 2 bit typed enum.; /// // Note: enum underlying type must be unsigned.; /// enum class SuitEnum : uint8_t { CLUBS, DIAMONDS, HEARTS, SPADES };; /// // Note: enum maximum value needs to be passed in as last parameter.; /// using Suit = Bitfield::Element<SuitEnum, 1, 2, SuitEnum::SPADES>;; /// Bitfield::set<Suit>(Storage, SuitEnum::HEARTS);; /// EXPECT_EQ(Storage, 0b00000101);; /// // ^^; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::HEARTS);; ///; /// // Store and retrieve a 5 bit value as unsigned.; /// using Value = Bitfield::Element<unsigned, 3, 5>;; /// Bitfield::set<Value>(Storage, 10);; /// EXPECT_EQ(Storage, 0b01010101);; /// // ^^^^^; /// EXPECT_EQ(Bitfield::get<Value>(Storage), 10U);; ///; /// // Interpret the same 5 bit value as signed.; /// using SignedValue = Bitfield::Element<int, 3, 5>;; /// Bitfield::set<SignedValue>(Storage, -2);; /// EXPECT_EQ(Storage, 0b11110101);; /// // ^^^^^; /// EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -2);; ///; /// // Ability to efficiently test if a field is non zero.; /// EXPECT_TRUE(Bitfield::test<Value>(Storage));; ///; /// // Alter Storage changes value.; /// Storage = 0;; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), false);; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::CLUBS);; /// EXPECT_EQ(Bitfield::get<Value>(Storage), 0U);; /// EXPECT_EQ(Bitfield::get<SignedValue>(Storage), 0);; ///; /// Storage = 255;; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), true);; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::SPADES);; /// EXPECT_EQ(Bitfield::get<Value>(Storage), 31U);; /// EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -1);; /// \endcode; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h:428,Testability,test,test,428,"//===-- llvm/ADT/Bitfield.h - Get and Set bits in an integer ---*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements methods to test, set and extract typed bits from packed; /// unsigned integers.; ///; /// Why not C++ bitfields?; /// ----------------------; /// C++ bitfields do not offer control over the bit layout nor consistent; /// behavior when it comes to out of range values.; /// For instance, the layout is implementation defined and adjacent bits may be; /// packed together but are not required to. This is problematic when storage is; /// sparse and data must be stored in a particular integer type.; ///; /// The methods provided in this file ensure precise control over the; /// layout/storage as well as protection against out of range values.; ///; /// Usage example; /// -------------; /// \code{.cpp}; /// uint8_t Storage = 0;; ///; /// // Store and retrieve a single bit as bool.; /// using Bool = Bitfield::Element<bool, 0, 1>;; /// Bitfield::set<Bool>(Storage, true);; /// EXPECT_EQ(Storage, 0b00000001);; /// // ^; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), true);; ///; /// // Store and retrieve a 2 bit typed enum.; /// // Note: enum underlying type must be unsigned.; /// enum class SuitEnum : uint8_t { CLUBS, DIAMONDS, HEARTS, SPADES };; /// // Note: enum maximum value needs to be passed in as last parameter.; /// using Suit = Bitfield::Element<SuitEnum, 1, 2, SuitEnum::SPADES>;; /// Bitfield::set<Suit>(Storage, SuitEnum::HEARTS);; /// EXPECT_EQ(Storage, 0b00000101);; /// // ^^; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::HEARTS);; ///; /// // Store and retrieve a 5 bit value as unsigned.; /// using Value = Bitfield::Element<unsigned, 3, 5>;; /// Bitfie",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h:2433,Testability,test,test,2433,";; ///; /// // Store and retrieve a single bit as bool.; /// using Bool = Bitfield::Element<bool, 0, 1>;; /// Bitfield::set<Bool>(Storage, true);; /// EXPECT_EQ(Storage, 0b00000001);; /// // ^; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), true);; ///; /// // Store and retrieve a 2 bit typed enum.; /// // Note: enum underlying type must be unsigned.; /// enum class SuitEnum : uint8_t { CLUBS, DIAMONDS, HEARTS, SPADES };; /// // Note: enum maximum value needs to be passed in as last parameter.; /// using Suit = Bitfield::Element<SuitEnum, 1, 2, SuitEnum::SPADES>;; /// Bitfield::set<Suit>(Storage, SuitEnum::HEARTS);; /// EXPECT_EQ(Storage, 0b00000101);; /// // ^^; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::HEARTS);; ///; /// // Store and retrieve a 5 bit value as unsigned.; /// using Value = Bitfield::Element<unsigned, 3, 5>;; /// Bitfield::set<Value>(Storage, 10);; /// EXPECT_EQ(Storage, 0b01010101);; /// // ^^^^^; /// EXPECT_EQ(Bitfield::get<Value>(Storage), 10U);; ///; /// // Interpret the same 5 bit value as signed.; /// using SignedValue = Bitfield::Element<int, 3, 5>;; /// Bitfield::set<SignedValue>(Storage, -2);; /// EXPECT_EQ(Storage, 0b11110101);; /// // ^^^^^; /// EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -2);; ///; /// // Ability to efficiently test if a field is non zero.; /// EXPECT_TRUE(Bitfield::test<Value>(Storage));; ///; /// // Alter Storage changes value.; /// Storage = 0;; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), false);; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::CLUBS);; /// EXPECT_EQ(Bitfield::get<Value>(Storage), 0U);; /// EXPECT_EQ(Bitfield::get<SignedValue>(Storage), 0);; ///; /// Storage = 255;; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), true);; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::SPADES);; /// EXPECT_EQ(Bitfield::get<Value>(Storage), 31U);; /// EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -1);; /// \endcode; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h:2489,Testability,test,test,2489,";; ///; /// // Store and retrieve a single bit as bool.; /// using Bool = Bitfield::Element<bool, 0, 1>;; /// Bitfield::set<Bool>(Storage, true);; /// EXPECT_EQ(Storage, 0b00000001);; /// // ^; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), true);; ///; /// // Store and retrieve a 2 bit typed enum.; /// // Note: enum underlying type must be unsigned.; /// enum class SuitEnum : uint8_t { CLUBS, DIAMONDS, HEARTS, SPADES };; /// // Note: enum maximum value needs to be passed in as last parameter.; /// using Suit = Bitfield::Element<SuitEnum, 1, 2, SuitEnum::SPADES>;; /// Bitfield::set<Suit>(Storage, SuitEnum::HEARTS);; /// EXPECT_EQ(Storage, 0b00000101);; /// // ^^; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::HEARTS);; ///; /// // Store and retrieve a 5 bit value as unsigned.; /// using Value = Bitfield::Element<unsigned, 3, 5>;; /// Bitfield::set<Value>(Storage, 10);; /// EXPECT_EQ(Storage, 0b01010101);; /// // ^^^^^; /// EXPECT_EQ(Bitfield::get<Value>(Storage), 10U);; ///; /// // Interpret the same 5 bit value as signed.; /// using SignedValue = Bitfield::Element<int, 3, 5>;; /// Bitfield::set<SignedValue>(Storage, -2);; /// EXPECT_EQ(Storage, 0b11110101);; /// // ^^^^^; /// EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -2);; ///; /// // Ability to efficiently test if a field is non zero.; /// EXPECT_TRUE(Bitfield::test<Value>(Storage));; ///; /// // Alter Storage changes value.; /// Storage = 0;; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), false);; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::CLUBS);; /// EXPECT_EQ(Bitfield::get<Value>(Storage), 0U);; /// EXPECT_EQ(Bitfield::get<SignedValue>(Storage), 0);; ///; /// Storage = 255;; /// EXPECT_EQ(Bitfield::get<Bool>(Storage), true);; /// EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::SPADES);; /// EXPECT_EQ(Bitfield::get<Value>(Storage), 31U);; /// EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -1);; /// \endcode; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h:67,Testability,test,test,67,"// namespace bitfields_details; /// Holds functions to get, set or test bitfields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h:70,Energy Efficiency,efficient,efficient,70,/// Return a non-zero value if the field is non-zero.; /// It is more efficient than `getField`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h:78,Testability,assert,asserts,78,/// Sets the typed value in the provided `Packed` value.; /// The method will asserts if the provided value is too big to fit in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h:86,Performance,perform,perform,86,"/// LLVM_MARK_AS_BITMASK_ENUM lets you opt in an individual enum type so you can; /// perform bitwise operations on it without putting static_cast everywhere.; ///; /// \code; /// enum MyEnum {; /// E1 = 1, E2 = 2, E3 = 4, E4 = 8,; /// LLVM_MARK_AS_BITMASK_ENUM(/* LargestValue = */ E4); /// };; ///; /// void Foo() {; /// MyEnum A = (E1 | E2) & E3 ^ ~E4; // Look, ma: No static_cast!; /// }; /// \endcode; ///; /// Normally when you do a bitwise operation on an enum value, you get back an; /// instance of the underlying type (e.g. int). But using this macro, bitwise; /// ops on your enum will return you back instances of the enum. This is; /// particularly useful for enums which represent a combination of flags.; ///; /// The parameter to LLVM_MARK_AS_BITMASK_ENUM should be the largest individual; /// value in your enum.; ///; /// All of the enum's values must be non-negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h:100,Availability,mask,mask,100,"// On overflow, NextPowerOf2 returns zero with the type uint64_t, so; // subtracting 1 gives us the mask with all bits set, like we want.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:12,Testability,Test,Tests,12,/// empty - Tests whether there are no bits in this bitvector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:73,Integrability,depend,depending,73,"/// find_first_in - Returns the index of the first set / unset bit,; /// depending on \p Set, in the range [Begin, End).; /// Returns -1 if all bits in the range are unset / set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:4,Usability,clear,clear,4,/// clear - Removes all bits from the bitvector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:10,Energy Efficiency,Efficient,Efficiently,10,"/// set - Efficiently set a range of bits in [I, E)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:12,Energy Efficiency,Efficient,Efficiently,12,"/// reset - Efficiently reset a range of bits in [I, E)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:4,Testability,Test,Test,4,/// Test if any common bits are set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:4,Testability,test,test,4,/// test - Check if (This - RHS) is zero.; /// This is the same as reset(RHS) and any().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:96,Availability,mask,mask,96,"//===--------------------------------------------------------------------===//; // Portable bit mask operations.; //===--------------------------------------------------------------------===//; //; // These methods all operate on arrays of uint32_t, each holding 32 bits. The; // fixed word size makes it easier to work with literal bit vector constants; // in portable code.; //; // The LSB in each word is the lowest numbered bit. The size of a portable; // bit mask is always a whole multiple of 32 bits. If no bit mask size is; // given, the bit mask is assumed to cover the entire BitVector.; /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:464,Availability,mask,mask,464,"//===--------------------------------------------------------------------===//; // Portable bit mask operations.; //===--------------------------------------------------------------------===//; //; // These methods all operate on arrays of uint32_t, each holding 32 bits. The; // fixed word size makes it easier to work with literal bit vector constants; // in portable code.; //; // The LSB in each word is the lowest numbered bit. The size of a portable; // bit mask is always a whole multiple of 32 bits. If no bit mask size is; // given, the bit mask is assumed to cover the entire BitVector.; /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:518,Availability,mask,mask,518,"//===--------------------------------------------------------------------===//; // Portable bit mask operations.; //===--------------------------------------------------------------------===//; //; // These methods all operate on arrays of uint32_t, each holding 32 bits. The; // fixed word size makes it easier to work with literal bit vector constants; // in portable code.; //; // The LSB in each word is the lowest numbered bit. The size of a portable; // bit mask is always a whole multiple of 32 bits. If no bit mask size is; // given, the bit mask is assumed to cover the entire BitVector.; /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:550,Availability,mask,mask,550,"//===--------------------------------------------------------------------===//; // Portable bit mask operations.; //===--------------------------------------------------------------------===//; //; // These methods all operate on arrays of uint32_t, each holding 32 bits. The; // fixed word size makes it easier to work with literal bit vector constants; // in portable code.; //; // The LSB in each word is the lowest numbered bit. The size of a portable; // bit mask is always a whole multiple of 32 bits. If no bit mask size is; // given, the bit mask is assumed to cover the entire BitVector.; /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:636,Availability,Mask,Mask,636,"//===--------------------------------------------------------------------===//; // Portable bit mask operations.; //===--------------------------------------------------------------------===//; //; // These methods all operate on arrays of uint32_t, each holding 32 bits. The; // fixed word size makes it easier to work with literal bit vector constants; // in portable code.; //; // The LSB in each word is the lowest numbered bit. The size of a portable; // bit mask is always a whole multiple of 32 bits. If no bit mask size is; // given, the bit mask is assumed to cover the entire BitVector.; /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:700,Availability,Mask,Mask,700,"//===--------------------------------------------------------------------===//; // Portable bit mask operations.; //===--------------------------------------------------------------------===//; //; // These methods all operate on arrays of uint32_t, each holding 32 bits. The; // fixed word size makes it easier to work with literal bit vector constants; // in portable code.; //; // The LSB in each word is the lowest numbered bit. The size of a portable; // bit mask is always a whole multiple of 32 bits. If no bit mask size is; // given, the bit mask is assumed to cover the entire BitVector.; /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:83,Modifiability,Portab,Portable,83,"//===--------------------------------------------------------------------===//; // Portable bit mask operations.; //===--------------------------------------------------------------------===//; //; // These methods all operate on arrays of uint32_t, each holding 32 bits. The; // fixed word size makes it easier to work with literal bit vector constants; // in portable code.; //; // The LSB in each word is the lowest numbered bit. The size of a portable; // bit mask is always a whole multiple of 32 bits. If no bit mask size is; // given, the bit mask is assumed to cover the entire BitVector.; /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:361,Modifiability,portab,portable,361,"//===--------------------------------------------------------------------===//; // Portable bit mask operations.; //===--------------------------------------------------------------------===//; //; // These methods all operate on arrays of uint32_t, each holding 32 bits. The; // fixed word size makes it easier to work with literal bit vector constants; // in portable code.; //; // The LSB in each word is the lowest numbered bit. The size of a portable; // bit mask is always a whole multiple of 32 bits. If no bit mask size is; // given, the bit mask is assumed to cover the entire BitVector.; /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:447,Modifiability,portab,portable,447,"//===--------------------------------------------------------------------===//; // Portable bit mask operations.; //===--------------------------------------------------------------------===//; //; // These methods all operate on arrays of uint32_t, each holding 32 bits. The; // fixed word size makes it easier to work with literal bit vector constants; // in portable code.; //; // The LSB in each word is the lowest numbered bit. The size of a portable; // bit mask is always a whole multiple of 32 bits. If no bit mask size is; // given, the bit mask is assumed to cover the entire BitVector.; /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:68,Availability,Mask,Mask,68,"/// clearBitsInMask - Clear any bits in this vector that are set in Mask.; /// Don't resize. This computes ""*this &= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:118,Availability,Mask,Mask,118,"/// clearBitsInMask - Clear any bits in this vector that are set in Mask.; /// Don't resize. This computes ""*this &= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:4,Usability,clear,clearBitsInMask,4,"/// clearBitsInMask - Clear any bits in this vector that are set in Mask.; /// Don't resize. This computes ""*this &= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:22,Usability,Clear,Clear,22,"/// clearBitsInMask - Clear any bits in this vector that are set in Mask.; /// Don't resize. This computes ""*this &= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:69,Availability,Mask,Mask,69,"/// setBitsNotInMask - Add a bit to this vector for every '0' bit in Mask.; /// Don't resize. This computes ""*this |= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:119,Availability,Mask,Mask,119,"/// setBitsNotInMask - Add a bit to this vector for every '0' bit in Mask.; /// Don't resize. This computes ""*this |= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:73,Availability,Mask,Mask,73,"/// clearBitsNotInMask - Clear a bit in this vector for every '0' bit in Mask.; /// Don't resize. This computes ""*this &= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:122,Availability,Mask,Mask,122,"/// clearBitsNotInMask - Clear a bit in this vector for every '0' bit in Mask.; /// Don't resize. This computes ""*this &= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:4,Usability,clear,clearBitsNotInMask,4,"/// clearBitsNotInMask - Clear a bit in this vector for every '0' bit in Mask.; /// Don't resize. This computes ""*this &= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:25,Usability,Clear,Clear,25,"/// clearBitsNotInMask - Clear a bit in this vector for every '0' bit in Mask.; /// Don't resize. This computes ""*this &= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:4,Performance,Perform,Perform,4,"/// Perform a logical left shift of \p Count words by moving everything; /// \p Count words to the right in memory.; ///; /// While confusing, words are stored from least significant at Bits[0] to; /// most significant at Bits[NumWords-1]. A logical shift left, however,; /// moves the current least significant bit to a higher logical index, and; /// fills the previous least significant bits with 0. Thus, we actually; /// need to move the bytes of the memory to the right, not to the left.; /// Example:; /// Words = [0xBBBBAAAA, 0xDDDDFFFF, 0x00000000, 0xDDDD0000]; /// represents a BitVector where 0xBBBBAAAA contain the least significant; /// bits. So if we want to shift the BitVector left by 2 words, we need; /// to turn this into 0x00000000 0x00000000 0xBBBBAAAA 0xDDDDFFFF by using a; /// memmove which moves right, not left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:14,Testability,log,logical,14,"/// Perform a logical left shift of \p Count words by moving everything; /// \p Count words to the right in memory.; ///; /// While confusing, words are stored from least significant at Bits[0] to; /// most significant at Bits[NumWords-1]. A logical shift left, however,; /// moves the current least significant bit to a higher logical index, and; /// fills the previous least significant bits with 0. Thus, we actually; /// need to move the bytes of the memory to the right, not to the left.; /// Example:; /// Words = [0xBBBBAAAA, 0xDDDDFFFF, 0x00000000, 0xDDDD0000]; /// represents a BitVector where 0xBBBBAAAA contain the least significant; /// bits. So if we want to shift the BitVector left by 2 words, we need; /// to turn this into 0x00000000 0x00000000 0xBBBBAAAA 0xDDDDFFFF by using a; /// memmove which moves right, not left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:242,Testability,log,logical,242,"/// Perform a logical left shift of \p Count words by moving everything; /// \p Count words to the right in memory.; ///; /// While confusing, words are stored from least significant at Bits[0] to; /// most significant at Bits[NumWords-1]. A logical shift left, however,; /// moves the current least significant bit to a higher logical index, and; /// fills the previous least significant bits with 0. Thus, we actually; /// need to move the bytes of the memory to the right, not to the left.; /// Example:; /// Words = [0xBBBBAAAA, 0xDDDDFFFF, 0x00000000, 0xDDDD0000]; /// represents a BitVector where 0xBBBBAAAA contain the least significant; /// bits. So if we want to shift the BitVector left by 2 words, we need; /// to turn this into 0x00000000 0x00000000 0xBBBBAAAA 0xDDDDFFFF by using a; /// memmove which moves right, not left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:328,Testability,log,logical,328,"/// Perform a logical left shift of \p Count words by moving everything; /// \p Count words to the right in memory.; ///; /// While confusing, words are stored from least significant at Bits[0] to; /// most significant at Bits[NumWords-1]. A logical shift left, however,; /// moves the current least significant bit to a higher logical index, and; /// fills the previous least significant bits with 0. Thus, we actually; /// need to move the bytes of the memory to the right, not to the left.; /// Example:; /// Words = [0xBBBBAAAA, 0xDDDDFFFF, 0x00000000, 0xDDDD0000]; /// represents a BitVector where 0xBBBBAAAA contain the least significant; /// bits. So if we want to shift the BitVector left by 2 words, we need; /// to turn this into 0x00000000 0x00000000 0xBBBBAAAA 0xDDDDFFFF by using a; /// memmove which moves right, not left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:4,Performance,Perform,Perform,4,/// Perform a logical right shift of \p Count words by moving those; /// words to the left in memory. See wordShl for more information.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:14,Testability,log,logical,14,/// Perform a logical right shift of \p Count words by moving those; /// words to the left in memory. See wordShl for more information.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:3,Usability,Clear,Clear,3,// Clear the unused bits in the high words.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h:507,Security,expose,exposes,507,"//===- llvm/ADT/BreadthFirstIterator.h - Breadth First iterator -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file builds on the ADT/GraphTraits.h file to build a generic breadth; /// first graph iterator. This file exposes the following functions/types:; ///; /// bf_begin/bf_end/bf_iterator; /// * Normal breadth-first iteration - visit a graph level-by-level.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h:44,Usability,simpl,simple,44,// The visited state for the iteration is a simple set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h:9,Performance,queue,queue,9,// Visit queue - used to maintain BFS ordering.; // std::optional<> because we need markers for levels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h:14,Security,access,accessor,14,// Provide an accessor method to use them in range-based patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:16,Performance,Cache,CachedHashString,16,"//===- llvm/ADT/CachedHashString.h - Prehashed string/StringRef -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines CachedHashString and CachedHashStringRef. These are; /// owning and not-owning string types that store their hash in addition to; /// their string data.; ///; /// Unlike std::string, CachedHashString can be used in DenseSet/DenseMap; /// (because, unlike std::string, CachedHashString lets us have empty and; /// tombstone values).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:414,Performance,Cache,CachedHashString,414,"//===- llvm/ADT/CachedHashString.h - Prehashed string/StringRef -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines CachedHashString and CachedHashStringRef. These are; /// owning and not-owning string types that store their hash in addition to; /// their string data.; ///; /// Unlike std::string, CachedHashString can be used in DenseSet/DenseMap; /// (because, unlike std::string, CachedHashString lets us have empty and; /// tombstone values).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:435,Performance,Cache,CachedHashStringRef,435,"//===- llvm/ADT/CachedHashString.h - Prehashed string/StringRef -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines CachedHashString and CachedHashStringRef. These are; /// owning and not-owning string types that store their hash in addition to; /// their string data.; ///; /// Unlike std::string, CachedHashString can be used in DenseSet/DenseMap; /// (because, unlike std::string, CachedHashString lets us have empty and; /// tombstone values).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:597,Performance,Cache,CachedHashString,597,"//===- llvm/ADT/CachedHashString.h - Prehashed string/StringRef -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines CachedHashString and CachedHashStringRef. These are; /// owning and not-owning string types that store their hash in addition to; /// their string data.; ///; /// Unlike std::string, CachedHashString can be used in DenseSet/DenseMap; /// (because, unlike std::string, CachedHashString lets us have empty and; /// tombstone values).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:682,Performance,Cache,CachedHashString,682,"//===- llvm/ADT/CachedHashString.h - Prehashed string/StringRef -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines CachedHashString and CachedHashStringRef. These are; /// owning and not-owning string types that store their hash in addition to; /// their string data.; ///; /// Unlike std::string, CachedHashString can be used in DenseSet/DenseMap; /// (because, unlike std::string, CachedHashString lets us have empty and; /// tombstone values).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:523,Security,hash,hash,523,"//===- llvm/ADT/CachedHashString.h - Prehashed string/StringRef -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines CachedHashString and CachedHashStringRef. These are; /// owning and not-owning string types that store their hash in addition to; /// their string data.; ///; /// Unlike std::string, CachedHashString can be used in DenseSet/DenseMap; /// (because, unlike std::string, CachedHashString lets us have empty and; /// tombstone values).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:62,Security,hash,hash,62,/// A container which contains a StringRef plus a precomputed hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:20,Security,hash,hashing,20,// Explicit because hashing a string isn't free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:75,Security,hash,hash,75,"/// A container which contains a string, which it owns, plus a precomputed hash.; ///; /// We do not null-terminate the string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:26,Performance,optimiz,optimization,26,// TODO: Use small-string optimization to avoid allocating.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:42,Safety,avoid,avoid,42,// TODO: Use small-string optimization to avoid allocating.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:32,Security,hash,hashing,32,// Explicit because copying and hashing a string isn't free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:110,Usability,usab,usable,110,"// Ideally this class would not be copyable. But SetVector requires copyable; // keys, and we want this to be usable there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:11,Safety,safe,safe,11,"// This is safe because if RHS.P is the empty or tombstone key, it will have; // length 0, so we'll never dereference its pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:339,Performance,perform,performance,339,"/// A bitvector that, under the hood, relies on an IntervalMap to coalesce; /// elements into intervals. Good for representing sets which predominantly; /// contain contiguous ranges. Bad for representing sets with lots of gaps; /// between elements.; ///; /// Compared to SparseBitVector, CoalescingBitVector offers more predictable; /// performance for non-sequential find() operations.; ///; /// \tparam IndexT - The type of the index into the bitvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:322,Safety,predict,predictable,322,"/// A bitvector that, under the hood, relies on an IntervalMap to coalesce; /// elements into intervals. Good for representing sets which predominantly; /// contain contiguous ranges. Bad for representing sets with lots of gaps; /// between elements.; ///; /// Compared to SparseBitVector, CoalescingBitVector offers more predictable; /// performance for non-sequential find() operations.; ///; /// \tparam IndexT - The type of the index into the bitvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:12,Usability,Clear,Clear,12,/// @}; /// Clear all the bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:144,Safety,safe,safe,144,"/// Set the bits set in \p Other.; ///; /// This method does /not/ support setting already-set bits, see \ref set; /// for the rationale. For a safe set union operation, use \ref operator|=.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:41,Testability,test,testing,41,"/// Set the bits at \p Indices. Used for testing, primarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:249,Usability,simpl,simply,249,"// Split the interval containing Index into up to two parts: one from; // [Start, Index-1] and another from [Index+1, Stop]. If Index is equal to; // either Start or Stop, we create one new interval. If Index is equal to; // both Start and Stop, we simply erase the existing interval.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:7,Performance,perform,performance,7,"// For performance reasons, make the offset at the end different than the; // one used in \ref begin, to optimize the common `It == end()` pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:105,Performance,optimiz,optimize,105,"// For performance reasons, make the offset at the end different than the; // one used in \ref begin, to optimize the common `It == end()` pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:81,Performance,Cache,Cache,81,// Querying the start/stop of an IntervalMap iterator can be very expensive.; // Cache these values for performance reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:104,Performance,perform,performance,104,// Querying the start/stop of an IntervalMap iterator can be very expensive.; // Cache these values for performance reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:44,Performance,cache,cached,44,"/// MapIterator has just changed, reset the cached state to point to the; /// start of the new underlying iterator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:81,Performance,cache,cached,81,"// Do /not/ compare MapIterator for equality, as this is very expensive.; // The cached start/stop values make that check unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:285,Performance,perform,performance,285,"/// Advance the iterator to the first set bit AT, OR AFTER, \p Index. If; /// no such set bit exists, advance to end(). This is like std::lower_bound.; /// This is useful if \p Index is close to the current iterator position.; /// However, unlike \ref find(), this has worst-case O(n) performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:191,Performance,perform,performance,191,"/// Return an iterator pointing to the first set bit AT, OR AFTER, \p Index.; /// If no such set bit exists, return end(). This is like std::lower_bound.; /// This has worst-case logarithmic performance (roughly O(log(gaps between; /// contiguous ranges))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:179,Testability,log,logarithmic,179,"/// Return an iterator pointing to the first set bit AT, OR AFTER, \p Index.; /// If no such set bit exists, return end(). This is like std::lower_bound.; /// This has worst-case logarithmic performance (roughly O(log(gaps between; /// contiguous ranges))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:214,Testability,log,log,214,"/// Return an iterator pointing to the first set bit AT, OR AFTER, \p Index.; /// If no such set bit exists, return end(). This is like std::lower_bound.; /// This has worst-case logarithmic performance (roughly O(log(gaps between; /// contiguous ranges))).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:1126,Integrability,wrap,wrapped,1126,"//===-- llvm/ADT/CombinationGenerator.h ------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Combination generator.; ///; /// Example: given input {{0, 1}, {2}, {3, 4}} it will produce the following; /// combinations: {0, 2, 3}, {0, 2, 4}, {1, 2, 3}, {1, 2, 4}.; ///; /// It is useful to think of input as vector-of-vectors, where the; /// outer vector is the variable space, and inner vector is choice space.; /// The number of choices for each variable can be different.; ///; /// As for implementation, it is useful to think of this as a weird number,; /// where each digit (==variable) may have different base (==number of choices).; /// Thus modelling of 'produce next combination' is exactly analogous to the; /// incrementing of an number - increment lowest digit (pick next choice for the; /// variable), and if it wrapped to the beginning then increment next digit.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:663,Modifiability,variab,variable,663,"//===-- llvm/ADT/CombinationGenerator.h ------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Combination generator.; ///; /// Example: given input {{0, 1}, {2}, {3, 4}} it will produce the following; /// combinations: {0, 2, 3}, {0, 2, 4}, {1, 2, 3}, {1, 2, 4}.; ///; /// It is useful to think of input as vector-of-vectors, where the; /// outer vector is the variable space, and inner vector is choice space.; /// The number of choices for each variable can be different.; ///; /// As for implementation, it is useful to think of this as a weird number,; /// where each digit (==variable) may have different base (==number of choices).; /// Thus modelling of 'produce next combination' is exactly analogous to the; /// incrementing of an number - increment lowest digit (pick next choice for the; /// variable), and if it wrapped to the beginning then increment next digit.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:749,Modifiability,variab,variable,749,"//===-- llvm/ADT/CombinationGenerator.h ------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Combination generator.; ///; /// Example: given input {{0, 1}, {2}, {3, 4}} it will produce the following; /// combinations: {0, 2, 3}, {0, 2, 4}, {1, 2, 3}, {1, 2, 4}.; ///; /// It is useful to think of input as vector-of-vectors, where the; /// outer vector is the variable space, and inner vector is choice space.; /// The number of choices for each variable can be different.; ///; /// As for implementation, it is useful to think of this as a weird number,; /// where each digit (==variable) may have different base (==number of choices).; /// Thus modelling of 'produce next combination' is exactly analogous to the; /// incrementing of an number - increment lowest digit (pick next choice for the; /// variable), and if it wrapped to the beginning then increment next digit.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:883,Modifiability,variab,variable,883,"//===-- llvm/ADT/CombinationGenerator.h ------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Combination generator.; ///; /// Example: given input {{0, 1}, {2}, {3, 4}} it will produce the following; /// combinations: {0, 2, 3}, {0, 2, 4}, {1, 2, 3}, {1, 2, 4}.; ///; /// It is useful to think of input as vector-of-vectors, where the; /// outer vector is the variable space, and inner vector is choice space.; /// The number of choices for each variable can be different.; ///; /// As for implementation, it is useful to think of this as a weird number,; /// where each digit (==variable) may have different base (==number of choices).; /// Thus modelling of 'produce next combination' is exactly analogous to the; /// incrementing of an number - increment lowest digit (pick next choice for the; /// variable), and if it wrapped to the beginning then increment next digit.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:1105,Modifiability,variab,variable,1105,"//===-- llvm/ADT/CombinationGenerator.h ------------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Combination generator.; ///; /// Example: given input {{0, 1}, {2}, {3, 4}} it will produce the following; /// combinations: {0, 2, 3}, {0, 2, 4}, {1, 2, 3}, {1, 2, 4}.; ///; /// It is useful to think of input as vector-of-vectors, where the; /// outer vector is the variable space, and inner vector is choice space.; /// The number of choices for each variable can be different.; ///; /// As for implementation, it is useful to think of this as a weird number,; /// where each digit (==variable) may have different base (==number of choices).; /// Thus modelling of 'produce next combination' is exactly analogous to the; /// incrementing of an number - increment lowest digit (pick next choice for the; /// variable), and if it wrapped to the beginning then increment next digit.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:38,Integrability,wrap,wrapping,38,"// Advance position forward, possibly wrapping to the beginning.; // Returns whether the wrap happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:89,Integrability,wrap,wrap,89,"// Advance position forward, possibly wrapping to the beginning.; // Returns whether the wrap happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:173,Integrability,wrap,wrapped,173,"// 'increment' of the whole VariablesState is defined identically to the; // increment of a number: starting from the least significant element,; // increment it, and if it wrapped, then propagate that carry by also; // incrementing next (more significant) element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:28,Modifiability,Variab,VariablesState,28,"// 'increment' of the whole VariablesState is defined identically to the; // increment of a number: starting from the least significant element,; // increment it, and if it wrapped, then propagate that carry by also; // incrementing next (more significant) element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:91,Modifiability,variab,variable,91,"// There you go, next combination is ready.; // We have carry - increment more significant variable next..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:16,Integrability,wrap,wrapped,16,"// MSB variable wrapped, no more unique combinations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:7,Modifiability,variab,variable,7,"// MSB variable wrapped, no more unique combinations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:22,Modifiability,variab,variable,22,// Initialize the per-variable state to refer to the possible choices for; // that variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:83,Modifiability,variab,variable,83,// Initialize the per-variable state to refer to the possible choices for; // that variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:53,Performance,perform,performing,53,// Temporary buffer to store each combination before performing Callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:33,Modifiability,variab,variable,33,// Gather the currently-selected variable choices into a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:2,Safety,Abort,Abort,2,/*Abort=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:12,Performance,perform,perform,12,// Actually perform exhaustive combination generation.; // Each result will be passed into the callback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:7,Performance,Concurren,ConcurrentHashtable,7,"//===- ConcurrentHashtable.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:152,Energy Efficiency,efficient,efficient,152,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:1739,Energy Efficiency,allocate,allocate,1739,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:774,Modifiability,extend,extended,774,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:4,Performance,Concurren,ConcurrentHashTable,4,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:42,Performance,concurren,concurrent,42,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:309,Performance,concurren,concurrent,309,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:1672,Performance,Concurren,ConcurrentHashTableByPtr,1672,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:1721,Safety,safe,safe,1721,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:53,Security,hash,hashtable,53,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:119,Security,hash,hashtable,119,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:162,Security,access,access,162,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:287,Security,hash,hashtable,287,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:457,Security,hash,hash,457,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:497,Security,Hash,Hash,497,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:1150,Security,hash,hashes,1150,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:1192,Security,Hash,Hashes,1192,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:1279,Security,Hash,Hashes,1279,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:1383,Security,Hash,Hashes,1383,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:1557,Security,Hash,Hashes,1557,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:13,Security,Hash,Hash,13,/// \returns Hash value for the specified \p Key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate buckets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:13,Availability,mask,masks,13,// Calculate masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:105,Energy Efficiency,power,power,105,// We keep only high 32-bits of hash value. So bucket size cannot; // exceed 2^31. Bucket size is always power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:32,Security,hash,hash,32,// We keep only high 32-bits of hash value. So bucket size cannot; // exceed 2^31. Bucket size is always power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:13,Availability,mask,mask,13,// Calculate mask for extended hash bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:22,Modifiability,extend,extended,22,// Calculate mask for extended hash bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:31,Security,hash,hash,31,// Calculate mask for extended hash bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:3,Security,Hash,Hash,3,// Hash matched. Check value for equality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:45,Security,hash,hash,45,/// Print information about current state of hash table structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:3,Security,Hash,Hashes,3,// Hashes for [Size] entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:23,Security,hash,hashes,23,// Store old entries & hashes arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new entries&hashes arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:24,Security,hash,hashes,24,// Allocate new entries&hashes arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:3,Deployability,Update,Update,3,// Update bucket fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:26,Availability,mask,mask,26,// Number of bits in hash mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:21,Security,hash,hash,21,// Number of bits in hash mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:8,Availability,mask,mask,8,// Hash mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:3,Security,Hash,Hash,3,// Hash mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:8,Availability,mask,mask,8,// Hash mask for the extended hash bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:21,Modifiability,extend,extended,21,// Hash mask for the extended hash bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:3,Security,Hash,Hash,3,// Hash mask for the extended hash bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:30,Security,hash,hash,30,// Hash mask for the extended hash bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:426,Integrability,depend,dependencies,426,"/// DAGDeltaAlgorithm - Implements a ""delta debugging"" algorithm for minimizing; /// directed acyclic graphs using a predicate function.; ///; /// The result of the algorithm is a subset of the input change set which is; /// guaranteed to satisfy the predicate, assuming that the input set did. For; /// well formed predicates, the result set is guaranteed to be such that; /// removing any single element not required by the dependencies on the other; /// elements would falsify the predicate.; ///; /// The DAG should be used to represent dependencies in the changes which are; /// likely to hold across the predicate function. That is, for a particular; /// changeset S and predicate P:; ///; /// P(S) => P(S union pred(S)); ///; /// The minimization algorithm uses this dependency information to attempt to; /// eagerly prune large subsets of changes. As with \see DeltaAlgorithm, the DAG; /// is not required to satisfy this property, but the algorithm will run; /// substantially fewer tests with appropriate dependencies. \see DeltaAlgorithm; /// for more information on the properties which the predicate function itself; /// should satisfy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:541,Integrability,depend,dependencies,541,"/// DAGDeltaAlgorithm - Implements a ""delta debugging"" algorithm for minimizing; /// directed acyclic graphs using a predicate function.; ///; /// The result of the algorithm is a subset of the input change set which is; /// guaranteed to satisfy the predicate, assuming that the input set did. For; /// well formed predicates, the result set is guaranteed to be such that; /// removing any single element not required by the dependencies on the other; /// elements would falsify the predicate.; ///; /// The DAG should be used to represent dependencies in the changes which are; /// likely to hold across the predicate function. That is, for a particular; /// changeset S and predicate P:; ///; /// P(S) => P(S union pred(S)); ///; /// The minimization algorithm uses this dependency information to attempt to; /// eagerly prune large subsets of changes. As with \see DeltaAlgorithm, the DAG; /// is not required to satisfy this property, but the algorithm will run; /// substantially fewer tests with appropriate dependencies. \see DeltaAlgorithm; /// for more information on the properties which the predicate function itself; /// should satisfy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:774,Integrability,depend,dependency,774,"/// DAGDeltaAlgorithm - Implements a ""delta debugging"" algorithm for minimizing; /// directed acyclic graphs using a predicate function.; ///; /// The result of the algorithm is a subset of the input change set which is; /// guaranteed to satisfy the predicate, assuming that the input set did. For; /// well formed predicates, the result set is guaranteed to be such that; /// removing any single element not required by the dependencies on the other; /// elements would falsify the predicate.; ///; /// The DAG should be used to represent dependencies in the changes which are; /// likely to hold across the predicate function. That is, for a particular; /// changeset S and predicate P:; ///; /// P(S) => P(S union pred(S)); ///; /// The minimization algorithm uses this dependency information to attempt to; /// eagerly prune large subsets of changes. As with \see DeltaAlgorithm, the DAG; /// is not required to satisfy this property, but the algorithm will run; /// substantially fewer tests with appropriate dependencies. \see DeltaAlgorithm; /// for more information on the properties which the predicate function itself; /// should satisfy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:1015,Integrability,depend,dependencies,1015,"/// DAGDeltaAlgorithm - Implements a ""delta debugging"" algorithm for minimizing; /// directed acyclic graphs using a predicate function.; ///; /// The result of the algorithm is a subset of the input change set which is; /// guaranteed to satisfy the predicate, assuming that the input set did. For; /// well formed predicates, the result set is guaranteed to be such that; /// removing any single element not required by the dependencies on the other; /// elements would falsify the predicate.; ///; /// The DAG should be used to represent dependencies in the changes which are; /// likely to hold across the predicate function. That is, for a particular; /// changeset S and predicate P:; ///; /// P(S) => P(S union pred(S)); ///; /// The minimization algorithm uses this dependency information to attempt to; /// eagerly prune large subsets of changes. As with \see DeltaAlgorithm, the DAG; /// is not required to satisfy this property, but the algorithm will run; /// substantially fewer tests with appropriate dependencies. \see DeltaAlgorithm; /// for more information on the properties which the predicate function itself; /// should satisfy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:992,Testability,test,tests,992,"/// DAGDeltaAlgorithm - Implements a ""delta debugging"" algorithm for minimizing; /// directed acyclic graphs using a predicate function.; ///; /// The result of the algorithm is a subset of the input change set which is; /// guaranteed to satisfy the predicate, assuming that the input set did. For; /// well formed predicates, the result set is guaranteed to be such that; /// removing any single element not required by the dependencies on the other; /// elements would falsify the predicate.; ///; /// The DAG should be used to represent dependencies in the changes which are; /// likely to hold across the predicate function. That is, for a particular; /// changeset S and predicate P:; ///; /// P(S) => P(S union pred(S)); ///; /// The minimization algorithm uses this dependency information to attempt to; /// eagerly prune large subsets of changes. As with \see DeltaAlgorithm, the DAG; /// is not required to satisfy this property, but the algorithm will run; /// substantially fewer tests with appropriate dependencies. \see DeltaAlgorithm; /// for more information on the properties which the predicate function itself; /// should satisfy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:594,Availability,error,error,594,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:77,Integrability,Depend,Dependencies,77,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:252,Integrability,Depend,Dependencies,252,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:329,Integrability,Depend,Dependencies,329,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:354,Integrability,depend,dependencies,354,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:410,Integrability,Depend,Dependencies,410,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:620,Integrability,depend,dependencies,620,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:215,Testability,test,test,215,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:517,Testability,test,tested,517,"/// Run - Minimize the DAG formed by the \p Changes vertices and the; /// \p Dependencies edges by executing \see ExecuteOneTest() on subsets of; /// changes and returning the smallest set which still satisfies the test; /// predicate and the input \p Dependencies.; ///; /// \param Changes The list of changes.; ///; /// \param Dependencies The list of dependencies amongst changes. For each; /// (x,y) in \p Dependencies, both x and y must be in \p Changes. The; /// minimization algorithm guarantees that for each tested changed set S,; /// \f$ x \in S \f$ implies \f$ y \in S \f$. It is an error to have cyclic; /// dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:4,Deployability,Update,UpdatedSearchState,4,/// UpdatedSearchState - Callback used when the search state changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h:38,Testability,test,test,38,/// ExecuteOneTest - Execute a single test predicate on the change set \p S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DAGDeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:793,Availability,error,error,793,"/// DeltaAlgorithm - Implements the delta debugging algorithm (A. Zeller '99); /// for minimizing arbitrary sets using a predicate function.; ///; /// The result of the algorithm is a subset of the input change set which is; /// guaranteed to satisfy the predicate, assuming that the input set did. For; /// well formed predicates, the result set is guaranteed to be such that; /// removing any single element would falsify the predicate.; ///; /// For best results the predicate function *should* (but need not) satisfy; /// certain properties, in particular:; /// (1) The predicate should return false on an empty set and true on the full; /// set.; /// (2) If the predicate returns true for a set of changes, it should return; /// true for all supersets of that set.; ///; /// It is not an error to provide a predicate that does not satisfy these; /// requirements, and the algorithm will generally produce reasonable; /// results. However, it may run substantially more tests than with a good; /// predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:974,Testability,test,tests,974,"/// DeltaAlgorithm - Implements the delta debugging algorithm (A. Zeller '99); /// for minimizing arbitrary sets using a predicate function.; ///; /// The result of the algorithm is a subset of the input change set which is; /// guaranteed to satisfy the predicate, assuming that the input set did. For; /// well formed predicates, the result set is guaranteed to be such that; /// removing any single element would falsify the predicate.; ///; /// For best results the predicate function *should* (but need not) satisfy; /// certain properties, in particular:; /// (1) The predicate should return false on an empty set and true on the full; /// set.; /// (2) If the predicate returns true for a set of changes, it should return; /// true for all supersets of that set.; ///; /// It is not an error to provide a predicate that does not satisfy these; /// requirements, and the algorithm will generally produce reasonable; /// results. However, it may run substantially more tests than with a good; /// predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:96,Energy Efficiency,reduce,reduce,96,/// Cache of failed test results. Successful test results are never cached; /// since we always reduce following a success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:4,Performance,Cache,Cache,4,/// Cache of failed test results. Successful test results are never cached; /// since we always reduce following a success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:68,Performance,cache,cached,68,/// Cache of failed test results. Successful test results are never cached; /// since we always reduce following a success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:20,Testability,test,test,20,/// Cache of failed test results. Successful test results are never cached; /// since we always reduce following a success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:45,Testability,test,test,45,/// Cache of failed test results. Successful test results are never cached; /// since we always reduce following a success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:73,Performance,cache,cache,73,"/// GetTestResult - Get the test result for the \p Changes from the; /// cache, executing the test if necessary.; ///; /// \param Changes - The change set to test.; /// \return - The test result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:28,Testability,test,test,28,"/// GetTestResult - Get the test result for the \p Changes from the; /// cache, executing the test if necessary.; ///; /// \param Changes - The change set to test.; /// \return - The test result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:94,Testability,test,test,94,"/// GetTestResult - Get the test result for the \p Changes from the; /// cache, executing the test if necessary.; ///; /// \param Changes - The change set to test.; /// \return - The test result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:158,Testability,test,test,158,"/// GetTestResult - Get the test result for the \p Changes from the; /// cache, executing the test if necessary.; ///; /// \param Changes - The change set to test.; /// \return - The test result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:183,Testability,test,test,183,"/// GetTestResult - Get the test result for the \p Changes from the; /// cache, executing the test if necessary.; ///; /// \param Changes - The change set to test.; /// \return - The test result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:4,Deployability,Update,UpdatedSearchState,4,/// UpdatedSearchState - Callback used when the search state changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:38,Testability,test,test,38,/// ExecuteOneTest - Execute a single test predicate on the change set \p S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:162,Testability,test,test,162,/// Run - Minimize the set \p Changes by executing \see ExecuteOneTest() on; /// subsets of changes and returning the smallest set which still satisfies; /// the test predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:42,Security,hash,hash,42,"//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the DenseMap class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:6,Modifiability,extend,extend,6,// We extend a pair to allow users to override the bucket type with their own; // implementation without requiring two members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:26,Safety,avoid,avoid,26,"// When the map is empty, avoid the overhead of advancing/retreating past; // empty buckets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:9,Usability,simpl,simpler,9,// Use a simpler loop when values don't need destruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:52,Safety,abort,abort,52,"/// at - Return the entry for the specified key, or abort if no such; /// entry exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:143,Deployability,update,update,143,"// Inserts key,value pair into the map if the key isn't already in the map.; // If the key is already in the map, it returns false and doesn't update the; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:143,Deployability,update,update,143,"// Inserts key,value pair into the map if the key isn't already in the map.; // If the key is already in the map, it returns false and doesn't update the; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:37,Energy Efficiency,allocate,allocate,37,/// Returns the number of buckets to allocate to ensure that the DenseMap can; /// accommodate \p NumEntries without need to grow().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:10,Performance,load,load,10,"// If the load of the hash table is more than 3/4, or if fewer than 1/8 of; // the buckets are empty (meaning that many are filled with tombstones),; // grow the table.; //; // The later case is tricky. For example, if we had one empty bucket with; // tons of tombstones, failing lookups (e.g. for insertion) would have to; // probe almost the entire table until it found the empty bucket. If the; // table completely filled with tombstones, no lookup would ever succeed,; // causing infinite loops in lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:22,Security,hash,hash,22,"// If the load of the hash table is more than 3/4, or if fewer than 1/8 of; // the buckets are empty (meaning that many are filled with tombstones),; // grow the table.; //; // The later case is tricky. For example, if we had one empty bucket with; // tons of tombstones, failing lookups (e.g. for insertion) would have to; // probe almost the entire table until it found the empty bucket. If the; // table completely filled with tombstones, no lookup would ever succeed,; // causing infinite loops in lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:8,Deployability,update,update,8,// Only update the state after we've grown our bucket space appropriately; // so that when growing buckets we have self-consistent entry count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:61,Security,hash,hash,61,"// Remember the first tombstone found.; // Otherwise, it's a hash collision or a tombstone, continue quadratic; // probing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:318,Security,hash,hash,318,"/// Equality comparison for DenseMap.; ///; /// Iterates over elements of LHS confirming that each (key, value) pair in LHS; /// is also in RHS, and that no additional pairs are in RHS.; /// Equivalent to N calls to RHS.find and N value comparisons. Amortized; /// complexity is linear, worst case is O(N^2) (if every hash collides).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:98,Performance,perform,performance,98,/// Inequality comparison for DenseMap.; ///; /// Equivalent to !(LHS == RHS). See operator== for performance notes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:28,Integrability,depend,dependent,28,// Lift some types from the dependent base class into this class for; // simplicity of referring to them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:73,Usability,simpl,simplicity,73,// Lift some types from the dependent base class into this class for; // simplicity of referring to them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the number of buckets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:28,Integrability,depend,dependent,28,// Lift some types from the dependent base class into this class for; // simplicity of referring to them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:73,Usability,simpl,simplicity,73,// Lift some types from the dependent base class into this class for; // simplicity of referring to them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:241,Security,hash,hash,241,"// This is similar to the standard move-from-old-buckets, but the bucket; // count hasn't actually rotated in this case. So we have to carefully; // move construct the keys and values into their new locations, but there; // is no need to re-hash things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:3,Energy Efficiency,Reduce,Reduce,3,// Reduce the number of buckets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:61,Testability,assert,assert,61,"// Note that this cast does not violate aliasing rules as we assert that; // the memory's dynamic type is the small, inline bucket buffer, and the; // 'storage' is a POD containing a char buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h:37,Security,hash,hash,37,/// Simplistic combination of 32-bit hash values into 32-bit hash values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h:61,Security,hash,hash,61,/// Simplistic combination of 32-bit hash values into 32-bit hash values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h:4,Usability,Simpl,Simplistic,4,/// Simplistic combination of 32-bit hash values into 32-bit hash values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h:132,Safety,avoid,avoid,132,"// Provide DenseMapInfo for all pointers. Come up with sentinel pointer values; // that are aligned to alignof(T) bytes, but try to avoid requiring T to be; // complete. This allows clients to instantiate DenseMap<T*, ...> with forward; // declared key types. Assume that no pointer key type requires more than 4096; // bytes of alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h:3,Security,Expose,Expose,3,// Expose an additional function intended to be used by other; // specializations of DenseMapInfo without needing to know how; // to combine hash values manually,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h:141,Security,hash,hash,141,// Expose an additional function intended to be used by other; // specializations of DenseMapInfo without needing to know how; // to combine hash values manually,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfoVariant.h:20,Security,hash,hash,20,// Include index in hash to make sure same value as different; // alternatives don't collide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfoVariant.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfoVariant.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h:42,Security,hash,hash,42,"//===- llvm/ADT/DenseSet.h - Dense probed hash table ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the DenseSet and SmallDenseSet classes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h:290,Security,hash,hash,290,"/// Equality comparison for DenseSet.; ///; /// Iterates over elements of LHS confirming that each element is also a member; /// of RHS, and that RHS contains no additional values.; /// Equivalent to N calls to RHS.count. Amortized complexity is linear, worst; /// case is O(N^2) (if every hash collides).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h:98,Performance,perform,performance,98,/// Inequality comparison for DenseSet.; ///; /// Equivalent to !(LHS == RHS). See operator== for performance notes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h:55,Security,hash,hash-table,55,// end namespace detail; /// Implements a dense probed hash-table based set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h:30,Security,hash,hash-table,30,/// Implements a dense probed hash-table based set with some number of buckets; /// stored inline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:987,Energy Efficiency,efficient,efficient,987,"//===- llvm/ADT/DepthFirstIterator.h - Depth First iterator -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file builds on the ADT/GraphTraits.h file to build generic depth; /// first graph iterator. This file exposes the following functions/types:; ///; /// df_begin/df_end/df_iterator; /// * Normal depth-first iteration - visit a node and then all of its; /// children.; ///; /// idf_begin/idf_end/idf_iterator; /// * Depth-first iteration on the 'inverse' graph.; ///; /// df_ext_begin/df_ext_end/df_ext_iterator; /// * Normal depth-first iteration - visit a node and then all of its; /// children. This iterator stores the 'visited' set in an external set,; /// which allows it to be more efficient, and allows external clients to; /// use the set for other purposes.; ///; /// idf_ext_begin/idf_ext_end/idf_ext_iterator; /// * Depth-first iteration on the 'inverse' graph.; /// This iterator stores the 'visited' set in an external set, which; /// allows it to be more efficient, and allows external clients to use; /// the set for other purposes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:1268,Energy Efficiency,efficient,efficient,1268,"//===- llvm/ADT/DepthFirstIterator.h - Depth First iterator -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file builds on the ADT/GraphTraits.h file to build generic depth; /// first graph iterator. This file exposes the following functions/types:; ///; /// df_begin/df_end/df_iterator; /// * Normal depth-first iteration - visit a node and then all of its; /// children.; ///; /// idf_begin/idf_end/idf_iterator; /// * Depth-first iteration on the 'inverse' graph.; ///; /// df_ext_begin/df_ext_end/df_ext_iterator; /// * Normal depth-first iteration - visit a node and then all of its; /// children. This iterator stores the 'visited' set in an external set,; /// which allows it to be more efficient, and allows external clients to; /// use the set for other purposes.; ///; /// idf_ext_begin/idf_ext_end/idf_ext_iterator; /// * Depth-first iteration on the 'inverse' graph.; /// This iterator stores the 'visited' set in an external set, which; /// allows it to be more efficient, and allows external clients to use; /// the set for other purposes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:503,Security,expose,exposes,503,"//===- llvm/ADT/DepthFirstIterator.h - Depth First iterator -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file builds on the ADT/GraphTraits.h file to build generic depth; /// first graph iterator. This file exposes the following functions/types:; ///; /// df_begin/df_end/df_iterator; /// * Normal depth-first iteration - visit a node and then all of its; /// children.; ///; /// idf_begin/idf_end/idf_iterator; /// * Depth-first iteration on the 'inverse' graph.; ///; /// df_ext_begin/df_ext_end/df_ext_iterator; /// * Normal depth-first iteration - visit a node and then all of its; /// children. This iterator stores the 'visited' set in an external set,; /// which allows it to be more efficient, and allows external clients to; /// use the set for other purposes.; ///; /// idf_ext_begin/idf_ext_end/idf_ext_iterator; /// * Depth-first iteration on the 'inverse' graph.; /// This iterator stores the 'visited' set in an external set, which; /// allows it to be more efficient, and allows external clients to use; /// the set for other purposes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:45,Usability,simpl,simple,45,"// The visited stated for the iteration is a simple set augmented with; // one more method, completed, which is invoked when all children of a; // node have been processed. It is intended to distinguish of back and; // cross edges in the spanning tree but is not used in the common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:96,Deployability,update,updated,96,"// Notice that we directly mutate *Opt here, so that; // VisitStack.back().second actually gets updated as the iterator; // increases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:198,Safety,risk,risk,198,"/// Skips all children of the current node and traverses to next node; ///; /// Note: This function takes care of incrementing the iterator. If you; /// always increment and call this function, you risk walking off the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:14,Security,access,accessor,14,// Provide an accessor method to use them in range-based patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:14,Security,access,accessor,14,// Provide an accessor method to use them in range-based patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h:418,Integrability,interface,interface,418,"//===- llvm/ADT/DirectedGraph.h - Directed Graph ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interface and a base class implementation for a; /// directed graph.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h:11,Modifiability,polymorphi,polymorphism,11,/// Static polymorphism: delegate implementation (via isEqualTo) to the; /// derived class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h:11,Modifiability,polymorphi,polymorphism,11,/// Static polymorphism: delegate implementation (via isEqualTo) to the; /// derived class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h:4,Testability,Test,Test,4,/// Test whether there is an edge that goes from this node to \p N.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h:4,Usability,Clear,Clear,4,/// Clear the outgoing edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DirectedGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/edit_distance.h:551,Integrability,rout,routine,551,"/// Determine the edit distance between two sequences.; ///; /// \param FromArray the first sequence to compare.; ///; /// \param ToArray the second sequence to compare.; ///; /// \param Map A Functor to apply to each item of the sequences before; /// comparison.; ///; /// \param AllowReplacements whether to allow element replacements (change one; /// element into another) as a single operation, rather than as two operations; /// (an insertion and a removal).; ///; /// \param MaxEditDistance If non-zero, the maximum edit distance that this; /// routine is allowed to compute. If the edit distance will exceed that; /// maximum, returns \c MaxEditDistance+1.; ///; /// \returns the minimum number of element insertions, removals, or (if; /// \p AllowReplacements is \c true) replacements needed to transform one of; /// the given sequences into the other. If zero, the sequences are identical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/edit_distance.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/edit_distance.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/edit_distance.h:408,Deployability,update,update,408,"// The algorithm implemented below is the ""classic""; // dynamic-programming algorithm for computing the Levenshtein; // distance, which is described here:; //; // http://en.wikipedia.org/wiki/Levenshtein_distance; //; // Although the algorithm is typically described using an m x n; // array, only one row plus one element are used at a time, so this; // implementation just keeps one vector for the row. To update one entry,; // only the entries to the left, top, and top-left are needed. The left; // entry is in Row[x-1], the top entry is what's in Row[x] from the last; // iteration, and the top-left entry is stored in Previous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/edit_distance.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/edit_distance.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h:563,Testability,assert,asserts,563,"//===- llvm/ADT/EpochTracker.h - ADT epoch tracking --------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the DebugEpochBase and DebugEpochBase::HandleBase classes.; /// These can be used to write iterators that are fail-fast when LLVM is built; /// with asserts enabled.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h:306,Integrability,rout,routines,306,"/// A base class for data structure classes wishing to make iterators; /// (""handles"") pointing into themselves fail-fast. When building without; /// asserts, this class is empty and does nothing.; ///; /// DebugEpochBase does not by itself track handles pointing into itself. The; /// expectation is that routines touching the handles will poll on; /// isHandleInSync at appropriate points to assert that the handle they're using; /// is still valid.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h:150,Testability,assert,asserts,150,"/// A base class for data structure classes wishing to make iterators; /// (""handles"") pointing into themselves fail-fast. When building without; /// asserts, this class is empty and does nothing.; ///; /// DebugEpochBase does not by itself track handles pointing into itself. The; /// expectation is that routines touching the handles will poll on; /// isHandleInSync at appropriate points to assert that the handle they're using; /// is still valid.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h:394,Testability,assert,assert,394,"/// A base class for data structure classes wishing to make iterators; /// (""handles"") pointing into themselves fail-fast. When building without; /// asserts, this class is empty and does nothing.; ///; /// DebugEpochBase does not by itself track handles pointing into itself. The; /// expectation is that routines touching the handles will poll on; /// isHandleInSync at appropriate points to assert that the handle they're using; /// is still valid.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h:319,Integrability,rout,routines,319,"/// A base class for iterator classes (""handles"") that wish to poll for; /// iterator invalidating modifications in the underlying data structure.; /// When LLVM is built without asserts, this class is empty and does nothing.; ///; /// HandleBase does not track the parent data structure by itself. It expects; /// the routines modifying the data structure to call incrementEpoch when they; /// make an iterator-invalidating modification.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h:179,Testability,assert,asserts,179,"/// A base class for iterator classes (""handles"") that wish to poll for; /// iterator invalidating modifications in the underlying data structure.; /// When LLVM is built without asserts, this class is empty and does nothing.; ///; /// HandleBase does not track the parent data structure by itself. It expects; /// the routines modifying the data structure to call incrementEpoch when they; /// make an iterator-invalidating modification.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EpochTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:472,Energy Efficiency,efficient,efficient,472,"//===- llvm/ADT/EquivalenceClasses.h - Generic Equiv. Classes ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Generic implementation of equivalence classes through the use Tarjan's; /// efficient union-find algorithm.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:101,Energy Efficiency,efficient,efficient,101,"/// EquivalenceClasses - This represents a collection of equivalence classes and; /// supports three efficient operations: insert an element into a class of its; /// own, union two classes, and find the class for a given element. In; /// addition to these modification methods, it is possible to iterate over all; /// of the equivalence classes and all of the elements in a class.; ///; /// This implementation is an efficient implementation that only stores one copy; /// of the element being indexed per entry in the set, and allows any arbitrary; /// type to be indexed (as long as it can be ordered with operator< or a; /// comparator is provided).; ///; /// Here is a simple example using integers:; ///; /// \code; /// EquivalenceClasses<int> EC;; /// EC.unionSets(1, 2); // insert 1, 2 into the same set; /// EC.insert(4); EC.insert(5); // insert 4, 5 into own sets; /// EC.unionSets(5, 1); // merge the set for 1 with 5's set.; ///; /// for (EquivalenceClasses<int>::iterator I = EC.begin(), E = EC.end();; /// I != E; ++I) { // Iterate over all of the equivalence sets.; /// if (!I->isLeader()) continue; // Ignore non-leader sets.; /// for (EquivalenceClasses<int>::member_iterator MI = EC.member_begin(I);; /// MI != EC.member_end(); ++MI) // Loop over members in this set.; /// cerr << *MI << "" ""; // Print member.; /// cerr << ""\n""; // Finish set.; /// }; /// \endcode; ///; /// This example prints:; /// 4; /// 5 1 2; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:417,Energy Efficiency,efficient,efficient,417,"/// EquivalenceClasses - This represents a collection of equivalence classes and; /// supports three efficient operations: insert an element into a class of its; /// own, union two classes, and find the class for a given element. In; /// addition to these modification methods, it is possible to iterate over all; /// of the equivalence classes and all of the elements in a class.; ///; /// This implementation is an efficient implementation that only stores one copy; /// of the element being indexed per entry in the set, and allows any arbitrary; /// type to be indexed (as long as it can be ordered with operator< or a; /// comparator is provided).; ///; /// Here is a simple example using integers:; ///; /// \code; /// EquivalenceClasses<int> EC;; /// EC.unionSets(1, 2); // insert 1, 2 into the same set; /// EC.insert(4); EC.insert(5); // insert 4, 5 into own sets; /// EC.unionSets(5, 1); // merge the set for 1 with 5's set.; ///; /// for (EquivalenceClasses<int>::iterator I = EC.begin(), E = EC.end();; /// I != E; ++I) { // Iterate over all of the equivalence sets.; /// if (!I->isLeader()) continue; // Ignore non-leader sets.; /// for (EquivalenceClasses<int>::member_iterator MI = EC.member_begin(I);; /// MI != EC.member_end(); ++MI) // Loop over members in this set.; /// cerr << *MI << "" ""; // Print member.; /// cerr << ""\n""; // Finish set.; /// }; /// \endcode; ///; /// This example prints:; /// 4; /// 5 1 2; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:673,Usability,simpl,simple,673,"/// EquivalenceClasses - This represents a collection of equivalence classes and; /// supports three efficient operations: insert an element into a class of its; /// own, union two classes, and find the class for a given element. In; /// addition to these modification methods, it is possible to iterate over all; /// of the equivalence classes and all of the elements in a class.; ///; /// This implementation is an efficient implementation that only stores one copy; /// of the element being indexed per entry in the set, and allows any arbitrary; /// type to be indexed (as long as it can be ordered with operator< or a; /// comparator is provided).; ///; /// Here is a simple example using integers:; ///; /// \code; /// EquivalenceClasses<int> EC;; /// EC.unionSets(1, 2); // insert 1, 2 into the same set; /// EC.insert(4); EC.insert(5); // insert 4, 5 into own sets; /// EC.unionSets(5, 1); // merge the set for 1 with 5's set.; ///; /// for (EquivalenceClasses<int>::iterator I = EC.begin(), E = EC.end();; /// I != E; ++I) { // Iterate over all of the equivalence sets.; /// if (!I->isLeader()) continue; // Ignore non-leader sets.; /// for (EquivalenceClasses<int>::member_iterator MI = EC.member_begin(I);; /// MI != EC.member_end(); ++MI) // Loop over members in this set.; /// cerr << *MI << "" ""; // Print member.; /// cerr << ""\n""; // Finish set.; /// }; /// \endcode; ///; /// This example prints:; /// 4; /// 5 1 2; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:408,Integrability,depend,depending,408,"/// ECValue - The EquivalenceClasses data structure is just a set of these.; /// Each of these represents a relation for a value. First it stores the; /// value itself, which provides the ordering that the set queries. Next, it; /// provides a ""next pointer"", which is used to enumerate all of the elements; /// in the unioned set. Finally, it defines either a ""end of list pointer"" or; /// ""leader pointer"" depending on whether the value itself is a leader. A; /// ""leader pointer"" points to the node that is the leader for this element,; /// if the node is not a leader. A ""end of list pointer"" points to the last; /// node in the list of members of this list. Whether or not a node is a; /// leader is determined by a bit stolen from one of the pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:6,Integrability,wrap,wrapper,6,"/// A wrapper of the comparator, to be passed to the set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:97,Availability,error,error,97,"/// getLeaderValue - Return the leader for the specified value that is in the; /// set. It is an error to call this method for a value that is not yet in; /// the set. For that, call getOrInsertLeaderValue(V).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:3,Deployability,Update,Update,3,// Update L1LV's end of list pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:3,Usability,Clear,Clear,3,// Clear L2's leader flag:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:31,Integrability,Wrap,Wrapper,31,"//===--- fallible_iterator.h - Wrapper for fallible iterators ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:245,Availability,Error,Error,245,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:263,Availability,Error,Error,263,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:585,Availability,Error,Error,585,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:665,Availability,Error,Error,665,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:981,Availability,Error,Error,981,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1120,Availability,Error,Error,1120,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1253,Availability,Error,Error,1253,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1265,Availability,Error,Error,1265,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1416,Availability,error,error,1416,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1494,Availability,Error,Error,1494,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1736,Availability,error,error,1736,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1787,Availability,Error,Error,1787,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1872,Availability,redundant,redundant,1872,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1882,Availability,error,error,1882,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:6,Integrability,wrap,wrapper,6,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:85,Integrability,wrap,wraps,85,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:315,Integrability,interface,interface,315,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:466,Integrability,wrap,wrapper,466,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1465,Integrability,wrap,wrapper,1465,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1872,Safety,redund,redundant,1872,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1571,Usability,clear,clears,1571,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:250,Availability,error,error,250,"/// Construct a fallible iterator that *cannot* be used as an end-of-range; /// value.; ///; /// A value created by this method can be dereferenced, incremented,; /// decremented and compared, providing the underlying type supports it.; ///; /// The error that is passed in will be initially marked as checked, so if the; /// iterator is not used at all the Error need not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:358,Availability,Error,Error,358,"/// Construct a fallible iterator that *cannot* be used as an end-of-range; /// value.; ///; /// A value created by this method can be dereferenced, incremented,; /// decremented and compared, providing the underlying type supports it.; ///; /// The error that is passed in will be initially marked as checked, so if the; /// iterator is not used at all the Error need not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:106,Availability,Error,Error,106,"/// Increment the fallible iterator.; ///; /// If the underlying 'inc' operation fails, this will set the Error value; /// and update this iterator value to point to end-of-range.; ///; /// The Error value is marked as needing checking, regardless of whether the; /// 'inc' operation succeeds or fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:194,Availability,Error,Error,194,"/// Increment the fallible iterator.; ///; /// If the underlying 'inc' operation fails, this will set the Error value; /// and update this iterator value to point to end-of-range.; ///; /// The Error value is marked as needing checking, regardless of whether the; /// 'inc' operation succeeds or fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:127,Deployability,update,update,127,"/// Increment the fallible iterator.; ///; /// If the underlying 'inc' operation fails, this will set the Error value; /// and update this iterator value to point to end-of-range.; ///; /// The Error value is marked as needing checking, regardless of whether the; /// 'inc' operation succeeds or fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:106,Availability,Error,Error,106,"/// Decrement the fallible iterator.; ///; /// If the underlying 'dec' operation fails, this will set the Error value; /// and update this iterator value to point to end-of-range.; ///; /// The Error value is marked as needing checking, regardless of whether the; /// 'dec' operation succeeds or fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:194,Availability,Error,Error,194,"/// Decrement the fallible iterator.; ///; /// If the underlying 'dec' operation fails, this will set the Error value; /// and update this iterator value to point to end-of-range.; ///; /// The Error value is marked as needing checking, regardless of whether the; /// 'dec' operation succeeds or fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:127,Deployability,update,update,127,"/// Decrement the fallible iterator.; ///; /// If the underlying 'dec' operation fails, this will set the Error value; /// and update this iterator value to point to end-of-range.; ///; /// The Error value is marked as needing checking, regardless of whether the; /// 'dec' operation succeeds or fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:319,Availability,Error,Error,319,"/// Compare fallible iterators for equality.; ///; /// Returns true if both LHS and RHS are end-of-range values, or if both are; /// non-end-of-range values whose underlying iterator values compare equal.; ///; /// If this is a comparison between an end-of-range iterator and a; /// non-end-of-range iterator, then the Error (referenced by the; /// non-end-of-range value) is marked as checked: Since all; /// increment/decrement operations result in an end-of-range value, comparing; /// false against end-of-range is equivalent to checking that the Error value; /// is success. This flag management enables early returns from loop bodies; /// without redundant Error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:551,Availability,Error,Error,551,"/// Compare fallible iterators for equality.; ///; /// Returns true if both LHS and RHS are end-of-range values, or if both are; /// non-end-of-range values whose underlying iterator values compare equal.; ///; /// If this is a comparison between an end-of-range iterator and a; /// non-end-of-range iterator, then the Error (referenced by the; /// non-end-of-range value) is marked as checked: Since all; /// increment/decrement operations result in an end-of-range value, comparing; /// false against end-of-range is equivalent to checking that the Error value; /// is success. This flag management enables early returns from loop bodies; /// without redundant Error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:653,Availability,redundant,redundant,653,"/// Compare fallible iterators for equality.; ///; /// Returns true if both LHS and RHS are end-of-range values, or if both are; /// non-end-of-range values whose underlying iterator values compare equal.; ///; /// If this is a comparison between an end-of-range iterator and a; /// non-end-of-range iterator, then the Error (referenced by the; /// non-end-of-range value) is marked as checked: Since all; /// increment/decrement operations result in an end-of-range value, comparing; /// false against end-of-range is equivalent to checking that the Error value; /// is success. This flag management enables early returns from loop bodies; /// without redundant Error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:663,Availability,Error,Error,663,"/// Compare fallible iterators for equality.; ///; /// Returns true if both LHS and RHS are end-of-range values, or if both are; /// non-end-of-range values whose underlying iterator values compare equal.; ///; /// If this is a comparison between an end-of-range iterator and a; /// non-end-of-range iterator, then the Error (referenced by the; /// non-end-of-range value) is marked as checked: Since all; /// increment/decrement operations result in an end-of-range value, comparing; /// false against end-of-range is equivalent to checking that the Error value; /// is success. This flag management enables early returns from loop bodies; /// without redundant Error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:653,Safety,redund,redundant,653,"/// Compare fallible iterators for equality.; ///; /// Returns true if both LHS and RHS are end-of-range values, or if both are; /// non-end-of-range values whose underlying iterator values compare equal.; ///; /// If this is a comparison between an end-of-range iterator and a; /// non-end-of-range iterator, then the Error (referenced by the; /// non-end-of-range value) is marked as checked: Since all; /// increment/decrement operations result in an end-of-range value, comparing; /// false against end-of-range is equivalent to checking that the Error value; /// is success. This flag management enables early returns from loop bodies; /// without redundant Error checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:82,Availability,Error,Error,82,// If the iterators differ and this is a comparison against end then mark; // the Error as checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:113,Availability,Error,Error,113,/// Convenience wrapper to make a fallible_iterator value from an instance; /// of an underlying iterator and an Error reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:16,Integrability,wrap,wrapper,16,/// Convenience wrapper to make a fallible_iterator value from an instance; /// of an underlying iterator and an Error reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:16,Integrability,wrap,wrapper,16,/// Convenience wrapper to make a fallible_iterator end value from an instance; /// of an underlying iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:580,Availability,error,errors,580,"/// Rounding mode.; ///; /// Enumerates supported rounding modes, as well as some special values. The set; /// of the modes must agree with IEEE-754, 4.3.1 and 4.3.2. The constants; /// assigned to the IEEE rounding modes must agree with the values used by; /// FLT_ROUNDS (C11, 5.2.4.2.2p8).; ///; /// This value is packed into bitfield in some cases, including \c FPOptions, so; /// the rounding mode values and the special value \c Dynamic must fit into the; /// the bit field (now - 3 bits). The value \c Invalid is used only in values; /// returned by intrinsics to indicate errors, it should never be stored as; /// rounding mode value, so it does not need to fit the bit fields.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:25,Testability,test,tests,25,"/// Floating-point class tests, supported by 'is_fpclass' intrinsic. Actual; /// test may be an OR combination of basic tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:81,Testability,test,test,81,"/// Floating-point class tests, supported by 'is_fpclass' intrinsic. Actual; /// test may be an OR combination of basic tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:120,Testability,test,tests,120,"/// Floating-point class tests, supported by 'is_fpclass' intrinsic. Actual; /// test may be an OR combination of basic tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:20,Availability,mask,mask,20,/// Return the test mask which returns true if the value's sign bit is flipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:15,Testability,test,test,15,/// Return the test mask which returns true if the value's sign bit is flipped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:20,Availability,mask,mask,20,/// Return the test mask which returns true after fabs is applied to the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:15,Testability,test,test,15,/// Return the test mask which returns true after fabs is applied to the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:20,Availability,mask,mask,20,"/// Return the test mask which returns true if the value could have the same set; /// of classes, but with a different sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:15,Testability,test,test,15,"/// Return the test mask which returns true if the value could have the same set; /// of classes, but with a different sign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h:38,Availability,Mask,Mask,38,/// Write a human readable form of \p Mask to \p OS,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:40,Security,Hash,Hash,40,"//===- llvm/ADT/FoldingSet.h - Uniquing Hash Set ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines a hash set that can be used to remove duplication of nodes; /// in a graph. This code was originally created by Chris Lattner for use with; /// SelectionDAGCSEMap, but was isolated to provide use across the llvm code; /// set.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:416,Security,hash,hash,416,"//===- llvm/ADT/FoldingSet.h - Uniquing Hash Set ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines a hash set that can be used to remove duplication of nodes; /// in a graph. This code was originally created by Chris Lattner for use with; /// SelectionDAGCSEMap, but was isolated to provide use across the llvm code; /// set.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:1575,Availability,avail,available,1575,"a subclass of; /// FoldingSetNode. The node class must also define a Profile method used to; /// establish the unique bits of data for the node. The Profile method is; /// passed a FoldingSetNodeID object which is used to gather the bits. Just; /// call one of the Add* functions defined in the FoldingSetBase::NodeID class.; /// NOTE: That the folding set does not own the nodes and it is the; /// responsibility of the user to dispose of the nodes.; ///; /// Eg.; /// class MyNode : public FoldingSetNode {; /// private:; /// std::string Name;; /// unsigned Value;; /// public:; /// MyNode(const char *N, unsigned V) : Name(N), Value(V) {}; /// ...; /// void Profile(FoldingSetNodeID &ID) const {; /// ID.AddString(Name);; /// ID.AddInteger(Value);; /// }; /// ...; /// };; ///; /// To define the folding set itself use the FoldingSet template;; ///; /// Eg.; /// FoldingSet<MyNode> MyFoldingSet;; ///; /// Four public methods are available to manipulate the folding set;; ///; /// 1) If you have an existing node that you want add to the set but unsure; /// that the node might already exist then call;; ///; /// MyNode *M = MyFoldingSet.GetOrInsertNode(N);; ///; /// If The result is equal to the input then the node has been inserted.; /// Otherwise, the result is the node existing in the folding set, and the; /// input can be discarded (use the result instead.); ///; /// 2) If you are ready to construct a node but want to check if it already; /// exists, then call FindNodeOrInsertPos with a FoldingSetNodeID of the bits to; /// check;; ///; /// FoldingSetNodeID ID;; /// ID.AddString(Name);; /// ID.AddInteger(Value);; /// void *InsertPoint;; ///; /// MyNode *M = MyFoldingSet.FindNodeOrInsertPos(ID, InsertPoint);; ///; /// If found then M will be non-NULL, else InsertPoint will point to where it; /// should be inserted using InsertNode.; ///; /// 3) If you get a NULL result from FindNodeOrInsertPos then you can insert a; /// new node with InsertNode;; ///; /// MyFoldingSet.InsertNode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:396,Security,hash,hash,396,"/// This folding set used for two purposes:; /// 1. Given information about a node we want to create, look up the unique; /// instance of the node in the set. If the node already exists, return; /// it, otherwise return the bucket it should be inserted into.; /// 2. Given a node that has already been created, remove it from the set.; ///; /// This class is implemented as a single-link chained hash table, where the; /// ""buckets"" are actually the nodes themselves (the next pointer is in the; /// node). The last node points back to the bucket to simplify node removal.; ///; /// Any node that is to be included in the folding set must be a subclass of; /// FoldingSetNode. The node class must also define a Profile method used to; /// establish the unique bits of data for the node. The Profile method is; /// passed a FoldingSetNodeID object which is used to gather the bits. Just; /// call one of the Add* functions defined in the FoldingSetBase::NodeID class.; /// NOTE: That the folding set does not own the nodes and it is the; /// responsibility of the user to dispose of the nodes.; ///; /// Eg.; /// class MyNode : public FoldingSetNode {; /// private:; /// std::string Name;; /// unsigned Value;; /// public:; /// MyNode(const char *N, unsigned V) : Name(N), Value(V) {}; /// ...; /// void Profile(FoldingSetNodeID &ID) const {; /// ID.AddString(Name);; /// ID.AddInteger(Value);; /// }; /// ...; /// };; ///; /// To define the folding set itself use the FoldingSet template;; ///; /// Eg.; /// FoldingSet<MyNode> MyFoldingSet;; ///; /// Four public methods are available to manipulate the folding set;; ///; /// 1) If you have an existing node that you want add to the set but unsure; /// that the node might already exist then call;; ///; /// MyNode *M = MyFoldingSet.GetOrInsertNode(N);; ///; /// If The result is equal to the input then the node has been inserted.; /// Otherwise, the result is the node existing in the folding set, and the; /// input can be discarded (use the result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:550,Usability,simpl,simplify,550,"/// This folding set used for two purposes:; /// 1. Given information about a node we want to create, look up the unique; /// instance of the node in the set. If the node already exists, return; /// it, otherwise return the bucket it should be inserted into.; /// 2. Given a node that has already been created, remove it from the set.; ///; /// This class is implemented as a single-link chained hash table, where the; /// ""buckets"" are actually the nodes themselves (the next pointer is in the; /// node). The last node points back to the bucket to simplify node removal.; ///; /// Any node that is to be included in the folding set must be a subclass of; /// FoldingSetNode. The node class must also define a Profile method used to; /// establish the unique bits of data for the node. The Profile method is; /// passed a FoldingSetNodeID object which is used to gather the bits. Just; /// call one of the Add* functions defined in the FoldingSetBase::NodeID class.; /// NOTE: That the folding set does not own the nodes and it is the; /// responsibility of the user to dispose of the nodes.; ///; /// Eg.; /// class MyNode : public FoldingSetNode {; /// private:; /// std::string Name;; /// unsigned Value;; /// public:; /// MyNode(const char *N, unsigned V) : Name(N), Value(V) {}; /// ...; /// void Profile(FoldingSetNodeID &ID) const {; /// ID.AddString(Name);; /// ID.AddInteger(Value);; /// }; /// ...; /// };; ///; /// To define the folding set itself use the FoldingSet template;; ///; /// Eg.; /// FoldingSet<MyNode> MyFoldingSet;; ///; /// Four public methods are available to manipulate the folding set;; ///; /// 1) If you have an existing node that you want add to the set but unsure; /// that the node might already exist then call;; ///; /// MyNode *M = MyFoldingSet.GetOrInsertNode(N);; ///; /// If The result is equal to the input then the node has been inserted.; /// Otherwise, the result is the node existing in the folding set, and the; /// input can be discarded (use the result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:223,Security,hash,hash,223,//===----------------------------------------------------------------------===//; /// FoldingSetBase - Implements the folding set functionality. The main; /// structure is an array of buckets. Each bucket is indexed by the hash of; /// the nodes it contains. The bucket itself points to the nodes contained; /// in the bucket via a singly linked list. The last node in the list points; /// back to the bucket to facilitate node removal.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:55,Energy Efficiency,power,power,55,/// NumBuckets - Length of the Buckets array. Always a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:3,Security,Access,Accessors,3,// Accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:4,Usability,clear,clear,4,/// clear - Remove all nodes from the folding set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:108,Performance,perform,performed,108,/// capacity - Returns the number of nodes permitted in the folding set; /// before a rebucket operation is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:14,Performance,load,load,14,"// We allow a load factor of up to 2.0,; // so that means our capacity is NumBuckets * 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:106,Security,hash,hash,106,/// ComputeNodeHash - Instantiations of the FoldingSet template implement; /// this function to compute a hash value for the given node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:43,Security,hash,hash,43,/// GrowHashTable - Double the size of the hash table and rehash everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:97,Energy Efficiency,power,power,97,"/// GrowBucketCount - resize the hash table and rehash everything.; /// NewBucketCount must be a power of two, and must be greater than the old; /// bucket count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:33,Security,hash,hash,33,"/// GrowBucketCount - resize the hash table and rehash everything.; /// NewBucketCount must be a power of two, and must be greater than the old; /// bucket count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:248,Energy Efficiency,allocate,allocate,248,// The below methods are protected to encourage subclasses to provide a more; // type-safe API.; /// reserve - Increase the number of buckets such that adding the; /// EltCount-th node won't cause a rebucket operation. reserve is permitted; /// to allocate more space than requested by EltCount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:86,Safety,safe,safe,86,// The below methods are protected to encourage subclasses to provide a more; // type-safe API.; /// reserve - Increase the number of buckets such that adding the; /// EltCount-th node won't cause a rebucket operation. reserve is permitted; /// to allocate more space than requested by EltCount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:46,Usability,simpl,simple,46,"/// GetOrInsertNode - If there is an existing simple Node exactly; /// equal to the specified node, return it. Otherwise, insert 'N' and return; /// it instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:246,Energy Efficiency,efficient,efficient,246,"// Equals - Test if the profile for X would match ID, using TempID; // to compute a temporary ID if necessary. The default implementation; // just calls Profile and does a regular comparison. Implementations; // can override this to provide more efficient implementations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:12,Testability,Test,Test,12,"// Equals - Test if the profile for X would match ID, using TempID; // to compute a temporary ID if necessary. The default implementation; // just calls Profile and does a regular comparison. Implementations; // can override this to provide more efficient implementations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:243,Energy Efficiency,efficient,efficient,243,"// ComputeHash - Compute a hash value for X, using TempID to; // compute a temporary ID if necessary. The default implementation; // just calls Profile and does a regular hash computation.; // Implementations can override this to provide more efficient; // implementations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:27,Security,hash,hash,27,"// ComputeHash - Compute a hash value for X, using TempID to; // compute a temporary ID if necessary. The default implementation; // just calls Profile and does a regular hash computation.; // Implementations can override this to provide more efficient; // implementations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:171,Security,hash,hash,171,"// ComputeHash - Compute a hash value for X, using TempID to; // compute a temporary ID if necessary. The default implementation; // just calls Profile and does a regular hash computation.; // Implementations can override this to provide more efficient; // implementations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:35,Security,hash,hash,35,"/// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,; /// used to lookup the node in the FoldingSetBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:241,Security,hash,hash,241,//===--------------------------------------------------------------------===//; /// FoldingSetNodeID - This class is used to gather all the unique data bits of; /// a node. When all the bits are gathered this class is used to produce a; /// hash value for the node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:92,Safety,avoid,avoid,92,/// Bits - Vector of all the data bits that make the node unique.; /// Use a SmallVector to avoid a heap allocation in the common case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:76,Integrability,depend,depend,76,"// Note: this adds pointers to the hash using sizes and endianness that; // depend on the host. It doesn't matter, however, because hashing on; // pointer values is inherently unstable. Nothing should depend on the; // ordering of nodes in the folding set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:201,Integrability,depend,depend,201,"// Note: this adds pointers to the hash using sizes and endianness that; // depend on the host. It doesn't matter, however, because hashing on; // pointer values is inherently unstable. Nothing should depend on the; // ordering of nodes in the folding set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:35,Security,hash,hash,35,"// Note: this adds pointers to the hash using sizes and endianness that; // depend on the host. It doesn't matter, however, because hashing on; // pointer values is inherently unstable. Nothing should depend on the; // ordering of nodes in the folding set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:132,Security,hash,hashing,132,"// Note: this adds pointers to the hash using sizes and endianness that; // depend on the host. It doesn't matter, however, because hashing on; // pointer values is inherently unstable. Nothing should depend on the; // ordering of nodes in the folding set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:4,Usability,clear,clear,4,"/// clear - Clear the accumulated profile, allowing this FoldingSetNodeID; /// object to be used to compute a new profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:12,Usability,Clear,Clear,12,"/// clear - Clear the accumulated profile, allowing this FoldingSetNodeID; /// object to be used to compute a new profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:35,Security,hash,hash,35,"/// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used; /// to lookup the node in the FoldingSetBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:54,Energy Efficiency,allocate,allocated,54,/// Intern - Copy this node's data to a memory region allocated from the; /// given allocator and return a FoldingSetNodeIDRef describing the; /// interned data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:151,Energy Efficiency,allocate,allocate,151,/// reserve - Increase the number of buckets such that adding the; /// EltCount-th node won't cause a rebucket operation. reserve is permitted; /// to allocate more space than requested by EltCount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:46,Usability,simpl,simple,46,"/// GetOrInsertNode - If there is an existing simple Node exactly; /// equal to the specified node, return it. Otherwise, insert 'N' and; /// return it instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:84,Security,hash,hash,84,/// ComputeNodeHash - Instantiations may optionally provide a way to compute a; /// hash value directly from a node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:180,Integrability,interface,interface,180,//===----------------------------------------------------------------------===//; /// FoldingSetVector - This template class combines a FoldingSet and a vector; /// to provide the interface of FoldingSet but with deterministic iteration; /// order based on the insertion order. T must be a subclass of FoldingSetNode; /// and implement a Profile function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:4,Usability,clear,clear,4,/// clear - Remove all nodes from the folding set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:46,Usability,simpl,simple,46,"/// GetOrInsertNode - If there is an existing simple Node exactly; /// equal to the specified node, return it. Otherwise, insert 'N' and; /// return it instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:220,Security,hash,hash,220,"//===----------------------------------------------------------------------===//; /// FoldingSetIteratorImpl - This is the common iterator support shared by all; /// folding sets, which knows how to walk the folding set hash table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:259,Security,hash,hash,259,"//===----------------------------------------------------------------------===//; /// FoldingSetBucketIteratorImpl - This is the common bucket iterator support; /// shared by all folding sets, which knows how to walk a particular bucket; /// of a folding set hash table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:142,Integrability,wrap,wrap,142,"//===----------------------------------------------------------------------===//; /// FoldingSetNodeWrapper - This template class is used to ""wrap"" arbitrary; /// types in an enclosing object so that they can be inserted into FoldingSets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:1172,Usability,simpl,simplified,1172,"//===- FunctionExtras.h - Function type erasure utilities -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides a collection of function (or more generally, callable); /// type erasure utilities supplementing those provided by the standard library; /// in `<function>`.; ///; /// It provides `unique_function`, which works like `std::function` but supports; /// move-only callable objects and const-qualification.; ///; /// Future plans:; /// - Add a `function` that provides ref-qualified support, which doesn't work; /// with `std::function`.; /// - Provide support for specifying multiple signatures to type erase callable; /// objects with an overload set, such as those produced by generic lambdas.; /// - Expand to include a copyable utility that directly replaces std::function; /// but brings the above improvements.; ///; /// Note that LLVM's utilities are greatly simplified by not supporting; /// allocators.; ///; /// If the standard library ever begins to provide comparable facilities we can; /// consider switching to those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:122,Availability,error,error,122,// This specialization ensures that 'AdjustedParam<V<T>&>' or; // 'AdjustedParam<V<T>&&>' does not trigger a compile-time error when 'T' is; // an incomplete type and V a templated type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:389,Integrability,Wrap,Wrap,389,"// The pointers to call/move/destroy functions are determined for each; // callable type (and called-as type, which determines the overload chosen).; // (definitions are out-of-line).; // By default, we need an object that contains all the different; // type erased behaviors needed. Create a static instance of the struct type; // here and each instance will contain a pointer to it.; // Wrap in a struct to avoid https://gcc.gnu.org/PR71954",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:409,Safety,avoid,avoid,409,"// The pointers to call/move/destroy functions are determined for each; // callable type (and called-as type, which determines the overload chosen).; // (definitions are out-of-line).; // By default, we need an object that contains all the different; // type erased behaviors needed. Create a static instance of the struct type; // here and each instance will contain a pointer to it.; // Wrap in a struct to avoid https://gcc.gnu.org/PR71954",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:5,Usability,simpl,simple,5,// A simple tag type so the call-as type to be passed to the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate out-of-line storage. FIXME: Use an explicit alignment; // parameter in C++17 mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:3,Performance,Cache,Cache,3,// Cache this value so we don't re-check it after type-erased operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:3,Usability,Clear,Clear,3,// Clear the old callback and inline flag to get back to as-if-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:49,Safety,safe,safety,49,// Because we don't try to provide any exception safety guarantees we can; // implement move assignment very simply by first destroying the current; // object and then move-constructing over top of it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:109,Usability,simpl,simply,109,// Because we don't try to provide any exception safety guarantees we can; // implement move assignment very simply by first destroying the current; // object and then move-constructing over top of it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericConvergenceVerifier.h:3,Performance,Cache,Cache,3,// Cache token uses found so far. Note that we track the unique definitions; // and not the token values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericConvergenceVerifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericConvergenceVerifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleImpl.h:481,Integrability,inject,injected,481,"//===- GenericCycleImpl.h -------------------------------------*- C++ -*---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This template implementation resides in a separate file so that it; /// does not get injected into every .cpp file that includes the; /// generic header.; ///; /// DO NOT INCLUDE THIS FILE WHEN MERELY USING CYCLEINFO.; ///; /// This file should only be included by files that implement a; /// specialization of the relevant templates. Currently these are:; /// - llvm/lib/IR/CycleInfo.cpp; /// - llvm/lib/CodeGen/MachineCycleAnalysis.cpp; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleImpl.h:481,Security,inject,injected,481,"//===- GenericCycleImpl.h -------------------------------------*- C++ -*---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This template implementation resides in a separate file so that it; /// does not get injected into every .cpp file that includes the; /// generic header.; ///; /// DO NOT INCLUDE THIS FILE WHEN MERELY USING CYCLEINFO.; ///; /// This file should only be included by files that implement a; /// specialization of the relevant templates. Currently these are:; /// - llvm/lib/IR/CycleInfo.cpp; /// - llvm/lib/CodeGen/MachineCycleAnalysis.cpp; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleImpl.h:11,Security,Validat,Validate,11,"/// \brief Validate the internal consistency of the cycle tree.; ///; /// Note that this does \em not check that cycles are really cycles in the CFG,; /// or that the right set of cycles in the CFG were found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h:734,Integrability,depend,depending,734,"//===- GenericCycleInfo.h - Info for Cycles in any IR ------*- C++ -*------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// \brief Find all cycles in a control-flow graph, including irreducible loops.; ///; /// See docs/CycleTerminology.rst for a formal definition of cycles.; ///; /// Briefly:; /// - A cycle is a generalization of a loop which can represent; /// irreducible control flow.; /// - Cycles identified in a program are implementation defined,; /// depending on the DFS traversal chosen.; /// - Cycles are well-nested, and form a forest with a parent-child; /// relationship.; /// - In any choice of DFS, every natural loop L is represented by a; /// unique cycle C which is a superset of L.; /// - In the absence of irreducible control flow, the cycles are; /// exactly the natural loops in the program.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h:124,Safety,avoid,avoid,124,"/// The entry block(s) of the cycle. The header is the only entry if; /// this is a loop. Is empty for the root ""cycle"", to avoid; /// unnecessary memory use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h:130,Deployability,update,update,130,/// Move \p Child to \p NewParent by manipulating Children vectors.; ///; /// Note: This is an incomplete operation that does not update the depth of; /// the subtree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h:31,Testability,test,test,31,/// Methods for debug and self-test.; //@{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericSSAContext.h:105,Security,access,access,105,// Ideally this should have been a stateless traits class. But the print methods; // for Machine IR need access to the owning function. So we track that state in; // the template itself.; //; // We use FunctionT as a template argument and not GenericSSATraits to allow; // forward declarations using well-known typenames.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericSSAContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericSSAContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericSSAContext.h:62,Usability,simpl,simply,62,"// The null value for ValueRefT. For LLVM IR and MIR, this is simply the; // default constructed value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericSSAContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericSSAContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1665,Deployability,update,update,1665,"yImpl.h -----------------------*- C++ -*------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This template implementation resides in a separate file so that it; // does not get injected into every .cpp file that includes the; // generic header.; //; // DO NOT INCLUDE THIS FILE WHEN MERELY USING UNIFORMITYINFO.; //; // This file should only be included by files that implement a; // specialization of the relvant templates. Currently these are:; // - UniformityAnalysis.cpp; //; // Note: The DEBUG_TYPE macro should be defined before using this; // file so that any use of LLVM_DEBUG is associated with the; // including file rather than this file.; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// \brief Implementation of uniformity analysis.; ///; /// The algorithm is a fixed point iteration that starts with the assumption; /// that all control flow and all values are uniform. Starting from sources of; /// divergence (whose discovery must be implemented by a CFG- or even; /// target-specific derived class), divergence of values is propagated from; /// definition to uses in a straight-forward way. The main complexity lies in; /// the propagation of the impact of divergent control flow on the divergence of; /// values (sync dependencies).; ///; /// NOTE: In general, no interface exists for a transform to update; /// (Machine)UniformityInfo. Additionally, (Machine)CycleAnalysis is a; /// transitive dependence, but it also does not provide an interface for; /// updating itself. Given that, transforms should not preserve uniformity in; /// their getAnalysisUsage() callback.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:467,Integrability,inject,injected,467,"//===- GenericUniformityImpl.h -----------------------*- C++ -*------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This template implementation resides in a separate file so that it; // does not get injected into every .cpp file that includes the; // generic header.; //; // DO NOT INCLUDE THIS FILE WHEN MERELY USING UNIFORMITYINFO.; //; // This file should only be included by files that implement a; // specialization of the relvant templates. Currently these are:; // - UniformityAnalysis.cpp; //; // Note: The DEBUG_TYPE macro should be defined before using this; // file so that any use of LLVM_DEBUG is associated with the; // including file rather than this file.; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// \brief Implementation of uniformity analysis.; ///; /// The algorithm is a fixed point iteration that starts with the assumption; /// that all control flow and all values are uniform. Starting from sources of; /// divergence (whose discovery must be implemented by a CFG- or even; /// target-specific derived class), divergence of values is propagated from; /// definition to uses in a straight-forward way. The main complexity lies in; /// the propagation of the impact of divergent control flow on the divergence of; /// values (sync dependencies).; ///; /// NOTE: In general, no interface exists for a transform to update; /// (Machine)UniformityInfo. Additionally, (Machine)CycleAnalysis is a; /// transitive dependence, but it also does not provide an interface for; /// updating itself. Given that, transforms should not preserve uniformity in; /// their getAnalysisUsage() callback.; ///; //===-----------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1583,Integrability,depend,dependencies,1583,"yImpl.h -----------------------*- C++ -*------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This template implementation resides in a separate file so that it; // does not get injected into every .cpp file that includes the; // generic header.; //; // DO NOT INCLUDE THIS FILE WHEN MERELY USING UNIFORMITYINFO.; //; // This file should only be included by files that implement a; // specialization of the relvant templates. Currently these are:; // - UniformityAnalysis.cpp; //; // Note: The DEBUG_TYPE macro should be defined before using this; // file so that any use of LLVM_DEBUG is associated with the; // including file rather than this file.; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// \brief Implementation of uniformity analysis.; ///; /// The algorithm is a fixed point iteration that starts with the assumption; /// that all control flow and all values are uniform. Starting from sources of; /// divergence (whose discovery must be implemented by a CFG- or even; /// target-specific derived class), divergence of values is propagated from; /// definition to uses in a straight-forward way. The main complexity lies in; /// the propagation of the impact of divergent control flow on the divergence of; /// values (sync dependencies).; ///; /// NOTE: In general, no interface exists for a transform to update; /// (Machine)UniformityInfo. Additionally, (Machine)CycleAnalysis is a; /// transitive dependence, but it also does not provide an interface for; /// updating itself. Given that, transforms should not preserve uniformity in; /// their getAnalysisUsage() callback.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1629,Integrability,interface,interface,1629,"yImpl.h -----------------------*- C++ -*------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This template implementation resides in a separate file so that it; // does not get injected into every .cpp file that includes the; // generic header.; //; // DO NOT INCLUDE THIS FILE WHEN MERELY USING UNIFORMITYINFO.; //; // This file should only be included by files that implement a; // specialization of the relvant templates. Currently these are:; // - UniformityAnalysis.cpp; //; // Note: The DEBUG_TYPE macro should be defined before using this; // file so that any use of LLVM_DEBUG is associated with the; // including file rather than this file.; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// \brief Implementation of uniformity analysis.; ///; /// The algorithm is a fixed point iteration that starts with the assumption; /// that all control flow and all values are uniform. Starting from sources of; /// divergence (whose discovery must be implemented by a CFG- or even; /// target-specific derived class), divergence of values is propagated from; /// definition to uses in a straight-forward way. The main complexity lies in; /// the propagation of the impact of divergent control flow on the divergence of; /// values (sync dependencies).; ///; /// NOTE: In general, no interface exists for a transform to update; /// (Machine)UniformityInfo. Additionally, (Machine)CycleAnalysis is a; /// transitive dependence, but it also does not provide an interface for; /// updating itself. Given that, transforms should not preserve uniformity in; /// their getAnalysisUsage() callback.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1760,Integrability,depend,dependence,1760,"yImpl.h -----------------------*- C++ -*------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This template implementation resides in a separate file so that it; // does not get injected into every .cpp file that includes the; // generic header.; //; // DO NOT INCLUDE THIS FILE WHEN MERELY USING UNIFORMITYINFO.; //; // This file should only be included by files that implement a; // specialization of the relvant templates. Currently these are:; // - UniformityAnalysis.cpp; //; // Note: The DEBUG_TYPE macro should be defined before using this; // file so that any use of LLVM_DEBUG is associated with the; // including file rather than this file.; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// \brief Implementation of uniformity analysis.; ///; /// The algorithm is a fixed point iteration that starts with the assumption; /// that all control flow and all values are uniform. Starting from sources of; /// divergence (whose discovery must be implemented by a CFG- or even; /// target-specific derived class), divergence of values is propagated from; /// definition to uses in a straight-forward way. The main complexity lies in; /// the propagation of the impact of divergent control flow on the divergence of; /// values (sync dependencies).; ///; /// NOTE: In general, no interface exists for a transform to update; /// (Machine)UniformityInfo. Additionally, (Machine)CycleAnalysis is a; /// transitive dependence, but it also does not provide an interface for; /// updating itself. Given that, transforms should not preserve uniformity in; /// their getAnalysisUsage() callback.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1804,Integrability,interface,interface,1804,"yImpl.h -----------------------*- C++ -*------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This template implementation resides in a separate file so that it; // does not get injected into every .cpp file that includes the; // generic header.; //; // DO NOT INCLUDE THIS FILE WHEN MERELY USING UNIFORMITYINFO.; //; // This file should only be included by files that implement a; // specialization of the relvant templates. Currently these are:; // - UniformityAnalysis.cpp; //; // Note: The DEBUG_TYPE macro should be defined before using this; // file so that any use of LLVM_DEBUG is associated with the; // including file rather than this file.; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// \brief Implementation of uniformity analysis.; ///; /// The algorithm is a fixed point iteration that starts with the assumption; /// that all control flow and all values are uniform. Starting from sources of; /// divergence (whose discovery must be implemented by a CFG- or even; /// target-specific derived class), divergence of values is propagated from; /// definition to uses in a straight-forward way. The main complexity lies in; /// the propagation of the impact of divergent control flow on the divergence of; /// values (sync dependencies).; ///; /// NOTE: In general, no interface exists for a transform to update; /// (Machine)UniformityInfo. Additionally, (Machine)CycleAnalysis is a; /// transitive dependence, but it also does not provide an interface for; /// updating itself. Given that, transforms should not preserve uniformity in; /// their getAnalysisUsage() callback.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:467,Security,inject,injected,467,"//===- GenericUniformityImpl.h -----------------------*- C++ -*------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This template implementation resides in a separate file so that it; // does not get injected into every .cpp file that includes the; // generic header.; //; // DO NOT INCLUDE THIS FILE WHEN MERELY USING UNIFORMITYINFO.; //; // This file should only be included by files that implement a; // specialization of the relvant templates. Currently these are:; // - UniformityAnalysis.cpp; //; // Note: The DEBUG_TYPE macro should be defined before using this; // file so that any use of LLVM_DEBUG is associated with the; // including file rather than this file.; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// \brief Implementation of uniformity analysis.; ///; /// The algorithm is a fixed point iteration that starts with the assumption; /// that all control flow and all values are uniform. Starting from sources of; /// divergence (whose discovery must be implemented by a CFG- or even; /// target-specific derived class), divergence of values is propagated from; /// definition to uses in a straight-forward way. The main complexity lies in; /// the propagation of the impact of divergent control flow on the divergence of; /// values (sync dependencies).; ///; /// NOTE: In general, no interface exists for a transform to update; /// (Machine)UniformityInfo. Additionally, (Machine)CycleAnalysis is a; /// transitive dependence, but it also does not provide an interface for; /// updating itself. Given that, transforms should not preserve uniformity in; /// their getAnalysisUsage() callback.; ///; //===-----------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:2237,Energy Efficiency,reduce,reduce,2237," 1, %else ]; //; // Suppose %tid holds the thread ID. Although %a is not data dependent on %tid; // because %tid is not on its use-def chains, %a is sync dependent on %tid; // because the branch ""br i1 %cond"" depends on %tid and affects which value %a; // is assigned to.; //; //; // -- Reduction to SSA construction --; // There are two disjoint paths from A to X, if a certain variant of SSA; // construction places a phi node in X under the following set-up scheme.; //; // This variant of SSA construction ignores incoming undef values.; // That is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ /; // F; //; // Assume that A contains a divergent branch. We are interested; // in the set of all blocks where each block is reachable from A; // via two disjoint paths. This would be the set {D, F} in this; // case.; // To generally reduce this query to SSA construction we introduce; // a virtual variable x and assign to x different values in each; // successor block of A.; //; // entry; // / \; // A \; // / \ Y; // x = 0 x = 1 /; // \ / \ /; // D E; // \ /; // F; //; // Our flavor of SSA construction for x will construct the following; //; // entry; // / \; // A \; // / \ Y; // x0 = 0 x1 = 1 /; // \ / \ /; // x2 = phi E; // \ /; // x3 = phi; //; // The blocks D and F contain phi nodes and are thus each reachable; // by two disjoins paths from A.; //; // -- Remarks --; // * In case of cycle exits we need to check for temporal divergence.; // To this end, we check whether the definition of x differs between the; // cycle exit and the cycle header (_after_ SSA construction).; //; // * In the presence of irreducible control flow, the fixed point is; // reached only after multiple iterations. This is because labels; // reaching the header of a cycle must be repropagated through the; // cycle. This is true even in a reducible cycle, since the labels; // may have been produced by ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:986,Integrability,depend,dependence,986,"// \class GenericSyncDependenceAnalysis; ///; /// \brief Locate join blocks for disjoint paths starting at a divergent branch.; ///; /// An analysis per divergent branch that returns the set of basic; /// blocks whose phi nodes become divergent due to divergent control.; /// These are the blocks that are reachable by two disjoint paths from; /// the branch, or cycle exits reachable along a path that is disjoint; /// from a path to the cycle latch.; // --- Above line is not a doxygen comment; intentionally left blank ---; //; // Originally implemented in SyncDependenceAnalysis.cpp for DivergenceAnalysis.; //; // The SyncDependenceAnalysis is used in the UniformityAnalysis to model; // control-induced divergence in phi nodes.; //; // -- Reference --; // The algorithm is an extension of Section 5 of; //; // An abstract interpretation for SPMD divergence; // on reducible control flow graphs.; // Julian Rosemann, Simon Moll and Sebastian Hack; // POPL '21; //; //; // -- Sync dependence --; // Sync dependence characterizes the control flow aspect of the; // propagation of branch divergence. For example,; //; // %cond = icmp slt i32 %tid, 10; // br i1 %cond, label %then, label %else; // then:; // br label %merge; // else:; // br label %merge; // merge:; // %a = phi i32 [ 0, %then ], [ 1, %else ]; //; // Suppose %tid holds the thread ID. Although %a is not data dependent on %tid; // because %tid is not on its use-def chains, %a is sync dependent on %tid; // because the branch ""br i1 %cond"" depends on %tid and affects which value %a; // is assigned to.; //; //; // -- Reduction to SSA construction --; // There are two disjoint paths from A to X, if a certain variant of SSA; // construction places a phi node in X under the following set-up scheme.; //; // This variant of SSA construction ignores incoming undef values.; // That is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1009,Integrability,depend,dependence,1009,"// \class GenericSyncDependenceAnalysis; ///; /// \brief Locate join blocks for disjoint paths starting at a divergent branch.; ///; /// An analysis per divergent branch that returns the set of basic; /// blocks whose phi nodes become divergent due to divergent control.; /// These are the blocks that are reachable by two disjoint paths from; /// the branch, or cycle exits reachable along a path that is disjoint; /// from a path to the cycle latch.; // --- Above line is not a doxygen comment; intentionally left blank ---; //; // Originally implemented in SyncDependenceAnalysis.cpp for DivergenceAnalysis.; //; // The SyncDependenceAnalysis is used in the UniformityAnalysis to model; // control-induced divergence in phi nodes.; //; // -- Reference --; // The algorithm is an extension of Section 5 of; //; // An abstract interpretation for SPMD divergence; // on reducible control flow graphs.; // Julian Rosemann, Simon Moll and Sebastian Hack; // POPL '21; //; //; // -- Sync dependence --; // Sync dependence characterizes the control flow aspect of the; // propagation of branch divergence. For example,; //; // %cond = icmp slt i32 %tid, 10; // br i1 %cond, label %then, label %else; // then:; // br label %merge; // else:; // br label %merge; // merge:; // %a = phi i32 [ 0, %then ], [ 1, %else ]; //; // Suppose %tid holds the thread ID. Although %a is not data dependent on %tid; // because %tid is not on its use-def chains, %a is sync dependent on %tid; // because the branch ""br i1 %cond"" depends on %tid and affects which value %a; // is assigned to.; //; //; // -- Reduction to SSA construction --; // There are two disjoint paths from A to X, if a certain variant of SSA; // construction places a phi node in X under the following set-up scheme.; //; // This variant of SSA construction ignores incoming undef values.; // That is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1377,Integrability,depend,dependent,1377,"Above line is not a doxygen comment; intentionally left blank ---; //; // Originally implemented in SyncDependenceAnalysis.cpp for DivergenceAnalysis.; //; // The SyncDependenceAnalysis is used in the UniformityAnalysis to model; // control-induced divergence in phi nodes.; //; // -- Reference --; // The algorithm is an extension of Section 5 of; //; // An abstract interpretation for SPMD divergence; // on reducible control flow graphs.; // Julian Rosemann, Simon Moll and Sebastian Hack; // POPL '21; //; //; // -- Sync dependence --; // Sync dependence characterizes the control flow aspect of the; // propagation of branch divergence. For example,; //; // %cond = icmp slt i32 %tid, 10; // br i1 %cond, label %then, label %else; // then:; // br label %merge; // else:; // br label %merge; // merge:; // %a = phi i32 [ 0, %then ], [ 1, %else ]; //; // Suppose %tid holds the thread ID. Although %a is not data dependent on %tid; // because %tid is not on its use-def chains, %a is sync dependent on %tid; // because the branch ""br i1 %cond"" depends on %tid and affects which value %a; // is assigned to.; //; //; // -- Reduction to SSA construction --; // There are two disjoint paths from A to X, if a certain variant of SSA; // construction places a phi node in X under the following set-up scheme.; //; // This variant of SSA construction ignores incoming undef values.; // That is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ /; // F; //; // Assume that A contains a divergent branch. We are interested; // in the set of all blocks where each block is reachable from A; // via two disjoint paths. This would be the set {D, F} in this; // case.; // To generally reduce this query to SSA construction we introduce; // a virtual variable x and assign to x different values in each; // successor block of A.; //; // entry; // / \; // A \; // / \ Y; // x = 0 x = 1 /; // \ / \ /; // D E; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1453,Integrability,depend,dependent,1453,"Above line is not a doxygen comment; intentionally left blank ---; //; // Originally implemented in SyncDependenceAnalysis.cpp for DivergenceAnalysis.; //; // The SyncDependenceAnalysis is used in the UniformityAnalysis to model; // control-induced divergence in phi nodes.; //; // -- Reference --; // The algorithm is an extension of Section 5 of; //; // An abstract interpretation for SPMD divergence; // on reducible control flow graphs.; // Julian Rosemann, Simon Moll and Sebastian Hack; // POPL '21; //; //; // -- Sync dependence --; // Sync dependence characterizes the control flow aspect of the; // propagation of branch divergence. For example,; //; // %cond = icmp slt i32 %tid, 10; // br i1 %cond, label %then, label %else; // then:; // br label %merge; // else:; // br label %merge; // merge:; // %a = phi i32 [ 0, %then ], [ 1, %else ]; //; // Suppose %tid holds the thread ID. Although %a is not data dependent on %tid; // because %tid is not on its use-def chains, %a is sync dependent on %tid; // because the branch ""br i1 %cond"" depends on %tid and affects which value %a; // is assigned to.; //; //; // -- Reduction to SSA construction --; // There are two disjoint paths from A to X, if a certain variant of SSA; // construction places a phi node in X under the following set-up scheme.; //; // This variant of SSA construction ignores incoming undef values.; // That is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ /; // F; //; // Assume that A contains a divergent branch. We are interested; // in the set of all blocks where each block is reachable from A; // via two disjoint paths. This would be the set {D, F} in this; // case.; // To generally reduce this query to SSA construction we introduce; // a virtual variable x and assign to x different values in each; // successor block of A.; //; // entry; // / \; // A \; // / \ Y; // x = 0 x = 1 /; // \ / \ /; // D E; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:1508,Integrability,depend,depends,1508,"Above line is not a doxygen comment; intentionally left blank ---; //; // Originally implemented in SyncDependenceAnalysis.cpp for DivergenceAnalysis.; //; // The SyncDependenceAnalysis is used in the UniformityAnalysis to model; // control-induced divergence in phi nodes.; //; // -- Reference --; // The algorithm is an extension of Section 5 of; //; // An abstract interpretation for SPMD divergence; // on reducible control flow graphs.; // Julian Rosemann, Simon Moll and Sebastian Hack; // POPL '21; //; //; // -- Sync dependence --; // Sync dependence characterizes the control flow aspect of the; // propagation of branch divergence. For example,; //; // %cond = icmp slt i32 %tid, 10; // br i1 %cond, label %then, label %else; // then:; // br label %merge; // else:; // br label %merge; // merge:; // %a = phi i32 [ 0, %then ], [ 1, %else ]; //; // Suppose %tid holds the thread ID. Although %a is not data dependent on %tid; // because %tid is not on its use-def chains, %a is sync dependent on %tid; // because the branch ""br i1 %cond"" depends on %tid and affects which value %a; // is assigned to.; //; //; // -- Reduction to SSA construction --; // There are two disjoint paths from A to X, if a certain variant of SSA; // construction places a phi node in X under the following set-up scheme.; //; // This variant of SSA construction ignores incoming undef values.; // That is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ /; // F; //; // Assume that A contains a divergent branch. We are interested; // in the set of all blocks where each block is reachable from A; // via two disjoint paths. This would be the set {D, F} in this; // case.; // To generally reduce this query to SSA construction we introduce; // a virtual variable x and assign to x different values in each; // successor block of A.; //; // entry; // / \; // A \; // / \ Y; // x = 0 x = 1 /; // \ / \ /; // D E; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:2302,Modifiability,variab,variable,2302," 1, %else ]; //; // Suppose %tid holds the thread ID. Although %a is not data dependent on %tid; // because %tid is not on its use-def chains, %a is sync dependent on %tid; // because the branch ""br i1 %cond"" depends on %tid and affects which value %a; // is assigned to.; //; //; // -- Reduction to SSA construction --; // There are two disjoint paths from A to X, if a certain variant of SSA; // construction places a phi node in X under the following set-up scheme.; //; // This variant of SSA construction ignores incoming undef values.; // That is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ /; // F; //; // Assume that A contains a divergent branch. We are interested; // in the set of all blocks where each block is reachable from A; // via two disjoint paths. This would be the set {D, F} in this; // case.; // To generally reduce this query to SSA construction we introduce; // a virtual variable x and assign to x different values in each; // successor block of A.; //; // entry; // / \; // A \; // / \ Y; // x = 0 x = 1 /; // \ / \ /; // D E; // \ /; // F; //; // Our flavor of SSA construction for x will construct the following; //; // entry; // / \; // A \; // / \ Y; // x0 = 0 x1 = 1 /; // \ / \ /; // x2 = phi E; // \ /; // x3 = phi; //; // The blocks D and F contain phi nodes and are thus each reachable; // by two disjoins paths from A.; //; // -- Remarks --; // * In case of cycle exits we need to check for temporal divergence.; // To this end, we check whether the definition of x differs between the; // cycle exit and the cycle header (_after_ SSA construction).; //; // * In the presence of irreducible control flow, the fixed point is; // reached only after multiple iterations. This is because labels; // reaching the header of a cycle must be repropagated through the; // cycle. This is true even in a reducible cycle, since the labels; // may have been produced by ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:3684,Usability,simpl,simple,3684," is paths from the entry without a definition do not result in; // phi nodes.; //; // entry; // / \; // A \; // / \ Y; // B C /; // \ / \ /; // D E; // \ /; // F; //; // Assume that A contains a divergent branch. We are interested; // in the set of all blocks where each block is reachable from A; // via two disjoint paths. This would be the set {D, F} in this; // case.; // To generally reduce this query to SSA construction we introduce; // a virtual variable x and assign to x different values in each; // successor block of A.; //; // entry; // / \; // A \; // / \ Y; // x = 0 x = 1 /; // \ / \ /; // D E; // \ /; // F; //; // Our flavor of SSA construction for x will construct the following; //; // entry; // / \; // A \; // / \ Y; // x0 = 0 x1 = 1 /; // \ / \ /; // x2 = phi E; // \ /; // x3 = phi; //; // The blocks D and F contain phi nodes and are thus each reachable; // by two disjoins paths from A.; //; // -- Remarks --; // * In case of cycle exits we need to check for temporal divergence.; // To this end, we check whether the definition of x differs between the; // cycle exit and the cycle header (_after_ SSA construction).; //; // * In the presence of irreducible control flow, the fixed point is; // reached only after multiple iterations. This is because labels; // reaching the header of a cycle must be repropagated through the; // cycle. This is true even in a reducible cycle, since the labels; // may have been produced by a nested irreducible cycle.; //; // * Note that SyncDependenceAnalysis is not concerned with the points; // of convergence in an irreducible cycle. It's only purpose is to; // identify join blocks. The ""diverged entry"" criterion is; // separately applied on join blocks to determine if an entire; // irreducible cycle is assumed to be divergent.; //; // * Relevant related work:; // A simple algorithm for global data flow analysis problems.; // Matthew S. Hecht and Jeffrey D. Ullman.; // SIAM Journal on Computing, 4(4):519–532, December 1975.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:39,Integrability,depend,dependence,39,/// Information discovered by the sync dependence analysis for each; /// divergent branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:3,Safety,Detect,Detected,3,// Detected/marked divergent values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:264,Safety,detect,detection,264,"// If the current block is the header of a reducible cycle that; // contains the divergent branch, then the label should be; // propagated to the cycle exits. Such a header is the ""last; // possible join"" of any disjoint paths within this cycle. This; // prevents detection of spurious joins at the entries of any; // irreducible child cycles.; //; // This conclusion about the header is true for any choice of DFS:; //; // If some DFS has a reducible cycle C with header H, then for; // any other DFS, H is the header of a cycle C' that is a; // superset of C. For a divergent branch inside the subgraph; // C, any join node inside C is either H, or some node; // encountered without passing through H.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:9,Deployability,update,update,9,// Floor update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:11,Availability,avail,available,11,// already available in cache?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:24,Performance,cache,cache,24,// already available in cache?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:117,Integrability,depend,depending,117,"// Cycles that are assumed divergent due to the diverged entry; // criterion potentially contain temporal divergence depending on; // the DFS chosen. Conservatively, all values produced in such a; // cycle are assumed divergent. ""Cycle invariant"" values may be; // assumed uniform, but that requires further analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:79,Deployability,update,updated,79,// All values on the Worklist are divergent.; // Their users may not have been updated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityInfo.h:31,Safety,detect,detected,31,/// Whether any divergence was detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h:147,Modifiability,evolve,evolved,147,// GraphTraits - This class should be specialized by different graph types...; // which is why the default version is empty.; //; // This template evolved from supporting `BasicBlock` to also later supporting; // more complex types (e.g. CFG and DomTree).; //; // GraphTraits can be used to create a view over a graph interpreting it; // differently without requiring a copy of the original graph. This could; // be achieved by carrying more data in NodeRef. See LoopBodyTraits for one; // example.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h:1468,Availability,error,error,1468,"// Elements to provide:; // typedef NodeRef - Type of Node token in the graph, which should; // be cheap to copy.; // typedef ChildIteratorType - Type used to iterate over children in graph,; // dereference to a NodeRef.; // static NodeRef getEntryNode(const GraphType &); // Return the entry node of the graph; // static ChildIteratorType child_begin(NodeRef); // static ChildIteratorType child_end (NodeRef); // Return iterators that point to the beginning and ending of the child; // node list for the specified node.; // typedef ...iterator nodes_iterator; - dereference to a NodeRef; // static nodes_iterator nodes_begin(GraphType *G); // static nodes_iterator nodes_end (GraphType *G); // nodes_iterator/begin/end - Allow iteration over all nodes in the graph; // typedef EdgeRef - Type of Edge token in the graph, which should; // be cheap to copy.; // typedef ChildEdgeIteratorType - Type used to iterate over children edges in; // graph, dereference to a EdgeRef.; // static ChildEdgeIteratorType child_edge_begin(NodeRef); // static ChildEdgeIteratorType child_edge_end(NodeRef); // Return iterators that point to the beginning and ending of the; // edge list for the given callgraph node.; //; // static NodeRef edge_dest(EdgeRef); // Return the destination node of an edge.; // static unsigned size (GraphType *G); // Return total number of nodes in the graph; // If anyone tries to use this class without having an appropriate; // specialization, make an error. If you get this error, it's because you; // need to include the appropriate specialization of GraphTraits<> for your; // graph, or you need to define it for a new graph type. Either that or; // your argument to XXX_begin(...) is unknown or needs to have the proper .h; // file #include'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h:1491,Availability,error,error,1491,"// Elements to provide:; // typedef NodeRef - Type of Node token in the graph, which should; // be cheap to copy.; // typedef ChildIteratorType - Type used to iterate over children in graph,; // dereference to a NodeRef.; // static NodeRef getEntryNode(const GraphType &); // Return the entry node of the graph; // static ChildIteratorType child_begin(NodeRef); // static ChildIteratorType child_end (NodeRef); // Return iterators that point to the beginning and ending of the child; // node list for the specified node.; // typedef ...iterator nodes_iterator; - dereference to a NodeRef; // static nodes_iterator nodes_begin(GraphType *G); // static nodes_iterator nodes_end (GraphType *G); // nodes_iterator/begin/end - Allow iteration over all nodes in the graph; // typedef EdgeRef - Type of Edge token in the graph, which should; // be cheap to copy.; // typedef ChildEdgeIteratorType - Type used to iterate over children edges in; // graph, dereference to a EdgeRef.; // static ChildEdgeIteratorType child_edge_begin(NodeRef); // static ChildEdgeIteratorType child_edge_end(NodeRef); // Return iterators that point to the beginning and ending of the; // edge list for the given callgraph node.; //; // static NodeRef edge_dest(EdgeRef); // Return the destination node of an edge.; // static unsigned size (GraphType *G); // Return total number of nodes in the graph; // If anyone tries to use this class without having an appropriate; // specialization, make an error. If you get this error, it's because you; // need to include the appropriate specialization of GraphTraits<> for your; // graph, or you need to define it for a new graph type. Either that or; // your argument to XXX_begin(...) is unknown or needs to have the proper .h; // file #include'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h:219,Integrability,depend,depends,219,"// Inverse - This class is used as a little marker class to tell the graph; // iterator to iterate over the graph in a graph defined ""Inverse"" ordering.; // Not all graphs define an inverse ordering, and if they do, it depends on; // the graph exactly what that is. Here's an example of usage with the; // df_iterator:; //; // idf_iterator<Method*> I = idf_begin(M), E = idf_end(M);; // for (; I != E; ++I) { ... }; //; // Which is equivalent to:; // df_iterator<Inverse<Method*>> I = idf_begin(M), E = idf_end(M);; // for (; I != E; ++I) { ... }; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:436,Integrability,interface,interfaces,436,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:539,Integrability,interface,interface,539,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:685,Integrability,interface,interfaces,685,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:1976,Integrability,rout,routine,1976,"tandard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // under 32-bytes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:1058,Safety,risk,risky,1058,"hing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' cont",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:17,Security,Hash,Hashing,17,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:43,Security,hash,hashing,43,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:451,Security,hash,hashing,451,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:491,Security,hash,hash,491,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:815,Security,hash,hash,815,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:874,Security,hash,hashing,874,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:916,Security,hash,hash,916,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:929,Security,checksum,checksumming,929,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:968,Security,hash,hashes,968,"//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar contex",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:1379,Security,hash,hashing,1379,"--------------------------------------------===//; //; // This file implements the newly proposed standard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // un",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:1531,Security,hash,hashing,1531,"tandard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // under 32-bytes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:2075,Security,hash,hashing,2075,"tandard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // under 32-bytes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:2305,Security,hash,hash,2305,"tandard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // under 32-bytes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:1910,Testability,log,logically,1910,"tandard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // under 32-bytes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:2065,Testability,log,logic,2065,"tandard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // under 32-bytes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:2136,Testability,log,logic,2136,"tandard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // under 32-bytes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:2244,Testability,benchmark,benchmarked,2244,"tandard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // under 32-bytes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:1811,Usability,intuit,intuitively,1811,"tandard C++ interfaces for hashing; // arbitrary data and building hash functions for user-defined types. This; // interface was originally proposed in N3333[1] and is currently under review; // for inclusion in a future TR and/or standard.; //; // The primary interfaces provide are comprised of one type and three functions:; //; // -- 'hash_code' class is an opaque type representing the hash code for some; // data. It is the intended product of hashing, and can be used to implement; // hash tables, checksumming, and other common uses of hashes. It is not an; // integer type (although it can be converted to one) because it is risky; // to assume much about the internals of a hash_code. In particular, each; // execution of the program has a high probability of producing a different; // hash_code for a given input. Thus their values are not stable to save or; // persist, and should only be used during the execution for the; // construction of hashing datastructures.; //; // -- 'hash_value' is a function designed to be overloaded for each; // user-defined type which wishes to be used within a hashing context. It; // should be overloaded within the user-defined type's namespace and found; // via ADL. Overloads for primitive types are provided by this library.; //; // -- 'hash_combine' and 'hash_combine_range' are functions designed to aid; // programmers in easily and intuitively combining a set of data into; // a single hash_code for their object. They should only logically be used; // within the implementation of a 'hash_value' routine or similar context.; //; // Note that 'hash_combine_range' contains very special logic for hashing; // a contiguous array of integers or pointers. This logic is *extremely* fast,; // on a modern Intel ""Gainestown"" Xeon (Nehalem uarch) @2.2 GHz, these were; // benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys; // under 32-bytes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:224,Integrability,wrap,wraps,224,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:313,Safety,predict,predictable,313,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:36,Security,hash,hash,36,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:94,Security,hash,hashing,94,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:159,Security,hash,hashtables,159,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:179,Security,hash,hashing-based,179,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:234,Security,expose,exposes,234,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:11,Security,hash,hash,11,/// Form a hash code directly from a numerical value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:16,Security,hash,hash,16,/// Convert the hash code to its numerical value for use.; /*explicit*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:70,Security,hash,hashes,70,/// Compute a hash_code for a pointer's address.; ///; /// N.B.: This hashes the *address*. Not the value and not the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:67,Security,hash,hashing,67,"/// Override the execution seed with a fixed value.; ///; /// This hashing library uses a per-execution seed designed to change on each; /// run with high probability in order to ensure that the hash codes are not; /// attackable and to ensure that output which is intended to be stable does; /// not rely on the particulars of the hash codes produced.; ///; /// That said, there are use cases where it is important to be able to; /// reproduce *exactly* a specific behavior. To that end, we provide a function; /// which will forcibly set the seed to a fixed value. This must be done at the; /// start of the program, before any hashes are computed. Also, it cannot be; /// undone. This makes it thread-hostile and very hard to use outside of; /// immediately on start of a simple program designed for reproducible; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:195,Security,hash,hash,195,"/// Override the execution seed with a fixed value.; ///; /// This hashing library uses a per-execution seed designed to change on each; /// run with high probability in order to ensure that the hash codes are not; /// attackable and to ensure that output which is intended to be stable does; /// not rely on the particulars of the hash codes produced.; ///; /// That said, there are use cases where it is important to be able to; /// reproduce *exactly* a specific behavior. To that end, we provide a function; /// which will forcibly set the seed to a fixed value. This must be done at the; /// start of the program, before any hashes are computed. Also, it cannot be; /// undone. This makes it thread-hostile and very hard to use outside of; /// immediately on start of a simple program designed for reproducible; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:219,Security,attack,attackable,219,"/// Override the execution seed with a fixed value.; ///; /// This hashing library uses a per-execution seed designed to change on each; /// run with high probability in order to ensure that the hash codes are not; /// attackable and to ensure that output which is intended to be stable does; /// not rely on the particulars of the hash codes produced.; ///; /// That said, there are use cases where it is important to be able to; /// reproduce *exactly* a specific behavior. To that end, we provide a function; /// which will forcibly set the seed to a fixed value. This must be done at the; /// start of the program, before any hashes are computed. Also, it cannot be; /// undone. This makes it thread-hostile and very hard to use outside of; /// immediately on start of a simple program designed for reproducible; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:332,Security,hash,hash,332,"/// Override the execution seed with a fixed value.; ///; /// This hashing library uses a per-execution seed designed to change on each; /// run with high probability in order to ensure that the hash codes are not; /// attackable and to ensure that output which is intended to be stable does; /// not rely on the particulars of the hash codes produced.; ///; /// That said, there are use cases where it is important to be able to; /// reproduce *exactly* a specific behavior. To that end, we provide a function; /// which will forcibly set the seed to a fixed value. This must be done at the; /// start of the program, before any hashes are computed. Also, it cannot be; /// undone. This makes it thread-hostile and very hard to use outside of; /// immediately on start of a simple program designed for reproducible; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:630,Security,hash,hashes,630,"/// Override the execution seed with a fixed value.; ///; /// This hashing library uses a per-execution seed designed to change on each; /// run with high probability in order to ensure that the hash codes are not; /// attackable and to ensure that output which is intended to be stable does; /// not rely on the particulars of the hash codes produced.; ///; /// That said, there are use cases where it is important to be able to; /// reproduce *exactly* a specific behavior. To that end, we provide a function; /// which will forcibly set the seed to a fixed value. This must be done at the; /// start of the program, before any hashes are computed. Also, it cannot be; /// undone. This makes it thread-hostile and very hard to use outside of; /// immediately on start of a simple program designed for reproducible; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:675,Usability,undo,undone,675,"/// Override the execution seed with a fixed value.; ///; /// This hashing library uses a per-execution seed designed to change on each; /// run with high probability in order to ensure that the hash codes are not; /// attackable and to ensure that output which is intended to be stable does; /// not rely on the particulars of the hash codes produced.; ///; /// That said, there are use cases where it is important to be able to; /// reproduce *exactly* a specific behavior. To that end, we provide a function; /// which will forcibly set the seed to a fixed value. This must be done at the; /// start of the program, before any hashes are computed. Also, it cannot be; /// undone. This makes it thread-hostile and very hard to use outside of; /// immediately on start of a simple program designed for reproducible; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:775,Usability,simpl,simple,775,"/// Override the execution seed with a fixed value.; ///; /// This hashing library uses a per-execution seed designed to change on each; /// run with high probability in order to ensure that the hash codes are not; /// attackable and to ensure that output which is intended to be stable does; /// not rely on the particulars of the hash codes produced.; ///; /// That said, there are use cases where it is important to be able to; /// reproduce *exactly* a specific behavior. To that end, we provide a function; /// which will forcibly set the seed to a fixed value. This must be done at the; /// start of the program, before any hashes are computed. Also, it cannot be; /// undone. This makes it thread-hostile and very hard to use outside of; /// immediately on start of a simple program designed for reproducible; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:130,Integrability,rout,routines,130,// All of the implementation details of actually computing the various hash; // code values are held within this namespace. These routines are included in; // the header file mainly to allow inlining and constant propagation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:71,Security,hash,hash,71,// All of the implementation details of actually computing the various hash; // code values are held within this namespace. These routines are included in; // the header file mainly to allow inlining and constant propagation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:3,Safety,Avoid,Avoid,3,// Avoid shifting by 64: doing so yields an undefined result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:19,Security,hash,hashing,19,// Murmur-inspired hashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:39,Security,hash,hashing,39,"/// The intermediate state used during hashing.; /// Currently, the algorithm for computing hash codes is based on CityHash and; /// keeps 56 bytes of arbitrary state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:92,Security,hash,hash,92,"/// The intermediate state used during hashing.; /// Currently, the algorithm for computing hash codes is based on CityHash and; /// keeps 56 bytes of arbitrary state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:130,Performance,perform,performs,130,/// Create a new hash_state structure and initialize it based on the; /// seed and the first 64-byte chunk.; /// This effectively performs the initial mix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:29,Security,hash,hash,29,/// Compute the final 64-bit hash code value based on the current; /// state and the length of bytes hashed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:101,Security,hash,hashed,101,/// Compute the final 64-bit hash code value based on the current; /// state and the length of bytes hashed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:34,Modifiability,variab,variable,34,"/// A global, fixed seed-override variable.; ///; /// This variable can be set using the \see llvm::set_fixed_execution_seed; /// function. See that function for details. Do not, under any circumstances,; /// set or read this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:59,Modifiability,variab,variable,59,"/// A global, fixed seed-override variable.; ///; /// This variable can be set using the \see llvm::set_fixed_execution_seed; /// function. See that function for details. Do not, under any circumstances,; /// set or read this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:226,Modifiability,variab,variable,226,"/// A global, fixed seed-override variable.; ///; /// This variable can be set using the \see llvm::set_fixed_execution_seed; /// function. See that function for details. Do not, under any circumstances,; /// set or read this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:51,Security,hash,hashed,51,"/// Trait to indicate whether a type's bits can be hashed directly.; ///; /// A type trait which is true if we want to combine values for hashing by; /// reading the underlying data. It is false if values of this type must; /// first be passed to hash_value, and the resulting hash_codes combined.; //; // FIXME: We want to replace is_integral_or_enum and is_pointer here with; // a predicate which asserts that comparing the underlying storage of two; // values of the type for equality is equivalent to comparing the two values; // for equality. For all the platforms we care about, this holds for integers; // and pointers, but there are platforms where it doesn't and we would like to; // support user-defined types which happen to satisfy this property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:138,Security,hash,hashing,138,"/// Trait to indicate whether a type's bits can be hashed directly.; ///; /// A type trait which is true if we want to combine values for hashing by; /// reading the underlying data. It is false if values of this type must; /// first be passed to hash_value, and the resulting hash_codes combined.; //; // FIXME: We want to replace is_integral_or_enum and is_pointer here with; // a predicate which asserts that comparing the underlying storage of two; // values of the type for equality is equivalent to comparing the two values; // for equality. For all the platforms we care about, this holds for integers; // and pointers, but there are platforms where it doesn't and we would like to; // support user-defined types which happen to satisfy this property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:399,Testability,assert,asserts,399,"/// Trait to indicate whether a type's bits can be hashed directly.; ///; /// A type trait which is true if we want to combine values for hashing by; /// reading the underlying data. It is false if values of this type must; /// first be passed to hash_value, and the resulting hash_codes combined.; //; // FIXME: We want to replace is_integral_or_enum and is_pointer here with; // a predicate which asserts that comparing the underlying storage of two; // values of the type for equality is equivalent to comparing the two values; // for equality. For all the platforms we care about, this holds for integers; // and pointers, but there are platforms where it doesn't and we would like to; // support user-defined types which happen to satisfy this property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:29,Safety,detect,detect,29,"// Special case std::pair to detect when both types are viable and when there; // is no alignment-derived padding in the pair. This is a bit of a lie because; // std::pair isn't truly POD, but it's close enough in all reasonable; // implementations for our use case of hashing the underlying data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:269,Security,hash,hashing,269,"// Special case std::pair to detect when both types are viable and when there; // is no alignment-derived padding in the pair. This is a bit of a lie because; // std::pair isn't truly POD, but it's close enough in all reasonable; // implementations for our use case of hashing the underlying data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:22,Security,hash,hashable,22,/// Helper to get the hashable data representation for a type.; /// This variant is enabled when the type itself can be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:22,Security,hash,hashable,22,/// Helper to get the hashable data representation for a type.; /// This variant is enabled when we must first call hash_value and use the; /// result as our data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:114,Integrability,rout,routine,114,"/// Helper to store data from a value into a buffer and advance the; /// pointer into that buffer.; ///; /// This routine first checks whether there is enough space in the provided; /// buffer, and if not immediately returns false. If there is space, it; /// copies the underlying bytes of value into the buffer, advances the; /// buffer_ptr past the copied bytes, and returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:247,Performance,optimiz,optimization,247,"/// Implement the combining of integral values into a hash_code.; ///; /// This overload is selected when the value type of the iterator is; /// integral. Rather than computing a hash_code for each object and then; /// combining them, this (as an optimization) directly combines the integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:32,Usability,clear,clear,32,"// Fill up the buffer. We don't clear it, which re-mixes the last round; // when only a partial 64-byte chunk is left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:418,Integrability,rout,routine,418,"/// Implement the combining of integral values into a hash_code.; ///; /// This overload is selected when the value type of the iterator is integral; /// and when the input iterator is actually a pointer. Rather than computing; /// a hash_code for each object and then combining them, this (as an; /// optimization) directly combines the integers. Also, because the integers; /// are stored in contiguous memory, this routine avoids copying each value; /// and directly reads from the underlying memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:302,Performance,optimiz,optimization,302,"/// Implement the combining of integral values into a hash_code.; ///; /// This overload is selected when the value type of the iterator is integral; /// and when the input iterator is actually a pointer. Rather than computing; /// a hash_code for each object and then combining them, this (as an; /// optimization) directly combines the integers. Also, because the integers; /// are stored in contiguous memory, this routine avoids copying each value; /// and directly reads from the underlying memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:426,Safety,avoid,avoids,426,"/// Implement the combining of integral values into a hash_code.; ///; /// This overload is selected when the value type of the iterator is integral; /// and when the input iterator is actually a pointer. Rather than computing; /// a hash_code for each object and then combining them, this (as an; /// optimization) directly combines the integers. Also, because the integers; /// are stored in contiguous memory, this routine avoids copying each value; /// and directly reads from the underlying memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:13,Security,hash,hashing,13,"// namespace hashing; /// Compute a hash_code for a sequence of values.; ///; /// This hashes a sequence of values. It produces the same hash_code as; /// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences; /// and is significantly faster given pointers and types which can be hashed as; /// a sequence of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:87,Security,hash,hashes,87,"// namespace hashing; /// Compute a hash_code for a sequence of values.; ///; /// This hashes a sequence of values. It produces the same hash_code as; /// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences; /// and is significantly faster given pointers and types which can be hashed as; /// a sequence of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:299,Security,hash,hashed,299,"// namespace hashing; /// Compute a hash_code for a sequence of values.; ///; /// This hashes a sequence of values. It produces the same hash_code as; /// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences; /// and is significantly faster given pointers and types which can be hashed as; /// a sequence of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:26,Security,hash,hash,26,"/// Construct a recursive hash combining helper.; ///; /// This sets up the state for a recursive hash combine, including getting; /// the seed and buffer setup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:98,Security,hash,hash,98,"/// Construct a recursive hash combining helper.; ///; /// This sets up the state for a recursive hash combine, including getting; /// the seed and buffer setup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:57,Security,hash,hash,57,"/// Combine one chunk of data into the current in-flight hash.; ///; /// This merges one chunk of data into the hash. First it tries to buffer; /// the data. If the buffer is full, it hashes the buffer into its; /// hash_state, empties it, and then merges the new chunk in. This also; /// handles cases where the data straddles the end of the buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:112,Security,hash,hash,112,"/// Combine one chunk of data into the current in-flight hash.; ///; /// This merges one chunk of data into the hash. First it tries to buffer; /// the data. If the buffer is full, it hashes the buffer into its; /// hash_state, empties it, and then merges the new chunk in. This also; /// handles cases where the data straddles the end of the buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:184,Security,hash,hashes,184,"/// Combine one chunk of data into the current in-flight hash.; ///; /// This merges one chunk of data into the hash. First it tries to buffer; /// the data. If the buffer is full, it hashes the buffer into its; /// hash_state, empties it, and then merges the new chunk in. This also; /// handles cases where the data straddles the end of the buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:55,Security,hash,hash,55,"// If the store fails, our buffer is full and ready to hash. We have to; // either initialize the hash state (on the first full buffer) or mix; // this buffer into the existing hash state. Length tracks the *hashed*; // length, not the buffered length.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:98,Security,hash,hash,98,"// If the store fails, our buffer is full and ready to hash. We have to; // either initialize the hash state (on the first full buffer) or mix; // this buffer into the existing hash state. Length tracks the *hashed*; // length, not the buffered length.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:177,Security,hash,hash,177,"// If the store fails, our buffer is full and ready to hash. We have to; // either initialize the hash state (on the first full buffer) or mix; // this buffer into the existing hash state. Length tracks the *hashed*; // length, not the buffered length.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:208,Security,hash,hashed,208,"// If the store fails, our buffer is full and ready to hash. We have to; // either initialize the hash state (on the first full buffer) or mix; // this buffer into the existing hash state. Length tracks the *hashed*; // length, not the buffered length.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:141,Security,hash,hash,141,"/// Recursive, variadic combining method.; ///; /// This function recurses through each argument, combining that argument; /// into a single hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:110,Integrability,rout,routine,110,"// Check whether the entire set of values fit in the buffer. If so, we'll; // use the optimized short hashing routine and skip state entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:86,Performance,optimiz,optimized,86,"// Check whether the entire set of values fit in the buffer. If so, we'll; // use the optimized short hashing routine and skip state entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:102,Security,hash,hashing,102,"// Check whether the entire set of values fit in the buffer. If so, we'll; // use the optimized short hashing routine and skip state entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:81,Integrability,rout,routine,81,"// namespace hashing; /// Combine values into a single hash_code.; ///; /// This routine accepts a varying number of arguments of any type. It will; /// attempt to combine them into a single hash_code. For user-defined types it; /// attempts to call a \see hash_value overload (via ADL) for the type. For; /// integer and pointer types it directly combines their data into the; /// resulting hash_code.; ///; /// The result is suitable for returning from a user's hash_value; /// *implementation* for their user-defined type. Consumers of a type should; /// *not* call this routine, they should instead call 'hash_value'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:574,Integrability,rout,routine,574,"// namespace hashing; /// Combine values into a single hash_code.; ///; /// This routine accepts a varying number of arguments of any type. It will; /// attempt to combine them into a single hash_code. For user-defined types it; /// attempts to call a \see hash_value overload (via ADL) for the type. For; /// integer and pointer types it directly combines their data into the; /// resulting hash_code.; ///; /// The result is suitable for returning from a user's hash_value; /// *implementation* for their user-defined type. Consumers of a type should; /// *not* call this routine, they should instead call 'hash_value'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:13,Security,hash,hashing,13,"// namespace hashing; /// Combine values into a single hash_code.; ///; /// This routine accepts a varying number of arguments of any type. It will; /// attempt to combine them into a single hash_code. For user-defined types it; /// attempts to call a \see hash_value overload (via ADL) for the type. For; /// integer and pointer types it directly combines their data into the; /// resulting hash_code.; ///; /// The result is suitable for returning from a user's hash_value; /// *implementation* for their user-defined type. Consumers of a type should; /// *not* call this routine, they should instead call 'hash_value'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:15,Security,hash,hash,15,// Recursively hash each argument using a helper class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:14,Security,hash,hash,14,"/// Helper to hash the value of a single integer.; ///; /// Overloads for smaller integer types are not provided to ensure consistent; /// behavior in the presence of integral promotions. Essentially,; /// ""hash_value('4')"" and ""hash_value('0' + 4)"" should be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:122,Availability,avail,available,122,"// namespace hashing; // Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:13,Security,hash,hashing,13,"// namespace hashing; // Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:92,Security,hash,hashing,92,"// namespace hashing; // Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:100,Availability,avail,available,100,"// Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:70,Security,hash,hashing,70,"// Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:100,Availability,avail,available,100,"// Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:70,Security,hash,hashing,70,"// Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:100,Availability,avail,available,100,"// Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:70,Security,hash,hashing,70,"// Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:38,Security,hash,hash,38,// namespace llvm; /// Implement std::hash so that hash_code can be used in STL containers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:88,Modifiability,inherit,inherit,88,"/// Custom traits to do nothing on deletion.; ///; /// Specialize ilist_alloc_traits to inherit from this to disable the; /// non-intrusive deletion in iplist (which implies ownership).; ///; /// If you want purely intrusive semantics with no callbacks, consider using \a; /// simple_ilist instead.; ///; /// \code; /// template <>; /// struct ilist_alloc_traits<MyType> : ilist_noalloc_traits<MyType> {};; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:92,Integrability,wrap,wrapper,92,"//===----------------------------------------------------------------------===//; //; /// A wrapper around an intrusive list with callbacks and non-intrusive; /// ownership.; ///; /// This wraps a purely intrusive list (like simple_ilist) with a configurable; /// traits class. The traits can implement callbacks and customize the; /// ownership semantics.; ///; /// This is a subset of ilist functionality that can safely be used on nodes of; /// polymorphic types, i.e. a heterogeneous list with a common base class that; /// holds the next/prev pointers. The only state of the list itself is an; /// ilist_sentinel, which holds pointers to the first and last nodes in the; /// list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:189,Integrability,wrap,wraps,189,"//===----------------------------------------------------------------------===//; //; /// A wrapper around an intrusive list with callbacks and non-intrusive; /// ownership.; ///; /// This wraps a purely intrusive list (like simple_ilist) with a configurable; /// traits class. The traits can implement callbacks and customize the; /// ownership semantics.; ///; /// This is a subset of ilist functionality that can safely be used on nodes of; /// polymorphic types, i.e. a heterogeneous list with a common base class that; /// holds the next/prev pointers. The only state of the list itself is an; /// ilist_sentinel, which holds pointers to the first and last nodes in the; /// list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:246,Modifiability,config,configurable,246,"//===----------------------------------------------------------------------===//; //; /// A wrapper around an intrusive list with callbacks and non-intrusive; /// ownership.; ///; /// This wraps a purely intrusive list (like simple_ilist) with a configurable; /// traits class. The traits can implement callbacks and customize the; /// ownership semantics.; ///; /// This is a subset of ilist functionality that can safely be used on nodes of; /// polymorphic types, i.e. a heterogeneous list with a common base class that; /// holds the next/prev pointers. The only state of the list itself is an; /// ilist_sentinel, which holds pointers to the first and last nodes in the; /// list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:448,Modifiability,polymorphi,polymorphic,448,"//===----------------------------------------------------------------------===//; //; /// A wrapper around an intrusive list with callbacks and non-intrusive; /// ownership.; ///; /// This wraps a purely intrusive list (like simple_ilist) with a configurable; /// traits class. The traits can implement callbacks and customize the; /// ownership semantics.; ///; /// This is a subset of ilist functionality that can safely be used on nodes of; /// polymorphic types, i.e. a heterogeneous list with a common base class that; /// holds the next/prev pointers. The only state of the list itself is an; /// ilist_sentinel, which holds pointers to the first and last nodes in the; /// list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:416,Safety,safe,safely,416,"//===----------------------------------------------------------------------===//; //; /// A wrapper around an intrusive list with callbacks and non-intrusive; /// ownership.; ///; /// This wraps a purely intrusive list (like simple_ilist) with a configurable; /// traits class. The traits can implement callbacks and customize the; /// ownership semantics.; ///; /// This is a subset of ilist functionality that can safely be used on nodes of; /// polymorphic types, i.e. a heterogeneous list with a common base class that; /// holds the next/prev pointers. The only state of the list itself is an; /// ilist_sentinel, which holds pointers to the first and last nodes in the; /// list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:28,Integrability,rout,routines,28,// Miscellaneous inspection routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:250,Performance,cache,cache,250,"/// Remove all nodes from the list like clear(), but do not call; /// removeNodeFromList() or deleteNode().; ///; /// This should only be used immediately before freeing nodes in bulk to; /// avoid traversing the list and bringing all the nodes into cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:192,Safety,avoid,avoid,192,"/// Remove all nodes from the list like clear(), but do not call; /// removeNodeFromList() or deleteNode().; ///; /// This should only be used immediately before freeing nodes in bulk to; /// avoid traversing the list and bringing all the nodes into cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:40,Usability,clear,clear,40,"/// Remove all nodes from the list like clear(), but do not call; /// removeNodeFromList() or deleteNode().; ///; /// This should only be used immediately before freeing nodes in bulk to; /// avoid traversing the list and bringing all the nodes into cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:258,Availability,avail,available,258,"/// An intrusive list with ownership and callbacks specified/controlled by; /// ilist_traits, only with API safe for polymorphic types.; ///; /// The \p Options parameters are the same as those for \a simple_ilist. See; /// there for a description of what's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:117,Modifiability,polymorphi,polymorphic,117,"/// An intrusive list with ownership and callbacks specified/controlled by; /// ilist_traits, only with API safe for polymorphic types.; ///; /// The \p Options parameters are the same as those for \a simple_ilist. See; /// there for a description of what's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:108,Safety,safe,safe,108,"/// An intrusive list with ownership and callbacks specified/controlled by; /// ilist_traits, only with API safe for polymorphic types.; ///; /// The \p Options parameters are the same as those for \a simple_ilist. See; /// there for a description of what's available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h:3,Security,Access,Accessors,3,// Accessors...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h:3,Security,Access,Accessors,3,// Accessors...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h:40,Security,access,accessible,40,// ilist_iterator_w_bits should also be accessible via isa/dyn_cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:191,Integrability,wrap,wrapper,191,"/// Implementation for an ilist node.; ///; /// Templated on an appropriate \a ilist_detail::node_options, usually computed; /// by \a ilist_detail::compute_node_options.; ///; /// This is a wrapper around \a ilist_node_base whose main purpose is to; /// provide type safety: you can't insert nodes of \a ilist_node_impl into the; /// wrong \a simple_ilist or \a iplist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:268,Safety,safe,safety,268,"/// Implementation for an ilist node.; ///; /// Templated on an appropriate \a ilist_detail::node_options, usually computed; /// by \a ilist_detail::compute_node_options.; ///; /// This is a wrapper around \a ilist_node_base whose main purpose is to; /// provide type safety: you can't insert nodes of \a ilist_node_impl into the; /// wrong \a simple_ilist or \a iplist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:35,Availability,avail,available,35,"// Under-approximation, but always available for assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:49,Testability,assert,assertions,49,"// Under-approximation, but always available for assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:648,Availability,mask,mask,648,"/// An intrusive list node.; ///; /// A base class to enable membership in intrusive lists, including \a; /// simple_ilist, \a iplist, and \a ilist. The first template parameter is the; /// \a value_type for the list.; ///; /// An ilist node can be configured with compile-time options to change; /// behaviour and/or add API.; ///; /// By default, an \a ilist_node knows whether it is the list sentinel (an; /// instance of \a ilist_sentinel) if and only if; /// LLVM_ENABLE_ABI_BREAKING_CHECKS. The function \a isKnownSentinel() always; /// returns \c false tracking is off. Sentinel tracking steals a bit from the; /// ""prev"" link, which adds a mask operation when decrementing an iterator, but; /// enables bug-finding assertions in \a ilist_iterator.; ///; /// To turn sentinel tracking on all the time, pass in the; /// ilist_sentinel_tracking<true> template parameter. This also enables the \a; /// isSentinel() function. The same option must be passed to the intrusive; /// list. (ilist_sentinel_tracking<false> turns sentinel tracking off all the; /// time.); ///; /// A type can inherit from ilist_node multiple times by passing in different; /// \a ilist_tag options. This allows a single instance to be inserted into; /// multiple lists simultaneously, where each list is given the same tag.; ///; /// \example; /// struct A {};; /// struct B {};; /// struct N : ilist_node<N, ilist_tag<A>>, ilist_node<N, ilist_tag<B>> {};; ///; /// void foo() {; /// simple_ilist<N, ilist_tag<A>> ListA;; /// simple_ilist<N, ilist_tag<B>> ListB;; /// N N1;; /// ListA.push_back(N1);; /// ListB.push_back(N1);; /// }; /// \endexample; ///; /// See \a is_valid_option for steps on adding a new option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:249,Modifiability,config,configured,249,"/// An intrusive list node.; ///; /// A base class to enable membership in intrusive lists, including \a; /// simple_ilist, \a iplist, and \a ilist. The first template parameter is the; /// \a value_type for the list.; ///; /// An ilist node can be configured with compile-time options to change; /// behaviour and/or add API.; ///; /// By default, an \a ilist_node knows whether it is the list sentinel (an; /// instance of \a ilist_sentinel) if and only if; /// LLVM_ENABLE_ABI_BREAKING_CHECKS. The function \a isKnownSentinel() always; /// returns \c false tracking is off. Sentinel tracking steals a bit from the; /// ""prev"" link, which adds a mask operation when decrementing an iterator, but; /// enables bug-finding assertions in \a ilist_iterator.; ///; /// To turn sentinel tracking on all the time, pass in the; /// ilist_sentinel_tracking<true> template parameter. This also enables the \a; /// isSentinel() function. The same option must be passed to the intrusive; /// list. (ilist_sentinel_tracking<false> turns sentinel tracking off all the; /// time.); ///; /// A type can inherit from ilist_node multiple times by passing in different; /// \a ilist_tag options. This allows a single instance to be inserted into; /// multiple lists simultaneously, where each list is given the same tag.; ///; /// \example; /// struct A {};; /// struct B {};; /// struct N : ilist_node<N, ilist_tag<A>>, ilist_node<N, ilist_tag<B>> {};; ///; /// void foo() {; /// simple_ilist<N, ilist_tag<A>> ListA;; /// simple_ilist<N, ilist_tag<B>> ListB;; /// N N1;; /// ListA.push_back(N1);; /// ListB.push_back(N1);; /// }; /// \endexample; ///; /// See \a is_valid_option for steps on adding a new option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:1089,Modifiability,inherit,inherit,1089,"/// An intrusive list node.; ///; /// A base class to enable membership in intrusive lists, including \a; /// simple_ilist, \a iplist, and \a ilist. The first template parameter is the; /// \a value_type for the list.; ///; /// An ilist node can be configured with compile-time options to change; /// behaviour and/or add API.; ///; /// By default, an \a ilist_node knows whether it is the list sentinel (an; /// instance of \a ilist_sentinel) if and only if; /// LLVM_ENABLE_ABI_BREAKING_CHECKS. The function \a isKnownSentinel() always; /// returns \c false tracking is off. Sentinel tracking steals a bit from the; /// ""prev"" link, which adds a mask operation when decrementing an iterator, but; /// enables bug-finding assertions in \a ilist_iterator.; ///; /// To turn sentinel tracking on all the time, pass in the; /// ilist_sentinel_tracking<true> template parameter. This also enables the \a; /// isSentinel() function. The same option must be passed to the intrusive; /// list. (ilist_sentinel_tracking<false> turns sentinel tracking off all the; /// time.); ///; /// A type can inherit from ilist_node multiple times by passing in different; /// \a ilist_tag options. This allows a single instance to be inserted into; /// multiple lists simultaneously, where each list is given the same tag.; ///; /// \example; /// struct A {};; /// struct B {};; /// struct N : ilist_node<N, ilist_tag<A>>, ilist_node<N, ilist_tag<B>> {};; ///; /// void foo() {; /// simple_ilist<N, ilist_tag<A>> ListA;; /// simple_ilist<N, ilist_tag<B>> ListB;; /// N N1;; /// ListA.push_back(N1);; /// ListB.push_back(N1);; /// }; /// \endexample; ///; /// See \a is_valid_option for steps on adding a new option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:723,Testability,assert,assertions,723,"/// An intrusive list node.; ///; /// A base class to enable membership in intrusive lists, including \a; /// simple_ilist, \a iplist, and \a ilist. The first template parameter is the; /// \a value_type for the list.; ///; /// An ilist node can be configured with compile-time options to change; /// behaviour and/or add API.; ///; /// By default, an \a ilist_node knows whether it is the list sentinel (an; /// instance of \a ilist_sentinel) if and only if; /// LLVM_ENABLE_ABI_BREAKING_CHECKS. The function \a isKnownSentinel() always; /// returns \c false tracking is off. Sentinel tracking steals a bit from the; /// ""prev"" link, which adds a mask operation when decrementing an iterator, but; /// enables bug-finding assertions in \a ilist_iterator.; ///; /// To turn sentinel tracking on all the time, pass in the; /// ilist_sentinel_tracking<true> template parameter. This also enables the \a; /// isSentinel() function. The same option must be passed to the intrusive; /// list. (ilist_sentinel_tracking<false> turns sentinel tracking off all the; /// time.); ///; /// A type can inherit from ilist_node multiple times by passing in different; /// \a ilist_tag options. This allows a single instance to be inserted into; /// multiple lists simultaneously, where each list is given the same tag.; ///; /// \example; /// struct A {};; /// struct B {};; /// struct N : ilist_node<N, ilist_tag<A>>, ilist_node<N, ilist_tag<B>> {};; ///; /// void foo() {; /// simple_ilist<N, ilist_tag<A>> ListA;; /// simple_ilist<N, ilist_tag<B>> ListB;; /// N N1;; /// ListA.push_back(N1);; /// ListB.push_back(N1);; /// }; /// \endexample; ///; /// See \a is_valid_option for steps on adding a new option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:170,Modifiability,inherit,inherit,170,/// An access class for ilist_node private API.; ///; /// This gives access to the private parts of ilist nodes. Nodes for an ilist; /// should friend this class if they inherit privately from ilist_node.; ///; /// Using this class outside of the ilist implementation is unsupported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:7,Security,access,access,7,/// An access class for ilist_node private API.; ///; /// This gives access to the private parts of ilist nodes. Nodes for an ilist; /// should friend this class if they inherit privately from ilist_node.; ///; /// Using this class outside of the ilist implementation is unsupported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:69,Security,access,access,69,/// An access class for ilist_node private API.; ///; /// This gives access to the private parts of ilist nodes. Nodes for an ilist; /// should friend this class if they inherit privately from ilist_node.; ///; /// Using this class outside of the ilist implementation is unsupported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:27,Security,access,access,27,"/// An ilist node that can access its parent list.; ///; /// Requires \c NodeTy to have \a getParent() to find the parent node, and the; /// \c ParentTy to have \a getSublistAccess() to get a reference to the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:105,Availability,error,error,105,"/// Forward to NodeTy::getParent().; ///; /// Note: do not use the name ""getParent()"". We want a compile error; /// (instead of recursion) when the subclass fails to implement \a; /// getParent().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:24,Security,Access,Accessors,24,"/// @name Adjacent Node Accessors; /// @{; /// Get the previous node, or \c nullptr for the list head.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h:146,Integrability,depend,depends,146,"/// Option to choose whether to track sentinels.; ///; /// This option affects the ABI for the nodes. When not specified explicitly,; /// the ABI depends on LLVM_ENABLE_ABI_BREAKING_CHECKS. Specify explicitly to; /// enable \a ilist_node::isSentinel().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h:484,Modifiability,inherit,inherit,484,"/// Check whether an option is valid.; ///; /// The steps for adding and enabling a new ilist option include:; /// \li define the option, ilist_foo<Bar>, above;; /// \li add new parameters for Bar to \a ilist_detail::node_options;; /// \li add an extraction meta-function, ilist_detail::extract_foo;; /// \li call extract_foo from \a ilist_detail::compute_node_options and pass it; /// into \a ilist_detail::node_options; and; /// \li specialize \c is_valid_option<ilist_foo<Bar>> to inherit from \c; /// std::true_type to get static assertions passing in \a simple_ilist and \a; /// ilist_node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h:534,Testability,assert,assertions,534,"/// Check whether an option is valid.; ///; /// The steps for adding and enabling a new ilist option include:; /// \li define the option, ilist_foo<Bar>, above;; /// \li add new parameters for Bar to \a ilist_detail::node_options;; /// \li add an extraction meta-function, ilist_detail::extract_foo;; /// \li call extract_foo from \a ilist_detail::compute_node_options and pass it; /// into \a ilist_detail::node_options; and; /// \li specialize \c is_valid_option<ilist_foo<Bar>> to inherit from \c; /// std::true_type to get static assertions passing in \a simple_ilist and \a; /// ilist_node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h:137,Integrability,depend,depending,137,"/// Extract sentinel tracking option.; ///; /// Look through \p Options for the \a ilist_sentinel_tracking option, with the; /// default depending on LLVM_ENABLE_ABI_BREAKING_CHECKS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node_options.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h:54,Integrability,interface,interface,54,"//==--- ImmutableList.h - Immutable (functional) list interface --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the ImmutableList class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h:549,Deployability,release,released,549,"/// ImmutableList - This class represents an immutable (functional) list.; /// It is implemented as a smart pointer (wraps ImmutableListImpl), so it; /// it is intended to always be copied by value as if it were a pointer.; /// This interface matches ImmutableSet and ImmutableMap. ImmutableList; /// objects should almost never be created directly, and instead should; /// be created by ImmutableListFactory objects that manage the lifetime; /// of a group of lists. When the factory object is reclaimed, all lists; /// created by that factory are released as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h:117,Integrability,wrap,wraps,117,"/// ImmutableList - This class represents an immutable (functional) list.; /// It is implemented as a smart pointer (wraps ImmutableListImpl), so it; /// it is intended to always be copied by value as if it were a pointer.; /// This interface matches ImmutableSet and ImmutableMap. ImmutableList; /// objects should almost never be created directly, and instead should; /// be created by ImmutableListFactory objects that manage the lifetime; /// of a group of lists. When the factory object is reclaimed, all lists; /// created by that factory are released as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h:233,Integrability,interface,interface,233,"/// ImmutableList - This class represents an immutable (functional) list.; /// It is implemented as a smart pointer (wraps ImmutableListImpl), so it; /// it is intended to always be copied by value as if it were a pointer.; /// This interface matches ImmutableSet and ImmutableMap. ImmutableList; /// objects should almost never be created directly, and instead should; /// be created by ImmutableListFactory objects that manage the lifetime; /// of a group of lists. When the factory object is reclaimed, all lists; /// created by that factory are released as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h:59,Performance,cache,cache,59,// Profile the new list to see if it already exists in our cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h:34,Performance,cache,cache,34,// The list does not exist in our cache. Create it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h:32,Performance,cache,cache,32,// Insert the new list into the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableList.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h:53,Integrability,interface,interface,53,"//===--- ImmutableMap.h - Immutable (functional) map interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the ImmutableMap class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h:69,Testability,test,testing,69,//===--------------------------------------------------===//; // For testing.; //===--------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h:69,Testability,test,testing,69,//===--------------------------------------------------===//; // For testing.; //===--------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:53,Integrability,interface,interface,53,"//===--- ImmutableSet.h - Immutable (functional) set interface --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the ImutAVLTree and ImmutableSet classes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:74,Integrability,Interface,Interface,74,//===----------------------------------------------------===//; // Public Interface.; //===----------------------------------------------------===//; /// Return a pointer to the left subtree. This value; /// is NULL if there is no left subtree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:114,Performance,perform,performance,114,/// isEqual - Compares two trees for structural equality and returns true; /// if they are equal. This worst case performance of this operation is; // linear in the sizes of the trees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:63,Performance,Perform,Performance,63,/// isNotEqual - Compares two trees for structural inequality. Performance; /// is the same is isEqual.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:148,Testability,log,logarithmic,148,/// contains - Returns true if this tree contains a subtree (node) that; /// has an data element that matches the specified key. Complexity; /// is logarithmic in the size of the tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:4,Security,validat,validateTree,4,"/// validateTree - A utility method that checks that the balancing and; /// ordering invariants of the tree are satisfied. It is a recursive; /// method that returns the height of the tree, which is then consumed; /// by the enclosing validateTree call. External callers should ignore the; /// return value. An invalid tree will cause an assertion to fire in; /// a debug build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:235,Security,validat,validateTree,235,"/// validateTree - A utility method that checks that the balancing and; /// ordering invariants of the tree are satisfied. It is a recursive; /// method that returns the height of the tree, which is then consumed; /// by the enclosing validateTree call. External callers should ignore the; /// return value. An invalid tree will cause an assertion to fire in; /// a debug build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:338,Testability,assert,assertion,338,"/// validateTree - A utility method that checks that the balancing and; /// ordering invariants of the tree are satisfied. It is a recursive; /// method that returns the height of the tree, which is then consumed; /// by the enclosing validateTree call. External callers should ignore the; /// return value. An invalid tree will cause an assertion to fire in; /// a debug build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:66,Performance,cache,cached,66,/// hasCachedDigest - Returns true if the digest for this tree is cached.; /// This can only be true if the tree is immutable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:637,Availability,error,error,637,"//===----------------------------------------------------===//; // Mutating operations. A tree root can be manipulated as; // long as its reference has not ""escaped"" from internal; // methods of a factory object (see below). When a tree; // pointer is externally viewable by client code, the; // internal ""mutable bit"" is cleared to mark the tree; // immutable. Note that a tree that still has its mutable; // bit set may have children (subtrees) that are themselves; // immutable.; //===----------------------------------------------------===//; /// markImmutable - Clears the mutable flag for a tree. After this happens,; /// it is an error to call setLeft(), setRight(), and setHeight().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:322,Usability,clear,cleared,322,"//===----------------------------------------------------===//; // Mutating operations. A tree root can be manipulated as; // long as its reference has not ""escaped"" from internal; // methods of a factory object (see below). When a tree; // pointer is externally viewable by client code, the; // internal ""mutable bit"" is cleared to mark the tree; // immutable. Note that a tree that still has its mutable; // bit set may have children (subtrees) that are themselves; // immutable.; //===----------------------------------------------------===//; /// markImmutable - Clears the mutable flag for a tree. After this happens,; /// it is an error to call setLeft(), setRight(), and setHeight().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:567,Usability,Clear,Clears,567,"//===----------------------------------------------------===//; // Mutating operations. A tree root can be manipulated as; // long as its reference has not ""escaped"" from internal; // methods of a factory object (see below). When a tree; // pointer is externally viewable by client code, the; // internal ""mutable bit"" is cleared to mark the tree; // immutable. Note that a tree that still has its mutable; // bit set may have children (subtrees) that are themselves; // immutable.; //===----------------------------------------------------===//; /// markImmutable - Clears the mutable flag for a tree. After this happens,; /// it is an error to call setLeft(), setRight(), and setHeight().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:25,Usability,Clear,Clears,25,/// markedCachedDigest - Clears the NoCachedDigest flag for a tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:116,Availability,recover,recoverNodes,116,// We need to clear the mutability bit in case we are; // destroying the node as part of a sweep in ImutAVLFactory::recoverNodes().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:116,Safety,recover,recoverNodes,116,// We need to clear the mutability bit in case we are; // destroying the node as part of a sweep in ImutAVLFactory::recoverNodes().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:14,Usability,clear,clear,14,// We need to clear the mutability bit in case we are; // destroying the node as part of a sweep in ImutAVLFactory::recoverNodes().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:72,Integrability,interface,interface,72,//===--------------------------------------------------===//; // Public interface.; //===--------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:165,Usability,simpl,simply,165,"//===--------------------------------------------------===//; // ""createNode"" is used to generate new tree roots that link; // to other trees. The function may also simply move links; // in an existing root if that root is still marked mutable.; // This is necessary because otherwise our balancing code; // would leak memory as it would create nodes that are; // then discarded later before the finished tree is; // returned to the caller.; //===--------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:20,Usability,Clear,Clears,20,/// markImmutable - Clears the mutable bits of a root and all of its; /// descendants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:14,Security,hash,hashtable,14,"// Search the hashtable for another tree with the same digest, and; // if find a collision compare those trees by their contents.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:26,Integrability,wrap,wraps,26,/// Generic iterator that wraps a T::TreeTy::iterator and exposes; /// iterator::getValue() on dereference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:58,Security,expose,exposes,58,/// Generic iterator that wraps a T::TreeTy::iterator and exposes; /// iterator::getValue() on dereference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:229,Modifiability,inherit,inherit,229,"//===----------------------------------------------------------------------===//; // Trait classes that contain element comparison operators and type; // definitions used by ImutAVLTree, ImmutableSet, and ImmutableMap. These; // inherit from the profile traits (ImutProfileInfo) to include operations; // for element profiling.; //===----------------------------------------------------------------------===//; /// ImutContainerInfo - Generic definition of comparison operations for; /// elements of immutable containers that defaults to using; /// std::equal_to<> and std::less<> to perform comparison of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:584,Performance,perform,perform,584,"//===----------------------------------------------------------------------===//; // Trait classes that contain element comparison operators and type; // definitions used by ImutAVLTree, ImmutableSet, and ImmutableMap. These; // inherit from the profile traits (ImutProfileInfo) to include operations; // for element profiling.; //===----------------------------------------------------------------------===//; /// ImutContainerInfo - Generic definition of comparison operations for; /// elements of immutable containers that defaults to using; /// std::equal_to<> and std::less<> to perform comparison of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:408,Deployability,release,released,408,"/// add - Creates a new immutable set that contains all of the values; /// of the original set with the addition of the specified value. If; /// the original set already included the value, then the original set is; /// returned and no memory is allocated. The time and space complexity; /// of this operation is logarithmic in the size of the original set.; /// The memory allocated to represent the set is released when the; /// factory object that created the set is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:246,Energy Efficiency,allocate,allocated,246,"/// add - Creates a new immutable set that contains all of the values; /// of the original set with the addition of the specified value. If; /// the original set already included the value, then the original set is; /// returned and no memory is allocated. The time and space complexity; /// of this operation is logarithmic in the size of the original set.; /// The memory allocated to represent the set is released when the; /// factory object that created the set is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:374,Energy Efficiency,allocate,allocated,374,"/// add - Creates a new immutable set that contains all of the values; /// of the original set with the addition of the specified value. If; /// the original set already included the value, then the original set is; /// returned and no memory is allocated. The time and space complexity; /// of this operation is logarithmic in the size of the original set.; /// The memory allocated to represent the set is released when the; /// factory object that created the set is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:313,Testability,log,logarithmic,313,"/// add - Creates a new immutable set that contains all of the values; /// of the original set with the addition of the specified value. If; /// the original set already included the value, then the original set is; /// returned and no memory is allocated. The time and space complexity; /// of this operation is logarithmic in the size of the original set.; /// The memory allocated to represent the set is released when the; /// factory object that created the set is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:406,Deployability,release,released,406,"/// remove - Creates a new immutable set that contains all of the values; /// of the original set with the exception of the specified value. If; /// the original set did not contain the value, the original set is; /// returned and no memory is allocated. The time and space complexity; /// of this operation is logarithmic in the size of the original set.; /// The memory allocated to represent the set is released when the; /// factory object that created the set is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:244,Energy Efficiency,allocate,allocated,244,"/// remove - Creates a new immutable set that contains all of the values; /// of the original set with the exception of the specified value. If; /// the original set did not contain the value, the original set is; /// returned and no memory is allocated. The time and space complexity; /// of this operation is logarithmic in the size of the original set.; /// The memory allocated to represent the set is released when the; /// factory object that created the set is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:372,Energy Efficiency,allocate,allocated,372,"/// remove - Creates a new immutable set that contains all of the values; /// of the original set with the exception of the specified value. If; /// the original set did not contain the value, the original set is; /// returned and no memory is allocated. The time and space complexity; /// of this operation is logarithmic in the size of the original set.; /// The memory allocated to represent the set is released when the; /// factory object that created the set is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:311,Testability,log,logarithmic,311,"/// remove - Creates a new immutable set that contains all of the values; /// of the original set with the exception of the specified value. If; /// the original set did not contain the value, the original set is; /// returned and no memory is allocated. The time and space complexity; /// of this operation is logarithmic in the size of the original set.; /// The memory allocated to represent the set is released when the; /// factory object that created the set is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:69,Testability,test,testing,69,//===--------------------------------------------------===//; // For testing.; //===--------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:69,Testability,test,testing,69,//===--------------------------------------------------===//; // For testing.; //===--------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IndexedMap.h:128,Energy Efficiency,efficient,efficiently,128,// Prefer SmallVector with zero inline storage over std::vector. IndexedMaps; // can grow very large and SmallVector grows more efficiently as long as T; // is trivially copyable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IndexedMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IndexedMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntEqClasses.h:4,Usability,clear,clear,4,/// clear - Clear all classes so that grow() will assign a unique class to; /// every integer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntEqClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntEqClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntEqClasses.h:12,Usability,Clear,Clear,12,/// clear - Clear all classes so that grow() will assign a unique class to; /// every integer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntEqClasses.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntEqClasses.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:1463,Performance,optimiz,optimized,1463,"ed to ValT objects. Intervals of keys that map to the; /// same value are represented in a compressed form.; ///; /// Iterators provide ordered access to the compressed intervals rather than the; /// individual keys, and insert and erase operations use key intervals as well.; ///; /// Like SmallVector, IntervalMap will store the first N intervals in the map; /// object itself without any allocations. When space is exhausted it switches; /// to a B+-tree representation with very small overhead for small key and; /// value objects.; ///; /// A Traits class specifies how keys are compared. It also allows IntervalMap; /// to work with both closed and half-open intervals.; ///; /// Keys and values are not stored next to each other in a std::pair, so we; /// don't provide such a value_type. Dereferencing iterators only returns the; /// mapped value. The interval bounds are accessible through the start() and; /// stop() iterator methods.; ///; /// IntervalMap is optimized for small key and value objects, 4 or 8 bytes; /// each is the optimal size. For large objects use std::map instead.; //; //===----------------------------------------------------------------------===//; //; // Synopsis:; //; // template <typename KeyT, typename ValT, unsigned N, typename Traits>; // class IntervalMap {; // public:; // typedef KeyT key_type;; // typedef ValT mapped_type;; // typedef RecyclingAllocator<...> Allocator;; // class iterator;; // class const_iterator;; //; // explicit IntervalMap(Allocator&);; // ~IntervalMap():; //; // bool empty() const;; // KeyT start() const;; // KeyT stop() const;; // ValT lookup(KeyT x, Value NotFound = Value()) const;; //; // const_iterator begin() const;; // const_iterator end() const;; // iterator begin();; // iterator end();; // const_iterator find(KeyT x) const;; // iterator find(KeyT x);; //; // void insert(KeyT a, KeyT b, ValT y);; // void clear();; // };; //; // template <typename KeyT, typename ValT, unsigned N, typename Traits>; // class Interva",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:637,Security,access,access,637,"//===- llvm/ADT/IntervalMap.h - A sorted interval map -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a coalescing interval map for small objects.; ///; /// KeyT objects are mapped to ValT objects. Intervals of keys that map to the; /// same value are represented in a compressed form.; ///; /// Iterators provide ordered access to the compressed intervals rather than the; /// individual keys, and insert and erase operations use key intervals as well.; ///; /// Like SmallVector, IntervalMap will store the first N intervals in the map; /// object itself without any allocations. When space is exhausted it switches; /// to a B+-tree representation with very small overhead for small key and; /// value objects.; ///; /// A Traits class specifies how keys are compared. It also allows IntervalMap; /// to work with both closed and half-open intervals.; ///; /// Keys and values are not stored next to each other in a std::pair, so we; /// don't provide such a value_type. Dereferencing iterators only returns the; /// mapped value. The interval bounds are accessible through the start() and; /// stop() iterator methods.; ///; /// IntervalMap is optimized for small key and value objects, 4 or 8 bytes; /// each is the optimal size. For large objects use std::map instead.; //; //===----------------------------------------------------------------------===//; //; // Synopsis:; //; // template <typename KeyT, typename ValT, unsigned N, typename Traits>; // class IntervalMap {; // public:; // typedef KeyT key_type;; // typedef ValT mapped_type;; // typedef RecyclingAllocator<...> Allocator;; // class iterator;; // class const_iterator;; //; // explicit IntervalMap(Allocator&);; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:1373,Security,access,accessible,1373,"/// This file implements a coalescing interval map for small objects.; ///; /// KeyT objects are mapped to ValT objects. Intervals of keys that map to the; /// same value are represented in a compressed form.; ///; /// Iterators provide ordered access to the compressed intervals rather than the; /// individual keys, and insert and erase operations use key intervals as well.; ///; /// Like SmallVector, IntervalMap will store the first N intervals in the map; /// object itself without any allocations. When space is exhausted it switches; /// to a B+-tree representation with very small overhead for small key and; /// value objects.; ///; /// A Traits class specifies how keys are compared. It also allows IntervalMap; /// to work with both closed and half-open intervals.; ///; /// Keys and values are not stored next to each other in a std::pair, so we; /// don't provide such a value_type. Dereferencing iterators only returns the; /// mapped value. The interval bounds are accessible through the start() and; /// stop() iterator methods.; ///; /// IntervalMap is optimized for small key and value objects, 4 or 8 bytes; /// each is the optimal size. For large objects use std::map instead.; //; //===----------------------------------------------------------------------===//; //; // Synopsis:; //; // template <typename KeyT, typename ValT, unsigned N, typename Traits>; // class IntervalMap {; // public:; // typedef KeyT key_type;; // typedef ValT mapped_type;; // typedef RecyclingAllocator<...> Allocator;; // class iterator;; // class const_iterator;; //; // explicit IntervalMap(Allocator&);; // ~IntervalMap():; //; // bool empty() const;; // KeyT start() const;; // KeyT stop() const;; // ValT lookup(KeyT x, Value NotFound = Value()) const;; //; // const_iterator begin() const;; // const_iterator end() const;; // iterator begin();; // iterator end();; // const_iterator find(KeyT x) const;; // iterator find(KeyT x);; //; // void insert(KeyT a, KeyT b, ValT y);; // void clear();; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:2383,Usability,clear,clear,2383,":map instead.; //; //===----------------------------------------------------------------------===//; //; // Synopsis:; //; // template <typename KeyT, typename ValT, unsigned N, typename Traits>; // class IntervalMap {; // public:; // typedef KeyT key_type;; // typedef ValT mapped_type;; // typedef RecyclingAllocator<...> Allocator;; // class iterator;; // class const_iterator;; //; // explicit IntervalMap(Allocator&);; // ~IntervalMap():; //; // bool empty() const;; // KeyT start() const;; // KeyT stop() const;; // ValT lookup(KeyT x, Value NotFound = Value()) const;; //; // const_iterator begin() const;; // const_iterator end() const;; // iterator begin();; // iterator end();; // const_iterator find(KeyT x) const;; // iterator find(KeyT x);; //; // void insert(KeyT a, KeyT b, ValT y);; // void clear();; // };; //; // template <typename KeyT, typename ValT, unsigned N, typename Traits>; // class IntervalMap::const_iterator {; // public:; // using iterator_category = std::bidirectional_iterator_tag;; // using value_type = ValT;; // using difference_type = std::ptrdiff_t;; // using pointer = value_type *;; // using reference = value_type &;; //; // bool operator==(const const_iterator &) const;; // bool operator!=(const const_iterator &) const;; // bool valid() const;; //; // const KeyT &start() const;; // const KeyT &stop() const;; // const ValT &value() const;; // const ValT &operator*() const;; // const ValT *operator->() const;; //; // const_iterator &operator++();; // const_iterator &operator++(int);; // const_iterator &operator--();; // const_iterator &operator--(int);; // void goToBegin();; // void goToEnd();; // void find(KeyT x);; // void advanceTo(KeyT x);; // };; //; // template <typename KeyT, typename ValT, unsigned N, typename Traits>; // class IntervalMap::iterator : public const_iterator {; // public:; // void insert(KeyT a, KeyT b, Value y);; // void erase();; // };; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:704,Energy Efficiency,allocate,allocated,704,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeBase ---//; //===----------------------------------------------------------------------===//; //; // Both leaf and branch nodes store vectors of pairs.; // Leaves store ((KeyT, KeyT), ValT) pairs, branches use (NodeRef, KeyT).; //; // Keys and values are stored in separate arrays to avoid padding caused by; // different object alignments. This also helps improve locality of reference; // when searching the keys.; //; // The nodes don't know how many elements they contain - that information is; // stored elsewhere. Omitting the size field prevents padding and allows a node; // to fill the allocated cache lines completely.; //; // These are typical key and value sizes, the node branching factor (N), and; // wasted space when nodes are sized to fit in three cache lines (192 bytes):; //; // T1 T2 N Waste Used by; // 4 4 24 0 Branch<4> (32-bit pointers); // 8 4 16 0 Leaf<4,4>, Branch<4>; // 8 8 12 0 Leaf<4,8>, Branch<8>; // 16 4 9 12 Leaf<8,4>; // 16 8 8 0 Leaf<8,8>; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:714,Performance,cache,cache,714,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeBase ---//; //===----------------------------------------------------------------------===//; //; // Both leaf and branch nodes store vectors of pairs.; // Leaves store ((KeyT, KeyT), ValT) pairs, branches use (NodeRef, KeyT).; //; // Keys and values are stored in separate arrays to avoid padding caused by; // different object alignments. This also helps improve locality of reference; // when searching the keys.; //; // The nodes don't know how many elements they contain - that information is; // stored elsewhere. Omitting the size field prevents padding and allows a node; // to fill the allocated cache lines completely.; //; // These are typical key and value sizes, the node branching factor (N), and; // wasted space when nodes are sized to fit in three cache lines (192 bytes):; //; // T1 T2 N Waste Used by; // 4 4 24 0 Branch<4> (32-bit pointers); // 8 4 16 0 Leaf<4,4>, Branch<4>; // 8 8 12 0 Leaf<4,8>, Branch<8>; // 16 4 9 12 Leaf<8,4>; // 16 8 8 0 Leaf<8,8>; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:874,Performance,cache,cache,874,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeBase ---//; //===----------------------------------------------------------------------===//; //; // Both leaf and branch nodes store vectors of pairs.; // Leaves store ((KeyT, KeyT), ValT) pairs, branches use (NodeRef, KeyT).; //; // Keys and values are stored in separate arrays to avoid padding caused by; // different object alignments. This also helps improve locality of reference; // when searching the keys.; //; // The nodes don't know how many elements they contain - that information is; // stored elsewhere. Omitting the size field prevents padding and allows a node; // to fill the allocated cache lines completely.; //; // These are typical key and value sizes, the node branching factor (N), and; // wasted space when nodes are sized to fit in three cache lines (192 bytes):; //; // T1 T2 N Waste Used by; // 4 4 24 0 Branch<4> (32-bit pointers); // 8 4 16 0 Leaf<4,4>, Branch<4>; // 8 8 12 0 Leaf<4,8>, Branch<8>; // 16 4 9 12 Leaf<8,4>; // 16 8 8 0 Leaf<8,8>; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:393,Safety,avoid,avoid,393,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeBase ---//; //===----------------------------------------------------------------------===//; //; // Both leaf and branch nodes store vectors of pairs.; // Leaves store ((KeyT, KeyT), ValT) pairs, branches use (NodeRef, KeyT).; //; // Keys and values are stored in separate arrays to avoid padding caused by; // different object alignments. This also helps improve locality of reference; // when searching the keys.; //; // The nodes don't know how many elements they contain - that information is; // stored elsewhere. Omitting the size field prevents padding and allows a node; // to fill the allocated cache lines completely.; //; // These are typical key and value sizes, the node branching factor (N), and; // wasted space when nodes are sized to fit in three cache lines (192 bytes):; //; // T1 T2 N Waste Used by; // 4 4 24 0 Branch<4> (32-bit pointers); // 8 4 16 0 Leaf<4,4>, Branch<4>; // 8 8 12 0 Leaf<4,8>, Branch<8>; // 16 4 9 12 Leaf<8,4>; // 16 8 8 0 Leaf<8,8>; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:324,Performance,cache,cache,324,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeSizer ---//; //===----------------------------------------------------------------------===//; //; // Compute node sizes from key and value types.; //; // The branching factors are chosen to make nodes fit in three cache lines.; // This may not be possible if keys or values are very large. Such large objects; // are handled correctly, but a std::map would probably give better performance.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:488,Performance,perform,performance,488,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeSizer ---//; //===----------------------------------------------------------------------===//; //; // Compute node sizes from key and value types.; //; // The branching factors are chosen to make nodes fit in three cache lines.; // This may not be possible if keys or values are very large. Such large objects; // are handled correctly, but a std::map would probably give better performance.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Performance,Cache,Cache,3,// Cache line size. Most architectures have 32 or 64 byte cache lines.; // We use 64 bytes here because it provides good branching factors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:58,Performance,cache,cache,58,// Cache line size. Most architectures have 32 or 64 byte cache lines.; // We use 64 bytes here because it provides good branching factors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:77,Performance,cache,cache,77,"// Compute the leaf node branching factor that makes a node fit in three; // cache lines. The branching factor must be at least 3, or some B+-tree; // balancing algorithms won't work.; // LeafSize can't be larger than CacheLineBytes. This is required by the; // PointerIntPair used by NodeRef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:218,Performance,Cache,CacheLineBytes,218,"// Compute the leaf node branching factor that makes a node fit in three; // cache lines. The branching factor must be at least 3, or some B+-tree; // balancing algorithms won't work.; // LeafSize can't be larger than CacheLineBytes. This is required by the; // PointerIntPair used by NodeRef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:127,Performance,cache,cache,127,"// Now that we have the leaf branching factor, compute the actual allocation; // unit size by rounding up to a whole number of cache lines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:605,Availability,fault,faulting,605,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeRef ---//; //===----------------------------------------------------------------------===//; //; // B+-tree nodes can be leaves or branches, so we need a polymorphic node; // pointer that can point to both kinds.; //; // All nodes are cache line aligned and the low 6 bits of a node pointer are; // always 0. These bits are used to store the number of elements in the; // referenced node. Besides saving space, placing node sizes in the parents; // allow tree balancing algorithms to run without faulting cache lines for nodes; // that may not need to be modified.; //; // A NodeRef doesn't know whether it references a leaf node or a branch node.; // It is the responsibility of the caller to use the correct types.; //; // Nodes are never supposed to be empty, and it is invalid to store a node size; // of 0 in a NodeRef. The valid range of sizes is 1-64.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:263,Modifiability,polymorphi,polymorphic,263,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeRef ---//; //===----------------------------------------------------------------------===//; //; // B+-tree nodes can be leaves or branches, so we need a polymorphic node; // pointer that can point to both kinds.; //; // All nodes are cache line aligned and the low 6 bits of a node pointer are; // always 0. These bits are used to store the number of elements in the; // referenced node. Besides saving space, placing node sizes in the parents; // allow tree balancing algorithms to run without faulting cache lines for nodes; // that may not need to be modified.; //; // A NodeRef doesn't know whether it references a leaf node or a branch node.; // It is the responsibility of the caller to use the correct types.; //; // Nodes are never supposed to be empty, and it is invalid to store a node size; // of 0 in a NodeRef. The valid range of sizes is 1-64.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:344,Performance,cache,cache,344,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeRef ---//; //===----------------------------------------------------------------------===//; //; // B+-tree nodes can be leaves or branches, so we need a polymorphic node; // pointer that can point to both kinds.; //; // All nodes are cache line aligned and the low 6 bits of a node pointer are; // always 0. These bits are used to store the number of elements in the; // referenced node. Besides saving space, placing node sizes in the parents; // allow tree balancing algorithms to run without faulting cache lines for nodes; // that may not need to be modified.; //; // A NodeRef doesn't know whether it references a leaf node or a branch node.; // It is the responsibility of the caller to use the correct types.; //; // Nodes are never supposed to be empty, and it is invalid to store a node size; // of 0 in a NodeRef. The valid range of sizes is 1-64.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:614,Performance,cache,cache,614,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeRef ---//; //===----------------------------------------------------------------------===//; //; // B+-tree nodes can be leaves or branches, so we need a polymorphic node; // pointer that can point to both kinds.; //; // All nodes are cache line aligned and the low 6 bits of a node pointer are; // always 0. These bits are used to store the number of elements in the; // referenced node. Besides saving space, placing node sizes in the parents; // allow tree balancing algorithms to run without faulting cache lines for nodes; // that may not need to be modified.; //; // A NodeRef doesn't know whether it references a leaf node or a branch node.; // It is the responsibility of the caller to use the correct types.; //; // Nodes are never supposed to be empty, and it is invalid to store a node size; // of 0 in a NodeRef. The valid range of sizes is 1-64.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:20,Safety,Detect,Detect,20,/// operator bool - Detect a null ref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:14,Deployability,Update,Update,14,/// setSize - Update the node size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:76,Integrability,depend,depends,76,/// subtree - Access the i'th subtree reference in a branch node.; /// This depends on branch nodes storing the NodeRef array as their first; /// member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:14,Security,Access,Access,14,/// subtree - Access the i'th subtree reference in a branch node.; /// This depends on branch nodes storing the NodeRef array as their first; /// member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,Safety,safe,safeFind,4,"/// safeFind - Find an interval that is known to exist. This is the same as; /// findFrom except is it assumed that x is at least within range of the last; /// interval.; /// @param i Starting index for the search.; /// @param x Key to search for.; /// @return First index with !stopLess(key[i].stop, x), never size.; /// This is the first interval that can possibly contain x.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,Safety,safe,safeLookup,4,/// safeLookup - Lookup mapped value for a safe key.; /// It is assumed that x is within range of the last entry.; /// @param x Key to search for.; /// @param NotFound Value to return if x is not in any interval.; /// @return The mapped value at x or NotFound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:43,Safety,safe,safe,43,/// safeLookup - Lookup mapped value for a safe key.; /// It is assumed that x is within range of the last entry.; /// @param x Key to search for.; /// @param NotFound Value to return if x is not in any interval.; /// @return The mapped value at x or NotFound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Safety,Detect,Detect,3,// Detect overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:28,Safety,Detect,Detect,28,// We must insert before i. Detect overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:380,Availability,redundant,redundant,380,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::BranchNode ---//; //===----------------------------------------------------------------------===//; //; // A branch node stores references to 1--N subtrees all of the same height.; //; // The key array in a branch node holds the rightmost stop key of each subtree.; // It is redundant to store the last stop key since it can be found in the; // parent node, but doing so makes tree balancing a lot simpler.; //; // It is unusual for a branch node to only have one subtree, but it can happen; // in the root node if it is smaller than the normal nodes.; //; // When all of the leaf nodes from all the subtrees are concatenated, they must; // satisfy the same constraints as a single leaf node. They must be sorted,; // sane, and fully coalesced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:380,Safety,redund,redundant,380,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::BranchNode ---//; //===----------------------------------------------------------------------===//; //; // A branch node stores references to 1--N subtrees all of the same height.; //; // The key array in a branch node holds the rightmost stop key of each subtree.; // It is redundant to store the last stop key since it can be found in the; // parent node, but doing so makes tree balancing a lot simpler.; //; // It is unusual for a branch node to only have one subtree, but it can happen; // in the root node if it is smaller than the normal nodes.; //; // When all of the leaf nodes from all the subtrees are concatenated, they must; // satisfy the same constraints as a single leaf node. They must be sorted,; // sane, and fully coalesced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:503,Usability,simpl,simpler,503,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::BranchNode ---//; //===----------------------------------------------------------------------===//; //; // A branch node stores references to 1--N subtrees all of the same height.; //; // The key array in a branch node holds the rightmost stop key of each subtree.; // It is redundant to store the last stop key since it can be found in the; // parent node, but doing so makes tree balancing a lot simpler.; //; // It is unusual for a branch node to only have one subtree, but it can happen; // in the root node if it is smaller than the normal nodes.; //; // When all of the leaf nodes from all the subtrees are concatenated, they must; // satisfy the same constraints as a single leaf node. They must be sorted,; // sane, and fully coalesced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,Safety,safe,safeFind,4,"/// safeFind - Find a subtree that is known to exist. This is the same as; /// findFrom except is it assumed that x is in range.; /// @param i Starting index for the search.; /// @param x Key to search for.; /// @return First index with !stopLess(key[i], x), never size.; /// This is the first subtree that can possibly contain x.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,Safety,safe,safeLookup,4,"/// safeLookup - Get the subtree containing x, Assuming that x is in range.; /// @param x Key to search for.; /// @return Subtree containing x",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:8,Security,access,accessors,8,// Node accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:8,Security,access,accessors,8,// Leaf accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:120,Deployability,update,update,120,/// reset - Reset cached information about node(Level) from subtree(Level -1).; /// @param Level 1..height. The node to update after parent node changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:18,Performance,cache,cached,18,/// reset - Reset cached information about node(Level) from subtree(Level -1).; /// @param Level 1..height. The node to update after parent node changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:14,Usability,Clear,Clear,14,/// setRoot - Clear the path and set a new root node.; /// @param Node New root node.; /// @param Size New root size.; /// @param Offset Offset into root node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:154,Safety,avoid,avoid,154,///@{; /// NOTE: The moved-from or copied-from object's allocator needs to have a; /// lifetime equal to or exceeding the moved-to or copied-to object to avoid; /// undefined behaviour.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:19,Testability,assert,assertion,19,// Future-proofing assertion: this function assumes the IntervalMap; // constructor doesn't add any nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:19,Testability,assert,assertion,19,// Future-proofing assertion: this function assumes the IntervalMap; // constructor doesn't add any nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:11,Usability,clear,clear,11,// Calling clear deallocates memory and switches to rootLeaf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,Usability,clear,clear,4,/// clear - Remove all entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,Safety,unsafe,unsafeStart,4,/// unsafeStart - Writable access to start() for iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:27,Security,access,access,27,/// unsafeStart - Writable access to start() for iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,Safety,unsafe,unsafeStop,4,/// unsafeStop - Writable access to stop() for iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:26,Security,access,access,26,/// unsafeStop - Writable access to stop() for iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,Safety,unsafe,unsafeValue,4,/// unsafeValue - Writable access to value() for iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:27,Security,access,access,27,/// unsafeValue - Writable access to value() for iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:33,Usability,usab,usable,33,// Search towards the root for a usable subtree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:29,Usability,usab,usable,29,// The branch node at l+1 is usable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:25,Usability,usab,usable,25,// Is the level-1 Branch usable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Deployability,Update,Update,3,// Update keys in branch nodes as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:18,Deployability,Update,Update,18,/// setNodeStop - Update the stop key of the current node at level and above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:59,Deployability,update,update,59,"// There are no references to the root node, so nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Deployability,Update,Update,3,// Update nodes pointing to the current node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Deployability,Update,Update,3,// Update root separately since it has a different layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:7,Usability,simpl,simple,7,// Try simple root leaf insert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:32,Modifiability,extend,extend,32,// Check if this insertion will extend the node to the left.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:105,Modifiability,Extend,Extend,105,"// This insertion will coalesce with the last entry in SibLeaf. We can; // handle it in two ways:; // 1. Extend SibLeaf.stop to b and be done, or; // 2. Extend a to SibLeaf, erase the SibLeaf entry and continue.; // We prefer 1., but need 2 when coalescing to the right as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:153,Modifiability,Extend,Extend,153,"// This insertion will coalesce with the last entry in SibLeaf. We can; // handle it in two ways:; // 1. Extend SibLeaf.stop to b and be done, or; // 2. Extend a to SibLeaf, erase the SibLeaf entry and continue.; // We prefer 1., but need 2 when coalescing to the right as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:14,Modifiability,extend,extend,14,"// Easy, just extend SibLeaf and we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Deployability,Update,UpdateRoot,3,/* UpdateRoot= */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:44,Deployability,Update,Update,44,// No left sibling means we are at begin(). Update cached bound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:51,Performance,cache,cached,51,// No left sibling means we are at begin(). Update cached bound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:60,Deployability,update,update,60,"// When we are inserting at the end of a leaf node, we must update stops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:13,Deployability,update,update,13,"// Inserted, update offset and leaf size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:35,Deployability,update,update,35,"// Insert was the last node entry, update stops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Deployability,Update,Update,3,// Update rootBranchStart if we erased begin().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:33,Deployability,update,update,33,"// When we erase the last entry, update stop and move to a legal position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:11,Usability,clear,cleared,11,"// If this cleared the root, switch to height=0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:34,Deployability,update,update,34,"// If we removed the last branch, update stop and move to a legal pos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Deployability,Update,Update,3,// Update path cache for the new right sibling position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:15,Performance,cache,cache,15,// Update path cache for the new right sibling position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:17,Energy Efficiency,allocate,allocate,17,// Do we need to allocate a new node?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:38,Deployability,update,update,38,"// Elements have been rearranged, now update node sizes and stops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:415,Testability,Test,Test,415,"//===----------------------------------------------------------------------===//; //--- IntervalMapOverlaps ----//; //===----------------------------------------------------------------------===//; /// IntervalMapOverlaps - Iterate over the overlaps of mapped intervals in two; /// IntervalMaps. The maps may be different, but the KeyT and Traits types; /// should be the same.; ///; /// Typical uses:; ///; /// 1. Test for overlap:; /// bool overlap = IntervalMapOverlaps(a, b).valid();; ///; /// 2. Enumerate overlaps:; /// for (IntervalMapOverlaps I(a, b); I.valid() ; ++I) { ... }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:8,Security,access,access,8,/// a - access the left hand side in the overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:8,Security,access,access,8,/// b - access the right hand side in the overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:2718,Performance,optimiz,optimize,2718,"43),; // [50, 75] <- (5075), [10, 85] <- (1085); //; // The data represents a set of overlapping intervals:; //; // 30--35 39------------50 55----61; // 31------------------------56; // 12--------21 25------------41 49-------------65 71-----79; // 11----16 20-----30 36----------------54 60------70 74---- 80; // 15---------------------40 43--43 50--------------------75; // 10----------------------------------------------------------------------85; //; // The items are stored in a binary tree with each node storing:; //; // MP: A middle point.; // IL: All intervals whose left value are completely to the left of the middle; // point. They are sorted in ascending order by their beginning point.; // IR: All intervals whose right value are completely to the right of the; // middle point. They are sorted in descending order by their ending point.; // LS: Left subtree.; // RS: Right subtree.; //; // As IL and IR will contain the same intervals, in order to optimize space,; // instead of storing intervals on each node, we use two vectors that will; // contain the intervals described by IL and IR. Each node will contain an; // index into that vector (global bucket), to indicate the beginning of the; // intervals assigned to the node.; //; // The following is the output from print():; //; // 0: MP:43 IR [10,85] [31,56] [36,54] [39,50] [43,43]; // 0: MP:43 IL [10,85] [31,56] [36,54] [39,50] [43,43]; // 1: MP:25 IR [25,41] [15,40] [20,30]; // 1: MP:25 IL [15,40] [20,30] [25,41]; // 2: MP:15 IR [12,21] [11,16]; // 2: MP:15 IL [11,16] [12,21]; // 2: MP:36 IR []; // 2: MP:36 IL []; // 3: MP:31 IR [30,35]; // 3: MP:31 IL [30,35]; // 1: MP:61 IR [50,75] [60,70] [49,65] [55,61]; // 1: MP:61 IL [49,65] [50,75] [55,61] [60,70]; // 2: MP:74 IR [74,80] [71,79]; // 2: MP:74 IL [71,79] [74,80]; //; // with:; // 0: Root Node.; // MP: Middle point.; // IL: Intervals to the left (in ascending order by beginning point).; // IR: Intervals to the right (in descending order by ending point).; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:5065,Testability,test,tested,5065,"der by beginning point).; // IR: Intervals to the right (in descending order by ending point).; //; // Root; // |; // V; // +------------MP:43------------+; // | IL IR |; // | [10,85] [10,85] |; // LS | [31,56] [31,56] | RS; // | [36,54] [36,54] |; // | [39,50] [39,50] |; // | [43,43] [43,43] |; // V V; // +------------MP:25------------+ MP:61------------+; // | IL IR | IL IR |; // | [15,40] [25,41] | [49,65] [50,75] |; // LS | [20,30] [15,40] | RS [50,75] [60,70] | RS; // | [25,41] [20,30] | [55,61] [49,65] |; // | | [60,70] [55,61] |; // V V V; // MP:15 +-------MP:36 MP:74; // IL IR | IL IR IL IR; // [11,16] [12,21] LS | [] [] [71,79] [74,80]; // [12,21] [11,16] | [74,80] [71,79]; // V; // MP:31; // IL IR; // [30,35] [30,35]; //; // The creation of an interval tree is done in 2 steps:; // 1) Insert the interval items by calling; // void insert(PointT Left, PointT Right, ValueT Value);; // Left, Right: the interval left and right limits.; // Value: the data associated with that specific interval.; //; // 2) Create the interval tree by calling; // void create();; //; // Once the tree is created, it is switched to query mode.; // Query the tree by using iterators or container.; //; // a) Iterators over intervals overlapping the given point with very weak; // ordering guarantees.; // find_iterator begin(PointType Point) const;; // find_iterator end() const;; // Point: a target point to be tested for inclusion in any interval.; //; // b) Container:; // IntervalReferences getContaining(PointT Point);; // Point: a target point to be tested for inclusion in any interval.; // Returns vector with all the intervals containing the target point.; //; // The returned intervals are in their natural tree location. They can; // be sorted:; //; // static void sortIntervals(IntervalReferences &Intervals, Sorting Sort);; //; // Ability to print the constructed interval tree:; // void print(raw_ostream &OS, bool HexFormat = true);; // Display the associated data in hexadecimal format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:5209,Testability,test,tested,5209,"der by beginning point).; // IR: Intervals to the right (in descending order by ending point).; //; // Root; // |; // V; // +------------MP:43------------+; // | IL IR |; // | [10,85] [10,85] |; // LS | [31,56] [31,56] | RS; // | [36,54] [36,54] |; // | [39,50] [39,50] |; // | [43,43] [43,43] |; // V V; // +------------MP:25------------+ MP:61------------+; // | IL IR | IL IR |; // | [15,40] [25,41] | [49,65] [50,75] |; // LS | [20,30] [15,40] | RS [50,75] [60,70] | RS; // | [25,41] [20,30] | [55,61] [49,65] |; // | | [60,70] [55,61] |; // V V V; // MP:15 +-------MP:36 MP:74; // IL IR | IL IR IL IR; // [11,16] [12,21] LS | [] [] [71,79] [74,80]; // [12,21] [11,16] | [74,80] [71,79]; // V; // MP:31; // IL IR; // [30,35] [30,35]; //; // The creation of an interval tree is done in 2 steps:; // 1) Insert the interval items by calling; // void insert(PointT Left, PointT Right, ValueT Value);; // Left, Right: the interval left and right limits.; // Value: the data associated with that specific interval.; //; // 2) Create the interval tree by calling; // void create();; //; // Once the tree is created, it is switched to query mode.; // Query the tree by using iterators or container.; //; // a) Iterators over intervals overlapping the given point with very weak; // ordering guarantees.; // find_iterator begin(PointType Point) const;; // find_iterator end() const;; // Point: a target point to be tested for inclusion in any interval.; //; // b) Container:; // IntervalReferences getContaining(PointT Point);; // Point: a target point to be tested for inclusion in any interval.; // Returns vector with all the intervals containing the target point.; //; // The returned intervals are in their natural tree location. They can; // be sorted:; //; // static void sortIntervals(IntervalReferences &Intervals, Sorting Sort);; //; // Ability to print the constructed interval tree:; // void print(raw_ostream &OS, bool HexFormat = true);; // Display the associated data in hexadecimal format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:1078,Usability,clear,clear,1078,"// IntervalTree is a light tree data structure to hold intervals. It allows; // finding all intervals that overlap with any given point. At this time,; // it does not support any deletion or rebalancing operations.; //; // The IntervalTree is designed to be set up once, and then queried without; // any further additions.; //; // Synopsis:; // Closed intervals delimited by PointT objects are mapped to ValueT objects.; //; // Restrictions:; // PointT must be a fundamental type.; // ValueT must be a fundamental or pointer type.; //; // template <typename PointT, typename ValueT, typename DataT>; // class IntervalTree {; // public:; //; // IntervalTree();; // ~IntervalTree():; //; // using IntervalReferences = SmallVector<IntervalData *>;; //; // void create();; // void insert(PointT Left, PointT Right, ValueT Value);; //; // IntervalReferences getContaining(PointT Point);; // static void sortIntervals(IntervalReferences &Intervals, Sorting Sort);; //; // find_iterator begin(PointType Point) const;; // find_iterator end() const;; //; // bool empty() const;; // void clear();; //; // void print(raw_ostream &OS, bool HexFormat = true);; // };; //; //===----------------------------------------------------------------------===//; //; // In the below given dataset; //; // [a, b] <- (x); //; // 'a' and 'b' describe a range and 'x' the value for that interval.; //; // The following data are purely for illustrative purposes:; //; // [30, 35] <- (3035), [39, 50] <- (3950), [55, 61] <- (5561),; // [31, 56] <- (3156), [12, 21] <- (1221), [25, 41] <- (2541),; // [49, 65] <- (4965), [71, 79] <- (7179), [11, 16] <- (1116),; // [20, 30] <- (2030), [36, 54] <- (3654), [60, 70] <- (6070),; // [74, 80] <- (7480), [15, 40] <- (1540), [43, 43] <- (4343),; // [50, 75] <- (5075), [10, 85] <- (1085); //; // The data represents a set of overlapping intervals:; //; // 30--35 39------------50 55----61; // 31------------------------56; // 12--------21 25------------41 49-------------65 71-----79; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:125,Usability,clear,cleared,125,// Intervals to the right of middle point.; // Working vector used during the tree creation to sort the intervals. It is; // cleared once the tree is created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:16,Availability,avail,available,16,"// If there are available intervals that contain the reference point,; // traverse them; otherwise move to the left or right node, depending; // on the middle point value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:131,Integrability,depend,depending,131,"// If there are available intervals that contain the reference point,; // traverse them; otherwise move to the left or right node, depending; // on the middle point value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:77,Energy Efficiency,efficient,efficiently,77,"// Given a set of n intervals, construct a data structure so that; // we can efficiently retrieve all intervals overlapping another; // interval or point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:11,Usability,clear,clear,11,"// Save to clear this storage, as it used only to sort the intervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:2089,Deployability,Release,Release,2089,"cense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the RefCountedBase, ThreadSafeRefCountedBase, and; /// IntrusiveRefCntPtr classes.; ///; /// IntrusiveRefCntPtr is a smart pointer to an object which maintains a; /// reference count. (ThreadSafe)RefCountedBase is a mixin class that adds a; /// refcount member variable and methods for updating the refcount. An object; /// that inherits from (ThreadSafe)RefCountedBase deletes itself when its; /// refcount hits zero.; ///; /// For example:; ///; /// ```; /// class MyClass : public RefCountedBase<MyClass> {};; ///; /// void foo() {; /// // Constructing an IntrusiveRefCntPtr increases the pointee's refcount; /// // by 1 (from 0 in this case).; /// IntrusiveRefCntPtr<MyClass> Ptr1(new MyClass());; ///; /// // Copying an IntrusiveRefCntPtr increases the pointee's refcount by 1.; /// IntrusiveRefCntPtr<MyClass> Ptr2(Ptr1);; ///; /// // Constructing an IntrusiveRefCntPtr has no effect on the object's; /// // refcount. After a move, the moved-from pointer is null.; /// IntrusiveRefCntPtr<MyClass> Ptr3(std::move(Ptr1));; /// assert(Ptr1 == nullptr);; ///; /// // Clearing an IntrusiveRefCntPtr decreases the pointee's refcount by 1.; /// Ptr2.reset();; ///; /// // The object deletes itself when we return from the function, because; /// // Ptr3's destructor decrements its refcount to 0.; /// }; /// ```; ///; /// You can use IntrusiveRefCntPtr with isa<T>(), dyn_cast<T>(), etc.:; ///; /// ```; /// IntrusiveRefCntPtr<MyClass> Ptr(new MyClass());; /// OtherClass *Other = dyn_cast<OtherClass>(Ptr); // Ptr.get() not required; /// ```; ///; /// IntrusiveRefCntPtr works with any class that; ///; /// - inherits from (ThreadSafe)RefCountedBase,; /// - has Retain() and Release() methods, or; /// - specializes IntrusiveRefCntPtrInfo.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:675,Modifiability,variab,variable,675,"//==- llvm/ADT/IntrusiveRefCntPtr.h - Smart Refcounting Pointer --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the RefCountedBase, ThreadSafeRefCountedBase, and; /// IntrusiveRefCntPtr classes.; ///; /// IntrusiveRefCntPtr is a smart pointer to an object which maintains a; /// reference count. (ThreadSafe)RefCountedBase is a mixin class that adds a; /// refcount member variable and methods for updating the refcount. An object; /// that inherits from (ThreadSafe)RefCountedBase deletes itself when its; /// refcount hits zero.; ///; /// For example:; ///; /// ```; /// class MyClass : public RefCountedBase<MyClass> {};; ///; /// void foo() {; /// // Constructing an IntrusiveRefCntPtr increases the pointee's refcount; /// // by 1 (from 0 in this case).; /// IntrusiveRefCntPtr<MyClass> Ptr1(new MyClass());; ///; /// // Copying an IntrusiveRefCntPtr increases the pointee's refcount by 1.; /// IntrusiveRefCntPtr<MyClass> Ptr2(Ptr1);; ///; /// // Constructing an IntrusiveRefCntPtr has no effect on the object's; /// // refcount. After a move, the moved-from pointer is null.; /// IntrusiveRefCntPtr<MyClass> Ptr3(std::move(Ptr1));; /// assert(Ptr1 == nullptr);; ///; /// // Clearing an IntrusiveRefCntPtr decreases the pointee's refcount by 1.; /// Ptr2.reset();; ///; /// // The object deletes itself when we return from the function, because; /// // Ptr3's destructor decrements its refcount to 0.; /// }; /// ```; ///; /// You can use IntrusiveRefCntPtr with isa<T>(), dyn_cast<T>(), etc.:; ///; /// ```; /// IntrusiveRefCntPtr<MyClass> Ptr(new MyClass());; /// OtherClass *Other = dyn_cast<OtherClass>(Ptr); // Ptr.get() not required; /// ```; ///; /// IntrusiveRefCntPtr works with any c",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:743,Modifiability,inherit,inherits,743,"//==- llvm/ADT/IntrusiveRefCntPtr.h - Smart Refcounting Pointer --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the RefCountedBase, ThreadSafeRefCountedBase, and; /// IntrusiveRefCntPtr classes.; ///; /// IntrusiveRefCntPtr is a smart pointer to an object which maintains a; /// reference count. (ThreadSafe)RefCountedBase is a mixin class that adds a; /// refcount member variable and methods for updating the refcount. An object; /// that inherits from (ThreadSafe)RefCountedBase deletes itself when its; /// refcount hits zero.; ///; /// For example:; ///; /// ```; /// class MyClass : public RefCountedBase<MyClass> {};; ///; /// void foo() {; /// // Constructing an IntrusiveRefCntPtr increases the pointee's refcount; /// // by 1 (from 0 in this case).; /// IntrusiveRefCntPtr<MyClass> Ptr1(new MyClass());; ///; /// // Copying an IntrusiveRefCntPtr increases the pointee's refcount by 1.; /// IntrusiveRefCntPtr<MyClass> Ptr2(Ptr1);; ///; /// // Constructing an IntrusiveRefCntPtr has no effect on the object's; /// // refcount. After a move, the moved-from pointer is null.; /// IntrusiveRefCntPtr<MyClass> Ptr3(std::move(Ptr1));; /// assert(Ptr1 == nullptr);; ///; /// // Clearing an IntrusiveRefCntPtr decreases the pointee's refcount by 1.; /// Ptr2.reset();; ///; /// // The object deletes itself when we return from the function, because; /// // Ptr3's destructor decrements its refcount to 0.; /// }; /// ```; ///; /// You can use IntrusiveRefCntPtr with isa<T>(), dyn_cast<T>(), etc.:; ///; /// ```; /// IntrusiveRefCntPtr<MyClass> Ptr(new MyClass());; /// OtherClass *Other = dyn_cast<OtherClass>(Ptr); // Ptr.get() not required; /// ```; ///; /// IntrusiveRefCntPtr works with any c",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:2023,Modifiability,inherit,inherits,2023,"cense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the RefCountedBase, ThreadSafeRefCountedBase, and; /// IntrusiveRefCntPtr classes.; ///; /// IntrusiveRefCntPtr is a smart pointer to an object which maintains a; /// reference count. (ThreadSafe)RefCountedBase is a mixin class that adds a; /// refcount member variable and methods for updating the refcount. An object; /// that inherits from (ThreadSafe)RefCountedBase deletes itself when its; /// refcount hits zero.; ///; /// For example:; ///; /// ```; /// class MyClass : public RefCountedBase<MyClass> {};; ///; /// void foo() {; /// // Constructing an IntrusiveRefCntPtr increases the pointee's refcount; /// // by 1 (from 0 in this case).; /// IntrusiveRefCntPtr<MyClass> Ptr1(new MyClass());; ///; /// // Copying an IntrusiveRefCntPtr increases the pointee's refcount by 1.; /// IntrusiveRefCntPtr<MyClass> Ptr2(Ptr1);; ///; /// // Constructing an IntrusiveRefCntPtr has no effect on the object's; /// // refcount. After a move, the moved-from pointer is null.; /// IntrusiveRefCntPtr<MyClass> Ptr3(std::move(Ptr1));; /// assert(Ptr1 == nullptr);; ///; /// // Clearing an IntrusiveRefCntPtr decreases the pointee's refcount by 1.; /// Ptr2.reset();; ///; /// // The object deletes itself when we return from the function, because; /// // Ptr3's destructor decrements its refcount to 0.; /// }; /// ```; ///; /// You can use IntrusiveRefCntPtr with isa<T>(), dyn_cast<T>(), etc.:; ///; /// ```; /// IntrusiveRefCntPtr<MyClass> Ptr(new MyClass());; /// OtherClass *Other = dyn_cast<OtherClass>(Ptr); // Ptr.get() not required; /// ```; ///; /// IntrusiveRefCntPtr works with any class that; ///; /// - inherits from (ThreadSafe)RefCountedBase,; /// - has Retain() and Release() methods, or; /// - specializes IntrusiveRefCntPtrInfo.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:1445,Testability,assert,assert,1445,"cense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the RefCountedBase, ThreadSafeRefCountedBase, and; /// IntrusiveRefCntPtr classes.; ///; /// IntrusiveRefCntPtr is a smart pointer to an object which maintains a; /// reference count. (ThreadSafe)RefCountedBase is a mixin class that adds a; /// refcount member variable and methods for updating the refcount. An object; /// that inherits from (ThreadSafe)RefCountedBase deletes itself when its; /// refcount hits zero.; ///; /// For example:; ///; /// ```; /// class MyClass : public RefCountedBase<MyClass> {};; ///; /// void foo() {; /// // Constructing an IntrusiveRefCntPtr increases the pointee's refcount; /// // by 1 (from 0 in this case).; /// IntrusiveRefCntPtr<MyClass> Ptr1(new MyClass());; ///; /// // Copying an IntrusiveRefCntPtr increases the pointee's refcount by 1.; /// IntrusiveRefCntPtr<MyClass> Ptr2(Ptr1);; ///; /// // Constructing an IntrusiveRefCntPtr has no effect on the object's; /// // refcount. After a move, the moved-from pointer is null.; /// IntrusiveRefCntPtr<MyClass> Ptr3(std::move(Ptr1));; /// assert(Ptr1 == nullptr);; ///; /// // Clearing an IntrusiveRefCntPtr decreases the pointee's refcount by 1.; /// Ptr2.reset();; ///; /// // The object deletes itself when we return from the function, because; /// // Ptr3's destructor decrements its refcount to 0.; /// }; /// ```; ///; /// You can use IntrusiveRefCntPtr with isa<T>(), dyn_cast<T>(), etc.:; ///; /// ```; /// IntrusiveRefCntPtr<MyClass> Ptr(new MyClass());; /// OtherClass *Other = dyn_cast<OtherClass>(Ptr); // Ptr.get() not required; /// ```; ///; /// IntrusiveRefCntPtr works with any class that; ///; /// - inherits from (ThreadSafe)RefCountedBase,; /// - has Retain() and Release() methods, or; /// - specializes IntrusiveRefCntPtrInfo.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:1483,Usability,Clear,Clearing,1483,"cense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the RefCountedBase, ThreadSafeRefCountedBase, and; /// IntrusiveRefCntPtr classes.; ///; /// IntrusiveRefCntPtr is a smart pointer to an object which maintains a; /// reference count. (ThreadSafe)RefCountedBase is a mixin class that adds a; /// refcount member variable and methods for updating the refcount. An object; /// that inherits from (ThreadSafe)RefCountedBase deletes itself when its; /// refcount hits zero.; ///; /// For example:; ///; /// ```; /// class MyClass : public RefCountedBase<MyClass> {};; ///; /// void foo() {; /// // Constructing an IntrusiveRefCntPtr increases the pointee's refcount; /// // by 1 (from 0 in this case).; /// IntrusiveRefCntPtr<MyClass> Ptr1(new MyClass());; ///; /// // Copying an IntrusiveRefCntPtr increases the pointee's refcount by 1.; /// IntrusiveRefCntPtr<MyClass> Ptr2(Ptr1);; ///; /// // Constructing an IntrusiveRefCntPtr has no effect on the object's; /// // refcount. After a move, the moved-from pointer is null.; /// IntrusiveRefCntPtr<MyClass> Ptr3(std::move(Ptr1));; /// assert(Ptr1 == nullptr);; ///; /// // Clearing an IntrusiveRefCntPtr decreases the pointee's refcount by 1.; /// Ptr2.reset();; ///; /// // The object deletes itself when we return from the function, because; /// // Ptr3's destructor decrements its refcount to 0.; /// }; /// ```; ///; /// You can use IntrusiveRefCntPtr with isa<T>(), dyn_cast<T>(), etc.:; ///; /// ```; /// IntrusiveRefCntPtr<MyClass> Ptr(new MyClass());; /// OtherClass *Other = dyn_cast<OtherClass>(Ptr); // Ptr.get() not required; /// ```; ///; /// IntrusiveRefCntPtr works with any class that; ///; /// - inherits from (ThreadSafe)RefCountedBase,; /// - has Retain() and Release() methods, or; /// - specializes IntrusiveRefCntPtrInfo.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:162,Deployability,Release,Release,162,"/// A CRTP mixin class that adds reference counting to a type.; ///; /// The lifetime of an object which inherits from RefCountedBase is managed by; /// calls to Release() and Retain(), which increment and decrement the object's; /// refcount, respectively. When a Release() call decrements the refcount to 0,; /// the object deletes itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:265,Deployability,Release,Release,265,"/// A CRTP mixin class that adds reference counting to a type.; ///; /// The lifetime of an object which inherits from RefCountedBase is managed by; /// calls to Release() and Retain(), which increment and decrement the object's; /// refcount, respectively. When a Release() call decrements the refcount to 0,; /// the object deletes itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:105,Modifiability,inherit,inherits,105,"/// A CRTP mixin class that adds reference counting to a type.; ///; /// The lifetime of an object which inherits from RefCountedBase is managed by; /// calls to Release() and Retain(), which increment and decrement the object's; /// refcount, respectively. When a Release() call decrements the refcount to 0,; /// the object deletes itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:29,Deployability,release,release,29,"// Default the destructor in release builds, A trivial destructor may enable; // better codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:13,Safety,safe,safe,13,/// A thread-safe version of \c RefCountedBase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:29,Deployability,release,release,29,"// Default the destructor in release builds, A trivial destructor may enable; // better codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:54,Deployability,release,release,54,"/// Class you can specialize to provide custom retain/release functionality for; /// a type.; ///; /// Usually specializing this class is not necessary, as IntrusiveRefCntPtr; /// works with any type which defines Retain() and Release() functions -- you; /// can define those functions yourself if RefCountedBase doesn't work for you.; ///; /// One case when you might want to specialize this type is if you have; /// - Foo.h defines type Foo and includes Bar.h, and; /// - Bar.h uses IntrusiveRefCntPtr<Foo> in inline functions.; ///; /// Because Foo.h includes Bar.h, Bar.h can't include Foo.h in order to pull in; /// the declaration of Foo. Without the declaration of Foo, normally Bar.h; /// wouldn't be able to use IntrusiveRefCntPtr<Foo>, which wants to call; /// T::Retain and T::Release.; ///; /// To resolve this, Bar.h could include a third header, FooFwd.h, which; /// forward-declares Foo and specializes IntrusiveRefCntPtrInfo<Foo>. Then; /// Bar.h could use IntrusiveRefCntPtr<Foo>, although it still couldn't call any; /// functions on Foo itself, because Foo would be an incomplete type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:227,Deployability,Release,Release,227,"/// Class you can specialize to provide custom retain/release functionality for; /// a type.; ///; /// Usually specializing this class is not necessary, as IntrusiveRefCntPtr; /// works with any type which defines Retain() and Release() functions -- you; /// can define those functions yourself if RefCountedBase doesn't work for you.; ///; /// One case when you might want to specialize this type is if you have; /// - Foo.h defines type Foo and includes Bar.h, and; /// - Bar.h uses IntrusiveRefCntPtr<Foo> in inline functions.; ///; /// Because Foo.h includes Bar.h, Bar.h can't include Foo.h in order to pull in; /// the declaration of Foo. Without the declaration of Foo, normally Bar.h; /// wouldn't be able to use IntrusiveRefCntPtr<Foo>, which wants to call; /// T::Retain and T::Release.; ///; /// To resolve this, Bar.h could include a third header, FooFwd.h, which; /// forward-declares Foo and specializes IntrusiveRefCntPtrInfo<Foo>. Then; /// Bar.h could use IntrusiveRefCntPtr<Foo>, although it still couldn't call any; /// functions on Foo itself, because Foo would be an incomplete type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:788,Deployability,Release,Release,788,"/// Class you can specialize to provide custom retain/release functionality for; /// a type.; ///; /// Usually specializing this class is not necessary, as IntrusiveRefCntPtr; /// works with any type which defines Retain() and Release() functions -- you; /// can define those functions yourself if RefCountedBase doesn't work for you.; ///; /// One case when you might want to specialize this type is if you have; /// - Foo.h defines type Foo and includes Bar.h, and; /// - Bar.h uses IntrusiveRefCntPtr<Foo> in inline functions.; ///; /// Because Foo.h includes Bar.h, Bar.h can't include Foo.h in order to pull in; /// the declaration of Foo. Without the declaration of Foo, normally Bar.h; /// wouldn't be able to use IntrusiveRefCntPtr<Foo>, which wants to call; /// T::Retain and T::Release.; ///; /// To resolve this, Bar.h could include a third header, FooFwd.h, which; /// forward-declares Foo and specializes IntrusiveRefCntPtrInfo<Foo>. Then; /// Bar.h could use IntrusiveRefCntPtr<Foo>, although it still couldn't call any; /// functions on Foo itself, because Foo would be an incomplete type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:55,Modifiability,inherit,inherits,55,"/// A smart pointer to a reference-counted object that inherits from; /// RefCountedBase or ThreadSafeRefCountedBase.; ///; /// This class increments its pointee's reference count when it is created, and; /// decrements its refcount when it's destroyed (or is changed to point to a; /// different object).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:114,Integrability,interface,interface,114,"/// CRTP base class which implements the entire standard iterator facade; /// in terms of a minimal subset of the interface.; ///; /// Use this when it is reasonable to implement most of the iterator; /// functionality in terms of a core subset. If you need special behavior or; /// there are performance implications for this, you may want to override the; /// relevant members instead.; ///; /// Note, one abstraction that this does *not* provide is implementing; /// subtraction in terms of addition by negating the difference. Negation isn't; /// always information preserving, and I can see very reasonable iterator; /// designs where this doesn't work well. It doesn't really force much added; /// boilerplate anyways.; ///; /// Another abstraction that this doesn't provide is implementing increment in; /// terms of addition of one. These aren't equivalent for all iterator; /// categories, and respecting that adds a lot of complexity for little gain.; ///; /// Iterators are expected to have const rules analogous to pointers, with a; /// single, const-qualified operator*() that returns ReferenceT. This matches; /// the second and third pointers in the following example:; /// \code; /// int Value;; /// { int *I = &Value; } // ReferenceT 'int&'; /// { int *const I = &Value; } // ReferenceT 'int&'; const; /// { const int *I = &Value; } // ReferenceT 'const int&'; /// { const int *const I = &Value; } // ReferenceT 'const int&'; const; /// \endcode; /// If an iterator facade returns a handle to its own state, then T (and; /// PointerT and ReferenceT) should usually be const-qualified. Otherwise, if; /// clients are expected to modify the handle itself, the field can be declared; /// mutable or use const_cast.; ///; /// Classes wishing to use `iterator_facade_base` should implement the following; /// methods:; ///; /// Forward Iterators:; /// (All of the following methods); /// - DerivedT &operator=(const DerivedT &R);; /// - bool operator==(const DerivedT &R) const;; /// - T &",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:293,Performance,perform,performance,293,"/// CRTP base class which implements the entire standard iterator facade; /// in terms of a minimal subset of the interface.; ///; /// Use this when it is reasonable to implement most of the iterator; /// functionality in terms of a core subset. If you need special behavior or; /// there are performance implications for this, you may want to override the; /// relevant members instead.; ///; /// Note, one abstraction that this does *not* provide is implementing; /// subtraction in terms of addition by negating the difference. Negation isn't; /// always information preserving, and I can see very reasonable iterator; /// designs where this doesn't work well. It doesn't really force much added; /// boilerplate anyways.; ///; /// Another abstraction that this doesn't provide is implementing increment in; /// terms of addition of one. These aren't equivalent for all iterator; /// categories, and respecting that adds a lot of complexity for little gain.; ///; /// Iterators are expected to have const rules analogous to pointers, with a; /// single, const-qualified operator*() that returns ReferenceT. This matches; /// the second and third pointers in the following example:; /// \code; /// int Value;; /// { int *I = &Value; } // ReferenceT 'int&'; /// { int *const I = &Value; } // ReferenceT 'int&'; const; /// { const int *I = &Value; } // ReferenceT 'const int&'; /// { const int *const I = &Value; } // ReferenceT 'const int&'; const; /// \endcode; /// If an iterator facade returns a handle to its own state, then T (and; /// PointerT and ReferenceT) should usually be const-qualified. Otherwise, if; /// clients are expected to modify the handle itself, the field can be declared; /// mutable or use const_cast.; ///; /// Classes wishing to use `iterator_facade_base` should implement the following; /// methods:; ///; /// Forward Iterators:; /// (All of the following methods); /// - DerivedT &operator=(const DerivedT &R);; /// - bool operator==(const DerivedT &R) const;; /// - T &",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:2194,Security,access,access,2194,"nd I can see very reasonable iterator; /// designs where this doesn't work well. It doesn't really force much added; /// boilerplate anyways.; ///; /// Another abstraction that this doesn't provide is implementing increment in; /// terms of addition of one. These aren't equivalent for all iterator; /// categories, and respecting that adds a lot of complexity for little gain.; ///; /// Iterators are expected to have const rules analogous to pointers, with a; /// single, const-qualified operator*() that returns ReferenceT. This matches; /// the second and third pointers in the following example:; /// \code; /// int Value;; /// { int *I = &Value; } // ReferenceT 'int&'; /// { int *const I = &Value; } // ReferenceT 'int&'; const; /// { const int *I = &Value; } // ReferenceT 'const int&'; /// { const int *const I = &Value; } // ReferenceT 'const int&'; const; /// \endcode; /// If an iterator facade returns a handle to its own state, then T (and; /// PointerT and ReferenceT) should usually be const-qualified. Otherwise, if; /// clients are expected to modify the handle itself, the field can be declared; /// mutable or use const_cast.; ///; /// Classes wishing to use `iterator_facade_base` should implement the following; /// methods:; ///; /// Forward Iterators:; /// (All of the following methods); /// - DerivedT &operator=(const DerivedT &R);; /// - bool operator==(const DerivedT &R) const;; /// - T &operator*() const;; /// - DerivedT &operator++();; ///; /// Bidirectional Iterators:; /// (All methods of forward iterators, plus the following); /// - DerivedT &operator--();; ///; /// Random-access Iterators:; /// (All methods of bidirectional iterators excluding the following); /// - DerivedT &operator++();; /// - DerivedT &operator--();; /// (and plus the following); /// - bool operator<(const DerivedT &RHS) const;; /// - DifferenceTypeT operator-(const DerivedT &R) const;; /// - DerivedT &operator+=(DifferenceTypeT N);; /// - DerivedT &operator-=(DifferenceTypeT N);; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:274,Security,expose,exposes,274,/// A proxy object for computing a reference via indirecting a copy of an; /// iterator. This is used in APIs which need to produce a reference via; /// indirection but for which the iterator object might be a temporary. The; /// proxy preserves the iterator internally and exposes the indirected; /// reference via a conversion operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:249,Security,expose,exposes,249,/// A proxy object for computing a pointer via indirecting a copy of a; /// reference. This is used in APIs which need to produce a pointer but for; /// which the reference might be a temporary. The proxy preserves the; /// reference internally and exposes the pointer via a arrow operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:24,Energy Efficiency,adapt,adapting,24,/// CRTP base class for adapting an iterator to a different type.; ///; /// This class can be used through CRTP to adapt one iterator into another.; /// Typically this is done through providing in the derived class a custom \c; /// operator* implementation. Other methods can be overridden as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:115,Energy Efficiency,adapt,adapt,115,/// CRTP base class for adapting an iterator to a different type.; ///; /// This class can be used through CRTP to adapt one iterator into another.; /// Typically this is done through providing in the derived class a custom \c; /// operator* implementation. Other methods can be overridden as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:24,Modifiability,adapt,adapting,24,/// CRTP base class for adapting an iterator to a different type.; ///; /// This class can be used through CRTP to adapt one iterator into another.; /// Typically this is done through providing in the derived class a custom \c; /// operator* implementation. Other methods can be overridden as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:115,Modifiability,adapt,adapt,115,/// CRTP base class for adapting an iterator to a different type.; ///; /// This class can be used through CRTP to adapt one iterator into another.; /// Typically this is done through providing in the derived class a custom \c; /// operator* implementation. Other methods can be overridden as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:100,Integrability,Wrap,WrappedIteratorT,100,// We have to explicitly provide ++ and -- rather than letting the facade; // forward to += because WrappedIteratorT might not support +=.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:133,Security,expose,expose,133,"/// An iterator type that allows iterating over the pointees via some; /// other iterator.; ///; /// The typical usage of this is to expose a type that iterates over Ts, but; /// which is implemented with some iterator over T*s:; ///; /// \code; /// using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h:34,Energy Efficiency,adapt,adaptor,34,"//===- iterator_range.h - A range adaptor for iterators ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This provides a very simple, boring adaptor for a begin and end iterator; /// into a range type. This should be used to build range views that work well; /// with range based for loops and range based constructors.; ///; /// Note that code here follows more standards-based coding conventions as it; /// is mirroring proposed interfaces for standardization.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h:427,Energy Efficiency,adapt,adaptor,427,"//===- iterator_range.h - A range adaptor for iterators ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This provides a very simple, boring adaptor for a begin and end iterator; /// into a range type. This should be used to build range views that work well; /// with range based for loops and range based constructors.; ///; /// Note that code here follows more standards-based coding conventions as it; /// is mirroring proposed interfaces for standardization.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h:717,Integrability,interface,interfaces,717,"//===- iterator_range.h - A range adaptor for iterators ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This provides a very simple, boring adaptor for a begin and end iterator; /// into a range type. This should be used to build range views that work well; /// with range based for loops and range based constructors.; ///; /// Note that code here follows more standards-based coding conventions as it; /// is mirroring proposed interfaces for standardization.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h:34,Modifiability,adapt,adaptor,34,"//===- iterator_range.h - A range adaptor for iterators ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This provides a very simple, boring adaptor for a begin and end iterator; /// into a range type. This should be used to build range views that work well; /// with range based for loops and range based constructors.; ///; /// Note that code here follows more standards-based coding conventions as it; /// is mirroring proposed interfaces for standardization.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h:427,Modifiability,adapt,adaptor,427,"//===- iterator_range.h - A range adaptor for iterators ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This provides a very simple, boring adaptor for a begin and end iterator; /// into a range type. This should be used to build range views that work well; /// with range based for loops and range based constructors.; ///; /// Note that code here follows more standards-based coding conventions as it; /// is mirroring proposed interfaces for standardization.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h:412,Usability,simpl,simple,412,"//===- iterator_range.h - A range adaptor for iterators ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This provides a very simple, boring adaptor for a begin and end iterator; /// into a range type. This should be used to build range views that work well; /// with range based for loops and range based constructors.; ///; /// Note that code here follows more standards-based coding conventions as it; /// is mirroring proposed interfaces for standardization.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator_range.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:61,Performance,concurren,concurrent,61,"/// Atomic pointer that's lock-free, but that can coordinate concurrent writes; /// from a lazy generator. Should be reserved for cases where concurrent uses of; /// a generator for the same storage is unlikely.; ///; /// The laziness comes in with \a loadOrGenerate(), which lazily calls the; /// provided generator ONLY when the value is currently \c nullptr. With; /// concurrent calls, only one generator is called and the rest see that value.; ///; /// Most other APIs treat an in-flight \a loadOrGenerate() as if \c nullptr; /// were stored. APIs that are required to write a value will spin.; ///; /// The underlying storage is \a std::atomic<uintptr_t>.; ///; /// TODO: In C++20, use std::atomic<T>::wait() instead of spinning and call; /// std::atomic<T>::notify_all() in \a loadOrGenerate().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:142,Performance,concurren,concurrent,142,"/// Atomic pointer that's lock-free, but that can coordinate concurrent writes; /// from a lazy generator. Should be reserved for cases where concurrent uses of; /// a generator for the same storage is unlikely.; ///; /// The laziness comes in with \a loadOrGenerate(), which lazily calls the; /// provided generator ONLY when the value is currently \c nullptr. With; /// concurrent calls, only one generator is called and the rest see that value.; ///; /// Most other APIs treat an in-flight \a loadOrGenerate() as if \c nullptr; /// were stored. APIs that are required to write a value will spin.; ///; /// The underlying storage is \a std::atomic<uintptr_t>.; ///; /// TODO: In C++20, use std::atomic<T>::wait() instead of spinning and call; /// std::atomic<T>::notify_all() in \a loadOrGenerate().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:252,Performance,load,loadOrGenerate,252,"/// Atomic pointer that's lock-free, but that can coordinate concurrent writes; /// from a lazy generator. Should be reserved for cases where concurrent uses of; /// a generator for the same storage is unlikely.; ///; /// The laziness comes in with \a loadOrGenerate(), which lazily calls the; /// provided generator ONLY when the value is currently \c nullptr. With; /// concurrent calls, only one generator is called and the rest see that value.; ///; /// Most other APIs treat an in-flight \a loadOrGenerate() as if \c nullptr; /// were stored. APIs that are required to write a value will spin.; ///; /// The underlying storage is \a std::atomic<uintptr_t>.; ///; /// TODO: In C++20, use std::atomic<T>::wait() instead of spinning and call; /// std::atomic<T>::notify_all() in \a loadOrGenerate().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:372,Performance,concurren,concurrent,372,"/// Atomic pointer that's lock-free, but that can coordinate concurrent writes; /// from a lazy generator. Should be reserved for cases where concurrent uses of; /// a generator for the same storage is unlikely.; ///; /// The laziness comes in with \a loadOrGenerate(), which lazily calls the; /// provided generator ONLY when the value is currently \c nullptr. With; /// concurrent calls, only one generator is called and the rest see that value.; ///; /// Most other APIs treat an in-flight \a loadOrGenerate() as if \c nullptr; /// were stored. APIs that are required to write a value will spin.; ///; /// The underlying storage is \a std::atomic<uintptr_t>.; ///; /// TODO: In C++20, use std::atomic<T>::wait() instead of spinning and call; /// std::atomic<T>::notify_all() in \a loadOrGenerate().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:496,Performance,load,loadOrGenerate,496,"/// Atomic pointer that's lock-free, but that can coordinate concurrent writes; /// from a lazy generator. Should be reserved for cases where concurrent uses of; /// a generator for the same storage is unlikely.; ///; /// The laziness comes in with \a loadOrGenerate(), which lazily calls the; /// provided generator ONLY when the value is currently \c nullptr. With; /// concurrent calls, only one generator is called and the rest see that value.; ///; /// Most other APIs treat an in-flight \a loadOrGenerate() as if \c nullptr; /// were stored. APIs that are required to write a value will spin.; ///; /// The underlying storage is \a std::atomic<uintptr_t>.; ///; /// TODO: In C++20, use std::atomic<T>::wait() instead of spinning and call; /// std::atomic<T>::notify_all() in \a loadOrGenerate().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:784,Performance,load,loadOrGenerate,784,"/// Atomic pointer that's lock-free, but that can coordinate concurrent writes; /// from a lazy generator. Should be reserved for cases where concurrent uses of; /// a generator for the same storage is unlikely.; ///; /// The laziness comes in with \a loadOrGenerate(), which lazily calls the; /// provided generator ONLY when the value is currently \c nullptr. With; /// concurrent calls, only one generator is called and the rest see that value.; ///; /// Most other APIs treat an in-flight \a loadOrGenerate() as if \c nullptr; /// were stored. APIs that are required to write a value will spin.; ///; /// The underlying storage is \a std::atomic<uintptr_t>.; ///; /// TODO: In C++20, use std::atomic<T>::wait() instead of spinning and call; /// std::atomic<T>::notify_all() in \a loadOrGenerate().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:29,Performance,concurren,concurrent,29,/// Store a value. Waits for concurrent \a loadOrGenerate() calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:43,Performance,load,loadOrGenerate,43,/// Store a value. Waits for concurrent \a loadOrGenerate() calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:49,Performance,concurren,concurrent,49,/// Set a value. Return the old value. Waits for concurrent \a; /// loadOrGenerate() calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:68,Performance,load,loadOrGenerate,68,/// Set a value. Return the old value. Waits for concurrent \a; /// loadOrGenerate() calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:53,Performance,concurren,concurrent,53,"/// Compare-exchange. Returns \c false if there is a concurrent \a; /// loadOrGenerate() call, setting \p ExistingValue to \c nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:72,Performance,load,loadOrGenerate,72,"/// Compare-exchange. Returns \c false if there is a concurrent \a; /// loadOrGenerate() call, setting \p ExistingValue to \c nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:49,Performance,concurren,concurrent,49,/// Compare-exchange. Keeps trying if there is a concurrent; /// \a loadOrGenerate() call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:68,Performance,load,loadOrGenerate,68,/// Compare-exchange. Keeps trying if there is a concurrent; /// \a loadOrGenerate() call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:67,Performance,concurren,concurrent,67,/// Return the current stored value. Returns \a None if there is a concurrent; /// \a loadOrGenerate() in flight.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:86,Performance,load,loadOrGenerate,86,/// Return the current stored value. Returns \a None if there is a concurrent; /// \a loadOrGenerate() in flight.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h:473,Integrability,interface,interface,473,"//===- llvm/ADT/MapVector.h - Map w/ deterministic value order --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a map that provides insertion order iteration. The; /// interface is purposefully minimal. The key is assumed to be cheap to copy; /// and 2 copies are kept, one for indexing in a DenseMap, one for iteration in; /// a SmallVector.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h:51,Security,access,access,51,"/// This class implements a map that also provides access to all stored values; /// in a deterministic order. The values are kept in a SmallVector<*, 0> and the; /// mapping is done with DenseMap from Keys to indexes in that vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h:4,Usability,Clear,Clear,4,/// Clear the MapVector and return the underlying vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h:3,Deployability,Update,Update,3,// Update indices in the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h:22,Deployability,update,update,22,// Move the value and update the index in the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h:21,Performance,perform,performs,21,/// A MapVector that performs no allocations if smaller than a certain; /// size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PackedVector.h:279,Testability,assert,assertion,279,"/// Store a vector of values using a specific number of bits for each; /// value. Both signed and unsigned types can be used, e.g; /// @code; /// PackedVector<signed, 2> vec;; /// @endcode; /// will create a vector accepting values -2, -1, 0, 1. Any other value will hit; /// an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PackedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PackedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:40,Energy Efficiency,allocate,allocated,40,"//===- llvm/ADT/PagedVector.h - 'Lazily allocated' vectors --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PagedVector class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:18,Energy Efficiency,allocate,allocates,18,"/// A vector that allocates memory in pages.; ///; /// Order is kept, but memory is allocated only when one element of the page is; /// accessed. This introduces a level of indirection, but it is useful when you; /// have a sparsely initialised vector where the full size is allocated upfront.; ///; /// As a side effect the elements are initialised later than in a normal vector.; /// On the first access to one of the elements of a given page, all the elements; /// of the page are initialised. This also means that the elements of the page; /// are initialised beyond the size of the vector.; ///; /// Similarly on destruction the elements are destroyed only when the page is; /// not needed anymore, delaying invoking the destructor of the elements.; ///; /// Notice that this has iterators only on materialized elements. This; /// is deliberately done under the assumption you would dereference the elements; /// while iterating, therefore materialising them and losing the gains in terms; /// of memory usage this container provides. If you have such a use case, you; /// probably want to use a normal std::vector or a llvm::SmallVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:84,Energy Efficiency,allocate,allocated,84,"/// A vector that allocates memory in pages.; ///; /// Order is kept, but memory is allocated only when one element of the page is; /// accessed. This introduces a level of indirection, but it is useful when you; /// have a sparsely initialised vector where the full size is allocated upfront.; ///; /// As a side effect the elements are initialised later than in a normal vector.; /// On the first access to one of the elements of a given page, all the elements; /// of the page are initialised. This also means that the elements of the page; /// are initialised beyond the size of the vector.; ///; /// Similarly on destruction the elements are destroyed only when the page is; /// not needed anymore, delaying invoking the destructor of the elements.; ///; /// Notice that this has iterators only on materialized elements. This; /// is deliberately done under the assumption you would dereference the elements; /// while iterating, therefore materialising them and losing the gains in terms; /// of memory usage this container provides. If you have such a use case, you; /// probably want to use a normal std::vector or a llvm::SmallVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:275,Energy Efficiency,allocate,allocated,275,"/// A vector that allocates memory in pages.; ///; /// Order is kept, but memory is allocated only when one element of the page is; /// accessed. This introduces a level of indirection, but it is useful when you; /// have a sparsely initialised vector where the full size is allocated upfront.; ///; /// As a side effect the elements are initialised later than in a normal vector.; /// On the first access to one of the elements of a given page, all the elements; /// of the page are initialised. This also means that the elements of the page; /// are initialised beyond the size of the vector.; ///; /// Similarly on destruction the elements are destroyed only when the page is; /// not needed anymore, delaying invoking the destructor of the elements.; ///; /// Notice that this has iterators only on materialized elements. This; /// is deliberately done under the assumption you would dereference the elements; /// while iterating, therefore materialising them and losing the gains in terms; /// of memory usage this container provides. If you have such a use case, you; /// probably want to use a normal std::vector or a llvm::SmallVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:136,Security,access,accessed,136,"/// A vector that allocates memory in pages.; ///; /// Order is kept, but memory is allocated only when one element of the page is; /// accessed. This introduces a level of indirection, but it is useful when you; /// have a sparsely initialised vector where the full size is allocated upfront.; ///; /// As a side effect the elements are initialised later than in a normal vector.; /// On the first access to one of the elements of a given page, all the elements; /// of the page are initialised. This also means that the elements of the page; /// are initialised beyond the size of the vector.; ///; /// Similarly on destruction the elements are destroyed only when the page is; /// not needed anymore, delaying invoking the destructor of the elements.; ///; /// Notice that this has iterators only on materialized elements. This; /// is deliberately done under the assumption you would dereference the elements; /// while iterating, therefore materialising them and losing the gains in terms; /// of memory usage this container provides. If you have such a use case, you; /// probably want to use a normal std::vector or a llvm::SmallVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:399,Security,access,access,399,"/// A vector that allocates memory in pages.; ///; /// Order is kept, but memory is allocated only when one element of the page is; /// accessed. This introduces a level of indirection, but it is useful when you; /// have a sparsely initialised vector where the full size is allocated upfront.; ///; /// As a side effect the elements are initialised later than in a normal vector.; /// On the first access to one of the elements of a given page, all the elements; /// of the page are initialised. This also means that the elements of the page; /// are initialised beyond the size of the vector.; ///; /// Similarly on destruction the elements are destroyed only when the page is; /// not needed anymore, delaying invoking the destructor of the elements.; ///; /// Notice that this has iterators only on materialized elements. This; /// is deliberately done under the assumption you would dereference the elements; /// while iterating, therefore materialising them and losing the gains in terms; /// of memory usage this container provides. If you have such a use case, you; /// probably want to use a normal std::vector or a llvm::SmallVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:61,Security,access,accessed,61,/// The actual number of elements in the vector which can be accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:87,Energy Efficiency,allocate,allocated,87,/// The position of the initial element of the page in the Data vector.; /// Pages are allocated contiguously in the Data vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:48,Energy Efficiency,allocate,allocated,48,/// Actual page data. All the page elements are allocated on the; /// first access of any of the elements of the page. Elements are default; /// constructed and elements of the page are stored contiguously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:76,Security,access,access,76,/// Actual page data. All the page elements are allocated on the; /// first access of any of the elements of the page. Elements are default; /// constructed and elements of the page are stored contiguously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:27,Energy Efficiency,allocate,allocated,27,"// If the page was not yet allocated, allocate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:38,Energy Efficiency,allocate,allocate,38,"// If the page was not yet allocated, allocate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:128,Security,access,accessed,128,"/// Resize the vector. Notice that the constructor of the elements will not; /// be invoked until an element of a given page is accessed, at which point; /// all the elements of the page will be constructed.; ///; /// If the new size is smaller than the current size, the elements of the; /// pages that are not needed anymore will be destroyed, however, elements of; /// the last page will not be destroyed.; ///; /// For these reason the usage of this vector is discouraged if you rely; /// on the construction / destructor of the elements to be invoked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:421,Security,access,access,421,"// Handle shrink case: destroy the elements in the pages that are not; // needed any more and deallocate the pages.; //; // On the other hand, we do not destroy the extra elements in the last page,; // because we might need them later and the logic is simpler if we do not; // destroy them. This means that elements are only destroyed when the; // page they belong to is destroyed. This is similar to what happens on; // access of the elements of a page, where all the elements of the page are; // constructed not only the one effectively needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:243,Testability,log,logic,243,"// Handle shrink case: destroy the elements in the pages that are not; // needed any more and deallocate the pages.; //; // On the other hand, we do not destroy the extra elements in the last page,; // because we might need them later and the logic is simpler if we do not; // destroy them. This means that elements are only destroyed when the; // page they belong to is destroyed. This is similar to what happens on; // access of the elements of a page, where all the elements of the page are; // constructed not only the one effectively needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:252,Usability,simpl,simpler,252,"// Handle shrink case: destroy the elements in the pages that are not; // needed any more and deallocate the pages.; //; // On the other hand, we do not destroy the extra elements in the last page,; // because we might need them later and the logic is simpler if we do not; // destroy them. This means that elements are only destroyed when the; // page they belong to is destroyed. This is similar to what happens on; // access of the elements of a page, where all the elements of the page are; // constructed not only the one effectively needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:37,Energy Efficiency,allocate,allocated,37,"/// Clear the vector, i.e. clear the allocated pages, the whole page; /// lookup index and reset the size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:4,Usability,Clear,Clear,4,"/// Clear the vector, i.e. clear the allocated pages, the whole page; /// lookup index and reset the size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:27,Usability,clear,clear,27,"/// Clear the vector, i.e. clear the allocated pages, the whole page; /// lookup index and reset the size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:28,Usability,simpl,simply,28,"// If we own the allocator, simply reset it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:114,Energy Efficiency,allocate,allocated,114,"/// Iterators over the materialized elements of the vector.; ///; /// This includes all the elements belonging to allocated pages,; /// even if they have not been accessed yet. It's enough to access; /// one element of a page to materialize all the elements of the page.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:163,Security,access,accessed,163,"/// Iterators over the materialized elements of the vector.; ///; /// This includes all the elements belonging to allocated pages,; /// even if they have not been accessed yet. It's enough to access; /// one element of a page to materialize all the elements of the page.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:192,Security,access,access,192,"/// Iterators over the materialized elements of the vector.; ///; /// This includes all the elements belonging to allocated pages,; /// even if they have not been accessed yet. It's enough to access; /// one element of a page to materialize all the elements of the page.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h:505,Testability,test,tested,505,"/// Utility to embed an integer into a pointer-like type. This is specifically; /// intended to allow embedding integers where fewer bits are required than; /// exist in a pointer, and the integer can participate in abstractions along; /// side other pointer-like types. For example it can be placed into a \c; /// PointerSumType or \c PointerUnion.; ///; /// Note that much like pointers, an integer value of zero has special utility; /// due to boolean conversions. For example, a non-null value can be tested for; /// in the above abstractions without testing the particular active member.; /// Also, the default constructed value zero initializes the integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h:555,Testability,test,testing,555,"/// Utility to embed an integer into a pointer-like type. This is specifically; /// intended to allow embedding integers where fewer bits are required than; /// exist in a pointer, and the integer can participate in abstractions along; /// side other pointer-like types. For example it can be placed into a \c; /// PointerSumType or \c PointerUnion.; ///; /// Note that much like pointers, an integer value of zero has special utility; /// due to boolean conversions. For example, a non-null value can be tested for; /// in the above abstractions without testing the particular active member.; /// Also, the default constructed value zero initializes the integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h:30,Availability,mask,mask,30,// We also want to be able to mask out the preserved bits for asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h:62,Testability,assert,asserts,62,// We also want to be able to mask out the preserved bits for asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerEmbeddedInt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h:3,Testability,Assert,Asserts,3,// Asserts that allow us to let the compiler implement the destructor and; // copy/move constructors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h:336,Availability,avail,available,336,"/// PointerIntPair - This class implements a pair of a pointer and small; /// integer. It is designed to represent this in the space required by one; /// pointer by bitmangling the integer into the low part of the pointer. This; /// can only be done for small integers: typically up to 3 bits, but it depends; /// on the number of bits available according to PointerLikeTypeTraits for the; /// type.; ///; /// Note that PointerIntPair always puts the IntVal part in the highest bits; /// possible. For example, PointerIntPair<void*, 1, bool> will put the bit for; /// the bool into bit #2, not bit #0, which allows the low two bits to be used; /// for something else. For example, this allows:; /// PointerIntPair<PointerIntPair<void*, 1, bool>, 1, bool>; /// ... and the two bools will land in different bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h:301,Integrability,depend,depends,301,"/// PointerIntPair - This class implements a pair of a pointer and small; /// integer. It is designed to represent this in the space required by one; /// pointer by bitmangling the integer into the low part of the pointer. This; /// can only be done for small integers: typically up to 3 bits, but it depends; /// on the number of bits available according to PointerLikeTypeTraits for the; /// type.; ///; /// Note that PointerIntPair always puts the IntVal part in the highest bits; /// possible. For example, PointerIntPair<void*, 1, bool> will put the bit for; /// the bool into bit #2, not bit #0, which allows the low two bits to be used; /// for something else. For example, this allows:; /// PointerIntPair<PointerIntPair<void*, 1, bool>, 1, bool>; /// ... and the two bools will land in different bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h:36,Availability,mask,mask,36,/// IntMask - This is the unshifted mask for valid bits of the int type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h:31,Deployability,update,update,31,"// Preserve all low bits, just update the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:702,Integrability,interface,interface,702,"// end namespace detail; /// A sum type over pointer-like types.; ///; /// This is a normal tagged union across pointer-like types that uses the low; /// bits of the pointers to store the tag.; ///; /// Each member of the sum type is specified by passing a \c; /// PointerSumTypeMember specialization in the variadic member argument list.; /// This allows the user to control the particular tag value associated with; /// a particular type, use the same type for multiple different tags, and; /// customize the pointer-like traits used for a particular member. Note that; /// these *must* be specializations of \c PointerSumTypeMember, no other type; /// will suffice, even if it provides a compatible interface.; ///; /// This type implements all of the comparison operators and even hash table; /// support by comparing the underlying storage of the pointer values. It; /// doesn't support delegating to particular members for comparisons.; ///; /// It also default constructs to a zero tag with a null pointer, whatever that; /// would be. This means that the zero value for the tag type is significant; /// and may be desirable to set to a state that is particularly desirable to; /// default construct.; ///; /// Having a supported zero-valued tag also enables getting the address of a; /// pointer stored with that tag provided it is stored in its natural bit; /// representation. This works because in the case of a zero-valued tag, the; /// pointer's value is directly stored into this object and we can expose the; /// address of that internal storage. This is especially useful when building an; /// `ArrayRef` of a single pointer stored in a sum type.; ///; /// There is no support for constructing or accessing with a dynamic tag as; /// that would fundamentally violate the type safety provided by the sum type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:1792,Safety,safe,safety,1792,"// end namespace detail; /// A sum type over pointer-like types.; ///; /// This is a normal tagged union across pointer-like types that uses the low; /// bits of the pointers to store the tag.; ///; /// Each member of the sum type is specified by passing a \c; /// PointerSumTypeMember specialization in the variadic member argument list.; /// This allows the user to control the particular tag value associated with; /// a particular type, use the same type for multiple different tags, and; /// customize the pointer-like traits used for a particular member. Note that; /// these *must* be specializations of \c PointerSumTypeMember, no other type; /// will suffice, even if it provides a compatible interface.; ///; /// This type implements all of the comparison operators and even hash table; /// support by comparing the underlying storage of the pointer values. It; /// doesn't support delegating to particular members for comparisons.; ///; /// It also default constructs to a zero tag with a null pointer, whatever that; /// would be. This means that the zero value for the tag type is significant; /// and may be desirable to set to a state that is particularly desirable to; /// default construct.; ///; /// Having a supported zero-valued tag also enables getting the address of a; /// pointer stored with that tag provided it is stored in its natural bit; /// representation. This works because in the case of a zero-valued tag, the; /// pointer's value is directly stored into this object and we can expose the; /// address of that internal storage. This is especially useful when building an; /// `ArrayRef` of a single pointer stored in a sum type.; ///; /// There is no support for constructing or accessing with a dynamic tag as; /// that would fundamentally violate the type safety provided by the sum type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:785,Security,hash,hash,785,"// end namespace detail; /// A sum type over pointer-like types.; ///; /// This is a normal tagged union across pointer-like types that uses the low; /// bits of the pointers to store the tag.; ///; /// Each member of the sum type is specified by passing a \c; /// PointerSumTypeMember specialization in the variadic member argument list.; /// This allows the user to control the particular tag value associated with; /// a particular type, use the same type for multiple different tags, and; /// customize the pointer-like traits used for a particular member. Note that; /// these *must* be specializations of \c PointerSumTypeMember, no other type; /// will suffice, even if it provides a compatible interface.; ///; /// This type implements all of the comparison operators and even hash table; /// support by comparing the underlying storage of the pointer values. It; /// doesn't support delegating to particular members for comparisons.; ///; /// It also default constructs to a zero tag with a null pointer, whatever that; /// would be. This means that the zero value for the tag type is significant; /// and may be desirable to set to a state that is particularly desirable to; /// default construct.; ///; /// Having a supported zero-valued tag also enables getting the address of a; /// pointer stored with that tag provided it is stored in its natural bit; /// representation. This works because in the case of a zero-valued tag, the; /// pointer's value is directly stored into this object and we can expose the; /// address of that internal storage. This is especially useful when building an; /// `ArrayRef` of a single pointer stored in a sum type.; ///; /// There is no support for constructing or accessing with a dynamic tag as; /// that would fundamentally violate the type safety provided by the sum type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:1512,Security,expose,expose,1512,"// end namespace detail; /// A sum type over pointer-like types.; ///; /// This is a normal tagged union across pointer-like types that uses the low; /// bits of the pointers to store the tag.; ///; /// Each member of the sum type is specified by passing a \c; /// PointerSumTypeMember specialization in the variadic member argument list.; /// This allows the user to control the particular tag value associated with; /// a particular type, use the same type for multiple different tags, and; /// customize the pointer-like traits used for a particular member. Note that; /// these *must* be specializations of \c PointerSumTypeMember, no other type; /// will suffice, even if it provides a compatible interface.; ///; /// This type implements all of the comparison operators and even hash table; /// support by comparing the underlying storage of the pointer values. It; /// doesn't support delegating to particular members for comparisons.; ///; /// It also default constructs to a zero tag with a null pointer, whatever that; /// would be. This means that the zero value for the tag type is significant; /// and may be desirable to set to a state that is particularly desirable to; /// default construct.; ///; /// Having a supported zero-valued tag also enables getting the address of a; /// pointer stored with that tag provided it is stored in its natural bit; /// representation. This works because in the case of a zero-valued tag, the; /// pointer's value is directly stored into this object and we can expose the; /// address of that internal storage. This is especially useful when building an; /// `ArrayRef` of a single pointer stored in a sum type.; ///; /// There is no support for constructing or accessing with a dynamic tag as; /// that would fundamentally violate the type safety provided by the sum type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:1713,Security,access,accessing,1713,"// end namespace detail; /// A sum type over pointer-like types.; ///; /// This is a normal tagged union across pointer-like types that uses the low; /// bits of the pointers to store the tag.; ///; /// Each member of the sum type is specified by passing a \c; /// PointerSumTypeMember specialization in the variadic member argument list.; /// This allows the user to control the particular tag value associated with; /// a particular type, use the same type for multiple different tags, and; /// customize the pointer-like traits used for a particular member. Note that; /// these *must* be specializations of \c PointerSumTypeMember, no other type; /// will suffice, even if it provides a compatible interface.; ///; /// This type implements all of the comparison operators and even hash table; /// support by comparing the underlying storage of the pointer values. It; /// doesn't support delegating to particular members for comparisons.; ///; /// It also default constructs to a zero tag with a null pointer, whatever that; /// would be. This means that the zero value for the tag type is significant; /// and may be desirable to set to a state that is particularly desirable to; /// default construct.; ///; /// Having a supported zero-valued tag also enables getting the address of a; /// pointer stored with that tag provided it is stored in its natural bit; /// representation. This works because in the case of a zero-valued tag, the; /// pointer's value is directly stored into this object and we can expose the; /// address of that internal storage. This is especially useful when building an; /// `ArrayRef` of a single pointer stored in a sum type.; ///; /// There is no support for constructing or accessing with a dynamic tag as; /// that would fundamentally violate the type safety provided by the sum type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:606,Safety,avoid,avoid,606,"// We keep both the raw value and the min tag value's pointer in a union. When; // the minimum tag value is zero, this allows code below to cleanly expose the; // address of the zero-tag pointer instead of just the zero-tag pointer; // itself. This is especially useful when building `ArrayRef`s out of a single; // pointer. However, we have to carefully access the union due to the active; // member potentially changing. When we *store* a new value, we directly; // access the union to allow us to store using the obvious types. However,; // when we *read* a value, we copy the underlying storage out to avoid relying; // on one member or the other being active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:148,Security,expose,expose,148,"// We keep both the raw value and the min tag value's pointer in a union. When; // the minimum tag value is zero, this allows code below to cleanly expose the; // address of the zero-tag pointer instead of just the zero-tag pointer; // itself. This is especially useful when building `ArrayRef`s out of a single; // pointer. However, we have to carefully access the union due to the active; // member potentially changing. When we *store* a new value, we directly; // access the union to allow us to store using the obvious types. However,; // when we *read* a value, we copy the underlying storage out to avoid relying; // on one member or the other being active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:355,Security,access,access,355,"// We keep both the raw value and the min tag value's pointer in a union. When; // the minimum tag value is zero, this allows code below to cleanly expose the; // address of the zero-tag pointer instead of just the zero-tag pointer; // itself. This is especially useful when building `ArrayRef`s out of a single; // pointer. However, we have to carefully access the union due to the active; // member potentially changing. When we *store* a new value, we directly; // access the union to allow us to store using the obvious types. However,; // when we *read* a value, we copy the underlying storage out to avoid relying; // on one member or the other being active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:468,Security,access,access,468,"// We keep both the raw value and the min tag value's pointer in a union. When; // the minimum tag value is zero, this allows code below to cleanly expose the; // address of the zero-tag pointer instead of just the zero-tag pointer; // itself. This is especially useful when building `ArrayRef`s out of a single; // pointer. However, we have to carefully access the union due to the active; // member potentially changing. When we *store* a new value, we directly; // access the union to allow us to store using the obvious types. However,; // when we *read* a value, we copy the underlying storage out to avoid relying; // on one member or the other being active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:4,Usability,Clear,Clear,4,/// Clear the value to null with the min tag type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:7,Deployability,update,update,7,// Now update the active member of the union to be the actual pointer-typed; // member so that accessing it indirectly through the returned address is; // valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:95,Security,access,accessing,95,// Now update the active member of the union to be the actual pointer-typed; // member so that accessing it indirectly through the returned address is; // valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:12,Security,validat,validate,12,"// Finally, validate that this was a no-op as expected by reading it back; // out using the same underlying-storage read as above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:46,Availability,avail,available,46,// Next we need to compute the number of bits available for the discriminant; // by taking the min of the bits available for each member. Much of this; // would be amazingly easier with good constexpr support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:111,Availability,avail,available,111,// Next we need to compute the number of bits available for the discriminant; // by taking the min of the bits available for each member. Much of this; // would be amazingly easier with good constexpr support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:54,Availability,mask,masks,54,// Also compute the smallest discriminant and various masks for convenience.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:532,Availability,failure,failure,532,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:584,Availability,failure,failure,584,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:691,Availability,failure,failure,691,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:749,Availability,failure,failure,749,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:158,Energy Efficiency,efficient,efficient,158,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:263,Safety,safe,safe,263,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:522,Testability,assert,assertion,522,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:681,Testability,assert,assertion,681,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:61,Security,access,access,61,/// This is needed to give the CastInfo implementation below access; /// to protected members.; /// Refer to its definition for further details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:4,Testability,Test,Test,4,"/// Test if the pointer held in the union is null, regardless of; /// which type it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:113,Testability,Test,Test,113,"// FIXME: Replace the uses of is(), get() and dyn_cast() with; // isa<T>, cast<T> and the llvm::dyn_cast<T>; /// Test if the Union currently holds the type matching T.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:107,Testability,assert,assert,107,"/// Returns the value of the specified pointer type.; ///; /// If the specified pointer type is incorrect, assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:39,Usability,clear,clears,39,/// Assignment from nullptr which just clears the union.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:340,Integrability,bridg,bridge,340,"/// We can't (at least, at this moment with C++14) declare CastInfo; /// as a friend of PointerUnion like this:; /// ```; /// template<typename To>; /// friend struct CastInfo<To, PointerUnion<PTs...>>;; /// ```; /// The compiler complains 'Partial specialization cannot be declared as a; /// friend'.; /// So we define this struct to be a bridge between CastInfo and; /// PointerUnion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:89,Availability,avail,available,89,"// Teach SmallPtrSet that PointerUnion is ""basically a pointer"", that has; // # low bits available = min(PT1bits,PT2bits)-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:22,Availability,avail,available,22,// The number of bits available are the min of the pointer types minus the; // bits needed for the discriminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h:45,Security,access,access,45,"// The po_iterator_storage template provides access to the set of already; // visited nodes during the po_iterator's depth-first traversal.; //; // The default implementation simply contains a set of visited nodes, while; // the External=true version uses a reference to an external set.; //; // It is possible to prune the depth-first traversal in several ways:; //; // - When providing an external set that already contains some graph nodes,; // those nodes won't be visited again. This is useful for restarting a; // post-order traversal on a graph with nodes that aren't dominated by a; // single node.; //; // - By providing a custom SetType class, unwanted graph nodes can be excluded; // by having the insert() function return false. This could for example; // confine a CFG traversal to blocks in a specific loop.; //; // - Finally, by specializing the po_iterator_storage template itself, graph; // edges can be pruned by returning false in the insertEdge() function. This; // could be used to remove loop back-edges from the CFG seen by po_iterator.; //; // A specialized po_iterator_storage class can observe both the pre-order and; // the post-order. The insertEdge() function is called in a pre-order, while; // the finishPostorder() function is called just before the po_iterator moves; // on to the next node.; /// Default po_iterator_storage implementation with an internal set object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h:175,Usability,simpl,simply,175,"// The po_iterator_storage template provides access to the set of already; // visited nodes during the po_iterator's depth-first traversal.; //; // The default implementation simply contains a set of visited nodes, while; // the External=true version uses a reference to an external set.; //; // It is possible to prune the depth-first traversal in several ways:; //; // - When providing an external set that already contains some graph nodes,; // those nodes won't be visited again. This is useful for restarting a; // post-order traversal on a graph with nodes that aren't dominated by a; // single node.; //; // - By providing a custom SetType class, unwanted graph nodes can be excluded; // by having the insert() function return false. This could for example; // confine a CFG traversal to blocks in a specific loop.; //; // - Finally, by specializing the po_iterator_storage template itself, graph; // edges can be pruned by returning false in the insertEdge() function. This; // could be used to remove loop back-edges from the CFG seen by po_iterator.; //; // A specialized po_iterator_storage class can observe both the pre-order and; // the post-order. The insertEdge() function is called in a pre-order, while; // the finishPostorder() function is called just before the po_iterator moves; // on to the next node.; /// Default po_iterator_storage implementation with an internal set object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:43,Performance,queue,queues,43,"//===- llvm/ADT/PriorityQueue.h - Priority queues ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the PriorityQueue class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:43,Performance,queue,queue,43,"/// erase_one - Erase one element from the queue, regardless of its; /// position. This operation performs a linear search to find an element; /// equal to t, but then uses all logarithmic-time algorithms to do; /// the erase operation.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:98,Performance,perform,performs,98,"/// erase_one - Erase one element from the queue, regardless of its; /// position. This operation performs a linear search to find an element; /// equal to t, but then uses all logarithmic-time algorithms to do; /// the erase operation.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:177,Testability,log,logarithmic-time,177,"/// erase_one - Erase one element from the queue, regardless of its; /// position. This operation performs a linear search to find an element; /// equal to t, but then uses all logarithmic-time algorithms to do; /// the erase operation.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:3,Testability,Log,Logarithmic-time,3,// Logarithmic-time heap bubble-up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:37,Performance,queue,queue,37,"/// reheapify - If an element in the queue has changed in a way that; /// affects its standing in the comparison function, the queue's; /// internal state becomes invalid. Calling reheapify() resets the; /// queue's state, making it valid again. This operation has time; /// complexity proportional to the number of elements in the queue,; /// so don't plan to use it a lot.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:127,Performance,queue,queue,127,"/// reheapify - If an element in the queue has changed in a way that; /// affects its standing in the comparison function, the queue's; /// internal state becomes invalid. Calling reheapify() resets the; /// queue's state, making it valid again. This operation has time; /// complexity proportional to the number of elements in the queue,; /// so don't plan to use it a lot.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:208,Performance,queue,queue,208,"/// reheapify - If an element in the queue has changed in a way that; /// affects its standing in the comparison function, the queue's; /// internal state becomes invalid. Calling reheapify() resets the; /// queue's state, making it valid again. This operation has time; /// complexity proportional to the number of elements in the queue,; /// so don't plan to use it a lot.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:332,Performance,queue,queue,332,"/// reheapify - If an element in the queue has changed in a way that; /// affects its standing in the comparison function, the queue's; /// internal state becomes invalid. Calling reheapify() resets the; /// queue's state, making it valid again. This operation has time; /// complexity proportional to the number of elements in the queue,; /// so don't plan to use it a lot.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:40,Performance,queue,queue,40,/// clear - Erase all elements from the queue.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:4,Usability,clear,clear,4,/// clear - Erase all elements from the queue.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:692,Availability,error,error,692,"/// A FILO worklist that prioritizes on re-insertion without duplication.; ///; /// This is very similar to a \c SetVector with the primary difference that; /// while re-insertion does not create a duplicate, it does adjust the; /// visitation order to respect the last insertion point. This can be useful; /// when the visit order needs to be prioritized based on insertion point; /// without actually having duplicate visits.; ///; /// Note that this doesn't prevent re-insertion of elements which have been; /// visited -- if you need to break cycles, a set will still be necessary.; ///; /// The type \c T must be default constructable to a null value that will be; /// ignored. It is an error to insert such a value, and popping elements will; /// never produce such a value. It is expected to be used with common nullable; /// types like pointers or optionals.; ///; /// Internally this uses a vector to store the worklist and a map to identify; /// existing elements in the worklist. Both of these may be customized, but the; /// map must support the basic DenseMap API for mapping from a T to an integer; /// index into the vector.; ///; /// A partial specialization is provided to automatically select a SmallVector; /// and a SmallDenseMap if custom data structures are not provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:50,Usability,clear,clear,50,// Otherwise the existing one comes first so just clear out the value in; // this slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:275,Security,expose,expose,275,"/// Erase items from the set vector based on a predicate function.; ///; /// This is intended to be equivalent to the following code, if we could; /// write it:; ///; /// \code; /// V.erase(remove_if(V, P), V.end());; /// \endcode; ///; /// However, PriorityWorklist doesn't expose non-const iterators, making any; /// algorithm like remove_if impossible to use.; ///; /// \returns true if any element is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:195,Usability,clear,clear,195,/// Reverse the items in the PriorityWorklist.; ///; /// This does an in-place reversal. Other kinds of reverse aren't easy to; /// support in the face of the worklist semantics.; /// Completely clear the PriorityWorklist,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:6,Integrability,wrap,wrapper,6,/// A wrapper predicate designed for use with std::remove_if.; ///; /// This predicate wraps a predicate suitable for use with std::remove_if to; /// call M.erase(x) on each element which is slated for removal. This just; /// allows the predicate to be move only which we can't do with lambdas; /// today.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:87,Integrability,wrap,wraps,87,/// A wrapper predicate designed for use with std::remove_if.; ///; /// This predicate wraps a predicate suitable for use with std::remove_if to; /// call M.erase(x) on each element which is slated for removal. This just; /// allows the predicate to be move only which we can't do with lambdas; /// today.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:61,Performance,optimiz,optimized,61,/// A version of \c PriorityWorklist that selects small size optimized data; /// structures for the vector and map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:821,Integrability,wrap,wrappers,821,"//===- ADT/SCCIterator.h - Strongly Connected Comp. Iter. -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This builds on the llvm/ADT/GraphTraits.h file to find the strongly; /// connected components (SCCs) of a graph in O(N+E) time using Tarjan's DFS; /// algorithm.; ///; /// The SCC iterator has the important property that if a node in SCC S1 has an; /// edge to a node in SCC S2, then it visits S1 *after* S2.; ///; /// To visit S1 *before* S2, use the scc_iterator on the Inverse graph. (NOTE:; /// This requires some simple wrappers and is not supported yet.); ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:814,Usability,simpl,simple,814,"//===- ADT/SCCIterator.h - Strongly Connected Comp. Iter. -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This builds on the llvm/ADT/GraphTraits.h file to find the strongly; /// connected components (SCCs) of a graph in O(N+E) time using Tarjan's DFS; /// algorithm.; ///; /// The SCC iterator has the important property that if a node in SCC S1 has an; /// edge to a node in SCC S2, then it visits S1 *after* S2.; ///; /// To visit S1 *before* S2, use the scc_iterator on the Inverse graph. (NOTE:; /// This requires some simple wrappers and is not supported yet.); ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:31,Safety,detect,detect,31,"/// The visit counters used to detect when a complete SCC is on the stack.; /// visitNum is the global counter.; ///; /// nodeVisitNumbers are per-node visit numbers, also used as DFS flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:47,Energy Efficiency,efficient,efficient,47,/// Direct loop termination test which is more efficient than; /// comparison with \c end().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:28,Testability,test,test,28,/// Direct loop termination test which is more efficient than; /// comparison with \c end().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:4,Testability,Test,Test,4,"/// Test if the current SCC has a cycle.; ///; /// If the SCC has more than one node, this is trivially true. If not, it may; /// still contain a cycle if the node has an edge back to itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:45,Safety,detect,detect,45,// Propagate MinVisitNum to parent so we can detect the SCC starting node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:46,Performance,queue,queue,46,"// Walk through SortedEdges to initialize the queue, instead of using NodeInfoMap; // to ensure an ordered deterministic push.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:407,Energy Efficiency,efficient,efficient,407,"//===- ScopedHashTable.h - A simple scoped hash table -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an efficient scoped hash table, which is useful for; // things like dominator-based optimizations. This allows clients to do things; // like this:; //; // ScopedHashTable<int, int> HT;; // {; // ScopedHashTableScope<int, int> Scope1(HT);; // HT.insert(0, 0);; // HT.insert(1, 1);; // {; // ScopedHashTableScope<int, int> Scope2(HT);; // HT.insert(0, 42);; // }; // }; //; // Looking up the value for ""0"" in the Scope2 block will return 42. Looking; // up the value for 0 before 42 is inserted or after Scope2 is popped will; // return 0.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:488,Performance,optimiz,optimizations,488,"//===- ScopedHashTable.h - A simple scoped hash table -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an efficient scoped hash table, which is useful for; // things like dominator-based optimizations. This allows clients to do things; // like this:; //; // ScopedHashTable<int, int> HT;; // {; // ScopedHashTableScope<int, int> Scope1(HT);; // HT.insert(0, 0);; // HT.insert(1, 1);; // {; // ScopedHashTableScope<int, int> Scope2(HT);; // HT.insert(0, 42);; // }; // }; //; // Looking up the value for ""0"" in the Scope2 block will return 42. Looking; // up the value for 0 before 42 is inserted or after Scope2 is popped will; // return 0.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:43,Security,hash,hash,43,"//===- ScopedHashTable.h - A simple scoped hash table -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an efficient scoped hash table, which is useful for; // things like dominator-based optimizations. This allows clients to do things; // like this:; //; // ScopedHashTable<int, int> HT;; // {; // ScopedHashTableScope<int, int> Scope1(HT);; // HT.insert(0, 0);; // HT.insert(1, 1);; // {; // ScopedHashTableScope<int, int> Scope2(HT);; // HT.insert(0, 42);; // }; // }; //; // Looking up the value for ""0"" in the Scope2 block will return 42. Looking; // up the value for 0 before 42 is inserted or after Scope2 is popped will; // return 0.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:424,Security,hash,hash,424,"//===- ScopedHashTable.h - A simple scoped hash table -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an efficient scoped hash table, which is useful for; // things like dominator-based optimizations. This allows clients to do things; // like this:; //; // ScopedHashTable<int, int> HT;; // {; // ScopedHashTableScope<int, int> Scope1(HT);; // HT.insert(0, 0);; // HT.insert(1, 1);; // {; // ScopedHashTableScope<int, int> Scope2(HT);; // HT.insert(0, 42);; // }; // }; //; // Looking up the value for ""0"" in the Scope2 block will return 42. Looking; // up the value for 0 before 42 is inserted or after Scope2 is popped will; // return 0.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:29,Usability,simpl,simple,29,"//===- ScopedHashTable.h - A simple scoped hash table -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an efficient scoped hash table, which is useful for; // things like dominator-based optimizations. This allows clients to do things; // like this:; //; // ScopedHashTable<int, int> HT;; // {; // ScopedHashTableScope<int, int> Scope1(HT);; // HT.insert(0, 0);; // HT.insert(1, 1);; // {; // ScopedHashTableScope<int, int> Scope2(HT);; // HT.insert(0, 42);; // }; // }; //; // Looking up the value for ""0"" in the Scope2 block will return 42. Looking; // up the value for 0 before 42 is inserted or after Scope2 is popped will; // return 0.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:13,Security,hash,hashtable,13,/// HT - The hashtable that we are active for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:72,Security,access,access,72,/// ScopeTy - This is a helpful typedef that allows clients to get easy access; /// to the name of the scope for this hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:118,Security,hash,hash,118,/// ScopeTy - This is a helpful typedef that allows clients to get easy access; /// to the name of the scope for this hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:4,Security,Access,Access,4,/// Access to the allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:32,Deployability,Install,Install,32,/// ScopedHashTableScope ctor - Install this as the current scope for the hash; /// table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:74,Security,hash,hash,74,/// ScopedHashTableScope ctor - Install this as the current scope for the hash; /// table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h:485,Testability,log,logic,485,"//===- llvm/ADT/ScopeExit.h - Execute code at scope exit --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the make_scope_exit function, which executes user-defined; /// cleanup logic at scope exit.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h:28,Deployability,release,release,28,// False once moved-from or release()d.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h:209,Integrability,Interface,Interface,209,"// end namespace detail; // Keeps the callable object that is passed in, and execute it at the; // destruction of the returned object (usually at the scope exit where the; // returned object is kept).; //; // Interface is specified by p0052r2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopeExit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:712,Safety,safe,safely,712,"//===- Sequence.h - Utility for producing sequences of values ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Provides some synthesis utilities to produce sequences of values. The names; /// are intentionally kept very short as they tend to occur in common and; /// widely used contexts.; ///; /// The `seq(A, B)` function produces a sequence of values from `A` to up to; /// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.; /// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum; /// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,; /// including `B`.; ///; /// Examples with integral types:; /// ```; /// for (int x : seq(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 `.; ///; /// ```; /// for (int x : seq_inclusive(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 3 `.; ///; /// Similar to `seq` and `seq_inclusive`, the `enum_seq` and; /// `enum_seq_inclusive` functions produce sequences of enum values that can be; /// iterated over.; /// To enable iteration with enum types, you need to either mark enums as safe; /// to iterate on by specializing `enum_iteration_traits`, or opt into; /// potentially unsafe iteration at every callsite by passing; /// `force_iteration_on_noniterable_enum`.; ///; /// Examples with enum types:; /// ```; /// namespace X {; /// enum class MyEnum : unsigned {A = 0, B, C};; /// } // namespace X; ///; /// template <> struct enum_iteration_traits<X::MyEnum> {; /// static contexpr bool is_iterable = true;; /// };; ///; /// class MyClass {; /// public:; /// enum Safe { D = 3, E, F };; /// enum MaybeUnsafe { G = 1, H = 2, I = 4 };; /// };; ///; /// template <> stru",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:1412,Safety,safe,safe,1412,"s; /// are intentionally kept very short as they tend to occur in common and; /// widely used contexts.; ///; /// The `seq(A, B)` function produces a sequence of values from `A` to up to; /// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.; /// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum; /// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,; /// including `B`.; ///; /// Examples with integral types:; /// ```; /// for (int x : seq(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 `.; ///; /// ```; /// for (int x : seq_inclusive(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 3 `.; ///; /// Similar to `seq` and `seq_inclusive`, the `enum_seq` and; /// `enum_seq_inclusive` functions produce sequences of enum values that can be; /// iterated over.; /// To enable iteration with enum types, you need to either mark enums as safe; /// to iterate on by specializing `enum_iteration_traits`, or opt into; /// potentially unsafe iteration at every callsite by passing; /// `force_iteration_on_noniterable_enum`.; ///; /// Examples with enum types:; /// ```; /// namespace X {; /// enum class MyEnum : unsigned {A = 0, B, C};; /// } // namespace X; ///; /// template <> struct enum_iteration_traits<X::MyEnum> {; /// static contexpr bool is_iterable = true;; /// };; ///; /// class MyClass {; /// public:; /// enum Safe { D = 3, E, F };; /// enum MaybeUnsafe { G = 1, H = 2, I = 4 };; /// };; ///; /// template <> struct enum_iteration_traits<MyClass::Safe> {; /// static contexpr bool is_iterable = true;; /// };; /// ```; ///; /// ```; /// for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `3 4 `.; ///; /// ```; /// for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,; /// force_iteration_on_noniterable_enum)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `2 3 `.; ///; //===-----",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:1506,Safety,unsafe,unsafe,1506,"s; /// are intentionally kept very short as they tend to occur in common and; /// widely used contexts.; ///; /// The `seq(A, B)` function produces a sequence of values from `A` to up to; /// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.; /// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum; /// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,; /// including `B`.; ///; /// Examples with integral types:; /// ```; /// for (int x : seq(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 `.; ///; /// ```; /// for (int x : seq_inclusive(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 3 `.; ///; /// Similar to `seq` and `seq_inclusive`, the `enum_seq` and; /// `enum_seq_inclusive` functions produce sequences of enum values that can be; /// iterated over.; /// To enable iteration with enum types, you need to either mark enums as safe; /// to iterate on by specializing `enum_iteration_traits`, or opt into; /// potentially unsafe iteration at every callsite by passing; /// `force_iteration_on_noniterable_enum`.; ///; /// Examples with enum types:; /// ```; /// namespace X {; /// enum class MyEnum : unsigned {A = 0, B, C};; /// } // namespace X; ///; /// template <> struct enum_iteration_traits<X::MyEnum> {; /// static contexpr bool is_iterable = true;; /// };; ///; /// class MyClass {; /// public:; /// enum Safe { D = 3, E, F };; /// enum MaybeUnsafe { G = 1, H = 2, I = 4 };; /// };; ///; /// template <> struct enum_iteration_traits<MyClass::Safe> {; /// static contexpr bool is_iterable = true;; /// };; /// ```; ///; /// ```; /// for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `3 4 `.; ///; /// ```; /// for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,; /// force_iteration_on_noniterable_enum)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `2 3 `.; ///; //===-----",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:1898,Safety,Safe,Safe,1898,"n and; /// widely used contexts.; ///; /// The `seq(A, B)` function produces a sequence of values from `A` to up to; /// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.; /// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum; /// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,; /// including `B`.; ///; /// Examples with integral types:; /// ```; /// for (int x : seq(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 `.; ///; /// ```; /// for (int x : seq_inclusive(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 3 `.; ///; /// Similar to `seq` and `seq_inclusive`, the `enum_seq` and; /// `enum_seq_inclusive` functions produce sequences of enum values that can be; /// iterated over.; /// To enable iteration with enum types, you need to either mark enums as safe; /// to iterate on by specializing `enum_iteration_traits`, or opt into; /// potentially unsafe iteration at every callsite by passing; /// `force_iteration_on_noniterable_enum`.; ///; /// Examples with enum types:; /// ```; /// namespace X {; /// enum class MyEnum : unsigned {A = 0, B, C};; /// } // namespace X; ///; /// template <> struct enum_iteration_traits<X::MyEnum> {; /// static contexpr bool is_iterable = true;; /// };; ///; /// class MyClass {; /// public:; /// enum Safe { D = 3, E, F };; /// enum MaybeUnsafe { G = 1, H = 2, I = 4 };; /// };; ///; /// template <> struct enum_iteration_traits<MyClass::Safe> {; /// static contexpr bool is_iterable = true;; /// };; /// ```; ///; /// ```; /// for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `3 4 `.; ///; /// ```; /// for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,; /// force_iteration_on_noniterable_enum)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `2 3 `.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:2035,Safety,Safe,Safe,2035,"n and; /// widely used contexts.; ///; /// The `seq(A, B)` function produces a sequence of values from `A` to up to; /// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.; /// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum; /// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,; /// including `B`.; ///; /// Examples with integral types:; /// ```; /// for (int x : seq(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 `.; ///; /// ```; /// for (int x : seq_inclusive(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 3 `.; ///; /// Similar to `seq` and `seq_inclusive`, the `enum_seq` and; /// `enum_seq_inclusive` functions produce sequences of enum values that can be; /// iterated over.; /// To enable iteration with enum types, you need to either mark enums as safe; /// to iterate on by specializing `enum_iteration_traits`, or opt into; /// potentially unsafe iteration at every callsite by passing; /// `force_iteration_on_noniterable_enum`.; ///; /// Examples with enum types:; /// ```; /// namespace X {; /// enum class MyEnum : unsigned {A = 0, B, C};; /// } // namespace X; ///; /// template <> struct enum_iteration_traits<X::MyEnum> {; /// static contexpr bool is_iterable = true;; /// };; ///; /// class MyClass {; /// public:; /// enum Safe { D = 3, E, F };; /// enum MaybeUnsafe { G = 1, H = 2, I = 4 };; /// };; ///; /// template <> struct enum_iteration_traits<MyClass::Safe> {; /// static contexpr bool is_iterable = true;; /// };; /// ```; ///; /// ```; /// for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `3 4 `.; ///; /// ```; /// for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,; /// force_iteration_on_noniterable_enum)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `2 3 `.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:2157,Safety,Safe,Safe,2157,"n and; /// widely used contexts.; ///; /// The `seq(A, B)` function produces a sequence of values from `A` to up to; /// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.; /// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum; /// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,; /// including `B`.; ///; /// Examples with integral types:; /// ```; /// for (int x : seq(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 `.; ///; /// ```; /// for (int x : seq_inclusive(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 3 `.; ///; /// Similar to `seq` and `seq_inclusive`, the `enum_seq` and; /// `enum_seq_inclusive` functions produce sequences of enum values that can be; /// iterated over.; /// To enable iteration with enum types, you need to either mark enums as safe; /// to iterate on by specializing `enum_iteration_traits`, or opt into; /// potentially unsafe iteration at every callsite by passing; /// `force_iteration_on_noniterable_enum`.; ///; /// Examples with enum types:; /// ```; /// namespace X {; /// enum class MyEnum : unsigned {A = 0, B, C};; /// } // namespace X; ///; /// template <> struct enum_iteration_traits<X::MyEnum> {; /// static contexpr bool is_iterable = true;; /// };; ///; /// class MyClass {; /// public:; /// enum Safe { D = 3, E, F };; /// enum MaybeUnsafe { G = 1, H = 2, I = 4 };; /// };; ///; /// template <> struct enum_iteration_traits<MyClass::Safe> {; /// static contexpr bool is_iterable = true;; /// };; /// ```; ///; /// ```; /// for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `3 4 `.; ///; /// ```; /// for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,; /// force_iteration_on_noniterable_enum)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `2 3 `.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:2175,Safety,Safe,Safe,2175,"n and; /// widely used contexts.; ///; /// The `seq(A, B)` function produces a sequence of values from `A` to up to; /// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.; /// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum; /// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,; /// including `B`.; ///; /// Examples with integral types:; /// ```; /// for (int x : seq(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 `.; ///; /// ```; /// for (int x : seq_inclusive(0, 3)); /// outs() << x << "" "";; /// ```; ///; /// Prints: `0 1 2 3 `.; ///; /// Similar to `seq` and `seq_inclusive`, the `enum_seq` and; /// `enum_seq_inclusive` functions produce sequences of enum values that can be; /// iterated over.; /// To enable iteration with enum types, you need to either mark enums as safe; /// to iterate on by specializing `enum_iteration_traits`, or opt into; /// potentially unsafe iteration at every callsite by passing; /// `force_iteration_on_noniterable_enum`.; ///; /// Examples with enum types:; /// ```; /// namespace X {; /// enum class MyEnum : unsigned {A = 0, B, C};; /// } // namespace X; ///; /// template <> struct enum_iteration_traits<X::MyEnum> {; /// static contexpr bool is_iterable = true;; /// };; ///; /// class MyClass {; /// public:; /// enum Safe { D = 3, E, F };; /// enum MaybeUnsafe { G = 1, H = 2, I = 4 };; /// };; ///; /// template <> struct enum_iteration_traits<MyClass::Safe> {; /// static contexpr bool is_iterable = true;; /// };; /// ```; ///; /// ```; /// for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `3 4 `.; ///; /// ```; /// for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,; /// force_iteration_on_noniterable_enum)); /// outs() << int(v) << "" "";; /// ```; ///; /// Prints: `2 3 `.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:3,Testability,assert,assert,3,// assert,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:35,Safety,safe,safe,35,"// Enum traits that marks enums as safe or unsafe to iterate over.; // By default, enum types are *not* considered safe for iteration.; // To allow iteration for your enum type, provide a specialization with; // `is_iterable` set to `true` in the `llvm` namespace.; // Alternatively, you can pass the `force_iteration_on_noniterable_enum` tag; // to `enum_seq` or `enum_seq_inclusive`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:43,Safety,unsafe,unsafe,43,"// Enum traits that marks enums as safe or unsafe to iterate over.; // By default, enum types are *not* considered safe for iteration.; // To allow iteration for your enum type, provide a specialization with; // `is_iterable` set to `true` in the `llvm` namespace.; // Alternatively, you can pass the `force_iteration_on_noniterable_enum` tag; // to `enum_seq` or `enum_seq_inclusive`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:115,Safety,safe,safe,115,"// Enum traits that marks enums as safe or unsafe to iterate over.; // By default, enum types are *not* considered safe for iteration.; // To allow iteration for your enum type, provide a specialization with; // `is_iterable` set to `true` in the `llvm` namespace.; // Alternatively, you can pass the `force_iteration_on_noniterable_enum` tag; // to `enum_seq` or `enum_seq_inclusive`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:24,Testability,assert,asserts,24,"// An integer type that asserts when:; // - constructed from a value that doesn't fit into intmax_t,; // - casted to a type that cannot hold the current value,; // - its internal representation overflows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:25,Testability,assert,asserts,25,"// Integral constructor, asserts if Value cannot be represented as intmax_t.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:21,Testability,assert,asserts,21,"// Enum constructor, asserts if Value cannot be represented as intmax_t.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:24,Testability,assert,asserts,24,"// Convert to integral, asserts if Value cannot be represented as Integral.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:20,Testability,assert,asserts,20,"// Convert to enum, asserts if Value cannot be represented as Enum's; // underlying type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:114,Safety,safe,safely,114,"/// Iterate over an enum type from Begin up to - but not including - End, even; /// when `EnumT` is not marked as safely iterable by `enum_iteration_traits`.; /// Note: `enum_seq` will generate each consecutive value, even if no; /// enumerator with that value exists.; /// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for; /// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse; /// iteration).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:99,Safety,safe,safely,99,"/// Iterate over an enum type from Begin to End inclusive, even when `EnumT`; /// is not marked as safely iterable by `enum_iteration_traits`.; /// Note: `enum_seq_inclusive` will generate each consecutive value, even if no; /// enumerator with that value exists.; /// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]; /// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse; /// iteration).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:610,Integrability,interface,interface,610,"//===- llvm/ADT/SetVector.h - Set with insert order iteration ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a set that has insertion order iteration; /// characteristics. This is useful for keeping a set of things that need to be; /// visited later but in a deterministic order (insertion order). The interface; /// is purposefully minimal.; ///; /// This file defines SetVector and SmallSetVector, which performs no; /// allocations if the SetVector has less than a certain number of elements.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:714,Performance,perform,performs,714,"//===- llvm/ADT/SetVector.h - Set with insert order iteration ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a set that has insertion order iteration; /// characteristics. This is useful for keeping a set of things that need to be; /// visited later but in a deterministic order (insertion order). The interface; /// is purposefully minimal.; ///; /// This file defines SetVector and SmallSetVector, which performs no; /// allocations if the SetVector has less than a certain number of elements.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:62,Energy Efficiency,adapt,adapter,62,"/// A vector that has set insertion semantics.; ///; /// This adapter class provides a way to keep a set of things that also has the; /// property of a deterministic iteration order. The order of iteration is the; /// order of insertion.; ///; /// The key and value types are derived from the Set and Vector types; /// respectively. This allows the vector-type operations and set-type operations; /// to have different types. In particular, this is useful when storing pointers; /// as ""Foo *"" values but looking them up as ""const Foo *"" keys.; ///; /// No constraint is placed on the key and value types, although it is assumed; /// that value_type can be converted into key_type for insertion. Users must be; /// aware of any loss of information in this conversion. For example, setting; /// value_type to float and key_type to int can produce very surprising results,; /// but it is not explicitly disallowed.; ///; /// The parameter N specifies the ""small"" size of the container, which is the; /// number of elements upto which a linear scan over the Vector will be used; /// when searching for elements instead of checking Set, due to it being better; /// for performance. A value of 0 means that this mode of operation is not used,; /// and is the default value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:62,Integrability,adapter,adapter,62,"/// A vector that has set insertion semantics.; ///; /// This adapter class provides a way to keep a set of things that also has the; /// property of a deterministic iteration order. The order of iteration is the; /// order of insertion.; ///; /// The key and value types are derived from the Set and Vector types; /// respectively. This allows the vector-type operations and set-type operations; /// to have different types. In particular, this is useful when storing pointers; /// as ""Foo *"" values but looking them up as ""const Foo *"" keys.; ///; /// No constraint is placed on the key and value types, although it is assumed; /// that value_type can be converted into key_type for insertion. Users must be; /// aware of any loss of information in this conversion. For example, setting; /// value_type to float and key_type to int can produce very surprising results,; /// but it is not explicitly disallowed.; ///; /// The parameter N specifies the ""small"" size of the container, which is the; /// number of elements upto which a linear scan over the Vector will be used; /// when searching for elements instead of checking Set, due to it being better; /// for performance. A value of 0 means that this mode of operation is not used,; /// and is the default value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:62,Modifiability,adapt,adapter,62,"/// A vector that has set insertion semantics.; ///; /// This adapter class provides a way to keep a set of things that also has the; /// property of a deterministic iteration order. The order of iteration is the; /// order of insertion.; ///; /// The key and value types are derived from the Set and Vector types; /// respectively. This allows the vector-type operations and set-type operations; /// to have different types. In particular, this is useful when storing pointers; /// as ""Foo *"" values but looking them up as ""const Foo *"" keys.; ///; /// No constraint is placed on the key and value types, although it is assumed; /// that value_type can be converted into key_type for insertion. Users must be; /// aware of any loss of information in this conversion. For example, setting; /// value_type to float and key_type to int can produce very surprising results,; /// but it is not explicitly disallowed.; ///; /// The parameter N specifies the ""small"" size of the container, which is the; /// number of elements upto which a linear scan over the Vector will be used; /// when searching for elements instead of checking Set, due to it being better; /// for performance. A value of 0 means that this mode of operation is not used,; /// and is the default value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:1165,Performance,perform,performance,1165,"/// A vector that has set insertion semantics.; ///; /// This adapter class provides a way to keep a set of things that also has the; /// property of a deterministic iteration order. The order of iteration is the; /// order of insertion.; ///; /// The key and value types are derived from the Set and Vector types; /// respectively. This allows the vector-type operations and set-type operations; /// to have different types. In particular, this is useful when storing pointers; /// as ""Foo *"" values but looking them up as ""const Foo *"" keys.; ///; /// No constraint is placed on the key and value types, although it is assumed; /// that value_type can be converted into key_type for insertion. Users must be; /// aware of any loss of information in this conversion. For example, setting; /// value_type to float and key_type to int can produce very surprising results,; /// but it is not explicitly disallowed.; ///; /// The parameter N specifies the ""small"" size of the container, which is the; /// number of elements upto which a linear scan over the Vector will be used; /// when searching for elements instead of checking Set, due to it being better; /// for performance. A value of 0 means that this mode of operation is not used,; /// and is the default value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:4,Usability,Clear,Clear,4,/// Clear the SetVector and return the underlying vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:269,Security,expose,expose,269,"/// Remove items from the set vector based on a predicate function.; ///; /// This is intended to be equivalent to the following code, if we could; /// write it:; ///; /// \code; /// V.erase(remove_if(V, P), V.end());; /// \endcode; ///; /// However, SetVector doesn't expose non-const iterators, making any; /// algorithm like remove_if impossible to use.; ///; /// \returns true if any element is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:15,Usability,clear,clear,15,/// Completely clear the SetVector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:148,Integrability,interface,interface,148,"/// Compute This := This u S, return whether 'This' changed.; /// TODO: We should be able to use set_union from SetOperations.h, but; /// SetVector interface is inconsistent with DenseSet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:119,Integrability,interface,interface,119,"/// Compute This := This - B; /// TODO: We should be able to use set_subtract from SetOperations.h, but; /// SetVector interface is inconsistent with DenseSet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:6,Integrability,wrap,wrapper,6,/// A wrapper predicate designed for use with std::remove_if.; ///; /// This predicate wraps a predicate suitable for use with std::remove_if to; /// call set_.erase(x) on each element which is slated for removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:87,Integrability,wrap,wraps,87,/// A wrapper predicate designed for use with std::remove_if.; ///; /// This predicate wraps a predicate suitable for use with std::remove_if to; /// call set_.erase(x) on each element which is slated for removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:21,Performance,perform,performs,21,/// A SetVector that performs no allocations if smaller than; /// a certain size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:33,Usability,Simpl,Simple,33,"//===- llvm/ADT/simple_ilist.h - Simple Intrusive List ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:1460,Availability,avail,available,1460,"pt for; /// the range version of \a insert().; ///; /// There are three sets of API for discarding nodes from the list: \a; /// remove(), which takes a reference to the node to remove, \a erase(), which; /// takes an iterator or iterator range and returns the next one, and \a; /// clear(), which empties out the container. All three are constant time; /// operations. None of these deletes any nodes; in particular, if there is a; /// single node in the list, then these have identical semantics:; /// \li \c L.remove(L.front());; /// \li \c L.erase(L.begin());; /// \li \c L.clear();; ///; /// As a convenience for callers, there are parallel APIs that take a \c; /// Disposer (such as \c std::default_delete<T>): \a removeAndDispose(), \a; /// eraseAndDispose(), and \a clearAndDispose(). These have different names; /// because the extra semantic is otherwise non-obvious. They are equivalent; /// to calling \a std::for_each() on the range to be discarded.; ///; /// The currently available \p Options customize the nodes in the list. The; /// same options must be specified in the \a ilist_node instantiation for; /// compatibility (although the order is irrelevant).; /// \li Use \a ilist_tag to designate which ilist_node for a given \p T this; /// list should use. This is useful if a type \p T is part of multiple,; /// independent lists simultaneously.; /// \li Use \a ilist_sentinel_tracking to always (or never) track whether a; /// node is a sentinel. Specifying \c true enables the \a; /// ilist_node::isSentinel() API. Unlike \a ilist_node::isKnownSentinel(),; /// which is only appropriate for assertions, \a ilist_node::isSentinel() is; /// appropriate for real logic.; ///; /// Here are examples of \p Options usage:; /// \li \c simple_ilist<T> gives the defaults. \li \c; /// simple_ilist<T,ilist_sentinel_tracking<true>> enables the \a; /// ilist_node::isSentinel() API.; /// \li \c simple_ilist<T,ilist_tag<A>,ilist_sentinel_tracking<false>>; /// specifies a tag of A and that t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:102,Modifiability,inherit,inherits,102,"/// A simple intrusive list implementation.; ///; /// This is a simple intrusive list for a \c T that inherits from \c; /// ilist_node<T>. The list never takes ownership of anything inserted in it.; ///; /// Unlike \a iplist<T> and \a ilist<T>, \a simple_ilist<T> never deletes; /// values, and has no callback traits.; ///; /// The API for adding nodes include \a push_front(), \a push_back(), and \a; /// insert(). These all take values by reference (not by pointer), except for; /// the range version of \a insert().; ///; /// There are three sets of API for discarding nodes from the list: \a; /// remove(), which takes a reference to the node to remove, \a erase(), which; /// takes an iterator or iterator range and returns the next one, and \a; /// clear(), which empties out the container. All three are constant time; /// operations. None of these deletes any nodes; in particular, if there is a; /// single node in the list, then these have identical semantics:; /// \li \c L.remove(L.front());; /// \li \c L.erase(L.begin());; /// \li \c L.clear();; ///; /// As a convenience for callers, there are parallel APIs that take a \c; /// Disposer (such as \c std::default_delete<T>): \a removeAndDispose(), \a; /// eraseAndDispose(), and \a clearAndDispose(). These have different names; /// because the extra semantic is otherwise non-obvious. They are equivalent; /// to calling \a std::for_each() on the range to be discarded.; ///; /// The currently available \p Options customize the nodes in the list. The; /// same options must be specified in the \a ilist_node instantiation for; /// compatibility (although the order is irrelevant).; /// \li Use \a ilist_tag to designate which ilist_node for a given \p T this; /// list should use. This is useful if a type \p T is part of multiple,; /// independent lists simultaneously.; /// \li Use \a ilist_sentinel_tracking to always (or never) track whether a; /// node is a sentinel. Specifying \c true enables the \a; /// ilist_node::isSentinel",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:2085,Testability,assert,assertions,2085,"s the next one, and \a; /// clear(), which empties out the container. All three are constant time; /// operations. None of these deletes any nodes; in particular, if there is a; /// single node in the list, then these have identical semantics:; /// \li \c L.remove(L.front());; /// \li \c L.erase(L.begin());; /// \li \c L.clear();; ///; /// As a convenience for callers, there are parallel APIs that take a \c; /// Disposer (such as \c std::default_delete<T>): \a removeAndDispose(), \a; /// eraseAndDispose(), and \a clearAndDispose(). These have different names; /// because the extra semantic is otherwise non-obvious. They are equivalent; /// to calling \a std::for_each() on the range to be discarded.; ///; /// The currently available \p Options customize the nodes in the list. The; /// same options must be specified in the \a ilist_node instantiation for; /// compatibility (although the order is irrelevant).; /// \li Use \a ilist_tag to designate which ilist_node for a given \p T this; /// list should use. This is useful if a type \p T is part of multiple,; /// independent lists simultaneously.; /// \li Use \a ilist_sentinel_tracking to always (or never) track whether a; /// node is a sentinel. Specifying \c true enables the \a; /// ilist_node::isSentinel() API. Unlike \a ilist_node::isKnownSentinel(),; /// which is only appropriate for assertions, \a ilist_node::isSentinel() is; /// appropriate for real logic.; ///; /// Here are examples of \p Options usage:; /// \li \c simple_ilist<T> gives the defaults. \li \c; /// simple_ilist<T,ilist_sentinel_tracking<true>> enables the \a; /// ilist_node::isSentinel() API.; /// \li \c simple_ilist<T,ilist_tag<A>,ilist_sentinel_tracking<false>>; /// specifies a tag of A and that tracking should be off (even when; /// LLVM_ENABLE_ABI_BREAKING_CHECKS are enabled).; /// \li \c simple_ilist<T,ilist_sentinel_tracking<false>,ilist_tag<A>> is; /// equivalent to the last.; ///; /// See \a is_valid_option for steps on adding a new option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:2154,Testability,log,logic,2154,"s the next one, and \a; /// clear(), which empties out the container. All three are constant time; /// operations. None of these deletes any nodes; in particular, if there is a; /// single node in the list, then these have identical semantics:; /// \li \c L.remove(L.front());; /// \li \c L.erase(L.begin());; /// \li \c L.clear();; ///; /// As a convenience for callers, there are parallel APIs that take a \c; /// Disposer (such as \c std::default_delete<T>): \a removeAndDispose(), \a; /// eraseAndDispose(), and \a clearAndDispose(). These have different names; /// because the extra semantic is otherwise non-obvious. They are equivalent; /// to calling \a std::for_each() on the range to be discarded.; ///; /// The currently available \p Options customize the nodes in the list. The; /// same options must be specified in the \a ilist_node instantiation for; /// compatibility (although the order is irrelevant).; /// \li Use \a ilist_tag to designate which ilist_node for a given \p T this; /// list should use. This is useful if a type \p T is part of multiple,; /// independent lists simultaneously.; /// \li Use \a ilist_sentinel_tracking to always (or never) track whether a; /// node is a sentinel. Specifying \c true enables the \a; /// ilist_node::isSentinel() API. Unlike \a ilist_node::isKnownSentinel(),; /// which is only appropriate for assertions, \a ilist_node::isSentinel() is; /// appropriate for real logic.; ///; /// Here are examples of \p Options usage:; /// \li \c simple_ilist<T> gives the defaults. \li \c; /// simple_ilist<T,ilist_sentinel_tracking<true>> enables the \a; /// ilist_node::isSentinel() API.; /// \li \c simple_ilist<T,ilist_tag<A>,ilist_sentinel_tracking<false>>; /// specifies a tag of A and that tracking should be off (even when; /// LLVM_ENABLE_ABI_BREAKING_CHECKS are enabled).; /// \li \c simple_ilist<T,ilist_sentinel_tracking<false>,ilist_tag<A>> is; /// equivalent to the last.; ///; /// See \a is_valid_option for steps on adding a new option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:6,Usability,simpl,simple,6,"/// A simple intrusive list implementation.; ///; /// This is a simple intrusive list for a \c T that inherits from \c; /// ilist_node<T>. The list never takes ownership of anything inserted in it.; ///; /// Unlike \a iplist<T> and \a ilist<T>, \a simple_ilist<T> never deletes; /// values, and has no callback traits.; ///; /// The API for adding nodes include \a push_front(), \a push_back(), and \a; /// insert(). These all take values by reference (not by pointer), except for; /// the range version of \a insert().; ///; /// There are three sets of API for discarding nodes from the list: \a; /// remove(), which takes a reference to the node to remove, \a erase(), which; /// takes an iterator or iterator range and returns the next one, and \a; /// clear(), which empties out the container. All three are constant time; /// operations. None of these deletes any nodes; in particular, if there is a; /// single node in the list, then these have identical semantics:; /// \li \c L.remove(L.front());; /// \li \c L.erase(L.begin());; /// \li \c L.clear();; ///; /// As a convenience for callers, there are parallel APIs that take a \c; /// Disposer (such as \c std::default_delete<T>): \a removeAndDispose(), \a; /// eraseAndDispose(), and \a clearAndDispose(). These have different names; /// because the extra semantic is otherwise non-obvious. They are equivalent; /// to calling \a std::for_each() on the range to be discarded.; ///; /// The currently available \p Options customize the nodes in the list. The; /// same options must be specified in the \a ilist_node instantiation for; /// compatibility (although the order is irrelevant).; /// \li Use \a ilist_tag to designate which ilist_node for a given \p T this; /// list should use. This is useful if a type \p T is part of multiple,; /// independent lists simultaneously.; /// \li Use \a ilist_sentinel_tracking to always (or never) track whether a; /// node is a sentinel. Specifying \c true enables the \a; /// ilist_node::isSentinel",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:64,Usability,simpl,simple,64,"/// A simple intrusive list implementation.; ///; /// This is a simple intrusive list for a \c T that inherits from \c; /// ilist_node<T>. The list never takes ownership of anything inserted in it.; ///; /// Unlike \a iplist<T> and \a ilist<T>, \a simple_ilist<T> never deletes; /// values, and has no callback traits.; ///; /// The API for adding nodes include \a push_front(), \a push_back(), and \a; /// insert(). These all take values by reference (not by pointer), except for; /// the range version of \a insert().; ///; /// There are three sets of API for discarding nodes from the list: \a; /// remove(), which takes a reference to the node to remove, \a erase(), which; /// takes an iterator or iterator range and returns the next one, and \a; /// clear(), which empties out the container. All three are constant time; /// operations. None of these deletes any nodes; in particular, if there is a; /// single node in the list, then these have identical semantics:; /// \li \c L.remove(L.front());; /// \li \c L.erase(L.begin());; /// \li \c L.clear();; ///; /// As a convenience for callers, there are parallel APIs that take a \c; /// Disposer (such as \c std::default_delete<T>): \a removeAndDispose(), \a; /// eraseAndDispose(), and \a clearAndDispose(). These have different names; /// because the extra semantic is otherwise non-obvious. They are equivalent; /// to calling \a std::for_each() on the range to be discarded.; ///; /// The currently available \p Options customize the nodes in the list. The; /// same options must be specified in the \a ilist_node instantiation for; /// compatibility (although the order is irrelevant).; /// \li Use \a ilist_tag to designate which ilist_node for a given \p T this; /// list should use. This is useful if a type \p T is part of multiple,; /// independent lists simultaneously.; /// \li Use \a ilist_sentinel_tracking to always (or never) track whether a; /// node is a sentinel. Specifying \c true enables the \a; /// ilist_node::isSentinel",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:756,Usability,clear,clear,756,"/// A simple intrusive list implementation.; ///; /// This is a simple intrusive list for a \c T that inherits from \c; /// ilist_node<T>. The list never takes ownership of anything inserted in it.; ///; /// Unlike \a iplist<T> and \a ilist<T>, \a simple_ilist<T> never deletes; /// values, and has no callback traits.; ///; /// The API for adding nodes include \a push_front(), \a push_back(), and \a; /// insert(). These all take values by reference (not by pointer), except for; /// the range version of \a insert().; ///; /// There are three sets of API for discarding nodes from the list: \a; /// remove(), which takes a reference to the node to remove, \a erase(), which; /// takes an iterator or iterator range and returns the next one, and \a; /// clear(), which empties out the container. All three are constant time; /// operations. None of these deletes any nodes; in particular, if there is a; /// single node in the list, then these have identical semantics:; /// \li \c L.remove(L.front());; /// \li \c L.erase(L.begin());; /// \li \c L.clear();; ///; /// As a convenience for callers, there are parallel APIs that take a \c; /// Disposer (such as \c std::default_delete<T>): \a removeAndDispose(), \a; /// eraseAndDispose(), and \a clearAndDispose(). These have different names; /// because the extra semantic is otherwise non-obvious. They are equivalent; /// to calling \a std::for_each() on the range to be discarded.; ///; /// The currently available \p Options customize the nodes in the list. The; /// same options must be specified in the \a ilist_node instantiation for; /// compatibility (although the order is irrelevant).; /// \li Use \a ilist_tag to designate which ilist_node for a given \p T this; /// list should use. This is useful if a type \p T is part of multiple,; /// independent lists simultaneously.; /// \li Use \a ilist_sentinel_tracking to always (or never) track whether a; /// node is a sentinel. Specifying \c true enables the \a; /// ilist_node::isSentinel",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:1051,Usability,clear,clear,1051,"s ownership of anything inserted in it.; ///; /// Unlike \a iplist<T> and \a ilist<T>, \a simple_ilist<T> never deletes; /// values, and has no callback traits.; ///; /// The API for adding nodes include \a push_front(), \a push_back(), and \a; /// insert(). These all take values by reference (not by pointer), except for; /// the range version of \a insert().; ///; /// There are three sets of API for discarding nodes from the list: \a; /// remove(), which takes a reference to the node to remove, \a erase(), which; /// takes an iterator or iterator range and returns the next one, and \a; /// clear(), which empties out the container. All three are constant time; /// operations. None of these deletes any nodes; in particular, if there is a; /// single node in the list, then these have identical semantics:; /// \li \c L.remove(L.front());; /// \li \c L.erase(L.begin());; /// \li \c L.clear();; ///; /// As a convenience for callers, there are parallel APIs that take a \c; /// Disposer (such as \c std::default_delete<T>): \a removeAndDispose(), \a; /// eraseAndDispose(), and \a clearAndDispose(). These have different names; /// because the extra semantic is otherwise non-obvious. They are equivalent; /// to calling \a std::for_each() on the range to be discarded.; ///; /// The currently available \p Options customize the nodes in the list. The; /// same options must be specified in the \a ilist_node instantiation for; /// compatibility (although the order is irrelevant).; /// \li Use \a ilist_tag to designate which ilist_node for a given \p T this; /// list should use. This is useful if a type \p T is part of multiple,; /// independent lists simultaneously.; /// \li Use \a ilist_sentinel_tracking to always (or never) track whether a; /// node is a sentinel. Specifying \c true enables the \a; /// ilist_node::isSentinel() API. Unlike \a ilist_node::isKnownSentinel(),; /// which is only appropriate for assertions, \a ilist_node::isSentinel() is; /// appropriate for real logi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:1247,Usability,clear,clearAndDispose,1247,"s ownership of anything inserted in it.; ///; /// Unlike \a iplist<T> and \a ilist<T>, \a simple_ilist<T> never deletes; /// values, and has no callback traits.; ///; /// The API for adding nodes include \a push_front(), \a push_back(), and \a; /// insert(). These all take values by reference (not by pointer), except for; /// the range version of \a insert().; ///; /// There are three sets of API for discarding nodes from the list: \a; /// remove(), which takes a reference to the node to remove, \a erase(), which; /// takes an iterator or iterator range and returns the next one, and \a; /// clear(), which empties out the container. All three are constant time; /// operations. None of these deletes any nodes; in particular, if there is a; /// single node in the list, then these have identical semantics:; /// \li \c L.remove(L.front());; /// \li \c L.erase(L.begin());; /// \li \c L.clear();; ///; /// As a convenience for callers, there are parallel APIs that take a \c; /// Disposer (such as \c std::default_delete<T>): \a removeAndDispose(), \a; /// eraseAndDispose(), and \a clearAndDispose(). These have different names; /// because the extra semantic is otherwise non-obvious. They are equivalent; /// to calling \a std::for_each() on the range to be discarded.; ///; /// The currently available \p Options customize the nodes in the list. The; /// same options must be specified in the \a ilist_node instantiation for; /// compatibility (although the order is irrelevant).; /// \li Use \a ilist_tag to designate which ilist_node for a given \p T this; /// list should use. This is useful if a type \p T is part of multiple,; /// independent lists simultaneously.; /// \li Use \a ilist_sentinel_tracking to always (or never) track whether a; /// node is a sentinel. Specifying \c true enables the \a; /// ilist_node::isSentinel() API. Unlike \a ilist_node::isKnownSentinel(),; /// which is only appropriate for assertions, \a ilist_node::isSentinel() is; /// appropriate for real logi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:4,Usability,Clear,Clear,4,/// Clear the list; never deletes.; ///; /// \see \a clearAndDispose() if the nodes should be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:53,Usability,clear,clearAndDispose,53,/// Clear the list; never deletes.; ///; /// \see \a clearAndDispose() if the nodes should be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h:4,Usability,Clear,Clear,4,/// Clear the list and dispose of the nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/simple_ilist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:265,Energy Efficiency,allocate,allocated,265,"/// This is a 'bitvector' (really, a variable-sized bit array), optimized for; /// the case when the array is small. It contains one pointer-sized field, which; /// is directly used as a plain collection of bits when possible, or as a; /// pointer to a larger heap-allocated array when necessary. This allows normal; /// ""small"" cases to be fast without losing generality for large inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:37,Modifiability,variab,variable-sized,37,"/// This is a 'bitvector' (really, a variable-sized bit array), optimized for; /// the case when the array is small. It contains one pointer-sized field, which; /// is directly used as a plain collection of bits when possible, or as a; /// pointer to a larger heap-allocated array when necessary. This allows normal; /// ""small"" cases to be fast without losing generality for large inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:64,Performance,optimiz,optimized,64,"/// This is a 'bitvector' (really, a variable-sized bit array), optimized for; /// the case when the array is small. It contains one pointer-sized field, which; /// is directly used as a plain collection of bits when possible, or as a; /// pointer to a larger heap-allocated array when necessary. This allows normal; /// ""small"" cases to be fast without losing generality for large inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:129,Energy Efficiency,efficient,efficient,129,"// TODO: In ""large"" mode, a pointer to a BitVector is used, leading to an; // unnecessary level of indirection. It would be more efficient to use a; // pointer to memory containing size, allocation size, and the array of bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:4,Testability,Test,Tests,4,/// Tests whether there are no bits in this bitvector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:3,Availability,Mask,Mask,3,// Mask off previous bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:3,Availability,Mask,Mask,3,// Mask in previous bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:3,Availability,Mask,Mask,3,// Mask in unused bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:4,Usability,Clear,Clear,4,/// Clear all bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:4,Energy Efficiency,Efficient,Efficiently,4,"/// Efficiently set a range of bits in [I, E)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:4,Energy Efficiency,Efficient,Efficiently,4,"/// Efficiently reset a range of bits in [I, E)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:4,Testability,Test,Test,4,/// Test if any common bits are set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:22,Availability,Mask,Mask,22,"/// Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:86,Availability,Mask,Mask,86,"/// Add '1' bits from Mask to this vector. Don't resize.; /// This computes ""*this |= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:50,Availability,Mask,Mask,50,"/// Clear any bits in this vector that are set in Mask. Don't resize.; /// This computes ""*this &= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:100,Availability,Mask,Mask,100,"/// Clear any bits in this vector that are set in Mask. Don't resize.; /// This computes ""*this &= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:4,Usability,Clear,Clear,4,"/// Clear any bits in this vector that are set in Mask. Don't resize.; /// This computes ""*this &= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:50,Availability,Mask,Mask,50,"/// Add a bit to this vector for every '0' bit in Mask. Don't resize.; /// This computes ""*this |= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:100,Availability,Mask,Mask,100,"/// Add a bit to this vector for every '0' bit in Mask. Don't resize.; /// This computes ""*this |= ~Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:52,Availability,Mask,Mask,52,"/// Clear a bit in this vector for every '0' bit in Mask. Don't resize.; /// This computes ""*this &= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:101,Availability,Mask,Mask,101,"/// Clear a bit in this vector for every '0' bit in Mask. Don't resize.; /// This computes ""*this &= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:4,Usability,Clear,Clear,4,"/// Clear a bit in this vector for every '0' bit in Mask. Don't resize.; /// This computes ""*this &= Mask"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:237,Energy Efficiency,allocate,allocated,237,"/// SmallPtrSetImplBase - This is the common code shared among all the; /// SmallPtrSet<>'s, which is almost everything. SmallPtrSet has two modes, one; /// for small and one for large sets.; ///; /// Small sets use an array of pointers allocated in the SmallPtrSet object,; /// which is treated as a simple array of pointers. When a pointer is added to; /// the set, the array is scanned to see if the element already exists, if not; /// the element is 'pushed back' onto the array. If we run out of space in the; /// array, we grow into the 'large set' case. SmallSet should be used when the; /// sets are often small. In this case, no memory allocation is used, and only; /// light-weight and cache-efficient scanning is used.; ///; /// Large sets use a classic exponentially-probed hash table. Empty buckets are; /// represented with an illegal pointer value (-1) to allow null pointers to be; /// inserted. Tombstones are represented with another illegal pointer value; /// (-2), to allow deletion. The hash table is resized when the table is 3/4 or; /// more. When this happens, the table is doubled in size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:702,Energy Efficiency,efficient,efficient,702,"/// SmallPtrSetImplBase - This is the common code shared among all the; /// SmallPtrSet<>'s, which is almost everything. SmallPtrSet has two modes, one; /// for small and one for large sets.; ///; /// Small sets use an array of pointers allocated in the SmallPtrSet object,; /// which is treated as a simple array of pointers. When a pointer is added to; /// the set, the array is scanned to see if the element already exists, if not; /// the element is 'pushed back' onto the array. If we run out of space in the; /// array, we grow into the 'large set' case. SmallSet should be used when the; /// sets are often small. In this case, no memory allocation is used, and only; /// light-weight and cache-efficient scanning is used.; ///; /// Large sets use a classic exponentially-probed hash table. Empty buckets are; /// represented with an illegal pointer value (-1) to allow null pointers to be; /// inserted. Tombstones are represented with another illegal pointer value; /// (-2), to allow deletion. The hash table is resized when the table is 3/4 or; /// more. When this happens, the table is doubled in size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:696,Performance,cache,cache-efficient,696,"/// SmallPtrSetImplBase - This is the common code shared among all the; /// SmallPtrSet<>'s, which is almost everything. SmallPtrSet has two modes, one; /// for small and one for large sets.; ///; /// Small sets use an array of pointers allocated in the SmallPtrSet object,; /// which is treated as a simple array of pointers. When a pointer is added to; /// the set, the array is scanned to see if the element already exists, if not; /// the element is 'pushed back' onto the array. If we run out of space in the; /// array, we grow into the 'large set' case. SmallSet should be used when the; /// sets are often small. In this case, no memory allocation is used, and only; /// light-weight and cache-efficient scanning is used.; ///; /// Large sets use a classic exponentially-probed hash table. Empty buckets are; /// represented with an illegal pointer value (-1) to allow null pointers to be; /// inserted. Tombstones are represented with another illegal pointer value; /// (-2), to allow deletion. The hash table is resized when the table is 3/4 or; /// more. When this happens, the table is doubled in size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:786,Security,hash,hash,786,"/// SmallPtrSetImplBase - This is the common code shared among all the; /// SmallPtrSet<>'s, which is almost everything. SmallPtrSet has two modes, one; /// for small and one for large sets.; ///; /// Small sets use an array of pointers allocated in the SmallPtrSet object,; /// which is treated as a simple array of pointers. When a pointer is added to; /// the set, the array is scanned to see if the element already exists, if not; /// the element is 'pushed back' onto the array. If we run out of space in the; /// array, we grow into the 'large set' case. SmallSet should be used when the; /// sets are often small. In this case, no memory allocation is used, and only; /// light-weight and cache-efficient scanning is used.; ///; /// Large sets use a classic exponentially-probed hash table. Empty buckets are; /// represented with an illegal pointer value (-1) to allow null pointers to be; /// inserted. Tombstones are represented with another illegal pointer value; /// (-2), to allow deletion. The hash table is resized when the table is 3/4 or; /// more. When this happens, the table is doubled in size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:1008,Security,hash,hash,1008,"/// SmallPtrSetImplBase - This is the common code shared among all the; /// SmallPtrSet<>'s, which is almost everything. SmallPtrSet has two modes, one; /// for small and one for large sets.; ///; /// Small sets use an array of pointers allocated in the SmallPtrSet object,; /// which is treated as a simple array of pointers. When a pointer is added to; /// the set, the array is scanned to see if the element already exists, if not; /// the element is 'pushed back' onto the array. If we run out of space in the; /// array, we grow into the 'large set' case. SmallSet should be used when the; /// sets are often small. In this case, no memory allocation is used, and only; /// light-weight and cache-efficient scanning is used.; ///; /// Large sets use a classic exponentially-probed hash table. Empty buckets are; /// represented with an illegal pointer value (-1) to allow null pointers to be; /// inserted. Tombstones are represented with another illegal pointer value; /// (-2), to allow deletion. The hash table is resized when the table is 3/4 or; /// more. When this happens, the table is doubled in size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:301,Usability,simpl,simple,301,"/// SmallPtrSetImplBase - This is the common code shared among all the; /// SmallPtrSet<>'s, which is almost everything. SmallPtrSet has two modes, one; /// for small and one for large sets.; ///; /// Small sets use an array of pointers allocated in the SmallPtrSet object,; /// which is treated as a simple array of pointers. When a pointer is added to; /// the set, the array is scanned to see if the element already exists, if not; /// the element is 'pushed back' onto the array. If we run out of space in the; /// array, we grow into the 'large set' case. SmallSet should be used when the; /// sets are often small. In this case, no memory allocation is used, and only; /// light-weight and cache-efficient scanning is used.; ///; /// Large sets use a classic exponentially-probed hash table. Empty buckets are; /// represented with an illegal pointer value (-1) to allow null pointers to be; /// inserted. Tombstones are represented with another illegal pointer value; /// (-2), to allow deletion. The hash table is resized when the table is 3/4 or; /// more. When this happens, the table is doubled in size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:23,Energy Efficiency,allocate,allocated,23,"/// CurArraySize - The allocated size of CurArray, always a power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:60,Energy Efficiency,power,power,60,"/// CurArraySize - The allocated size of CurArray, always a power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:42,Energy Efficiency,efficient,efficiently,42,// Note that -1 is chosen to make clear() efficiently implementable with; // memset and because it's not a valid pointer value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:34,Usability,clear,clear,34,// Note that -1 is chosen to make clear() efficiently implementable with; // memset and because it's not a valid pointer value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:11,Energy Efficiency,Allocate,Allocate,11,/// Grow - Allocate a larger backing store for the buckets and move it over.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:86,Energy Efficiency,power,power,86,/// RoundUpToPowerOfTwo - This is a helper template that rounds N up to the next; /// power of two (which means N itself if N is already a power of two).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:139,Energy Efficiency,power,power,139,/// RoundUpToPowerOfTwo - This is a helper template that rounds N up to the next; /// power of two (which means N itself if N is already a power of two).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:41,Energy Efficiency,power,power,41,"/// RoundUpToPowerOfTwoH - If N is not a power of two, increase it. This is a; /// helper template used to implement RoundUpToPowerOfTwo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:79,Integrability,interface,interface,79,/// A templated base class for \c SmallPtrSet which provides the; /// typesafe interface that is common across all small sizes.; ///; /// This is particularly useful for passing around between interface boundaries; /// to avoid encoding a particular small size in the interface boundary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:193,Integrability,interface,interface,193,/// A templated base class for \c SmallPtrSet which provides the; /// typesafe interface that is common across all small sizes.; ///; /// This is particularly useful for passing around between interface boundaries; /// to avoid encoding a particular small size in the interface boundary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:268,Integrability,interface,interface,268,/// A templated base class for \c SmallPtrSet which provides the; /// typesafe interface that is common across all small sizes.; ///; /// This is particularly useful for passing around between interface boundaries; /// to avoid encoding a particular small size in the interface boundary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:222,Safety,avoid,avoid,222,/// A templated base class for \c SmallPtrSet which provides the; /// typesafe interface that is common across all small sizes.; ///; /// This is particularly useful for passing around between interface boundaries; /// to avoid encoding a particular small size in the interface boundary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:163,Energy Efficiency,power,power,163,/// SmallPtrSet - This class implements a set which is optimized for holding; /// SmallSize or less elements. This internally rounds up SmallSize to the next; /// power of two if it is not already a power of two. See the comments above; /// SmallPtrSetImplBase for details of the algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:199,Energy Efficiency,power,power,199,/// SmallPtrSet - This class implements a set which is optimized for holding; /// SmallSize or less elements. This internally rounds up SmallSize to the next; /// power of two if it is not already a power of two. See the comments above; /// SmallPtrSetImplBase for details of the algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:55,Performance,optimiz,optimized,55,/// SmallPtrSet - This class implements a set which is optimized for holding; /// SmallSize or less elements. This internally rounds up SmallSize to the next; /// power of two if it is not already a power of two. See the comments above; /// SmallPtrSetImplBase for details of the algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:33,Energy Efficiency,power,power,33,"// Make sure that SmallSize is a power of two, round up if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:82,Integrability,depend,depending,82,/// Iterators to the parts of the SmallSet containing the data. They are set; /// depending on isSmall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:54,Performance,optimiz,optimizing,54,"/// SmallSet - This maintains a set of unique values, optimizing for the case; /// when the set is small (less than N). In this case, the set can be; /// maintained with no mallocs. If the set gets large, we expand to using an; /// std::set to maintain reasonable lookup times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:108,Safety,avoid,avoid,108,/// Use a SmallVector to hold the elements here (even though it will never; /// reach its 'large' stage) to avoid calling the default ctors of elements; /// we will never use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:94,Performance,perform,performance,94,"/// If this set is of pointer values, transparently switch over to using; /// SmallPtrSet for performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:369,Security,hash,hash,369,"/// Equality comparison for SmallSet.; ///; /// Iterates over elements of LHS confirming that each element is also a member; /// of RHS, and that RHS contains no additional values.; /// Equivalent to N calls to RHS.count.; /// For small-set mode amortized complexity is O(N^2); /// For large-set mode amortized complexity is linear, worst case is O(N^2) (if; /// every hash collides).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:98,Performance,perform,performance,98,/// Inequality comparison for SmallSet.; ///; /// Equivalent to !(LHS == RHS). See operator== for performance notes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h:71,Security,access,accessors,71,/// SmallString - A SmallString is just a SmallVector with methods and accessors; /// that make it work better as a string (e.g. operator+ etc).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h:89,Energy Efficiency,efficient,efficient,89,/// @}; /// @name String Comparison; /// @{; /// Check for string equality. This is more efficient than compare() when; /// the relative ordering of inequal strings isn't needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h:34,Safety,safe,safe,34,"// TODO: Make this const, if it's safe...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:121,Availability,error,error,121,/// This is a helper for \a grow() that's out of line to reduce code; /// duplication. This function will report a fatal error if it can't grow at; /// least to \p MinSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:57,Energy Efficiency,reduce,reduce,57,/// This is a helper for \a grow() that's out of line to reduce code; /// duplication. This function will report a fatal error if it can't grow at; /// least to \p MinSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:182,Availability,error,error,182,/// This is an implementation of the grow() method which only works; /// on POD-like data types and is out of line to reduce code duplication.; /// This function will report a fatal error if it cannot increase capacity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:118,Energy Efficiency,reduce,reduce,118,/// This is an implementation of the grow() method which only works; /// on POD-like data types and is out of line to reduce code duplication.; /// This function will report a fatal error if it cannot increase capacity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:549,Energy Efficiency,allocate,allocate,549,"/// If vector was first created with capacity 0, getFirstEl() points to the; /// memory right after, an area unallocated. If a subsequent allocation,; /// that grows the vector, happens to return the same pointer as getFirstEl(),; /// get a new allocation, otherwise isSmall() will falsely return that no; /// allocation was done (true) and the memory will not be freed in the; /// destructor. If a VSize is given (vector size), also copy that many; /// elements to the new allocation - used if realloca fails to increase; /// space, and happens to allocate precisely at BeginX.; /// This is unlikely to be called often, but resolves a memory leak when the; /// situation does occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:63,Integrability,depend,depend,63,/// This is the part of SmallVectorTemplateBase which does not depend on whether; /// the type T is a POD. The extra dummy template argument is used by ArrayRef; /// to avoid unnecessarily requiring T to be complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:169,Safety,avoid,avoid,169,/// This is the part of SmallVectorTemplateBase which does not depend on whether; /// the type T is a POD. The extra dummy template argument is used by ArrayRef; /// to avoid unnecessarily requiring T to be complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:79,Energy Efficiency,allocate,allocated,79,/// Return true if this is a smallvector which has not had dynamic; /// memory allocated for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:20,Safety,avoid,avoid,20,// Use std::less to avoid UB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:20,Safety,avoid,avoid,20,// Use std::less to avoid UB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:63,Usability,clear,clearing,63,/// Check whether any part of the range will be invalidated by clearing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:60,Deployability,update,updated,60,"/// Reserve enough space to add one element, and return the updated element; /// pointer in case it was a reference to the storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:13,Energy Efficiency,allocate,allocated,13,"/// Grow the allocated memory (without initializing new elements), doubling; /// the size of the allocated memory. Guarantees space for at least one more; /// element, or MinSize more elements if specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:97,Energy Efficiency,allocate,allocated,97,"/// Grow the allocated memory (without initializing new elements), doubling; /// the size of the allocated memory. Guarantees space for at least one more; /// element, or MinSize more elements if specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:60,Deployability,update,updated,60,"/// Reserve enough space to add one element, and return the updated element; /// pointer in case it was a reference to the storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:60,Deployability,update,updated,60,"/// Reserve enough space to add one element, and return the updated element; /// pointer in case it was a reference to the storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:68,Safety,avoid,avoids,68,/// True if it's cheap enough to take parameters by value. Doing so avoids; /// overhead related to mitigations for reference invalidation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:26,Integrability,depend,depending,26,"/// Either const T& or T, depending on whether it's cheap enough to take; /// parameters by value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:112,Performance,optimiz,optimizes,112,"// Use memcpy for PODs iterated by pointers (which includes SmallVector; // iterators): std::uninitialized_copy optimizes to memmove, but we can; // use memcpy here. Note that I and E are iterators and thus might be; // invalid for memcpy if they are equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:27,Energy Efficiency,allocate,allocated,27,"/// Double the size of the allocated memory, guaranteeing space for at; /// least one more element or MinSize if specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:60,Deployability,update,updated,60,"/// Reserve enough space to add one element, and return the updated element; /// pointer in case it was a reference to the storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:60,Deployability,update,updated,60,"/// Reserve enough space to add one element, and return the updated element; /// pointer in case it was a reference to the storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:37,Integrability,depend,depending,37,"/// Copy \p V or return a reference, depending on \a ValueParamT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:136,Performance,optimiz,optimization,136,"// Elt has been copied in case it's an internal reference, side-stepping; // reference invalidation problems without losing the realloc optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:150,Performance,optimiz,optimization,150,"// Use push_back with a copy in case Args has an internal reference,; // side-stepping reference invalidation problems without losing the realloc; // optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:85,Energy Efficiency,reduce,reduce,85,/// This class consists of common code factored out of the SmallVector class to; /// reduce code duplication based on the SmallVector 'N' template parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:30,Safety,avoid,avoid,30,// Make set_size() private to avoid misuse in subclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:65,Usability,clear,clearing,65,"// FIXME: Consider assigning over existing elements, rather than clearing &; // re-initializing them - for all assign(...) variants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:18,Availability,down,down,18,// Shift all elts down one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:18,Availability,down,down,18,// Shift all elts down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:60,Deployability,update,update,60,"// If we just moved the element we're inserting, be sure to update; // the reference (never happens if TakesParamByValue).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:31,Safety,avoid,avoid,31,// Convert iterator to elt# to avoid invalidating iterator when we reserve(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:52,Deployability,update,updated,52,"// Ensure there is enough space, and get the (maybe updated) address of; // Elt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:131,Usability,simpl,simple,131,"// If there are more elements between the insertion point and the end of the; // range than there are being inserted, we can use a simple approach to; // insertion. Since we already reserved space, we know that this won't; // reallocate the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:60,Deployability,update,update,60,"// If we just moved the element we're inserting, be sure to update; // the reference (never happens if TakesParamByValue).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:60,Deployability,update,update,60,"// If we just moved the element we're inserting, be sure to update; // the reference (never happens if TakesParamByValue).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:31,Safety,avoid,avoid,31,// Convert iterator to elt# to avoid invalidating iterator when we reserve(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:131,Usability,simpl,simple,131,"// If there are more elements between the insertion point and the end of the; // range than there are being inserted, we can use a simple approach to; // insertion. Since we already reserved space, we know that this won't; // reallocate the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:15,Safety,avoid,avoid,15,// We can only avoid copying elements if neither vector is small.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:3,Safety,Avoid,Avoid,3,// Avoid self-assignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:171,Energy Efficiency,efficient,efficiently,171,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // FIXME: don't do this if they're efficiently moveable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:99,Safety,avoid,avoid,99,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // FIXME: don't do this if they're efficiently moveable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:3,Safety,Avoid,Avoid,3,// Avoid self-assignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:27,Usability,clear,clear,27,"// If the RHS isn't small, clear this vector and then steal its buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:3,Usability,Clear,Clear,3,// Clear the RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:193,Energy Efficiency,efficient,efficiently,193,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // FIXME: this may not actually make any sense if we can efficiently move; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:99,Safety,avoid,avoid,99,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // FIXME: this may not actually make any sense if we can efficiently move; // elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:87,Safety,avoid,avoid,87,/// Storage for the SmallVector elements. This is specialized for the N=0 case; /// to avoid allocating unnecessary storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:181,Energy Efficiency,allocate,allocate,181,"// static_assert that sizeof(T) is not ""too big"".; //; // Because our policy guarantees at least one inlined element, it is possible; // for an arbitrarily large inlined element to allocate an arbitrarily large; // amount of inline storage. We generally consider it an antipattern for a; // SmallVector to allocate an excessive amount of inline storage, so we want; // to call attention to these cases and make sure that users are making an; // intentional decision if they request a lot of inline storage.; //; // We want this assertion to trigger in pathological cases, but otherwise; // not be too easy to hit. To accomplish that, the cutoff is actually somewhat; // larger than kPreferredSmallVectorSizeof (otherwise,; // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that; // pattern seems useful in practice).; //; // One wrinkle is that this assertion is in theory non-portable, since; // sizeof(T) is in general platform-dependent. However, we don't expect this; // to be much of an issue, because most LLVM development happens on 64-bit; // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for; // 32-bit hosts, dodging the issue. The reverse situation, where development; // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a; // 64-bit host, is expected to be very rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:306,Energy Efficiency,allocate,allocate,306,"// static_assert that sizeof(T) is not ""too big"".; //; // Because our policy guarantees at least one inlined element, it is possible; // for an arbitrarily large inlined element to allocate an arbitrarily large; // amount of inline storage. We generally consider it an antipattern for a; // SmallVector to allocate an excessive amount of inline storage, so we want; // to call attention to these cases and make sure that users are making an; // intentional decision if they request a lot of inline storage.; //; // We want this assertion to trigger in pathological cases, but otherwise; // not be too easy to hit. To accomplish that, the cutoff is actually somewhat; // larger than kPreferredSmallVectorSizeof (otherwise,; // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that; // pattern seems useful in practice).; //; // One wrinkle is that this assertion is in theory non-portable, since; // sizeof(T) is in general platform-dependent. However, we don't expect this; // to be much of an issue, because most LLVM development happens on 64-bit; // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for; // 32-bit hosts, dodging the issue. The reverse situation, where development; // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a; // 64-bit host, is expected to be very rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:951,Integrability,depend,dependent,951,"// static_assert that sizeof(T) is not ""too big"".; //; // Because our policy guarantees at least one inlined element, it is possible; // for an arbitrarily large inlined element to allocate an arbitrarily large; // amount of inline storage. We generally consider it an antipattern for a; // SmallVector to allocate an excessive amount of inline storage, so we want; // to call attention to these cases and make sure that users are making an; // intentional decision if they request a lot of inline storage.; //; // We want this assertion to trigger in pathological cases, but otherwise; // not be too easy to hit. To accomplish that, the cutoff is actually somewhat; // larger than kPreferredSmallVectorSizeof (otherwise,; // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that; // pattern seems useful in practice).; //; // One wrinkle is that this assertion is in theory non-portable, since; // sizeof(T) is in general platform-dependent. However, we don't expect this; // to be much of an issue, because most LLVM development happens on 64-bit; // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for; // 32-bit hosts, dodging the issue. The reverse situation, where development; // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a; // 64-bit host, is expected to be very rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:898,Modifiability,portab,portable,898,"// static_assert that sizeof(T) is not ""too big"".; //; // Because our policy guarantees at least one inlined element, it is possible; // for an arbitrarily large inlined element to allocate an arbitrarily large; // amount of inline storage. We generally consider it an antipattern for a; // SmallVector to allocate an excessive amount of inline storage, so we want; // to call attention to these cases and make sure that users are making an; // intentional decision if they request a lot of inline storage.; //; // We want this assertion to trigger in pathological cases, but otherwise; // not be too easy to hit. To accomplish that, the cutoff is actually somewhat; // larger than kPreferredSmallVectorSizeof (otherwise,; // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that; // pattern seems useful in practice).; //; // One wrinkle is that this assertion is in theory non-portable, since; // sizeof(T) is in general platform-dependent. However, we don't expect this; // to be much of an issue, because most LLVM development happens on 64-bit; // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for; // 32-bit hosts, dodging the issue. The reverse situation, where development; // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a; // 64-bit host, is expected to be very rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:528,Testability,assert,assertion,528,"// static_assert that sizeof(T) is not ""too big"".; //; // Because our policy guarantees at least one inlined element, it is possible; // for an arbitrarily large inlined element to allocate an arbitrarily large; // amount of inline storage. We generally consider it an antipattern for a; // SmallVector to allocate an excessive amount of inline storage, so we want; // to call attention to these cases and make sure that users are making an; // intentional decision if they request a lot of inline storage.; //; // We want this assertion to trigger in pathological cases, but otherwise; // not be too easy to hit. To accomplish that, the cutoff is actually somewhat; // larger than kPreferredSmallVectorSizeof (otherwise,; // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that; // pattern seems useful in practice).; //; // One wrinkle is that this assertion is in theory non-portable, since; // sizeof(T) is in general platform-dependent. However, we don't expect this; // to be much of an issue, because most LLVM development happens on 64-bit; // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for; // 32-bit hosts, dodging the issue. The reverse situation, where development; // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a; // 64-bit host, is expected to be very rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:871,Testability,assert,assertion,871,"// static_assert that sizeof(T) is not ""too big"".; //; // Because our policy guarantees at least one inlined element, it is possible; // for an arbitrarily large inlined element to allocate an arbitrarily large; // amount of inline storage. We generally consider it an antipattern for a; // SmallVector to allocate an excessive amount of inline storage, so we want; // to call attention to these cases and make sure that users are making an; // intentional decision if they request a lot of inline storage.; //; // We want this assertion to trigger in pathological cases, but otherwise; // not be too easy to hit. To accomplish that, the cutoff is actually somewhat; // larger than kPreferredSmallVectorSizeof (otherwise,; // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that; // pattern seems useful in practice).; //; // One wrinkle is that this assertion is in theory non-portable, since; // sizeof(T) is in general platform-dependent. However, we don't expect this; // to be much of an issue, because most LLVM development happens on 64-bit; // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for; // 32-bit hosts, dodging the issue. The reverse situation, where development; // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a; // 64-bit host, is expected to be very rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:34,Modifiability,variab,variable-sized,34,"/// This is a 'vector' (really, a variable-sized array), optimized; /// for the case when the array is small. It contains some number of elements; /// in-place, which allows it to avoid heap allocation when the actual number of; /// elements is below that threshold. This allows normal ""small"" cases to be; /// fast without losing generality for large inputs.; ///; /// \note; /// In the absence of a well-motivated choice for the number of inlined; /// elements \p N, it is recommended to use \c SmallVector<T> (that is,; /// omitting the \p N). This will choose a default number of inlined elements; /// reasonable for allocation on the stack (for example, trying to keep \c; /// sizeof(SmallVector<T>) around 64 bytes).; ///; /// \warning This does not attempt to be exception safe.; ///; /// \see https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:57,Performance,optimiz,optimized,57,"/// This is a 'vector' (really, a variable-sized array), optimized; /// for the case when the array is small. It contains some number of elements; /// in-place, which allows it to avoid heap allocation when the actual number of; /// elements is below that threshold. This allows normal ""small"" cases to be; /// fast without losing generality for large inputs.; ///; /// \note; /// In the absence of a well-motivated choice for the number of inlined; /// elements \p N, it is recommended to use \c SmallVector<T> (that is,; /// omitting the \p N). This will choose a default number of inlined elements; /// reasonable for allocation on the stack (for example, trying to keep \c; /// sizeof(SmallVector<T>) around 64 bytes).; ///; /// \warning This does not attempt to be exception safe.; ///; /// \see https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:180,Safety,avoid,avoid,180,"/// This is a 'vector' (really, a variable-sized array), optimized; /// for the case when the array is small. It contains some number of elements; /// in-place, which allows it to avoid heap allocation when the actual number of; /// elements is below that threshold. This allows normal ""small"" cases to be; /// fast without losing generality for large inputs.; ///; /// \note; /// In the absence of a well-motivated choice for the number of inlined; /// elements \p N, it is recommended to use \c SmallVector<T> (that is,; /// omitting the \p N). This will choose a default number of inlined elements; /// reasonable for allocation on the stack (for example, trying to keep \c; /// sizeof(SmallVector<T>) around 64 bytes).; ///; /// \warning This does not attempt to be exception safe.; ///; /// \see https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:780,Safety,safe,safe,780,"/// This is a 'vector' (really, a variable-sized array), optimized; /// for the case when the array is small. It contains some number of elements; /// in-place, which allows it to avoid heap allocation when the actual number of; /// elements is below that threshold. This allows normal ""small"" cases to be; /// fast without losing generality for large inputs.; ///; /// \note; /// In the absence of a well-motivated choice for the number of inlined; /// elements \p N, it is recommended to use \c SmallVector<T> (that is,; /// omitting the \p N). This will choose a default number of inlined elements; /// reasonable for allocation on the stack (for example, trying to keep \c; /// sizeof(SmallVector<T>) around 64 bytes).; ///; /// \warning This does not attempt to be exception safe.; ///; /// \see https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:57,Performance,Optimiz,Optimize,57,// SmallVectorImpl<T>::operator= does not leverage N==0. Optimize the; // case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:36,Energy Efficiency,Efficient,Efficient,36,"//===- llvm/ADT/SparseBitVector.h - Efficient Sparse BitVector --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the SparseBitVector class. See the doxygen comment for; /// SparseBitVector for more details on the algorithm used.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:801,Performance,perform,perform,801,"/// SparseBitVector is an implementation of a bitvector that is sparse by only; /// storing the elements that have non-zero bits set. In order to make this; /// fast for the most common cases, SparseBitVector is implemented as a linked; /// list of SparseBitVectorElements. We maintain a pointer to the last; /// SparseBitVectorElement accessed (in the form of a list iterator), in order; /// to make multiple in-order test/set constant time after the first one is; /// executed. Note that using vectors to store SparseBitVectorElement's does; /// not work out very well because it causes insertion in the middle to take; /// enormous amounts of time with a large amount of bits. Other structures that; /// have better worst cases for insertion in the middle (various balanced trees,; /// etc) do not perform as well in practice as a linked list with this iterator; /// kept up to date. They are also significantly more memory intensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:336,Security,access,accessed,336,"/// SparseBitVector is an implementation of a bitvector that is sparse by only; /// storing the elements that have non-zero bits set. In order to make this; /// fast for the most common cases, SparseBitVector is implemented as a linked; /// list of SparseBitVectorElements. We maintain a pointer to the last; /// SparseBitVectorElement accessed (in the form of a list iterator), in order; /// to make multiple in-order test/set constant time after the first one is; /// executed. Note that using vectors to store SparseBitVectorElement's does; /// not work out very well because it causes insertion in the middle to take; /// enormous amounts of time with a large amount of bits. Other structures that; /// have better worst cases for insertion in the middle (various balanced trees,; /// etc) do not perform as well in practice as a linked list with this iterator; /// kept up to date. They are also significantly more memory intensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:419,Testability,test,test,419,"/// SparseBitVector is an implementation of a bitvector that is sparse by only; /// storing the elements that have non-zero bits set. In order to make this; /// fast for the most common cases, SparseBitVector is implemented as a linked; /// list of SparseBitVectorElements. We maintain a pointer to the last; /// SparseBitVectorElement accessed (in the form of a list iterator), in order; /// to make multiple in-order test/set constant time after the first one is; /// executed. Note that using vectors to store SparseBitVectorElement's does; /// not work out very well because it causes insertion in the middle to take; /// enormous amounts of time with a large amount of bits. Other structures that; /// have better worst cases for insertion in the middle (various balanced trees,; /// etc) do not perform as well in practice as a linked list with this iterator; /// kept up to date. They are also significantly more memory intensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:3,Availability,Mask,Mask,3,// Mask off previous bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:136,Performance,perform,performance,136,"// Pointer to our current Element. This has no visible effect on the external; // state of a SparseBitVector, it's just used to improve performance in the; // common case of testing/modifying bits with similar indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:174,Testability,test,testing,174,"// Pointer to our current Element. This has no visible effect on the external; // state of a SparseBitVector, it's just used to improve performance in the; // common case of testing/modifying bits with similar indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:6,Performance,cache,cache,6,// We cache a non-const iterator so we're forced to resort to const_cast to; // get the begin/end in the case where 'this' is const. To avoid duplication; // of code with the only difference being whether the const cast is present; // 'this' is always const in this particular function and we sort out the; // difference in FindLowerBound and FindLowerBoundConst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:136,Safety,avoid,avoid,136,// We cache a non-const iterator so we're forced to resort to const_cast to; // get the begin/end in the case where 'this' is const. To avoid duplication; // of code with the only difference being whether the const cast is present; // 'this' is always const in this particular function and we sort out the; // difference in FindLowerBound and FindLowerBoundConst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:71,Integrability,depend,depending,71,"// Search from our current iterator, either backwards or forwards,; // depending on what element we are looking for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:111,Energy Efficiency,efficient,efficient,111,"// Iterator to walk set bits in the bitmap. This iterator is a lot uglier; // than it would be, in order to be efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:3,Usability,Clear,Clear,3,// Clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:3,Testability,Test,Test,3,"// Test, Reset, and Set a bit in the bitmap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:122,Energy Efficiency,allocate,allocates,122,"/// Fast multiset implementation for objects that can be identified by small; /// unsigned keys.; ///; /// SparseMultiSet allocates memory proportional to the size of the key; /// universe, so it is not recommended for building composite data structures.; /// It is useful for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time; /// fast clear() as fast as a vector. The find(), insert(), and erase(); /// operations are all constant time, and typically faster than a hash table.; /// The iteration order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:604,Integrability,depend,depend,604,"/// Fast multiset implementation for objects that can be identified by small; /// unsigned keys.; ///; /// SparseMultiSet allocates memory proportional to the size of the key; /// universe, so it is not recommended for building composite data structures.; /// It is useful for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time; /// fast clear() as fast as a vector. The find(), insert(), and erase(); /// operations are all constant time, and typically faster than a hash table.; /// The iteration order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:644,Integrability,depend,depends,644,"/// Fast multiset implementation for objects that can be identified by small; /// unsigned keys.; ///; /// SparseMultiSet allocates memory proportional to the size of the key; /// universe, so it is not recommended for building composite data structures.; /// It is useful for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time; /// fast clear() as fast as a vector. The find(), insert(), and erase(); /// operations are all constant time, and typically faster than a hash table.; /// The iteration order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:1456,Performance,cache,cache,1456,"r. The find(), insert(), and erase(); /// operations are all constant time, and typically faster than a hash table.; /// The iteration order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable number of entries per key, as it will retain the; /// SparseSet algorithmic properties despite being growable. Thus, it is often a; /// better choice than a SparseSet of growable containers or a vector of; /// vectors. SparseMultiSet also keeps iterators valid after erasure (provided; /// the iterators don't point to the element erased), allowing for more; /// intuitive and fast removal.; ///; /// @tparam ValueT The type of objects in the set.; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:1600,Performance,cache,cache,1600,"ion order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable number of entries per key, as it will retain the; /// SparseSet algorithmic properties despite being growable. Thus, it is often a; /// better choice than a SparseSet of growable containers or a vector of; /// vectors. SparseMultiSet also keeps iterators valid after erasure (provided; /// the iterators don't point to the element erased), allowing for more; /// intuitive and fast removal.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:559,Security,hash,hash,559,"/// Fast multiset implementation for objects that can be identified by small; /// unsigned keys.; ///; /// SparseMultiSet allocates memory proportional to the size of the key; /// universe, so it is not recommended for building composite data structures.; /// It is useful for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time; /// fast clear() as fast as a vector. The find(), insert(), and erase(); /// operations are all constant time, and typically faster than a hash table.; /// The iteration order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:429,Usability,clear,clear,429,"/// Fast multiset implementation for objects that can be identified by small; /// unsigned keys.; ///; /// SparseMultiSet allocates memory proportional to the size of the key; /// universe, so it is not recommended for building composite data structures.; /// It is useful for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time; /// fast clear() as fast as a vector. The find(), insert(), and erase(); /// operations are all constant time, and typically faster than a hash table.; /// The iteration order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:963,Usability,clear,clear,963,"/// Fast multiset implementation for objects that can be identified by small; /// unsigned keys.; ///; /// SparseMultiSet allocates memory proportional to the size of the key; /// universe, so it is not recommended for building composite data structures.; /// It is useful for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time; /// fast clear() as fast as a vector. The find(), insert(), and erase(); /// operations are all constant time, and typically faster than a hash table.; /// The iteration order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:2365,Usability,intuit,intuitive,2365,"order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable number of entries per key, as it will retain the; /// SparseSet algorithmic properties despite being growable. Thus, it is often a; /// better choice than a SparseSet of growable containers or a vector of; /// vectors. SparseMultiSet also keeps iterators valid after erasure (provided; /// the iterators don't point to the element erased), allowing for more; /// intuitive and fast removal.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:238,Energy Efficiency,efficient,efficient,238,"/// The actual data that's stored, as a doubly-linked list implemented via; /// indices into the DenseVector. The doubly linked list is implemented; /// circular in Prev indices, and INVALID-terminated in Next indices. This; /// provides efficient access to list tails. These nodes can also be; /// tombstones, in which case they are actually nodes in a single-linked; /// freelist of recyclable slots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:248,Security,access,access,248,"/// The actual data that's stored, as a doubly-linked list implemented via; /// indices into the DenseVector. The doubly linked list is implemented; /// circular in Prev indices, and INVALID-terminated in Next indices. This; /// provides efficient access to list tails. These nodes can also be; /// tombstones, in which case they are actually nodes in a single-linked; /// freelist of recyclable slots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:131,Energy Efficiency,efficient,efficient,131,"/// Whether the given entry is the head of the list. List heads's previous; /// pointers are to the tail of the list, allowing for efficient access to the; /// list tail. D must be a valid entry node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:141,Security,access,access,141,"/// Whether the given entry is the head of the list. List heads's previous; /// pointers are to the tail of the list, allowing for efficient access to the; /// list tail. D must be a valid entry node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:72,Availability,avail,available,72,/// Add in the given SMSNode. Uses a free entry in our freelist if; /// available. Returns the index of the added node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:4,Usability,Clear,Clears,4,/// Clears the set. This is a very fast constant time operation.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:30,Usability,clear,cleared,30,"// Sparse does not need to be cleared, see find().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:377,Testability,test,test,377,"/// Erases an existing element identified by a valid iterator.; ///; /// This invalidates iterators pointing at the same entry, but erase() returns; /// an iterator pointing to the next element in the subset's list. This makes; /// it possible to erase selected elements while iterating over the subset:; ///; /// tie(I, E) = Set.equal_range(Key);; /// while (I != E); /// if (test(*I)); /// I = Set.erase(I);; /// else; /// ++I;; ///; /// Note that if the last element in the subset list is erased, this will; /// return an end iterator which can be decremented to get the new tail (if it; /// exists):; ///; /// tie(B, I) = Set.equal_range(Key);; /// for (bool isBegin = B == I; !isBegin; /* empty */) {; /// isBegin = (--I) == B;; /// if (test(I)); /// break;; /// I = erase(I);; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:742,Testability,test,test,742,"/// Erases an existing element identified by a valid iterator.; ///; /// This invalidates iterators pointing at the same entry, but erase() returns; /// an iterator pointing to the next element in the subset's list. This makes; /// it possible to erase selected elements while iterating over the subset:; ///; /// tie(I, E) = Set.equal_range(Key);; /// while (I != E); /// if (test(*I)); /// I = Set.erase(I);; /// else; /// ++I;; ///; /// Note that if the last element in the subset list is erased, this will; /// return an end iterator which can be decremented to get the new tail (if it; /// exists):; ///; /// tie(B, I) = Set.equal_range(Key);; /// for (bool isBegin = B == I; !isBegin; /* empty */) {; /// isBegin = (--I) == B;; /// if (test(I)); /// break;; /// I = erase(I);; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:27,Deployability,update,update,27,"// If we're the head, then update the sparse array and our next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:27,Deployability,update,update,27,"// If we're the tail, then update our head and our previous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:498,Energy Efficiency,efficient,efficient,498,"//===- llvm/ADT/SparseSet.h - Sparse set ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the SparseSet class derived from the version described in; /// Briggs, Torczon, ""An efficient representation for sparse sets"", ACM Letters; /// on Programming Languages and Systems, Volume 2 Issue 1-4, March-Dec. 1993.; ///; /// A sparse set holds a small number of objects identified by integer keys from; /// a moderately sized universe. The sparse set uses more memory than other; /// containers in order to provide faster operations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:585,Usability,simpl,simple,585,"/// SparseSetValTraits - Objects in a SparseSet are identified by keys that can; /// be uniquely converted to a small integer less than the set's universe. This; /// class allows the set to hold values that differ from the set's key type as; /// long as an index can still be derived from the value. SparseSet never; /// directly compares ValueT, only their indices, so it can map keys to; /// arbitrary values. SparseSetValTraits computes the index from the value; /// object. To compute the index from a key, SparseSet uses a separate; /// KeyFunctorT template argument.; ///; /// A simple type declaration, SparseSet<Type>, handles these cases:; /// - unsigned key, identity index, identity value; /// - unsigned key, identity index, fat value providing getSparseSetIndex(); ///; /// The type declaration SparseSet<Type, UnaryFunction> handles:; /// - unsigned key, remapped index, identity value (virtual registers); /// - pointer key, pointer-derived index, identity value (node+ID); /// - pointer key, pointer-derived index, fat value with getSparseSetIndex(); ///; /// Only other, unexpected cases require specializing SparseSetValTraits.; ///; /// For best results, ValueT should not require a destructor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:124,Energy Efficiency,allocate,allocates,124,"/// SparseSet - Fast set implementation for objects that can be identified by; /// small unsigned keys.; ///; /// SparseSet allocates memory proportional to the size of the key universe, so; /// it is not recommended for building composite data structures. It is useful; /// for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseSet provides constant-time fast; /// clear() and iteration as fast as a vector. The find(), insert(), and; /// erase() operations are all constant time, and typically faster than a hash; /// table. The iteration order doesn't depend on numerical key values, it only; /// depends on the order of insert() and erase() operations. When no elements; /// have been erased, the iteration order is the insertion order.; ///; /// Compared to BitVector, SparseSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast; /// iteration independent on the size of the universe.; ///; /// SparseSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT; /// template parameter provides a space/speed tradeoff for sets holding many; /// elements.; ///; /// When SparseT is uint32_t, find() only touches 2 cache lines, but the sparse; /// array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 2+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:615,Integrability,depend,depend,615,"/// SparseSet - Fast set implementation for objects that can be identified by; /// small unsigned keys.; ///; /// SparseSet allocates memory proportional to the size of the key universe, so; /// it is not recommended for building composite data structures. It is useful; /// for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseSet provides constant-time fast; /// clear() and iteration as fast as a vector. The find(), insert(), and; /// erase() operations are all constant time, and typically faster than a hash; /// table. The iteration order doesn't depend on numerical key values, it only; /// depends on the order of insert() and erase() operations. When no elements; /// have been erased, the iteration order is the insertion order.; ///; /// Compared to BitVector, SparseSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast; /// iteration independent on the size of the universe.; ///; /// SparseSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT; /// template parameter provides a space/speed tradeoff for sets holding many; /// elements.; ///; /// When SparseT is uint32_t, find() only touches 2 cache lines, but the sparse; /// array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 2+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:660,Integrability,depend,depends,660,"/// SparseSet - Fast set implementation for objects that can be identified by; /// small unsigned keys.; ///; /// SparseSet allocates memory proportional to the size of the key universe, so; /// it is not recommended for building composite data structures. It is useful; /// for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseSet provides constant-time fast; /// clear() and iteration as fast as a vector. The find(), insert(), and; /// erase() operations are all constant time, and typically faster than a hash; /// table. The iteration order doesn't depend on numerical key values, it only; /// depends on the order of insert() and erase() operations. When no elements; /// have been erased, the iteration order is the insertion order.; ///; /// Compared to BitVector, SparseSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast; /// iteration independent on the size of the universe.; ///; /// SparseSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT; /// template parameter provides a space/speed tradeoff for sets holding many; /// elements.; ///; /// When SparseT is uint32_t, find() only touches 2 cache lines, but the sparse; /// array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 2+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:1396,Performance,cache,cache,1396,"/// SparseSet - Fast set implementation for objects that can be identified by; /// small unsigned keys.; ///; /// SparseSet allocates memory proportional to the size of the key universe, so; /// it is not recommended for building composite data structures. It is useful; /// for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseSet provides constant-time fast; /// clear() and iteration as fast as a vector. The find(), insert(), and; /// erase() operations are all constant time, and typically faster than a hash; /// table. The iteration order doesn't depend on numerical key values, it only; /// depends on the order of insert() and erase() operations. When no elements; /// have been erased, the iteration order is the insertion order.; ///; /// Compared to BitVector, SparseSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast; /// iteration independent on the size of the universe.; ///; /// SparseSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT; /// template parameter provides a space/speed tradeoff for sets holding many; /// elements.; ///; /// When SparseT is uint32_t, find() only touches 2 cache lines, but the sparse; /// array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 2+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:1540,Performance,cache,cache,1540,"/// SparseSet - Fast set implementation for objects that can be identified by; /// small unsigned keys.; ///; /// SparseSet allocates memory proportional to the size of the key universe, so; /// it is not recommended for building composite data structures. It is useful; /// for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseSet provides constant-time fast; /// clear() and iteration as fast as a vector. The find(), insert(), and; /// erase() operations are all constant time, and typically faster than a hash; /// table. The iteration order doesn't depend on numerical key values, it only; /// depends on the order of insert() and erase() operations. When no elements; /// have been erased, the iteration order is the insertion order.; ///; /// Compared to BitVector, SparseSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast; /// iteration independent on the size of the universe.; ///; /// SparseSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT; /// template parameter provides a space/speed tradeoff for sets holding many; /// elements.; ///; /// When SparseT is uint32_t, find() only touches 2 cache lines, but the sparse; /// array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 2+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:570,Security,hash,hash,570,"/// SparseSet - Fast set implementation for objects that can be identified by; /// small unsigned keys.; ///; /// SparseSet allocates memory proportional to the size of the key universe, so; /// it is not recommended for building composite data structures. It is useful; /// for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseSet provides constant-time fast; /// clear() and iteration as fast as a vector. The find(), insert(), and; /// erase() operations are all constant time, and typically faster than a hash; /// table. The iteration order doesn't depend on numerical key values, it only; /// depends on the order of insert() and erase() operations. When no elements; /// have been erased, the iteration order is the insertion order.; ///; /// Compared to BitVector, SparseSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast; /// iteration independent on the size of the universe.; ///; /// SparseSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT; /// template parameter provides a space/speed tradeoff for sets holding many; /// elements.; ///; /// When SparseT is uint32_t, find() only touches 2 cache lines, but the sparse; /// array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 2+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:426,Usability,clear,clear,426,"/// SparseSet - Fast set implementation for objects that can be identified by; /// small unsigned keys.; ///; /// SparseSet allocates memory proportional to the size of the key universe, so; /// it is not recommended for building composite data structures. It is useful; /// for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseSet provides constant-time fast; /// clear() and iteration as fast as a vector. The find(), insert(), and; /// erase() operations are all constant time, and typically faster than a hash; /// table. The iteration order doesn't depend on numerical key values, it only; /// depends on the order of insert() and erase() operations. When no elements; /// have been erased, the iteration order is the insertion order.; ///; /// Compared to BitVector, SparseSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast; /// iteration independent on the size of the universe.; ///; /// SparseSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT; /// template parameter provides a space/speed tradeoff for sets holding many; /// elements.; ///; /// When SparseT is uint32_t, find() only touches 2 cache lines, but the sparse; /// array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 2+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:909,Usability,clear,clear,909,"/// SparseSet - Fast set implementation for objects that can be identified by; /// small unsigned keys.; ///; /// SparseSet allocates memory proportional to the size of the key universe, so; /// it is not recommended for building composite data structures. It is useful; /// for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseSet provides constant-time fast; /// clear() and iteration as fast as a vector. The find(), insert(), and; /// erase() operations are all constant time, and typically faster than a hash; /// table. The iteration order doesn't depend on numerical key values, it only; /// depends on the order of insert() and erase() operations. When no elements; /// have been erased, the iteration order is the insertion order.; ///; /// Compared to BitVector, SparseSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast; /// iteration independent on the size of the universe.; ///; /// SparseSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT; /// template parameter provides a space/speed tradeoff for sets holding many; /// elements.; ///; /// When SparseT is uint32_t, find() only touches 2 cache lines, but the sparse; /// array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 2+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:4,Usability,clear,clear,4,/// clear - Clears the set. This is a very fast constant time operation.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:12,Usability,Clear,Clears,12,/// clear - Clears the set. This is a very fast constant time operation.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:30,Usability,clear,cleared,30,"// Sparse does not need to be cleared, see find().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:30,Usability,clear,cleared,30,"// Sparse does not need to be cleared, see find().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:343,Testability,test,test,343,"/// erase - Erases an existing element identified by a valid iterator.; ///; /// This invalidates all iterators, but erase() returns an iterator pointing; /// to the next element. This makes it possible to erase selected elements; /// while iterating over the set:; ///; /// for (SparseSet::iterator I = Set.begin(); I != Set.end();); /// if (test(*I)); /// I = Set.erase(I);; /// else; /// ++I;; ///; /// Note that end() changes when elements are erased, unlike std::list.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:8,Integrability,depend,depends,8,// This depends on SmallVector::pop_back() not invalidating iterators.; // std::vector::pop_back() doesn't give that guarantee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:55,Security,hash,hashing,55,"//===- llvm/ADT/StableHashing.h - Utilities for stable hashing * C++ *-----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides types and functions for computing and combining stable; // hashes. Stable hashes can be useful for hashing across different modules,; // processes, or compiler runs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:461,Security,hash,hashes,461,"//===- llvm/ADT/StableHashing.h - Utilities for stable hashing * C++ *-----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides types and functions for computing and combining stable; // hashes. Stable hashes can be useful for hashing across different modules,; // processes, or compiler runs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:476,Security,hash,hashes,476,"//===- llvm/ADT/StableHashing.h - Utilities for stable hashing * C++ *-----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides types and functions for computing and combining stable; // hashes. Stable hashes can be useful for hashing across different modules,; // processes, or compiler runs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:501,Security,hash,hashing,501,"//===- llvm/ADT/StableHashing.h - Utilities for stable hashing * C++ *-----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides types and functions for computing and combining stable; // hashes. Stable hashes can be useful for hashing across different modules,; // processes, or compiler runs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:43,Security,hash,hash,43,"/// An opaque object representing a stable hash code. It can be serialized,; /// deserialized, and is stable across processes and executions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:10,Security,hash,hashes,10,// Stable hashes are based on the 64-bit FNV-1 hash:; // https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:47,Security,hash,hash,47,// Stable hashes are based on the 64-bit FNV-1 hash:; // https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:13,Security,hash,hashing,13,// namespace hashing,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:67,Security,hash,hashes,67,"/// Compute a stable_hash for a sequence of values.; ///; /// This hashes a sequence of values. It produces the same stable_hash as; /// 'stable_hash_combine(a, b, c, ...)', but can run over arbitrary sized; /// sequences and is significantly faster given pointers and types which; /// can be hashed as a sequence of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:293,Security,hash,hashed,293,"/// Compute a stable_hash for a sequence of values.; ///; /// This hashes a sequence of values. It produces the same stable_hash as; /// 'stable_hash_combine(a, b, c, ...)', but can run over arbitrary sized; /// sequences and is significantly faster given pointers and types which; /// can be hashed as a sequence of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:1013,Modifiability,variab,variables,1013,"//===-- llvm/ADT/Statistic.h - Easy way to expose stats ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the 'Statistic' class, which is designed to be an easy way; /// to expose various metrics from passes. These statistics are printed at the; /// end of a run (from llvm_shutdown), when the -stats command line option is; /// passed on the command line.; ///; /// This is useful for reporting information like the number of instructions; /// simplified, optimized or removed by various transformations, like this:; ///; /// static Statistic NumInstsKilled(""gcse"", ""Number of instructions killed"");; ///; /// Later, in the code: ++NumInstsKilled;; ///; /// NOTE: Statistics *must* be declared as global variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:765,Performance,optimiz,optimized,765,"//===-- llvm/ADT/Statistic.h - Easy way to expose stats ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the 'Statistic' class, which is designed to be an easy way; /// to expose various metrics from passes. These statistics are printed at the; /// end of a run (from llvm_shutdown), when the -stats command line option is; /// passed on the command line.; ///; /// This is useful for reporting information like the number of instructions; /// simplified, optimized or removed by various transformations, like this:; ///; /// static Statistic NumInstsKilled(""gcse"", ""Number of instructions killed"");; ///; /// Later, in the code: ++NumInstsKilled;; ///; /// NOTE: Statistics *must* be declared as global variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:43,Security,expose,expose,43,"//===-- llvm/ADT/Statistic.h - Easy way to expose stats ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the 'Statistic' class, which is designed to be an easy way; /// to expose various metrics from passes. These statistics are printed at the; /// end of a run (from llvm_shutdown), when the -stats command line option is; /// passed on the command line.; ///; /// This is useful for reporting information like the number of instructions; /// simplified, optimized or removed by various transformations, like this:; ///; /// static Statistic NumInstsKilled(""gcse"", ""Number of instructions killed"");; ///; /// Later, in the code: ++NumInstsKilled;; ///; /// NOTE: Statistics *must* be declared as global variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:481,Security,expose,expose,481,"//===-- llvm/ADT/Statistic.h - Easy way to expose stats ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the 'Statistic' class, which is designed to be an easy way; /// to expose various metrics from passes. These statistics are printed at the; /// end of a run (from llvm_shutdown), when the -stats command line option is; /// passed on the command line.; ///; /// This is useful for reporting information like the number of instructions; /// simplified, optimized or removed by various transformations, like this:; ///; /// static Statistic NumInstsKilled(""gcse"", ""Number of instructions killed"");; ///; /// Later, in the code: ++NumInstsKilled;; ///; /// NOTE: Statistics *must* be declared as global variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:753,Usability,simpl,simplified,753,"//===-- llvm/ADT/Statistic.h - Easy way to expose stats ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the 'Statistic' class, which is designed to be an easy way; /// to expose various metrics from passes. These statistics are printed at the; /// end of a run (from llvm_shutdown), when the -stats command line option is; /// passed on the command line.; ///; /// This is useful for reporting information like the number of instructions; /// simplified, optimized or removed by various transformations, like this:; ///; /// static Statistic NumInstsKilled(""gcse"", ""Number of instructions killed"");; ///; /// Later, in the code: ++NumInstsKilled;; ///; /// NOTE: Statistics *must* be declared as global variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:109,Modifiability,config,config,109,// Determine whether statistics should be enabled. We must do it here rather; // than in CMake because multi-config generators cannot determine this at; // configure time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:156,Modifiability,config,configure,156,// Determine whether statistics should be enabled. We must do it here rather; // than in CMake because multi-config generators cannot determine this at; // configure time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:18,Deployability,update,update,18,// Keep trying to update max until we succeed or another thread produces; // a bigger max than us.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:63,Usability,simpl,simple,63,// STATISTIC - A macro to make definition of statistics really simple. This; // automatically passes the DEBUG_TYPE of the file into the statistic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:129,Usability,clear,cleared,129,"/// Print statistics in JSON format. This does include all global timers (\see; /// Timer, TimerGroup). Note that the timers are cleared after printing and will; /// not be printed in human readable form or in a second call of; /// PrintStatisticsJSON().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:170,Deployability,update,updated,170,"/// Get the statistics. This can be used to look up the value of; /// statistics without needing to parse JSON.; ///; /// This function does not prevent statistics being updated by other threads; /// during it's execution. It will return the value at the point that it is; /// read. However, it will prevent new statistics from registering until it; /// completes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:348,Deployability,update,update,348,"/// Reset the statistics. This can be used to zero and de-register the; /// statistics in order to measure a compilation.; ///; /// When this function begins to call destructors prior to returning, all; /// statistics will be zero and unregistered. However, that might not remain the; /// case by the time this function finishes returning. Whether update from other; /// threads are lost or merely deferred until during the function return is; /// timing sensitive.; ///; /// Callers who intend to use this to measure statistics for a single; /// compilation should ensure that no compilations are in progress at the point; /// this function is called and that only one compilation executes until calling; /// GetStatistics().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:29,Safety,Detect,Detects,29,"// end namespace detail; /// Detects if a given trait holds for some set of arguments 'Args'.; /// For example, the given trait could be used to detect if a given type; /// has a copy assignment operator:; /// template<class T>; /// using has_copy_assign_t = decltype(std::declval<T&>(); /// = std::declval<const T&>());; /// bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:145,Safety,detect,detect,145,"// end namespace detail; /// Detects if a given trait holds for some set of arguments 'Args'.; /// For example, the given trait could be used to detect if a given type; /// has a copy assignment operator:; /// template<class T>; /// using has_copy_assign_t = decltype(std::declval<T&>(); /// = std::declval<const T&>());; /// bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:85,Security,access,access,85,/// This class provides various trait information about a callable object.; /// * To access the number of arguments: Traits::num_args; /// * To access the type of an argument: Traits::arg_t<Index>; /// * To access the type of the result: Traits::result_t,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:144,Security,access,access,144,/// This class provides various trait information about a callable object.; /// * To access the number of arguments: Traits::num_args; /// * To access the type of an argument: Traits::arg_t<Index>; /// * To access the type of the result: Traits::result_t,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:207,Security,access,access,207,/// This class provides various trait information about a callable object.; /// * To access the number of arguments: Traits::num_args; /// * To access the type of an argument: Traits::arg_t<Index>; /// * To access the type of the result: Traits::result_t,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:99,Testability,assert,assert,99,"// namespace detail; /// Determine if all types in Ts are distinct.; ///; /// Useful to statically assert when Ts is intended to describe a non-multi set; /// of types.; ///; /// Expensive (currently quadratic in sizeof(Ts...)), and so should only be; /// asserted once per instantiation of a type which requires it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:256,Testability,assert,asserted,256,"// namespace detail; /// Determine if all types in Ts are distinct.; ///; /// Useful to statically assert when Ts is intended to describe a non-multi set; /// of types.; ///; /// Expensive (currently quadratic in sizeof(Ts...)), and so should only be; /// asserted once per instantiation of a type which requires it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:388,Availability,error,error,388,"/// Find the first index where a type appears in a list of types.; ///; /// FirstIndexOfType<T, Us...>::value is the first index of T in Us.; ///; /// Typically only meaningful when it is otherwise statically known that the; /// type pack has no duplicate types. This should be guaranteed explicitly with; /// static_assert(TypesAreDistinct<Us...>::value).; ///; /// It is a compile-time error to instantiate when T is not present in Us, i.e.; /// if is_one_of<T, Us...>::value is false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:22,Integrability,wrap,wrapper,22,"/// Templated storage wrapper for a callable.; ///; /// This class is consistently default constructible, copy / move; /// constructible / assignable.; ///; /// Supported callable types:; /// - Function pointer; /// - Function reference; /// - Lambda; /// - Function object",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:57,Integrability,wrap,wrapping,57,// Function specialization. No need to waste extra space wrapping with a; // std::optional.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:19,Availability,echo,echo,19,// Pointer... just echo it back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:26,Availability,echo,echo,26,// T is a pointer... just echo it back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:47,Energy Efficiency,adapt,adapter,47,// mapped_iterator - This is a simple iterator adapter that causes a function to; // be applied whenever operator* is invoked on the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:47,Integrability,adapter,adapter,47,// mapped_iterator - This is a simple iterator adapter that causes a function to; // be applied whenever operator* is invoked on the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:47,Modifiability,adapt,adapter,47,// mapped_iterator - This is a simple iterator adapter that causes a function to; // be applied whenever operator* is invoked on the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:31,Usability,simpl,simple,31,// mapped_iterator - This is a simple iterator adapter that causes a function to; // be applied whenever operator* is invoked on the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:186,Usability,simpl,simply,186,"/// A base type of mapped iterator, that is useful for building derived; /// iterators that do not need/want to store the map function (as in; /// mapped_iterator). These iterators must simply provide a `mapElement` method; /// that defines how to map a value of the iterator to the provided reference; /// type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:16,Energy Efficiency,adapt,adaptor,16,"/// An iterator adaptor that filters the elements of given inner iterators.; ///; /// The predicate parameter should be a callable object that accepts the wrapped; /// iterator's reference type and returns a bool. When incrementing or; /// decrementing the iterator, it will call the predicate on each element and; /// skip any where it returns false.; ///; /// \code; /// int A[] = { 1, 2, 3, 4 };; /// auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });; /// // R contains { 1, 3 }.; /// \endcode; ///; /// Note: filter_iterator_base implements support for forward iteration.; /// filter_iterator_impl exists to provide support for bidirectional iteration,; /// conditional on whether the wrapped iterator supports it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:155,Integrability,wrap,wrapped,155,"/// An iterator adaptor that filters the elements of given inner iterators.; ///; /// The predicate parameter should be a callable object that accepts the wrapped; /// iterator's reference type and returns a bool. When incrementing or; /// decrementing the iterator, it will call the predicate on each element and; /// skip any where it returns false.; ///; /// \code; /// int A[] = { 1, 2, 3, 4 };; /// auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });; /// // R contains { 1, 3 }.; /// \endcode; ///; /// Note: filter_iterator_base implements support for forward iteration.; /// filter_iterator_impl exists to provide support for bidirectional iteration,; /// conditional on whether the wrapped iterator supports it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:704,Integrability,wrap,wrapped,704,"/// An iterator adaptor that filters the elements of given inner iterators.; ///; /// The predicate parameter should be a callable object that accepts the wrapped; /// iterator's reference type and returns a bool. When incrementing or; /// decrementing the iterator, it will call the predicate on each element and; /// skip any where it returns false.; ///; /// \code; /// int A[] = { 1, 2, 3, 4 };; /// auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });; /// // R contains { 1, 3 }.; /// \endcode; ///; /// Note: filter_iterator_base implements support for forward iteration.; /// filter_iterator_impl exists to provide support for bidirectional iteration,; /// conditional on whether the wrapped iterator supports it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:16,Modifiability,adapt,adaptor,16,"/// An iterator adaptor that filters the elements of given inner iterators.; ///; /// The predicate parameter should be a callable object that accepts the wrapped; /// iterator's reference type and returns a bool. When incrementing or; /// decrementing the iterator, it will call the predicate on each element and; /// skip any where it returns false.; ///; /// \code; /// int A[] = { 1, 2, 3, 4 };; /// auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });; /// // R contains { 1, 3 }.; /// \endcode; ///; /// Note: filter_iterator_base implements support for forward iteration.; /// filter_iterator_impl exists to provide support for bidirectional iteration,; /// conditional on whether the wrapped iterator supports it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:22,Energy Efficiency,adapt,adaptor,22,"/// A pseudo-iterator adaptor that is designed to implement ""early increment""; /// style loops.; ///; /// This is *not a normal iterator* and should almost never be used directly. It; /// is intended primarily to be used with range based for loops and some range; /// algorithms.; ///; /// The iterator isn't quite an `OutputIterator` or an `InputIterator` but; /// somewhere between them. The constraints of these iterators are:; ///; /// - On construction or after being incremented, it is comparable and; /// dereferencable. It is *not* incrementable.; /// - After being dereferenced, it is neither comparable nor dereferencable, it; /// is only incrementable.; ///; /// This means you can only dereference the iterator once, and you can only; /// increment it once between dereferences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:22,Modifiability,adapt,adaptor,22,"/// A pseudo-iterator adaptor that is designed to implement ""early increment""; /// style loops.; ///; /// This is *not a normal iterator* and should almost never be used directly. It; /// is intended primarily to be used with range based for loops and some range; /// algorithms.; ///; /// The iterator isn't quite an `OutputIterator` or an `InputIterator` but; /// somewhere between them. The constraints of these iterators are:; ///; /// - On construction or after being incremented, it is comparable and; /// dereferencable. It is *not* incrementable.; /// - After being dereferenced, it is neither comparable nor dereferencable, it; /// is only incrementable.; ///; /// This means you can only dereference the iterator once, and you can only; /// increment it once between dereferences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:28,Security,access,access,28,// ^ TODO: Implement random access methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:91,Testability,assert,assertions,91,"/// zip iterator that assumes that all iteratees have the same length.; /// In builds with assertions on, this assumption is checked before the; /// iteration starts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:191,Testability,assert,assertions,191,"/// zip iterator that, for the sake of efficiency, assumes the first iteratee to; /// be the shortest. Iteration continues until the end of the first iteratee is; /// reached. In builds with assertions on, we check that the assumption about; /// the first iteratee being the shortest holds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:13,Integrability,wrap,wrapper,13,"/// Iterator wrapper that concatenates sequences together.; ///; /// This can concatenate different iterators, even with different types, into; /// a single iterator provided the value types of all the concatenated; /// iterators expose `reference` and `pointer` types that can be converted to; /// `ValueT &` and `ValueT *` respectively. It doesn't support more; /// interesting/customized pointer or reference types.; ///; /// Currently this only supports forward or higher iterator categories as; /// inputs and always exposes a forward iterator interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:549,Integrability,interface,interface,549,"/// Iterator wrapper that concatenates sequences together.; ///; /// This can concatenate different iterators, even with different types, into; /// a single iterator provided the value types of all the concatenated; /// iterators expose `reference` and `pointer` types that can be converted to; /// `ValueT &` and `ValueT *` respectively. It doesn't support more; /// interesting/customized pointer or reference types.; ///; /// Currently this only supports forward or higher iterator categories as; /// inputs and always exposes a forward iterator interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:230,Security,expose,expose,230,"/// Iterator wrapper that concatenates sequences together.; ///; /// This can concatenate different iterators, even with different types, into; /// a single iterator provided the value types of all the concatenated; /// iterators expose `reference` and `pointer` types that can be converted to; /// `ValueT &` and `ValueT *` respectively. It doesn't support more; /// interesting/customized pointer or reference types.; ///; /// Currently this only supports forward or higher iterator categories as; /// inputs and always exposes a forward iterator interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:522,Security,expose,exposes,522,"/// Iterator wrapper that concatenates sequences together.; ///; /// This can concatenate different iterators, even with different types, into; /// a single iterator provided the value types of all the concatenated; /// iterators expose `reference` and `pointer` types that can be converted to; /// `ValueT &` and `ValueT *` respectively. It doesn't support more; /// interesting/customized pointer or reference types.; ///; /// Currently this only supports forward or higher iterator categories as; /// inputs and always exposes a forward iterator interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:62,Availability,error,error,62,/// Increments the first non-end iterator.; ///; /// It is an error to call this with all iterators at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:113,Availability,error,error,113,"/// Finds the first non-end iterator, dereferences, and returns the resulting; /// reference.; ///; /// It is an error to call this with all iterators at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:64,Security,access,access,64,/// Helper to store a sequence of ranges being concatenated and access them.; ///; /// This is designed to facilitate providing actual storage when temporaries; /// are passed into the constructor such that we can use it as part of range; /// based for loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:10,Security,access,access,10,/// Allow access to the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:320,Safety,avoid,avoid,320,"/// Return a reference to the first or second member of a reference. Otherwise,; /// return a copy of the member of a temporary.; ///; /// When passing a range whose iterators return values instead of references,; /// the reference must be dropped from `decltype((elt.first))`, which will; /// always be a reference, to avoid returning a reference to a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:29,Modifiability,inherit,inheritance,29,/// Utility type to build an inheritance chain that makes it easy to rank; /// overload candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:91,Integrability,depend,dependent,91,"// It would be better to use a std::uniform_int_distribution,; // but that would be stdlib dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:3,Safety,Avoid,Avoid,3,// Avoid self-assignment due to incorrect assertions in libstdc++; // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:42,Testability,assert,assertions,42,// Avoid self-assignment due to incorrect assertions in libstdc++; // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Energy Efficiency,Adapt,Adapt,4,/// Adapt std::less<T> for array_pod_sort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Modifiability,Adapt,Adapt,4,/// Adapt std::less<T> for array_pod_sort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:702,Modifiability,portab,portable,702,"/// array_pod_sort - This sorts an array with the specified start and end; /// extent. This is just like std::sort, except that it calls qsort instead of; /// using an inlined template. qsort is slightly slower than std::sort, but; /// most sorts are not performance critical in LLVM and std::sort has to be; /// template instantiated for each type, leading to significant measured code; /// bloat. This function should generally be used instead of std::sort where; /// possible.; ///; /// This function assumes that you have simple POD-like types that can be; /// compared with std::less and can be moved with memcpy. If this isn't true,; /// you should use std::sort.; ///; /// NOTE: If qsort_r were portable, we could allow a custom comparator and; /// default to std::less.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:255,Performance,perform,performance,255,"/// array_pod_sort - This sorts an array with the specified start and end; /// extent. This is just like std::sort, except that it calls qsort instead of; /// using an inlined template. qsort is slightly slower than std::sort, but; /// most sorts are not performance critical in LLVM and std::sort has to be; /// template instantiated for each type, leading to significant measured code; /// bloat. This function should generally be used instead of std::sort where; /// possible.; ///; /// This function assumes that you have simple POD-like types that can be; /// compared with std::less and can be moved with memcpy. If this isn't true,; /// you should use std::sort.; ///; /// NOTE: If qsort_r were portable, we could allow a custom comparator and; /// default to std::less.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:526,Usability,simpl,simple,526,"/// array_pod_sort - This sorts an array with the specified start and end; /// extent. This is just like std::sort, except that it calls qsort instead of; /// using an inlined template. qsort is slightly slower than std::sort, but; /// most sorts are not performance critical in LLVM and std::sort has to be; /// template instantiated for each type, leading to significant measured code; /// bloat. This function should generally be used instead of std::sort where; /// possible.; ///; /// This function assumes that you have simple POD-like types that can be; /// compared with std::less and can be moved with memcpy. If this isn't true,; /// you should use std::sort.; ///; /// NOTE: If qsort_r were portable, we could allow a custom comparator and; /// default to std::less.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:32,Integrability,wrap,wrappers,32,// namespace detail; // Provide wrappers to std::sort which shuffle the elements before sorting; // to help uncover non-deterministic behavior (PR35135).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:112,Performance,perform,performance,112,// Forward trivially copyable types to array_pod_sort. This avoids a large; // amount of code bloat for a minor performance hit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:60,Safety,avoid,avoids,60,// Forward trivially copyable types to array_pod_sort. This avoids a large; // amount of code bloat for a minor performance hit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:39,Integrability,wrap,wrapper,39,/// Get the size of a range. This is a wrapper function around std::distance; /// which is only enabled when the operation is O(1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::for_each which take ranges instead of having to; /// pass begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::all_of which take ranges instead of having to pass; /// begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::any_of which take ranges instead of having to pass; /// begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::none_of which take ranges instead of having to pass; /// begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::find which take ranges instead of having to pass; /// begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::find_if which take ranges instead of having to pass; /// begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::remove_if which take ranges instead of having to; /// pass begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::copy_if which take ranges instead of having to; /// pass begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::replace_copy_if which take ranges instead of having; /// to pass begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::replace_copy which take ranges instead of having to; /// pass begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::move which take ranges instead of having to; /// pass begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:332,Security,expose,expose,332,"// namespace detail; /// Returns true if \p Element is found in \p Range. Delegates the check to; /// either `.contains(Element)`, `.find(Element)`, or `std::find`, in this; /// order of preference. This is intended as the canonical way to check if an; /// element exists in a range in generic code or range type that does not; /// expose a `.contains(Element)` member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper function around std::is_sorted to check if elements in a range \p R; /// are sorted with respect to a comparator \p C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper function around std::is_sorted to check if elements in a range \p R; /// are sorted in non-descending order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper function around std::count to count the number of times an element; /// \p Element occurs in the given range \p Range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper function around std::count_if to count the number of times an; /// element satisfying a given predicate occurs in a range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper function around std::transform to apply a function to a range and; /// store the result elsewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::partition which take ranges instead of having to; /// pass begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::lower_bound which take ranges instead of having to; /// pass begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:12,Integrability,wrap,wrappers,12,/// Provide wrappers to std::upper_bound which take ranges instead of having to; /// pass begin/end explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper function around std::equal to detect if pair-wise elements between; /// two ranges are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:42,Safety,detect,detect,42,/// Wrapper function around std::equal to detect if pair-wise elements between; /// two ranges are the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Integrability,Wrap,Wrapper,4,"/// Wrapper function to remove a value from a container:; ///; /// C.erase(remove(C.begin(), C.end(), V), C.end());",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Integrability,Wrap,Wrapper,4,"/// Wrapper function to append range `R` to container `C`.; ///; /// C.insert(C.end(), R.begin(), R.end());",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:160,Testability,log,logic,160,"/// An STL-style algorithm similar to std::for_each that applies a second; /// functor between every pair of elements.; ///; /// This provides the control flow logic to, for example, print a; /// comma-separated list:; /// \code; /// interleave(names.begin(), names.end(),; /// [&](StringRef name) { os << name; },; /// [&] { os << "", ""; });; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:24,Energy Efficiency,adapt,adapts,24,/// Binary functor that adapts to any other binary functor after dereferencing; /// operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:24,Modifiability,adapt,adapts,24,/// Binary functor that adapts to any other binary functor after dereferencing; /// operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:542,Integrability,depend,depend,542,"/// Zippy iterator that uses the second iterator for comparisons. For the; /// increment to be safe, the second range has to be the shortest.; /// Returns `enumerator_result` on dereference to provide `.index()` and; /// `.value()` member functions.; /// Note: Because the dereference operator returns `enumerator_result` as a; /// value instead of a reference and does not strictly conform to the C++17's; /// definition of forward iterator. However, it satisfies all the; /// forward_iterator requirements that the `zip_common` and `zippy` depend on; /// and fully conforms to the C++20 definition of forward iterator.; /// This is similar to `std::vector<bool>::iterator` that returns bit reference; /// wrappers on dereference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:707,Integrability,wrap,wrappers,707,"/// Zippy iterator that uses the second iterator for comparisons. For the; /// increment to be safe, the second range has to be the shortest.; /// Returns `enumerator_result` on dereference to provide `.index()` and; /// `.value()` member functions.; /// Note: Because the dereference operator returns `enumerator_result` as a; /// value instead of a reference and does not strictly conform to the C++17's; /// definition of forward iterator. However, it satisfies all the; /// forward_iterator requirements that the `zip_common` and `zippy` depend on; /// and fully conforms to the C++20 definition of forward iterator.; /// This is similar to `std::vector<bool>::iterator` that returns bit reference; /// wrappers on dereference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:95,Safety,safe,safe,95,"/// Zippy iterator that uses the second iterator for comparisons. For the; /// increment to be safe, the second range has to be the shortest.; /// Returns `enumerator_result` on dereference to provide `.index()` and; /// `.value()` member functions.; /// Note: Because the dereference operator returns `enumerator_result` as a; /// value instead of a reference and does not strictly conform to the C++17's; /// definition of forward iterator. However, it satisfies all the; /// forward_iterator requirements that the `zip_common` and `zippy` depend on; /// and fully conforms to the C++20 definition of forward iterator.; /// This is similar to `std::vector<bool>::iterator` that returns bit reference; /// wrappers on dereference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:219,Availability,down,down,219,"// Make this tuple mutable to avoid casts that obfuscate const-correctness; // issues. Const-correctness of references is taken care of by `zippy` that; // defines const-non and const iterator types that will propagate down to; // `enumerator_result`'s `Refs`.; // Note that unlike the results of `zip*` functions, `enumerate`'s result are; // supposed to be modifiable even when defined as; // `const`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:30,Safety,avoid,avoid,30,"// Make this tuple mutable to avoid casts that obfuscate const-correctness; // issues. Const-correctness of references is taken care of by `zippy` that; // defines const-non and const iterator types that will propagate down to; // `enumerator_result`'s `Refs`.; // Note that unlike the results of `zip*` functions, `enumerate`'s result are; // supposed to be modifiable even when defined as; // `const`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:245,Integrability,depend,depends,245,"// Note: This dereference operator returns a value instead of a reference; // and does not strictly conform to the C++17's definition of forward; // iterator. However, it satisfies all the forward_iterator requirements; // that the `zip_common` depends on and fully conforms to the C++20; // definition of forward iterator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:11,Energy Efficiency,adapt,adaptor,11,// Just an adaptor to switch the order of argument and have the predicate before; // the zipped inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:11,Modifiability,adapt,adaptor,11,// Just an adaptor to switch the order of argument and have the predicate before; // the zipped inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:120,Security,access,access,120,"/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N); /// time. Not meant for use with random-access iterators.; /// Can optionally take a predicate to filter lazily some items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:120,Security,access,access,120,"/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N); /// time. Not meant for use with random-access iterators.; /// Can optionally take a predicate to lazily filter some items.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:3,Safety,Detect,Detect,3,"// Detect incomplete types, relying on the fact that their size is unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:25,Safety,Detect,Detects,25,// namespace detail; /// Detects when type `T` is incomplete. This is true for forward declarations; /// and false for types with a full definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLForwardCompat.h:581,Deployability,update,updated,581,"//===- STLForwardCompat.h - Library features from future STLs ------C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains library features backported from future STL versions.; ///; /// These should be replaced with their STL counterparts as the C++ version LLVM; /// is compiled with is updated.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLForwardCompat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLForwardCompat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLFunctionalExtras.h:207,Energy Efficiency,efficient,efficient,207,"//===----------------------------------------------------------------------===//; // Extra additions to <functional>; //===----------------------------------------------------------------------===//; /// An efficient, type-erasing, non-owning reference to a callable. This is; /// intended for use as the type of a function parameter that is not used; /// after the function in question returns.; ///; /// This class does not own the callable, so it is not in general safe to store; /// a function_ref.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLFunctionalExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLFunctionalExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLFunctionalExtras.h:468,Safety,safe,safe,468,"//===----------------------------------------------------------------------===//; // Extra additions to <functional>; //===----------------------------------------------------------------------===//; /// An efficient, type-erasing, non-owning reference to a callable. This is; /// intended for use as the type of a function parameter that is not used; /// after the function in question returns.; ///; /// This class does not own the callable, so it is not in general safe to store; /// a function_ref.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/STLFunctionalExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLFunctionalExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringExtras.h:116,Safety,detect,detects,116,"/// Convert the string \p S to an integer of the specified type using; /// the radix \p Base. If \p Base is 0, auto-detects the radix.; /// Returns true if the number was successfully converted, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringExtras.h:21,Modifiability,Portab,Portable,21,"/// StrInStrNoCase - Portable version of strcasestr. Locates the first; /// occurrence of string 's1' in string 's2', ignoring case. Returns; /// the offset of s2 in s1 or npos if s2 cannot be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringExtras.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringExtras.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:43,Integrability,interface,interface,43,"//===- StringMap.h - String Hash table map interface ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the StringMap class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:28,Security,Hash,Hash,28,"//===- StringMap.h - String Hash table map interface ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the StringMap class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:179,Security,hash,hash,179,"// Array of NumBuckets pointers to entries, null pointers are holes.; // TheTable[NumBuckets] contains a sentinel value for easy iteration. Followed; // by an array of the actual hash values as unsigned integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:303,Security,hash,hash,303,"/// LookupBucketFor - Look up the bucket that the specified string should end; /// up in. If it already exists as a key in the map, the Item pointer for the; /// specified bucket will be non-null. Otherwise, it will be null. In either; /// case, the FullHashValue field of the bucket will be set to the hash value; /// of the string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:100,Safety,abort,aborts,100,"/// RemoveKey - Remove the specified StringMapEntry from the table, but do not; /// delete it. This aborts if the value isn't in the table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate the table with the specified number of buckets and otherwise; /// setup the map as empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:230,Energy Efficiency,efficient,efficient,230,"/// StringMap - This is an unconventional map that is specialized for handling; /// keys that are ""strings"", which are basically ranges of bytes. This does some; /// funky memory allocation and hashing things to make it extremely efficient,; /// storing the string data *after* the value in the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:194,Security,hash,hashing,194,"/// StringMap - This is an unconventional map that is specialized for handling; /// keys that are ""strings"", which are basically ranges of bytes. This does some; /// funky memory allocation and hashing things to make it extremely efficient,; /// storing the string data *after* the value in the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate TheTable of the same size as RHS's TheTable, and set the; // sentinel appropriately (and NumBuckets).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:122,Safety,avoid,avoids,122,"// Delete all the elements in the map, but don't reset the elements; // to default values. This is a copy of clear(), but avoids unnecessary; // work not required in the destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:109,Usability,clear,clear,109,"// Delete all the elements in the map, but don't reset the elements; // to default values. This is a copy of clear(), but avoids unnecessary; // work not required in the destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:52,Safety,abort,abort,52,"/// at - Return the entry for the specified key, or abort if no such; /// entry exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:3,Usability,clear,clear,3,// clear - Empties out the StringMap,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:88,Safety,safe,safe,88,"// Zap all values, resetting the keys back to non-present (not tombstone),; // which is safe because we're removing all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:94,Safety,abort,aborts,94,"/// remove - Remove the specified key/value pair from the map, but do not; /// erase it. This aborts if the key is not in the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h:48,Integrability,interface,interface,48,"//===- StringMapEntry.h - String Hash table map interface -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the StringMapEntry class - it is intended to be a low; /// dependency implementation detail of StringMap that is more suitable for; /// inclusion in public headers than StringMap.h itself is.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h:473,Integrability,depend,dependency,473,"//===- StringMapEntry.h - String Hash table map interface -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the StringMapEntry class - it is intended to be a low; /// dependency implementation detail of StringMap that is more suitable for; /// inclusion in public headers than StringMap.h itself is.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h:33,Security,Hash,Hash,33,"//===- StringMapEntry.h - String Hash table map interface -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the StringMapEntry class - it is intended to be a low; /// dependency implementation detail of StringMap that is more suitable for; /// inclusion in public headers than StringMap.h itself is.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h:19,Energy Efficiency,allocate,allocate,19,"/// Helper to tail-allocate \p Key. It'd be nice to generalize this so it; /// could be reused elsewhere, maybe even taking an llvm::function_ref to; /// type-erase the allocator and put it in a source file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new item with space for the string at the end and a null; // terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:47,Integrability,Wrap,Wrapper,47,"//===- StringRef.h - Constant String Reference Wrapper ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:308,Modifiability,extend,extends,308,"/// StringRef - Represent a constant reference to a string, i.e. a character; /// array and a length, which need not be null terminated.; ///; /// This class does not own the string data, it is expected to be used in; /// situations where the character data resides in some other buffer, whose; /// lifetime extends past that of the StringRef. For this reason, it is not in; /// general safe to store a StringRef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:387,Safety,safe,safe,387,"/// StringRef - Represent a constant reference to a string, i.e. a character; /// array and a length, which need not be null terminated.; ///; /// This class does not own the string data, it is expected to be used in; /// situations where the character data resides in some other buffer, whose; /// lifetime extends past that of the StringRef. For this reason, it is not in; /// general safe to store a StringRef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:10,Energy Efficiency,Allocate,Allocate,10,// copy - Allocate copy in Allocator and return StringRef to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:53,Energy Efficiency,efficient,efficient,53,"/// equals - Check for string equality, this is more efficient than; /// compare() when the relative ordering of inequal strings isn't needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:439,Integrability,rout,routine,439,"/// Determine the edit distance between this string and another; /// string.; ///; /// \param Other the string to compare this string against.; ///; /// \param AllowReplacements whether to allow character; /// replacements (change one character into another) as a single; /// operation, rather than as two operations (an insertion and a; /// removal).; ///; /// \param MaxEditDistance If non-zero, the maximum edit distance that; /// this routine is allowed to compute. If the edit distance will exceed; /// that maximum, returns \c MaxEditDistance+1.; ///; /// \returns the minimum number of character insertions, removals,; /// or (if \p AllowReplacements is \c true) replacements needed to; /// transform one of the given strings into the other. If zero,; /// the strings are identical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:317,Availability,error,error,317,"/// Parse the current string as an integer of the specified radix. If; /// \p Radix is specified as zero, this does radix autosensing using; /// extended C rules: 0 is octal, 0x is hex, 0b is binary.; ///; /// If the string is invalid or if only a subset of the string is valid,; /// this returns true to signify the error. The string is considered; /// erroneous if empty or if it overflows T.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:145,Modifiability,extend,extended,145,"/// Parse the current string as an integer of the specified radix. If; /// \p Radix is specified as zero, this does radix autosensing using; /// extended C rules: 0 is octal, 0x is hex, 0b is binary.; ///; /// If the string is invalid or if only a subset of the string is valid,; /// this returns true to signify the error. The string is considered; /// erroneous if empty or if it overflows T.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:60,Safety,avoid,avoid,60,// The additional cast to unsigned long long is required to avoid the; // Visual C++ warning C4805: '!=' : unsafe mix of type 'bool' and type; // 'unsigned __int64' when instantiating getAsInteger with T = bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:107,Safety,unsafe,unsafe,107,// The additional cast to unsigned long long is required to avoid the; // Visual C++ warning C4805: '!=' : unsafe mix of type 'bool' and type; // 'unsigned __int64' when instantiating getAsInteger with T = bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:315,Availability,error,error,315,"/// Parse the current string as an integer of the specified radix. If; /// \p Radix is specified as zero, this does radix autosensing using; /// extended C rules: 0 is octal, 0x is hex, 0b is binary.; ///; /// If the string does not begin with a number of the specified radix,; /// this returns true to signify the error. The string is considered; /// erroneous if empty or if it overflows T.; /// The portion of the string representing the discovered numeric value; /// is removed from the beginning of the string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:145,Modifiability,extend,extended,145,"/// Parse the current string as an integer of the specified radix. If; /// \p Radix is specified as zero, this does radix autosensing using; /// extended C rules: 0 is octal, 0x is hex, 0b is binary.; ///; /// If the string does not begin with a number of the specified radix,; /// this returns true to signify the error. The string is considered; /// erroneous if empty or if it overflows T.; /// The portion of the string representing the discovered numeric value; /// is removed from the beginning of the string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:318,Availability,error,error,318,"/// Parse the current string as an integer of the specified \p Radix. If; /// \p Radix is specified as zero, this does radix autosensing using; /// extended C rules: 0 is octal, 0x is hex, 0b is binary.; ///; /// If the string does not begin with a number of the specified radix,; /// this returns true to signify the error. The string is considered; /// erroneous if empty.; /// The portion of the string representing the discovered numeric value; /// is removed from the beginning of the string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:148,Modifiability,extend,extended,148,"/// Parse the current string as an integer of the specified \p Radix. If; /// \p Radix is specified as zero, this does radix autosensing using; /// extended C rules: 0 is octal, 0x is hex, 0b is binary.; ///; /// If the string does not begin with a number of the specified radix,; /// this returns true to signify the error. The string is considered; /// erroneous if empty.; /// The portion of the string representing the discovered numeric value; /// is removed from the beginning of the string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:4,Safety,Detect,Detect,4,"/// Detect the line ending style of the string.; ///; /// If the string contains a line ending, return the line ending character; /// sequence that is detected. Otherwise return '\n' for unix line endings.; ///; /// \return - The line ending character sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:151,Safety,detect,detected,151,"/// Detect the line ending style of the string.; ///; /// If the string contains a line ending, return the line ending character; /// sequence that is detected. Otherwise return '\n' for unix line endings.; ///; /// \return - The line ending character sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:6,Integrability,wrap,wrapper,6,"/// A wrapper around a string literal that serves as a proxy for constructing; /// global tables of StringRefs with the length computed at compile time.; /// In order to avoid the invocation of a global constructor, StringLiteral; /// should *only* be used in a constexpr context, as such:; ///; /// constexpr StringLiteral S(""test"");; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:170,Safety,avoid,avoid,170,"/// A wrapper around a string literal that serves as a proxy for constructing; /// global tables of StringRefs with the length computed at compile time.; /// In order to avoid the invocation of a global constructor, StringLiteral; /// should *only* be used in a constexpr context, as such:; ///; /// constexpr StringLiteral S(""test"");; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:327,Testability,test,test,327,"/// A wrapper around a string literal that serves as a proxy for constructing; /// global tables of StringRefs with the length computed at compile time.; /// In order to avoid the invocation of a global constructor, StringLiteral; /// should *only* be used in a constexpr context, as such:; ///; /// constexpr StringLiteral S(""test"");; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSet.h:24,Energy Efficiency,efficient,efficient,24,"//===- StringSet.h - An efficient set built on StringMap --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// StringSet - A set-like wrapper for the StringMap.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSet.h:419,Integrability,wrap,wrapper,419,"//===- StringSet.h - An efficient set built on StringMap --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// StringSet - A set-like wrapper for the StringMap.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSet.h:18,Integrability,wrap,wrapper,18,/// StringSet - A wrapper for StringMap that provides set-like functionality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringSet.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSet.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h:591,Energy Efficiency,green,green,591,"/// A switch()-like statement whose cases are string literals.; ///; /// The StringSwitch class is a simple form of a switch() statement that; /// determines whether the given string matches one of the given string; /// literals. The template type parameter \p T is the type of the value that; /// will be returned from the string-switch expression. For example,; /// the following code switches on the name of a color in \c argv[i]:; ///; /// \code; /// Color color = StringSwitch<Color>(argv[i]); /// .Case(""red"", Red); /// .Case(""orange"", Orange); /// .Case(""yellow"", Yellow); /// .Case(""green"", Green); /// .Case(""blue"", Blue); /// .Case(""indigo"", Indigo); /// .Cases(""violet"", ""purple"", Violet); /// .Default(UnknownColor);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h:599,Energy Efficiency,Green,Green,599,"/// A switch()-like statement whose cases are string literals.; ///; /// The StringSwitch class is a simple form of a switch() statement that; /// determines whether the given string matches one of the given string; /// literals. The template type parameter \p T is the type of the value that; /// will be returned from the string-switch expression. For example,; /// the following code switches on the name of a color in \c argv[i]:; ///; /// \code; /// Color color = StringSwitch<Color>(argv[i]); /// .Case(""red"", Red); /// .Case(""orange"", Orange); /// .Case(""yellow"", Yellow); /// .Case(""green"", Green); /// .Case(""blue"", Blue); /// .Case(""indigo"", Indigo); /// .Cases(""violet"", ""purple"", Violet); /// .Default(UnknownColor);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h:101,Usability,simpl,simple,101,"/// A switch()-like statement whose cases are string literals.; ///; /// The StringSwitch class is a simple form of a switch() statement that; /// determines whether the given string matches one of the given string; /// literals. The template type parameter \p T is the type of the value that; /// will be returned from the string-switch expression. For example,; /// the following code switches on the name of a color in \c argv[i]:; ///; /// \code; /// Color color = StringSwitch<Color>(argv[i]); /// .Case(""red"", Red); /// .Case(""orange"", Orange); /// .Case(""yellow"", Yellow); /// .Case(""green"", Green); /// .Case(""blue"", Blue); /// .Case(""indigo"", Indigo); /// .Cases(""violet"", ""purple"", Violet); /// .Default(UnknownColor);; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h:57,Energy Efficiency,allocate,allocate,57,"// Try to squeeze into the single slot. If it won't fit, allocate a copied; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h:28,Energy Efficiency,allocate,allocated,28,"// If we have a full vector allocated, try to re-use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h:27,Energy Efficiency,allocate,allocated,27,"// If this vector has been allocated on the heap, re-use it if cheap. If it; // would require more copying, just delete it and we'll steal the other; // side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h:34,Usability,clear,clear,34,"// If we have a vector form, just clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:45,Energy Efficiency,efficient,efficiently,45,"/// Twine - A lightweight data structure for efficiently representing the; /// concatenation of temporary values as strings.; ///; /// A Twine is a kind of rope, it represents a concatenated string using a; /// binary-tree, where the string is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:299,Energy Efficiency,efficient,efficiently,299,"/// Twine - A lightweight data structure for efficiently representing the; /// concatenation of temporary values as strings.; ///; /// A Twine is a kind of rope, it represents a concatenated string using a; /// binary-tree, where the string is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:2547,Energy Efficiency,efficient,efficient,2547,"oncatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we provide two additional methods (and accompanying operator+; /// overloads) to guarantee that particularly important cases (cstring plus; /// StringRef) codegen as desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:2753,Energy Efficiency,allocate,allocated,2753,"oncatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we provide two additional methods (and accompanying operator+; /// overloads) to guarantee that particularly important cases (cstring plus; /// StringRef) codegen as desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:1264,Performance,perform,performed,1264,"ring is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:2697,Performance,optimiz,optimized,2697,"oncatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we provide two additional methods (and accompanying operator+; /// overloads) to guarantee that particularly important cases (cstring plus; /// StringRef) codegen as desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:2830,Performance,optimiz,optimize,2830,"oncatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we provide two additional methods (and accompanying operator+; /// overloads) to guarantee that particularly important cases (cstring plus; /// StringRef) codegen as desired.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:367,Safety,avoid,avoids,367,"/// Twine - A lightweight data structure for efficiently representing the; /// concatenation of temporary values as strings.; ///; /// A Twine is a kind of rope, it represents a concatenated string using a; /// binary-tree, where the string is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:581,Safety,avoid,avoid,581,"/// Twine - A lightweight data structure for efficiently representing the; /// concatenation of temporary values as strings.; ///; /// A Twine is a kind of rope, it represents a concatenated string using a; /// binary-tree, where the string is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:1899,Testability,test,testing,1899,"jects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we prov",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:62,Performance,optimiz,optimize,62,"/// Construct from a C string.; ///; /// We take care here to optimize """" into the empty twine -- this will be; /// optimized out for string constants. This allows Twine arguments have; /// default """" values, without introducing unnecessary string constants.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:116,Performance,optimiz,optimized,116,"/// Construct from a C string.; ///; /// We take care here to optimize """" into the empty twine -- this will be; /// optimized out for string constants. This allows Twine arguments have; /// default """" values, without introducing unnecessary string constants.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:137,Safety,avoid,avoids,137,"/// Construct from an std::string_view by converting it to a pointer and; /// length. This handles string_views on a pure API basis, and avoids; /// storing one (or a pointer to one) inside a Twine, which avoids problems; /// when mixing code compiled under various C++ standards.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:205,Safety,avoid,avoids,205,"/// Construct from an std::string_view by converting it to a pointer and; /// length. This handles string_views on a pure API basis, and avoids; /// storing one (or a pointer to one) inside a Twine, which avoids problems; /// when mixing code compiled under various C++ standards.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:214,Availability,down,down,214,"// FIXME: Unfortunately, to make sure this is as efficient as possible we; // need extra binary constructors from particular types. We can't rely on; // the compiler to be smart enough to fold operator+()/concat() down to the; // right thing. Yet.; /// Construct as the concatenation of a C string and a StringRef.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:49,Energy Efficiency,efficient,efficient,49,"// FIXME: Unfortunately, to make sure this is as efficient as possible we; // need extra binary constructors from particular types. We can't rely on; // the compiler to be smart enough to fold operator+()/concat() down to the; // right thing. Yet.; /// Construct as the concatenation of a C string and a StringRef.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:49,Security,access,accessed,49,/// Return true if this twine can be dynamically accessed as a single; /// StringRef value with getSingleStringRef().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:37,Usability,simpl,simplified,37,/// Additional overload to guarantee simplified codegen; this is equivalent to; /// concat().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:37,Usability,simpl,simplified,37,/// Additional overload to guarantee simplified codegen; this is equivalent to; /// concat().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h:103,Performance,optimiz,optimization,103,"// This is marked always_inline and nodebug so it doesn't show up in stack; // traces at -O0 (or other optimization levels). Large TypeSwitch's are; // common, are equivalent to a switch, and don't add any value to stack; // traces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h:179,Usability,simpl,simple,179,"/// Invoke a case on the derived class, inferring the type of the Case from; /// the first input of the given callable.; /// Note: This inference rules for this overload are very simple: strip; /// pointers and references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h:343,Testability,Log,LogicalResult,343,"// end namespace detail; /// This class implements a switch-like dispatch statement for a value of 'T'; /// using dyn_cast functionality. Each `Case<T>` takes a callable to be invoked; /// if the root value isa<T>, the callable is invoked with the result of; /// dyn_cast<T>() as a parameter.; ///; /// Example:; /// Operation *op = ...;; /// LogicalResult result = TypeSwitch<Operation *, LogicalResult>(op); /// .Case<ConstantOp>([](ConstantOp op) { ... }); /// .Default([](Operation *op) { ... });; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h:390,Testability,Log,LogicalResult,390,"// end namespace detail; /// This class implements a switch-like dispatch statement for a value of 'T'; /// using dyn_cast functionality. Each `Case<T>` takes a callable to be invoked; /// if the root value isa<T>, the callable is invoked with the result of; /// dyn_cast<T>() as a parameter.; ///; /// Example:; /// Operation *op = ...;; /// LogicalResult result = TypeSwitch<Operation *, LogicalResult>(op); /// .Case<ConstantOp>([](ConstantOp op) { ... }); /// .Default([](Operation *op) { ... });; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TypeSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/UniqueVector.h:12,Usability,Clear,Clears,12,/// reset - Clears all the entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/ADT/UniqueVector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/UniqueVector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:54,Integrability,Interface,Interface,54,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:427,Integrability,interface,interface,427,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:470,Integrability,interface,interface,470,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:639,Integrability,interface,interface,639,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:682,Integrability,interface,interface,682,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:1621,Integrability,depend,dependencies,1621,"//===- llvm/Analysis/AliasAnalysis.h - Alias Analysis Interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the generic AliasAnalysis interface, which is used as the; // common interface used by all clients of alias analysis information, and; // implemented by all alias analysis implementations. Mod/Ref information is; // also captured by this interface.; //; // Implementations of this interface must implement the various virtual methods,; // which automatically provides functionality for the entire suite of client; // APIs.; //; // This API identifies memory regions with the MemoryLocation class. The pointer; // component specifies the base memory address of the region. The Size specifies; // the maximum size (in address units) of the memory region, or; // MemoryLocation::UnknownSize if the size is not known. The TBAA tag; // identifies the ""type"" of the memory reference; see the; // TypeBasedAliasAnalysis class for details.; //; // Some non-obvious details include:; // - Pointers that point to two completely different objects in memory never; // alias, regardless of the value of the Size component.; // - NoAlias doesn't imply inequal pointers. The most obvious example of this; // is two pointers to constant memory. Even if they are equal, constant; // memory is never stored to, so there will never be any dependencies.; // In this and other situations, the pointers may be both NoAlias and; // MustAlias at the same time. The current API can only return one result,; // though this is rarely a problem in practice.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:264,Testability,test,testing,264,"/// The possible results of an alias query.; ///; /// These results are always computed between two MemoryLocation objects as; /// a query to some alias analysis.; ///; /// Note that these are unscoped enumerations because we would like to support; /// implicitly testing a result for the existence of any possible aliasing with; /// a conversion to bool, but an ""enum class"" doesn't support this. The; /// canonical names from the literature are suffixed and unique anyways, and so; /// they serve as global constants in LLVM for these results.; ///; /// See docs/AliasAnalysis.html for more information on the specific meanings; /// of these values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:58,Performance,cache,caches,58,"/// Context-free CaptureInfo provider, which computes and caches whether an; /// object is captured in the function at all, but does not distinguish whether; /// it was captured before or after the context instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:63,Performance,cache,caches,63,"/// Context-sensitive CaptureInfo provider, which computes and caches the; /// earliest common dominator closure of all captures. It provides a good; /// approximation to a precise ""captures before"" analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:101,Performance,cache,cache,101,/// Reverse map from instruction to the objects it is the earliest escape for.; /// This is used for cache invalidation purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:4,Performance,Cache,Cache,4,"/// Cache key for BasicAA results. It only includes the pointer and size from; /// MemoryLocation, as BasicAA is AATags independent. Additionally, it includes; /// the value of MayBeCrossIteration, which may affect BasicAA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:463,Integrability,wrap,wrapper,463,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:597,Modifiability,extend,extended,597,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:554,Performance,cache,caches,554,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:319,Safety,avoid,avoid,319,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:405,Safety,safe,safe,405,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:64,Performance,perform,performed,64,// Alias analysis result aggregration using which this query is performed.; // Can be used to perform recursive queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:94,Performance,perform,perform,94,// Alias analysis result aggregration using which this query is performed.; // Can be used to perform recursive queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:140,Performance,cache,cache,140,/// Location pairs for which an assumption based result is currently stored.; /// Used to remove all potentially incorrect results from the cache if an; /// assumption is disproven.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:433,Performance,load,load,433,"/// Tracks whether the accesses may be on different cycle iterations.; ///; /// When interpret ""Value"" pointer equality as value equality we need to make; /// sure that the ""Value"" is not part of a cycle. Otherwise, two uses could; /// come from different ""iterations"" of a cycle and see different values for; /// the same ""Value"" pointer.; ///; /// The following example shows the problem:; /// %p = phi(%alloca1, %addr2); /// %l = load %ptr; /// %addr1 = gep, %alloca2, 0, %l; /// %addr2 = gep %alloca2, 0, (%l + 1); /// alias(%p, %addr1) -> MayAlias !; /// store %l, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:23,Security,access,accesses,23,"/// Tracks whether the accesses may be on different cycle iterations.; ///; /// When interpret ""Value"" pointer equality as value equality we need to make; /// sure that the ""Value"" is not part of a cycle. Otherwise, two uses could; /// come from different ""iterations"" of a cycle and see different values for; /// the same ""Value"" pointer.; ///; /// The following example shows the problem:; /// %p = phi(%alloca1, %addr2); /// %l = load %ptr; /// %addr1 = gep, %alloca2, 0, %l; /// %addr2 = gep %alloca2, 0, (%l + 1); /// alias(%p, %addr1) -> MayAlias !; /// store %l, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:100,Deployability,update,update,100,"/// Whether alias analysis is allowed to use the dominator tree, for use by; /// passes that lazily update the DT while performing AA queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:120,Performance,perform,performing,120,"/// Whether alias analysis is allowed to use the dominator tree, for use by; /// passes that lazily update the DT while performing AA queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:26,Usability,Simpl,SimpleCaptureInfo,26,/// AAQueryInfo that uses SimpleCaptureInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:72,Modifiability,polymorphi,polymorphic,72,// FIXME: We should use a much lighter weight system than the usual; // polymorphic pattern because we don't own AAResult. It should; // ideally involve two pointers and no separate allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:65,Integrability,depend,depends,65,/// Register a function analysis ID that the results aggregation depends on.; ///; /// This is used in the new pass manager to implement the invalidation logic; /// where we must invalidate the results aggregation if any of our component; /// analyses become invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:154,Testability,log,logic,154,/// Register a function analysis ID that the results aggregation depends on.; ///; /// This is used in the new pass manager to implement the invalidation logic; /// where we must invalidate the results aggregation if any of our component; /// analyses become invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:136,Integrability,interface,interface,136,//===--------------------------------------------------------------------===//; /// \name Alias Queries; /// @{; /// The main low level interface to the alias analysis implementation.; /// Returns an AliasResult indicating whether the two pointers are aliased to; /// each other. This is the interface that must be implemented by specific; /// alias analysis implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:292,Integrability,interface,interface,292,//===--------------------------------------------------------------------===//; /// \name Alias Queries; /// @{; /// The main low level interface to the alias analysis implementation.; /// Returns an AliasResult indicating whether the two pointers are aliased to; /// each other. This is the interface that must be implemented by specific; /// alias analysis implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the primary \c alias interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:54,Integrability,interface,interface,54,/// A convenience wrapper around the primary \c alias interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the primary \c alias interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:54,Integrability,interface,interface,54,/// A convenience wrapper around the primary \c alias interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the \c isNoAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:57,Integrability,interface,interface,57,/// A convenience wrapper around the \c isNoAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the \c isNoAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:57,Integrability,interface,interface,57,/// A convenience wrapper around the \c isNoAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the \c isMustAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:59,Integrability,interface,interface,59,/// A convenience wrapper around the \c isMustAlias helper interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the primary \c pointsToConstantMemory; /// interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:76,Integrability,interface,interface,76,/// A convenience wrapper around the primary \c pointsToConstantMemory; /// interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:98,Usability,Simpl,Simple,98,"/// @}; //===--------------------------------------------------------------------===//; /// \name Simple mod/ref information; /// @{; /// Returns a bitmask that should be unconditionally applied to the ModRef; /// info of a memory location. This allows us to eliminate Mod and/or Ref; /// from the ModRef info based on the knowledge that the memory location; /// points to constant and/or locally-invariant memory.; ///; /// If IgnoreLocals is true, then this method returns NoModRef for memory; /// that points to a local alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper around the primary \c getModRefInfoMask; /// interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:71,Integrability,interface,interface,71,/// A convenience wrapper around the primary \c getModRefInfoMask; /// interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:266,Performance,optimiz,optimizations,266,"/// Checks if the specified call is known to never read or write memory.; ///; /// Note that if the call only reads from known-constant memory, it is also; /// legal to return true. Also, calls that unwind the stack are legal for; /// this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// without worrying about aliasing properties, and many calls have this; /// property (e.g. calls to 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:310,Performance,perform,performed,310,"/// Checks if the specified call is known to never read or write memory.; ///; /// Note that if the call only reads from known-constant memory, it is also; /// legal to return true. Also, calls that unwind the stack are legal for; /// this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// without worrying about aliasing properties, and many calls have this; /// property (e.g. calls to 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:277,Performance,optimiz,optimizations,277,"/// Checks if the specified function is known to never read or write memory.; ///; /// Note that if the function only reads from known-constant memory, it is; /// also legal to return true. Also, function that unwind the stack are legal; /// for this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// to such functions without worrying about aliasing properties, and many; /// functions have this property (e.g. 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:321,Performance,perform,performed,321,"/// Checks if the specified function is known to never read or write memory.; ///; /// Note that if the function only reads from known-constant memory, it is; /// also legal to return true. Also, function that unwind the stack are legal; /// for this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// to such functions without worrying about aliasing properties, and many; /// functions have this property (e.g. 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:227,Performance,optimiz,optimizations,227,"/// Checks if the specified call is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Calls that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:247,Performance,perform,performed,247,"/// Checks if the specified call is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Calls that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:93,Security,access,access,93,"/// Checks if the specified call is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Calls that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:235,Performance,optimiz,optimizations,235,"/// Checks if the specified function is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Functions that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:255,Performance,perform,performed,255,"/// Checks if the specified function is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Functions that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:97,Security,access,access,97,"/// Checks if the specified function is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Functions that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper for constructing the memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper to synthesize a memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper synthesizing a memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:18,Integrability,wrap,wrapper,18,/// A convenience wrapper synthesizing a memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:20,Integrability,wrap,wrapper,20,"/// This class is a wrapper over an AAResults, and it is intended to be used; /// only when there are no IR changes inbetween queries. BatchAAResults is; /// reusing the same `AAQueryInfo` to preserve the state across queries,; /// esentially making AA work in ""batch mode"". The internal state cannot be; /// cleared, so to go ""out-of-batch-mode"", the user must either use AAResults,; /// or create a new BatchAAResults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:309,Usability,clear,cleared,309,"/// This class is a wrapper over an AAResults, and it is intended to be used; /// only when there are no IR changes inbetween queries. BatchAAResults is; /// reusing the same `AAQueryInfo` to preserve the state across queries,; /// esentially making AA work in ""batch mode"". The internal state cannot be; /// cleared, so to go ""out-of-batch-mode"", the user must either use AAResults,; /// or create a new BatchAAResults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:125,Integrability,interface,interface,125,/// A private abstract base class describing the concept of an individual alias; /// analysis implementation.; ///; /// This interface is implemented by any \c Model instantiation. It is also the; /// interface which a type used to instantiate the model must provide.; ///; /// All of these methods model methods by the same name in the \c; /// AAResults class. Only differences and specifics to how the; /// implementations are called are documented here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:201,Integrability,interface,interface,201,/// A private abstract base class describing the concept of an individual alias; /// analysis implementation.; ///; /// This interface is implemented by any \c Model instantiation. It is also the; /// interface which a type used to instantiate the model must provide.; ///; /// All of these methods model methods by the same name in the \c; /// AAResults class. Only differences and specifics to how the; /// implementations are called are documented here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:136,Integrability,interface,interface,136,//===--------------------------------------------------------------------===//; /// \name Alias Queries; /// @{; /// The main low level interface to the alias analysis implementation.; /// Returns an AliasResult indicating whether the two pointers are aliased to; /// each other. This is the interface that must be implemented by specific; /// alias analysis implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:292,Integrability,interface,interface,292,//===--------------------------------------------------------------------===//; /// \name Alias Queries; /// @{; /// The main low level interface to the alias analysis implementation.; /// Returns an AliasResult indicating whether the two pointers are aliased to; /// each other. This is the interface that must be implemented by specific; /// alias analysis implementations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:98,Usability,Simpl,Simple,98,/// @}; //===--------------------------------------------------------------------===//; /// \name Simple mod/ref information; /// @{; /// Returns a bitmask that should be unconditionally applied to the ModRef; /// info of a memory location. This allows us to eliminate Mod and/or Ref from; /// the ModRef info based on the knowledge that the memory location points to; /// constant and/or locally-invariant memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:63,Integrability,wrap,wraps,63,/// A private class template which derives from \c Concept and wraps some other; /// type.; ///; /// This models the concept by directly forwarding each interface point to the; /// wrapped type which must implement a compatible interface. This provides; /// a type erased binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:153,Integrability,interface,interface,153,/// A private class template which derives from \c Concept and wraps some other; /// type.; ///; /// This models the concept by directly forwarding each interface point to the; /// wrapped type which must implement a compatible interface. This provides; /// a type erased binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:181,Integrability,wrap,wrapped,181,/// A private class template which derives from \c Concept and wraps some other; /// type.; ///; /// This models the concept by directly forwarding each interface point to the; /// wrapped type which must implement a compatible interface. This provides; /// a type erased binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:228,Integrability,interface,interface,228,/// A private class template which derives from \c Concept and wraps some other; /// type.; ///; /// This models the concept by directly forwarding each interface point to the; /// wrapped type which must implement a compatible interface. This provides; /// a type erased binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:199,Integrability,interface,interface,199,"/// A base class to help implement the function alias analysis results concept.; ///; /// Because of the nature of many alias analysis implementations, they often; /// only implement a subset of the interface. This base class will attempt to; /// implement the remaining portions of the interface in terms of simpler forms; /// of the interface where possible, and otherwise provide conservatively; /// correct fallback implementations.; ///; /// Implementors of an alias analysis should derive from this class, and then; /// override specific methods that they wish to customize. There is no need to; /// use virtual anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:287,Integrability,interface,interface,287,"/// A base class to help implement the function alias analysis results concept.; ///; /// Because of the nature of many alias analysis implementations, they often; /// only implement a subset of the interface. This base class will attempt to; /// implement the remaining portions of the interface in terms of simpler forms; /// of the interface where possible, and otherwise provide conservatively; /// correct fallback implementations.; ///; /// Implementors of an alias analysis should derive from this class, and then; /// override specific methods that they wish to customize. There is no need to; /// use virtual anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:335,Integrability,interface,interface,335,"/// A base class to help implement the function alias analysis results concept.; ///; /// Because of the nature of many alias analysis implementations, they often; /// only implement a subset of the interface. This base class will attempt to; /// implement the remaining portions of the interface in terms of simpler forms; /// of the interface where possible, and otherwise provide conservatively; /// correct fallback implementations.; ///; /// Implementors of an alias analysis should derive from this class, and then; /// override specific methods that they wish to customize. There is no need to; /// use virtual anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:309,Usability,simpl,simpler,309,"/// A base class to help implement the function alias analysis results concept.; ///; /// Because of the nature of many alias analysis implementations, they often; /// only implement a subset of the interface. This base class will attempt to; /// implement the remaining portions of the interface in terms of simpler forms; /// of the interface where possible, and otherwise provide conservatively; /// correct fallback implementations.; ///; /// Implementors of an alias analysis should derive from this class, and then; /// override specific methods that they wish to customize. There is no need to; /// use virtual anywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:118,Modifiability,Variab,Variables,118,/// Return true if this pointer refers to a distinct and identifiable object.; /// This returns true for:; /// Global Variables and Functions (but not Global Aliases); /// Allocas; /// ByVal and NoAlias Arguments; /// NoAlias returns (e.g. calls to malloc); ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:113,Integrability,depend,depend,113,"/// Return true if Object memory is not visible after an unwind, in the sense; /// that program semantics cannot depend on Object containing any particular; /// value on unwind. If the RequiresNoCaptureBeforeUnwind out parameter is set; /// to true, then the memory is only not visible if the object has not been; /// captured prior to the unwind. Otherwise it is not visible even if captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:113,Performance,load,loaded,113,"/// Return true if the Object is writable, in the sense that any location based; /// on this pointer that can be loaded can also be stored to without trapping.; /// Additionally, at the point Object is declared, stores can be introduced; /// without data races. At later points, this is only the case if the pointer; /// can not escape to a different thread.; ///; /// If ExplicitlyDereferenceableOnly is set to true, this property only holds; /// for the part of Object that is explicitly marked as dereferenceable, e.g.; /// using the dereferenceable(N) attribute. It does not necessarily hold for; /// parts that are only known to be dereferenceable due to the presence of; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:681,Performance,load,loads,681,"/// Return true if the Object is writable, in the sense that any location based; /// on this pointer that can be loaded can also be stored to without trapping.; /// Additionally, at the point Object is declared, stores can be introduced; /// without data races. At later points, this is only the case if the pointer; /// can not escape to a different thread.; ///; /// If ExplicitlyDereferenceableOnly is set to true, this property only holds; /// for the part of Object that is explicitly marked as dereferenceable, e.g.; /// using the dereferenceable(N) attribute. It does not necessarily hold for; /// parts that are only known to be dereferenceable due to the presence of; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:258,Availability,avail,available,258,"/// A manager for alias analyses.; ///; /// This class can have analyses registered with it and when run, it will run; /// all of them and aggregate their results into single AA results interface; /// that dispatches across all of the alias analysis results available.; ///; /// Note that the order in which analyses are registered is very significant.; /// That is the order in which the results will be aggregated and queried.; ///; /// This manager effectively wraps the AnalysisManager for registering alias; /// analyses. When you register your alias analysis with this manager, it will; /// ensure the analysis itself is registered with its AnalysisManager.; ///; /// The result of this analysis is only invalidated if one of the particular; /// aggregated AA results end up being invalidated. This removes the need to; /// explicitly preserve the results of `AAManager`. Note that analyses should no; /// longer be registered once the `AAManager` is run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:186,Integrability,interface,interface,186,"/// A manager for alias analyses.; ///; /// This class can have analyses registered with it and when run, it will run; /// all of them and aggregate their results into single AA results interface; /// that dispatches across all of the alias analysis results available.; ///; /// Note that the order in which analyses are registered is very significant.; /// That is the order in which the results will be aggregated and queried.; ///; /// This manager effectively wraps the AnalysisManager for registering alias; /// analyses. When you register your alias analysis with this manager, it will; /// ensure the analysis itself is registered with its AnalysisManager.; ///; /// The result of this analysis is only invalidated if one of the particular; /// aggregated AA results end up being invalidated. This removes the need to; /// explicitly preserve the results of `AAManager`. Note that analyses should no; /// longer be registered once the `AAManager` is run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:464,Integrability,wrap,wraps,464,"/// A manager for alias analyses.; ///; /// This class can have analyses registered with it and when run, it will run; /// all of them and aggregate their results into single AA results interface; /// that dispatches across all of the alias analysis results available.; ///; /// Note that the order in which analyses are registered is very significant.; /// That is the order in which the results will be aggregated and queried.; ///; /// This manager effectively wraps the AnalysisManager for registering alias; /// analyses. When you register your alias analysis with this manager, it will; /// ensure the analysis itself is registered with its AnalysisManager.; ///; /// The result of this analysis is only invalidated if one of the particular; /// aggregated AA results end up being invalidated. This removes the need to; /// explicitly preserve the results of `AAManager`. Note that analyses should no; /// longer be registered once the `AAManager` is run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:6,Integrability,wrap,wrapper,6,/// A wrapper pass to provide the legacy pass manager access to a suitably; /// prepared AAResults object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:54,Security,access,access,54,/// A wrapper pass to provide the legacy pass manager access to a suitably; /// prepared AAResults object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:6,Integrability,wrap,wrapper,6,/// A wrapper pass for external alias analyses. This just squirrels away the; /// callback used to run any analyses and register their results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:403,Deployability,pipeline,pipeline,403,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:6,Integrability,wrap,wrapper,6,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:277,Integrability,wrap,wrapper,277,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:415,Integrability,inject,inject,415,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:415,Security,inject,inject,415,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:783,Deployability,pipeline,pipeline,783,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:931,Energy Efficiency,adapt,adapted,931,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:931,Modifiability,adapt,adapted,931,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:891,Security,expose,exposed,891,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:853,Testability,test,tested,853,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h:419,Usability,simpl,simple,419,"//===- AliasAnalysisEvaluator.h - Alias Analysis Accuracy Evaluator -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a simple N^2 alias analysis accuracy evaluator. The; /// analysis result is a set of statistics of how many times the AA; /// infrastructure provides each kind of alias result and mod/ref result when; /// queried with all pairs of pointers in the function.; ///; /// It can be used to evaluate a change in an alias analysis implementation,; /// algorithm, or the AA pipeline infrastructure itself. It acts like a stable; /// and easily tested consumer of all AA information exposed.; ///; /// This is inspired and adapted from code by: Naveen Neelakantam, Francesco; /// Spadini, and Wojciech Stryjewski.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysisEvaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:450,Integrability,interface,interfaces,450,"//===- llvm/Analysis/AliasSetTracker.h - Build Alias Sets -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines two classes: AliasSetTracker and AliasSet. These interfaces; // are used to classify a collection of memory locations into a maximal number; // of disjoint sets. Each AliasSet object constructed by the AliasSetTracker; // object refers to memory disjoint from the other sets.; //; // An AliasSetTracker can only be used on immutable IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:17,Security,access,access,17,"/// The kinds of access this alias set models.; ///; /// We keep track of whether this alias set merely refers to the locations of; /// memory (and not any particular access), whether it modifies or references; /// the memory, or whether it does both. The lattice goes from ""NoAccess"" to; /// either RefAccess or ModAccess, then to ModRefAccess as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:167,Security,access,access,167,"/// The kinds of access this alias set models.; ///; /// We keep track of whether this alias set merely refers to the locations of; /// memory (and not any particular access), whether it modifies or references; /// the memory, or whether it does both. The lattice goes from ""NoAccess"" to; /// either RefAccess or ModAccess, then to ModRefAccess as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:4,Security,Access,Accessors,4,/// Accessors...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:31,Security,access,access,31,// Alias Set iteration - Allow access to all of the memory locations which are; // part of this alias set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:110,Performance,load,load,110,"/// Create an empty collection of AliasSets, and use the specified alias; /// analysis object to disambiguate load and store addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:3,Deployability,Update,Update,3,"// Update an alias set field to point to its real destination. If the field is; // pointing to a set that has been merged with another set and is forwarding,; // the field is updated to point to the set obtained by following the; // forwarding links. The Forward fields of intermediate alias sets are; // collapsed as well, and alias set reference counts are updated to reflect; // the new situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:175,Deployability,update,updated,175,"// Update an alias set field to point to its real destination. If the field is; // pointing to a set that has been merged with another set and is forwarding,; // the field is updated to point to the set obtained by following the; // forwarding links. The Forward fields of intermediate alias sets are; // collapsed as well, and alias set reference counts are updated to reflect; // the new situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:359,Deployability,update,updated,359,"// Update an alias set field to point to its real destination. If the field is; // pointing to a set that has been merged with another set and is forwarding,; // the field is updated to point to the set obtained by following the; // forwarding links. The Forward fields of intermediate alias sets are; // collapsed as well, and alias set reference counts are updated to reflect; // the new situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumeBundleQueries.h:153,Integrability,depend,depends,153,/// A mapping from intrinsics (=`llvm.assume` calls) to a value range; /// (=knowledge) that is encoded in them. How the value range is interpreted; /// depends on the RetainedKnowledgeKey that was used to get this out of the; /// RetainedKnowledgeMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumeBundleQueries.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumeBundleQueries.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:574,Performance,optimiz,optimizer,574,"//===- llvm/Analysis/AssumptionCache.h - Track @llvm.assume -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that keeps track of @llvm.assume intrinsics in; // the functions of a module (allowing assumptions within any function to be; // found cheaply by other parts of the optimizer).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:6,Performance,cache,cache,6,/// A cache of \@llvm.assume calls within a function.; ///; /// This cache provides fast lookup of assumptions within a function by caching; /// them and amortizing the cost of scanning for them across all queries. Passes; /// that create new assumptions are required to call registerAssumption() to; /// register any new \@llvm.assume calls that they create. Deletions of; /// \@llvm.assume calls do not require special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:69,Performance,cache,cache,69,/// A cache of \@llvm.assume calls within a function.; ///; /// This cache provides fast lookup of assumptions within a function by caching; /// them and amortizing the cost of scanning for them across all queries. Passes; /// that create new assumptions are required to call registerAssumption() to; /// register any new \@llvm.assume calls that they create. Deletions of; /// \@llvm.assume calls do not require special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:32,Performance,cache,cache,32,/// The function for which this cache is handling assumptions.; ///; /// We track this to lazily populate our assumptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:64,Performance,cache,cache,64,/// Get the vector of assumptions which affect a value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:32,Performance,cache,cache,32,/// Move affected values in the cache for OV to be affected values for NV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:58,Performance,cache,cache,58,/// Scan the function for assumptions and add them to the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:9,Performance,cache,cache,9,/// This cache is designed to be self-updating and so it should never be; /// invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:54,Performance,cache,cache,54,/// Add an \@llvm.assume intrinsic to this function's cache.; ///; /// The call passed in must be an instruction within this function and must; /// not already be in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:170,Performance,cache,cache,170,/// Add an \@llvm.assume intrinsic to this function's cache.; ///; /// The call passed in must be an instruction within this function and must; /// not already be in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:59,Performance,cache,cache,59,/// Remove an \@llvm.assume intrinsic from this function's cache if it has; /// been added to the cache earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:98,Performance,cache,cache,98,/// Remove an \@llvm.assume intrinsic from this function's cache if it has; /// been added to the cache earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Deployability,Update,Update,4,/// Update the cache of values being affected by this assumption (i.e.; /// the values about which this assumption provides information).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:15,Performance,cache,cache,15,/// Update the cache of values being affected by this assumption (i.e.; /// the values about which this assumption provides information).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:14,Performance,cache,cache,14,/// Clear the cache of \@llvm.assume intrinsics for a function.; ///; /// It will be re-scanned the next time it is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Usability,Clear,Clear,4,/// Clear the cache of \@llvm.assume intrinsics for a function.; ///; /// It will be re-scanned the next time it is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Security,Access,Access,4,/// Access the list of assumption handles currently tracked for this; /// function.; ///; /// Note that these produce weak handles that may be null. The caller must; /// handle that case.; /// FIXME: We should replace this with pointee_iterator<filter_iterator<...>>; /// when we can write that to filter out the null values. Then caller code; /// will become simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:360,Usability,simpl,simpler,360,/// Access the list of assumption handles currently tracked for this; /// function.; ///; /// Note that these produce weak handles that may be null. The caller must; /// handle that case.; /// FIXME: We should replace this with pointee_iterator<filter_iterator<...>>; /// when we can write that to filter out the null values. Then caller code; /// will become simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Security,Access,Access,4,/// Access the list of assumptions which affect this value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:162,Performance,cache,caches,162,/// A function analysis which provides an \c AssumptionCache.; ///; /// This analysis is intended for use with the new pass manager and will vend; /// assumption caches for a given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:204,Performance,cache,cache,204,/// An immutable pass that tracks lazily created \c AssumptionCache; /// objects.; ///; /// This is essentially a workaround for the legacy pass manager's weaknesses; /// which associates each assumption cache with Function and clears it if the; /// function is deleted. The nature of the AssumptionCache is that it is not; /// invalidated by any changes to the function body and so this is sufficient; /// to be conservatively correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:228,Usability,clear,clears,228,/// An immutable pass that tracks lazily created \c AssumptionCache; /// objects.; ///; /// This is essentially a workaround for the legacy pass manager's weaknesses; /// which associates each assumption cache with Function and clears it if the; /// function is deleted. The nature of the AssumptionCache is that it is not; /// invalidated by any changes to the function body and so this is sufficient; /// to be conservatively correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:89,Performance,cache,cache,89,"/// A callback value handle applied to function objects, which we use to; /// delete our cache of intrinsics for a function when it is deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:12,Performance,cache,cached,12,"/// Get the cached assumptions for a function.; ///; /// If no assumptions are cached, this will scan the function. Otherwise, the; /// existing cache will be returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:79,Performance,cache,cached,79,"/// Get the cached assumptions for a function.; ///; /// If no assumptions are cached, this will scan the function. Otherwise, the; /// existing cache will be returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:145,Performance,cache,cache,145,"/// Get the cached assumptions for a function.; ///; /// If no assumptions are cached, this will scan the function. Otherwise, the; /// existing cache will be returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:15,Performance,cache,cached,15,/// Return the cached assumptions for a function if it has already been; /// scanned. Otherwise return nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:403,Integrability,interface,interface,403,"//===- BasicAliasAnalysis.h - Stateless, local Alias Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for LLVM's primary stateless and local alias analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:117,Integrability,interface,interface,117,"/// This is the AA result object for the basic, local, and stateless alias; /// analysis. It implements the AA query interface in an entirely stateless; /// manner. As one consequence, it is never invalidated due to IR changes.; /// While it does retain some storage, that is used as an optimization and not; /// to preserve information from query to query. However it does retain handles; /// to various other analyses and must be recomputed when those analyses are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:287,Performance,optimiz,optimization,287,"/// This is the AA result object for the basic, local, and stateless alias; /// analysis. It implements the AA query interface in an entirely stateless; /// manner. As one consequence, it is never invalidated due to IR changes.; /// While it does retain some storage, that is used as an optimization and not; /// to preserve information from query to query. However it does retain handles; /// to various other analyses and must be recomputed when those analyses are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:27,Security,access,accessing,27,"/// Use getDT() instead of accessing this member directly, in order to; /// respect the AAQI.UseDominatorTree option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:82,Modifiability,variab,variables,82,"/// A Heuristic for aliasGEP that searches for a constant offset; /// between the variables.; ///; /// GetLinearExpression has some limitations, as generally zext(%x + 1); /// != zext(%x) + zext(1) if the arithmetic overflows. GetLinearExpression; /// will therefore conservatively refuse to decompose these expressions.; /// However, we know that, for all %x, zext(%x) != zext(%x + 1), even if; /// the addition overflows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the BasicAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:399,Usability,simpl,simplified,399,"//===- BlockFrequencyInfo.h - Block Frequency Analysis ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:287,Safety,avoid,avoid,287,"/// getblockFreq - Return block frequency. Return 0 if we don't have the; /// information. Please note that initial frequency is equal to ENTRY_FREQ. It; /// means that we should not rely on the value itself, but only on the; /// comparison to the other block frequencies. We do this to avoid using of; /// floating points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:168,Availability,avail,available,168,/// Returns the estimated profile count of \p BB.; /// This computes the relative block frequency of \p BB and multiplies it by; /// the enclosing function's count (if available) and returns the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:150,Availability,avail,available,150,/// Returns the estimated profile count of \p Freq.; /// This uses the frequency \p Freq and multiplies it by; /// the enclosing function's count (if available) and returns the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:244,Usability,Simpl,Simple,244,"/// Mass of a block.; ///; /// This class implements a sort of fixed-point fraction always between 0.0 and; /// 1.0. getMass() == std::numeric_limits<uint64_t>::max() indicates a value of; /// 1.0.; ///; /// Masses can be added and subtracted. Simple saturation arithmetic is used,; /// so arithmetic operations never overflow or underflow.; ///; /// Masses can be multiplied. Multiplication treats full mass as 1.0 and uses; /// an inexpensive floating-point algorithm that's off-by-one (almost, but not; /// quite, maximum precision).; ///; /// Masses can be scaled by \a BranchProbability at maximum precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:217,Integrability,depend,depend,217,"// end namespace bfi_detail; /// Base class for BlockFrequencyInfoImpl; ///; /// BlockFrequencyInfoImplBase has supporting data structures and some; /// algorithms for BlockFrequencyInfoImplBase. Only algorithms that depend on; /// the block type (or that call such algorithms) are skipped here.; ///; /// Nevertheless, the majority of the overall algorithm documentation lives with; /// BlockFrequencyInfoImpl. See there for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:58,Integrability,wrap,wrapper,58,"/// Representative of a block.; ///; /// This is a simple wrapper around an index into the reverse-post-order; /// traversal of the blocks.; ///; /// Unlike a block pointer, its order has meaning (location in the; /// topological sort) and it's class is the same regardless of block type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:51,Usability,simpl,simple,51,"/// Representative of a block.; ///; /// This is a simple wrapper around an index into the reverse-post-order; /// traversal of the blocks.; ///; /// Unlike a block pointer, its order has meaning (location in the; /// topological sort) and it's class is the same regardless of block type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:116,Availability,down,down,116,"/// Normalize the distribution.; ///; /// Combines multiple edges to the same \a Weight::TargetNode and scales; /// down so that \a Total fits into 32-bits.; ///; /// This is linear in the size of \a Weights. For the vast majority of; /// cases, adjacent edge weights are combined by sorting WeightList and; /// combining adjacent weights. However, for very large edge lists an; /// auxiliary hash table is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:393,Security,hash,hash,393,"/// Normalize the distribution.; ///; /// Combines multiple edges to the same \a Weight::TargetNode and scales; /// down so that \a Total fits into 32-bits.; ///; /// This is linear in the size of \a Weights. For the vast majority of; /// cases, adjacent edge weights are combined by sorting WeightList and; /// combining adjacent weights. However, for very large edge lists an; /// auxiliary hash table is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:40,Availability,down,downstream,40,/// Data about each block. This is used downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:72,Availability,down,downstream,72,/// Whether each block is an irreducible loop header.; /// This is used downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:63,Availability,mask,mask,63,/// Virtual destructor.; ///; /// Need a virtual destructor to mask the compiler warning about; /// getBlockName().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:306,Safety,abort,aborted,306,"/// Add an edge to the distribution.; ///; /// Adds an edge to Succ to Dist. If \c LoopHead.isValid(), then whether the; /// edge is local/exit/backedge is in the context of LoopHead. Otherwise,; /// every edge should be a local edge (since all the loops are packaged up).; ///; /// \return \c true unless aborted due to an irreducible backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:4,Deployability,Update,Update,4,"/// Update a loop after packaging irreducible SCCs inside of it.; ///; /// Update \c OuterLoop. Before finding irreducible control flow, it was; /// partway through \a computeMassInLoop(), so \a LoopData::Exits and \a; /// LoopData::BackedgeMass need to be reset. Also, nodes that were packaged; /// up need to be removed from \a OuterLoop::Nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:75,Deployability,Update,Update,75,"/// Update a loop after packaging irreducible SCCs inside of it.; ///; /// Update \c OuterLoop. Before finding irreducible control flow, it was; /// partway through \a computeMassInLoop(), so \a LoopData::Exits and \a; /// LoopData::BackedgeMass need to be reset. Also, nodes that were packaged; /// up need to be removed from \a OuterLoop::Nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:4,Usability,Clear,Clear,4,/// Clear all memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:4079,Availability,down,down,4079,"ersal through; /// the loop. Start by assigning full mass to the Loop header. For each; /// node in the loop:; ///; /// - Fetch and categorize the weight distribution for its successors.; /// If this is a packaged-subloop, the weight distribution is stored; /// in \a LoopData::Exits. Otherwise, fetch it from; /// BranchProbabilityInfo.; ///; /// - Each successor is categorized as \a Weight::Local, a local edge; /// within the current loop, \a Weight::Backedge, a backedge to the; /// loop header, or \a Weight::Exit, any successor outside the loop.; /// The weight, the successor, and its category are stored in \a; /// Distribution. There can be multiple edges to each successor.; ///; /// - If there's a backedge to a non-header, there's an irreducible SCC.; /// The usual flow is temporarily aborted. \a; /// computeIrreducibleMass() finds the irreducible SCCs within the; /// loop, packages them up, and restarts the flow.; ///; /// - Normalize the distribution: scale weights down so that their sum; /// is 32-bits, and coalesce multiple edges to the same node.; ///; /// - Distribute the mass accordingly, dithering to minimize mass loss,; /// as described in \a distributeMass().; ///; /// In the case of irreducible loops, instead of a single loop header,; /// there will be several. The computation of backedge masses is similar; /// but instead of having a single backedge mass, there will be one; /// backedge per loop header. In these cases, each backedge will carry; /// a mass proportional to the edge weights along the corresponding; /// path.; ///; /// At the end of propagation, the full mass assigned to the loop will be; /// distributed among the loop headers proportionally according to the; /// mass flowing through their backedges.; ///; /// Finally, calculate the loop scale from the accumulated backedge mass.; ///; /// 3. Distribute mass in the function (\a computeMassInFunction()).; ///; /// Finally, distribute mass through the DAG resulting from packaging all; /// lo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:5402,Availability,down,down,5402,"/// but instead of having a single backedge mass, there will be one; /// backedge per loop header. In these cases, each backedge will carry; /// a mass proportional to the edge weights along the corresponding; /// path.; ///; /// At the end of propagation, the full mass assigned to the loop will be; /// distributed among the loop headers proportionally according to the; /// mass flowing through their backedges.; ///; /// Finally, calculate the loop scale from the accumulated backedge mass.; ///; /// 3. Distribute mass in the function (\a computeMassInFunction()).; ///; /// Finally, distribute mass through the DAG resulting from packaging all; /// loops in the function. This uses the same algorithm as distributing; /// mass in a loop, except that there are no exit or backedge edges.; ///; /// 4. Unpackage loops (\a unwrapLoops()).; ///; /// Initialize each block's frequency to a floating point representation of; /// its mass.; ///; /// Visit loops top-down, scaling the frequencies of its immediate members; /// by the loop's pseudo-node's frequency.; ///; /// 5. Convert frequencies to a 64-bit range (\a finalizeMetrics()).; ///; /// Using the min and max frequencies as a guide, translate floating point; /// frequencies to an appropriate range in uint64_t.; ///; /// It has some known flaws.; ///; /// - The model of irreducible control flow is a rough approximation.; ///; /// Modelling irreducible control flow exactly involves setting up and; /// solving a group of infinite geometric series. Such precision is; /// unlikely to be worthwhile, since most of our algorithms give up on; /// irreducible control flow anyway.; ///; /// Nevertheless, we might find that we need to get closer. Here's a sort; /// of TODO list for the model with diminishing returns, to be completed as; /// necessary.; ///; /// - The headers for the \a LoopData representing an irreducible SCC; /// include non-entry blocks. When these extra blocks exist, they; /// indicate a self-contained irreducible s",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:1637,Integrability,wrap,wrapper,1637,"ble; /// SCCs, which are SCCs with multiple entry blocks. Irreducible SCCs are; /// discovered on the fly, and modelled as loops with multiple headers.; ///; /// The headers of irreducible sub-SCCs consist of its entry blocks and all; /// nodes that are targets of a backedge within it (excluding backedges within; /// true sub-loops). Block frequency calculations act as if a block is; /// inserted that intercepts all the edges to the headers. All backedges and; /// entries point to this block. Its successors are the headers, which split; /// the frequency evenly.; ///; /// This algorithm leverages BlockMass and ScaledNumber to maintain precision,; /// separates mass distribution from loop scaling, and dithers to eliminate; /// probability mass loss.; ///; /// The implementation is split between BlockFrequencyInfoImpl, which knows the; /// type of graph being modelled (BasicBlock vs. MachineBasicBlock), and; /// BlockFrequencyInfoImplBase, which doesn't. The base class uses \a; /// BlockNode, a wrapper around a uint32_t. BlockNode is numbered from 0 in; /// reverse-post order. This gives two advantages: it's easy to compare the; /// relative ordering of two nodes, and maps keyed on BlockT can be represented; /// by vectors.; ///; /// This algorithm is O(V+E), unless there is irreducible control flow, in; /// which case it's O(V*E) in the worst case.; ///; /// These are the main stages:; ///; /// 0. Reverse post-order traversal (\a initializeRPOT()).; ///; /// Run a single post-order traversal and save it (in reverse) in RPOT.; /// All other stages make use of this ordering. Save a lookup from BlockT; /// to BlockNode (the index into RPOT) in Nodes.; ///; /// 1. Loop initialization (\a initializeLoops()).; ///; /// Translate LoopInfo/MachineLoopInfo into a form suitable for the rest of; /// the algorithm. In particular, store the immediate members of each loop; /// in reverse post-order.; ///; /// 2. Calculate mass and scale in loops (\a computeMassInLoops()).; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:3893,Safety,abort,aborted,3893,"le (number of loop iterations). Immediate; /// members that represent sub-loops will already have been visited and; /// packaged into a pseudo-node.; ///; /// Distributing mass in a loop is a reverse-post-order traversal through; /// the loop. Start by assigning full mass to the Loop header. For each; /// node in the loop:; ///; /// - Fetch and categorize the weight distribution for its successors.; /// If this is a packaged-subloop, the weight distribution is stored; /// in \a LoopData::Exits. Otherwise, fetch it from; /// BranchProbabilityInfo.; ///; /// - Each successor is categorized as \a Weight::Local, a local edge; /// within the current loop, \a Weight::Backedge, a backedge to the; /// loop header, or \a Weight::Exit, any successor outside the loop.; /// The weight, the successor, and its category are stored in \a; /// Distribution. There can be multiple edges to each successor.; ///; /// - If there's a backedge to a non-header, there's an irreducible SCC.; /// The usual flow is temporarily aborted. \a; /// computeIrreducibleMass() finds the irreducible SCCs within the; /// loop, packages them up, and restarts the flow.; ///; /// - Normalize the distribution: scale weights down so that their sum; /// is 32-bits, and coalesce multiple edges to the same node.; ///; /// - Distribute the mass accordingly, dithering to minimize mass loss,; /// as described in \a distributeMass().; ///; /// In the case of irreducible loops, instead of a single loop header,; /// there will be several. The computation of backedge masses is similar; /// but instead of having a single backedge mass, there will be one; /// backedge per loop header. In these cases, each backedge will carry; /// a mass proportional to the edge weights along the corresponding; /// path.; ///; /// At the end of propagation, the full mass assigned to the loop will be; /// distributed among the loop headers proportionally according to the; /// mass flowing through their backedges.; ///; /// Finally, calculat",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:5625,Usability,guid,guide,5625,"ing; /// path.; ///; /// At the end of propagation, the full mass assigned to the loop will be; /// distributed among the loop headers proportionally according to the; /// mass flowing through their backedges.; ///; /// Finally, calculate the loop scale from the accumulated backedge mass.; ///; /// 3. Distribute mass in the function (\a computeMassInFunction()).; ///; /// Finally, distribute mass through the DAG resulting from packaging all; /// loops in the function. This uses the same algorithm as distributing; /// mass in a loop, except that there are no exit or backedge edges.; ///; /// 4. Unpackage loops (\a unwrapLoops()).; ///; /// Initialize each block's frequency to a floating point representation of; /// its mass.; ///; /// Visit loops top-down, scaling the frequencies of its immediate members; /// by the loop's pseudo-node's frequency.; ///; /// 5. Convert frequencies to a 64-bit range (\a finalizeMetrics()).; ///; /// Using the min and max frequencies as a guide, translate floating point; /// frequencies to an appropriate range in uint64_t.; ///; /// It has some known flaws.; ///; /// - The model of irreducible control flow is a rough approximation.; ///; /// Modelling irreducible control flow exactly involves setting up and; /// solving a group of infinite geometric series. Such precision is; /// unlikely to be worthwhile, since most of our algorithms give up on; /// irreducible control flow anyway.; ///; /// Nevertheless, we might find that we need to get closer. Here's a sort; /// of TODO list for the model with diminishing returns, to be completed as; /// necessary.; ///; /// - The headers for the \a LoopData representing an irreducible SCC; /// include non-entry blocks. When these extra blocks exist, they; /// indicate a self-contained irreducible sub-SCC. We could treat them; /// as sub-loops, rather than arbitrarily shoving the problematic; /// blocks into the headers of the main irreducible SCC.; ///; /// - Entry frequencies are assumed to be even",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:128,Safety,abort,aborts,128,"/// Compute mass in all loops.; ///; /// For each loop bottom-up, call \a computeMassInLoop().; ///; /// \a computeMassInLoop() aborts (and returns \c false) on loops that; /// contain a irreducible sub-SCCs. Use \a computeIrreducibleMass() and then; /// re-enter \a computeMassInLoop().; ///; /// \post \a computeMassInLoop() has returned \c true for every loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:238,Deployability,update,updates,238,"/// The current implementation for computing relative block frequencies does; /// not handle correctly control-flow graphs containing irreducible loops. To; /// resolve the problem, we apply a post-processing step, which iteratively; /// updates block frequencies based on the frequencies of their predesessors.; /// This corresponds to finding the stationary point of the Markov chain by; /// an iterative method aka ""PageRank computation"".; /// The algorithm takes at most O(|E| * IterativeBFIMaxIterations) steps but; /// typically converges faster.; ///; /// Decide whether we want to apply iterative inference for a given function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:76,Safety,avoid,avoid,76,"// We don't erase corresponding items from `Freqs`, `RPOT` and other to; // avoid invalidating indices. Doing so would have saved some memory, but; // it's not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:291,Testability,test,tests,291,"/// Print the frequencies for the current function.; ///; /// Prints the frequencies for the blocks in the current function.; ///; /// Blocks are printed in the natural iteration order of the function, rather; /// than reverse post-order. This provides two advantages: writing -analyze; /// tests is easier (since blocks come out in source order), and even; /// unreachable blocks are printed.; ///; /// \a BlockFrequencyInfoImplBase::print() only knows reverse post-order, so; /// we need to override it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:6,Safety,detect,detect,6,"// To detect BFI queries for unknown blocks, add entries for unreachable; // blocks, if any. This is to distinguish between known/existing unreachable; // blocks and unknown blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:19,Availability,down,down,19,// Visit loops top down and assign them an index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:301,Deployability,update,update,301,"// As a heuristic, if some headers don't have a weight, give them the; // minimum weight seen (not to disrupt the existing trends too much by; // using a weight that's in the general range of the other headers' weights,; // and the minimum seems to perform better than the average.); // FIXME: better update in the passes that drop the header weight.; // If no headers have a weight, give them even weight (use weight 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:249,Performance,perform,perform,249,"// As a heuristic, if some headers don't have a weight, give them the; // minimum weight seen (not to disrupt the existing trends too much by; // using a weight that's in the general range of the other headers' weights,; // and the minimum seems to perform better than the average.); // FIXME: better update in the passes that drop the header weight.; // If no headers have a weight, give them even weight (use weight 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:97,Deployability,update,updated,97,"// To speedup computation, we maintain a set of ""active"" blocks whose; // frequencies need to be updated based on the incoming edges.; // The set is dynamic and changes after every update. Initially all blocks; // with a positive frequency are active",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:181,Deployability,update,update,181,"// To speedup computation, we maintain a set of ""active"" blocks whose; // frequencies need to be updated based on the incoming edges.; // The set is dynamic and changes after every update. Initially all blocks; // with a positive frequency are active",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:3,Deployability,Update,Update,3,// Update the frequency for the block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:777,Testability,log,logically,777,"/// Analysis providing branch probability information.; ///; /// This is a function analysis which provides information on the relative; /// probabilities of each ""edge"" in the function's CFG where such an edge is; /// defined by a pair (PredBlock and an index in the successors). The; /// probability of an edge from one block is always relative to the; /// probabilities of other edges from the block. The probabilites of all edges; /// from a block sum to exactly one (100%).; /// We use a pair (PredBlock and an index in the successors) to uniquely; /// identify an edge, since we can have multiple edges from Src to Dst.; /// As an example, we can have a switch which jumps to Dst with value 0 and; /// value 10.; ///; /// Process of computing branch probabilities can be logically viewed as three; /// step process:; ///; /// First, if there is a profile information associated with the branch then; /// it is trivially translated to branch probabilities. There is one exception; /// from this rule though. Probabilities for edges leading to ""unreachable""; /// blocks (blocks with the estimated weight not greater than; /// UNREACHABLE_WEIGHT) are evaluated according to static estimation and; /// override profile information. If no branch probabilities were calculated; /// on this step then take the next one.; ///; /// Second, estimate absolute execution weights for each block based on; /// statically known information. Roots of such information are ""cold"",; /// ""unreachable"", ""noreturn"" and ""unwind"" blocks. Those blocks get their; /// weights set to BlockExecWeight::COLD, BlockExecWeight::UNREACHABLE,; /// BlockExecWeight::NORETURN and BlockExecWeight::UNWIND respectively. Then the; /// weights are propagated to the other blocks up the domination line. In; /// addition, if all successors have estimated weights set then maximum of these; /// weights assigned to the block itself (while this is not ideal heuristic in; /// theory it's simple and works reasonably well in most cases)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:1954,Usability,simpl,simple,1954,"hen; /// it is trivially translated to branch probabilities. There is one exception; /// from this rule though. Probabilities for edges leading to ""unreachable""; /// blocks (blocks with the estimated weight not greater than; /// UNREACHABLE_WEIGHT) are evaluated according to static estimation and; /// override profile information. If no branch probabilities were calculated; /// on this step then take the next one.; ///; /// Second, estimate absolute execution weights for each block based on; /// statically known information. Roots of such information are ""cold"",; /// ""unreachable"", ""noreturn"" and ""unwind"" blocks. Those blocks get their; /// weights set to BlockExecWeight::COLD, BlockExecWeight::UNREACHABLE,; /// BlockExecWeight::NORETURN and BlockExecWeight::UNWIND respectively. Then the; /// weights are propagated to the other blocks up the domination line. In; /// addition, if all successors have estimated weights set then maximum of these; /// weights assigned to the block itself (while this is not ideal heuristic in; /// theory it's simple and works reasonably well in most cases) and the process; /// repeats. Once the process of weights propagation converges branch; /// probabilities are set for all such branches that have at least one successor; /// with the weight set. Default execution weight (BlockExecWeight::DEFAULT) is; /// used for any successors which doesn't have its weight set. For loop back; /// branches we use their weights scaled by loop trip count equal to; /// 'LBH_TAKEN_WEIGHT/LBH_NOTTAKEN_WEIGHT'.; ///; /// Here is a simple example demonstrating how the described algorithm works.; ///; /// BB1; /// / \; /// v v; /// BB2 BB3; /// / \; /// v v; /// ColdBB UnreachBB; ///; /// Initially, ColdBB is associated with COLD_WEIGHT and UnreachBB with; /// UNREACHABLE_WEIGHT. COLD_WEIGHT is set to BB2 as maximum between its; /// successors. BB1 and BB3 has no explicit estimated weights and assumed to; /// have DEFAULT_WEIGHT. Based on assigned weights branc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:2465,Usability,simpl,simple,2465,"e"", ""noreturn"" and ""unwind"" blocks. Those blocks get their; /// weights set to BlockExecWeight::COLD, BlockExecWeight::UNREACHABLE,; /// BlockExecWeight::NORETURN and BlockExecWeight::UNWIND respectively. Then the; /// weights are propagated to the other blocks up the domination line. In; /// addition, if all successors have estimated weights set then maximum of these; /// weights assigned to the block itself (while this is not ideal heuristic in; /// theory it's simple and works reasonably well in most cases) and the process; /// repeats. Once the process of weights propagation converges branch; /// probabilities are set for all such branches that have at least one successor; /// with the weight set. Default execution weight (BlockExecWeight::DEFAULT) is; /// used for any successors which doesn't have its weight set. For loop back; /// branches we use their weights scaled by loop trip count equal to; /// 'LBH_TAKEN_WEIGHT/LBH_NOTTAKEN_WEIGHT'.; ///; /// Here is a simple example demonstrating how the described algorithm works.; ///; /// BB1; /// / \; /// v v; /// BB2 BB3; /// / \; /// v v; /// ColdBB UnreachBB; ///; /// Initially, ColdBB is associated with COLD_WEIGHT and UnreachBB with; /// UNREACHABLE_WEIGHT. COLD_WEIGHT is set to BB2 as maximum between its; /// successors. BB1 and BB3 has no explicit estimated weights and assumed to; /// have DEFAULT_WEIGHT. Based on assigned weights branches will have the; /// following probabilities:; /// P(BB1->BB2) = COLD_WEIGHT/(COLD_WEIGHT + DEFAULT_WEIGHT) =; /// 0xffff / (0xffff + 0xfffff) = 0.0588(5.9%); /// P(BB1->BB3) = DEFAULT_WEIGHT_WEIGHT/(COLD_WEIGHT + DEFAULT_WEIGHT) =; /// 0xfffff / (0xffff + 0xfffff) = 0.941(94.1%); /// P(BB2->ColdBB) = COLD_WEIGHT/(COLD_WEIGHT + UNREACHABLE_WEIGHT) = 1(100%); /// P(BB2->UnreachBB) =; /// UNREACHABLE_WEIGHT/(COLD_WEIGHT+UNREACHABLE_WEIGHT) = 0(0%); ///; /// If no branch probabilities were calculated on this step then take the next; /// one.; ///; /// Third, apply different kinds",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:86,Integrability,rout,routine,86,"/// Get an edge's probability, relative to other out-edges of the Src.; ///; /// This routine provides access to the fractional probability between zero; /// (0%) and one (100%) of this edge executing, relative to other edges; /// leaving the 'Src' block. The returned probability is never zero, and can; /// only be one if the source block has only one successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:103,Security,access,access,103,"/// Get an edge's probability, relative to other out-edges of the Src.; ///; /// This routine provides access to the fractional probability between zero; /// (0%) and one (100%) of this edge executing, relative to other edges; /// leaving the 'Src' block. The returned probability is never zero, and can; /// only be one if the source block has only one successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:4,Testability,Test,Test,4,/// Test if an edge is hot relative to other out-edges of the Src.; ///; /// Check whether this edge out of the source block is 'hot'. We define hot; /// as having a relative probability >= 80%.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h:190,Deployability,update,update,190,/// Set the raw probabilities for all edges from the given block.; ///; /// This allows a pass to explicitly set edge probabilities for a block. It; /// can be used when updating the CFG to update the branch probability; /// information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:415,Integrability,interface,interfaces,415,"//===- CallGraph.h - Build a Module's call graph ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to build and manipulate a call graph,; /// which is a very useful tool for interprocedural optimization.; ///; /// Every function in a module is represented as a node in the call graph. The; /// callgraph node keeps track of which functions are called by the function; /// corresponding to the node.; ///; /// A call graph may contain nodes where the function that they correspond to; /// is null. These 'external' nodes are used to represent control flow that is; /// not represented (or analyzable) in the module. In particular, this; /// analysis builds one external node such that:; /// 1. All functions in the module without internal linkage will have edges; /// from this external node, indicating that they could be called by; /// functions outside of the module.; /// 2. All functions whose address is used for something more than a direct; /// call, for example being stored into a memory location will also have; /// an edge from this external node. Since they may be called by an; /// unknown caller later, they must be tracked as such.; ///; /// There is a second external node added for calls that leave this module.; /// Functions have a call edge to the external node iff:; /// 1. The function is external, reflecting the fact that they could call; /// anything without internal linkage or that has its address taken.; /// 2. The function contains an indirect function call.; ///; /// As an extension in the future, there may be multiple nodes with a null; /// function. These will be used when we can prove (through pointer analysis); /// that an indirec",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:522,Performance,optimiz,optimization,522,"//===- CallGraph.h - Build a Module's call graph ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to build and manipulate a call graph,; /// which is a very useful tool for interprocedural optimization.; ///; /// Every function in a module is represented as a node in the call graph. The; /// callgraph node keeps track of which functions are called by the function; /// corresponding to the node.; ///; /// A call graph may contain nodes where the function that they correspond to; /// is null. These 'external' nodes are used to represent control flow that is; /// not represented (or analyzable) in the module. In particular, this; /// analysis builds one external node such that:; /// 1. All functions in the module without internal linkage will have edges; /// from this external node, indicating that they could be called by; /// functions outside of the module.; /// 2. All functions whose address is used for something more than a direct; /// call, for example being stored into a memory location will also have; /// an edge from this external node. Since they may be called by an; /// unknown caller later, they must be tracked as such.; ///; /// There is a second external node added for calls that leave this module.; /// Functions have a call edge to the external node iff:; /// 1. The function is external, reflecting the fact that they could call; /// anything without internal linkage or that has its address taken.; /// 2. The function contains an indirect function call.; ///; /// As an extension in the future, there may be multiple nodes with a null; /// function. These will be used when we can prove (through pointer analysis); /// that an indirec",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:205,Deployability,update,updated,205,/// The basic data container for the call graph of a \c Module of IR.; ///; /// This class exposes both the interface to the call graph for a module of IR.; ///; /// The core call graph itself can also be updated to reflect changes to the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:108,Integrability,interface,interface,108,/// The basic data container for the call graph of a \c Module of IR.; ///; /// This class exposes both the interface to the call graph for a module of IR.; ///; /// The core call graph itself can also be updated to reflect changes to the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:91,Security,expose,exposes,91,/// The basic data container for the call graph of a \c Module of IR.; ///; /// This class exposes both the interface to the call graph for a module of IR.; ///; /// The core call graph itself can also be updated to reflect changes to the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:67,Deployability,update,update,67,"/// Old node has been deleted, and New is to be used in its place, update the; /// ExternalCallingNode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:209,Performance,cache,cache,209,/// An analysis pass to compute the \c CallGraph for a \c Module.; ///; /// This class implements the concept of an analysis pass used by the \c; /// ModuleAnalysisManager to run an analysis over a module and cache the; /// resulting data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:28,Integrability,wrap,wraps,28,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:122,Integrability,interface,interface,122,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:265,Integrability,interface,interface,265,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:290,Integrability,wrap,wrapper,290,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:105,Security,expose,exposes,105,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:60,Testability,log,logic,60,/// The \c ModulePass which wraps up a \c CallGraph and the logic to; /// build it.; ///; /// This class exposes both the interface to the call graph container and the; /// module pass which runs over a module of IR and produces the call graph. The; /// call graph interface is entirelly a wrapper around a \c CallGraph object; /// which is stored internally for each module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:60,Integrability,interface,interface,60,/// The internal \c CallGraph around which the rest of this interface; /// is wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:78,Integrability,wrap,wrapped,78,/// The internal \c CallGraph around which the rest of this interface; /// is wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:112,Integrability,interface,interface,112,//===---------------------------------------------------------------------; // Implementation of the ModulePass interface needed here.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h:374,Deployability,update,update,374,"/// runOnSCC - This method should be implemented by the subclass to perform; /// whatever action is necessary for the specified SCC. Note that; /// non-recursive (or only self-recursive) functions will have an SCC size of; /// 1, where recursive portions of the call graph will have SCC size > 1.; ///; /// SCC passes that add or delete functions to the SCC are required to update; /// the SCC list, otherwise stale pointers may be dereferenced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h:68,Performance,perform,perform,68,"/// runOnSCC - This method should be implemented by the subclass to perform; /// whatever action is necessary for the specified SCC. Note that; /// non-recursive (or only self-recursive) functions will have an SCC size of; /// 1, where recursive portions of the call graph will have SCC size > 1.; ///; /// SCC passes that add or delete functions to the SCC are required to update; /// the SCC list, otherwise stale pointers may be dereferenced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h:111,Performance,optimiz,optimization,111,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallPrinter.h:52,Integrability,interface,interface,52,"//===-- CallPrinter.h - Call graph printer external interface ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines external functions that can be called to explicitly; // instantiate the call graph printer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CallPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:402,Integrability,rout,routines,402,"//===----- llvm/Analysis/CaptureTracking.h - Pointer capture ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help determine which pointers are captured.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:143,Integrability,rout,routine,143,"/// PointerMayBeCaptured - Return true if this pointer value may be captured; /// by the enclosing function (which is required to exist). This routine can; /// be expensive, so consider caching the results. The boolean ReturnCaptures; /// specifies whether returning the value (or part of it) from the function; /// counts as capturing it or not. The boolean StoreCaptures specified; /// whether storing the value (or part of it) into memory anywhere; /// automatically counts as capturing it or not.; /// MaxUsesToExplore specifies how many uses the analysis should explore for; /// one value before giving up due too ""too many uses"". If MaxUsesToExplore; /// is zero, a default value is assumed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:263,Integrability,rout,routine,263,"/// PointerMayBeCapturedBefore - Return true if this pointer value may be; /// captured by the enclosing function (which is required to exist). If a; /// DominatorTree is provided, only captures which happen before the given; /// instruction are considered. This routine can be expensive, so consider; /// caching the results. The boolean ReturnCaptures specifies whether; /// returning the value (or part of it) from the function counts as capturing; /// it or not. The boolean StoreCaptures specified whether storing the value; /// (or part of it) into memory anywhere automatically counts as capturing it; /// or not. Captures by the provided instruction are considered if the; /// final parameter is true.; /// MaxUsesToExplore specifies how many uses the analysis should explore for; /// one value before giving up due too ""too many uses"". If MaxUsesToExplore; /// is zero, a default value is assumed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:92,Integrability,interface,interface,92,"/// This callback is used in conjunction with PointerMayBeCaptured. In; /// addition to the interface here, you'll need to provide your own getters; /// to see whether anything was captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:151,Safety,avoid,avoid,151,/// isDereferenceableOrNull - Overload to allow clients with additional; /// knowledge about pointer dereferenceability to provide it and thereby; /// avoid conservative responses when a pointer is compared to null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:408,Performance,perform,performs,408,"//===-- Analysis/CFG.h - BasicBlock Analyses --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions performs analyses on basic blocks, and instructions; // contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:147,Availability,error,error,147,/// Search for the specified successor of basic block BB and return its position; /// in the terminator instruction's list of successors. It is an error to call; /// this with a block that is not a successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:473,Availability,down,down,473,"/// Determine whether instruction 'To' is reachable from 'From', without passing; /// through any blocks in ExclusionSet, returning true if uncertain.; ///; /// Determine whether there is a path from From to To within a single function.; /// Returns false only if we can prove that once 'From' has been executed then; /// 'To' can not be executed. Conservatively returns true.; ///; /// This function is linear with respect to the number of blocks in the CFG,; /// walking down successors from From to reach To, with a fixed threshold.; /// Using DT or LI allows us to answer more quickly. LI reduces the cost of; /// an entire loop of any number of blocks to be the same as the cost of a; /// single block. DT reduces the cost by allowing the search to terminate when; /// we find a block that dominates the block containing 'To'. DT is most useful; /// on branchy code but not loops, and LI is most useful on code with loops but; /// does not help on branchy code outside loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:593,Energy Efficiency,reduce,reduces,593,"/// Determine whether instruction 'To' is reachable from 'From', without passing; /// through any blocks in ExclusionSet, returning true if uncertain.; ///; /// Determine whether there is a path from From to To within a single function.; /// Returns false only if we can prove that once 'From' has been executed then; /// 'To' can not be executed. Conservatively returns true.; ///; /// This function is linear with respect to the number of blocks in the CFG,; /// walking down successors from From to reach To, with a fixed threshold.; /// Using DT or LI allows us to answer more quickly. LI reduces the cost of; /// an entire loop of any number of blocks to be the same as the cost of a; /// single block. DT reduces the cost by allowing the search to terminate when; /// we find a block that dominates the block containing 'To'. DT is most useful; /// on branchy code but not loops, and LI is most useful on code with loops but; /// does not help on branchy code outside loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:711,Energy Efficiency,reduce,reduces,711,"/// Determine whether instruction 'To' is reachable from 'From', without passing; /// through any blocks in ExclusionSet, returning true if uncertain.; ///; /// Determine whether there is a path from From to To within a single function.; /// Returns false only if we can prove that once 'From' has been executed then; /// 'To' can not be executed. Conservatively returns true.; ///; /// This function is linear with respect to the number of blocks in the CFG,; /// walking down successors from From to reach To, with a fixed threshold.; /// Using DT or LI allows us to answer more quickly. LI reduces the cost of; /// an entire loop of any number of blocks to be the same as the cost of a; /// single block. DT reduces the cost by allowing the search to terminate when; /// we find a block that dominates the block containing 'To'. DT is most useful; /// on branchy code but not loops, and LI is most useful on code with loops but; /// does not help on branchy code outside loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:444,Availability,avail,available,444,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:488,Availability,avail,available,488,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:573,Energy Efficiency,efficient,efficient,573,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:957,Integrability,interface,interfaces,957,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:117,Safety,detect,detect,117,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:591,Safety,detect,detect,591,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:808,Security,access,access,808,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:44,Integrability,interface,interface,44,"//===-- CFGPrinter.h - CFG printer external interface -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a 'dot-cfg' analysis pass, which emits the; // cfg.<fnname>.dot file for each function in the program, with a graph of the; // CFG for that function.; //; // This file defines external functions that can be called to explicitly; // instantiate the CFG printer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:33,Availability,avail,available,33,// Print EdgeWeights when BPI is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:32,Availability,avail,available,32,// Print RawWeights when BFI is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:3,Integrability,Wrap,Wrap,3,// Wrap lines.; // Wrap very long names even though we can't find a space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:19,Integrability,Wrap,Wrap,19,// Wrap lines.; // Wrap very long names even though we can't find a space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h:3,Performance,Cache,Cache,3,// Cache for is hidden property,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3126,Deployability,update,update,3126,"erprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3994,Deployability,update,update,3994,"more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-order, including the current entity. If the current; /// entity's shape changes, it and everything after it in post-order needs; /// to be visited to observe that shape.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4178,Deployability,update,update,4178,"more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-order, including the current entity. If the current; /// entity's shape changes, it and everything after it in post-order needs; /// to be visited to observe that shape.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:551,Performance,optimiz,optimizations,551,"//===- CGSCCPassManager.h - Call graph pass management ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:721,Performance,optimiz,optimizations,721,"//===- CGSCCPassManager.h - Call graph pass management ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:856,Performance,optimiz,optimizations,856,"//===- CGSCCPassManager.h - Call graph pass management ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:928,Performance,optimiz,optimized,928,"//===- CGSCCPassManager.h - Call graph pass management ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1090,Performance,optimiz,optimization,1090,"; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1179,Performance,optimiz,optimizations,1179,"-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reac",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1401,Performance,optimiz,optimizations,1401,"ses over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the referen",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1952,Performance,optimiz,optimize,1952,"neral goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call grap",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:2131,Performance,optimiz,optimizations,2131,"neral goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call grap",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:2157,Performance,optimiz,optimized,2157,"neral goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call grap",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:2983,Performance,optimiz,optimization,2983," /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3187,Performance,cache,cached,3187,"erprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3235,Performance,cache,cache-based,3235,"e independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3421,Performance,cache,cached,3421,"e independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3620,Performance,optimiz,optimization,3620,"e fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3873,Testability,test,tests,3873,"is, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-order, including the current entity. If the current; /// entity's shape changes, it and everything after it in post-order needs; /// to be visited to observe t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:2804,Usability,usab,usability,2804,"is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be exp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:15,Testability,log,logging,15,// Allow debug logging in this inline function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:233,Deployability,integrat,integrate,233,/// The CGSCC analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This type serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:204,Energy Efficiency,adapt,adaptors,204,/// The CGSCC analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This type serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:233,Integrability,integrat,integrate,233,/// The CGSCC analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This type serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:204,Modifiability,adapt,adaptors,204,/// The CGSCC analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This type serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:96,Security,access,access,96,/// We need a specialized result for the \c CGSCCAnalysisManagerModuleProxy so; /// it can have access to the call graph in order to walk all the SCCs when; /// invalidating things.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Security,Access,Accessor,4,/// Accessor for the analysis manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:273,Usability,clear,clear,273,"/// Handler for invalidation of the Module.; ///; /// If the proxy analysis itself is preserved, then we assume that the set of; /// SCCs in the Module hasn't changed. Thus any pointers to SCCs in the; /// CGSCCAnalysisManager are still valid, and we don't need to call \c clear; /// on the CGSCCAnalysisManager.; ///; /// Regardless of whether this analysis is marked as preserved, all of the; /// analyses in the \c CGSCCAnalysisManager are potentially invalidated based; /// on the set of preserved analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:52,Deployability,update,updates,52,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:197,Deployability,update,update,197,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:455,Deployability,update,updates,455,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:590,Deployability,update,update,590,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:655,Deployability,update,updates,655,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:668,Performance,perform,performed,668,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:28,Performance,queue,queued,28,"/// Worklist of the RefSCCs queued for processing.; ///; /// When a pass refines the graph and creates new RefSCCs or causes them to; /// have a different shape or set of component SCCs it should add the RefSCCs; /// to this worklist so that we visit them in the refined form.; ///; /// This worklist is in reverse post-order, as we pop off the back in order; /// to observe RefSCCs in post-order. When adding RefSCCs, clients should add; /// them in reverse post-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:25,Performance,queue,queued,25,"/// Worklist of the SCCs queued for processing.; ///; /// When a pass refines the graph and creates new SCCs or causes them to have; /// a different shape or set of component functions it should add the SCCs to; /// this worklist so that we visit them in the refined form.; ///; /// Note that if the SCCs are part of a RefSCC that is added to the \c; /// RCWorklist, they don't need to be added here as visiting the RefSCC will; /// be sufficient to re-visit the SCCs within it.; ///; /// This worklist is in reverse post-order, as we pop off the back in order; /// to observe SCCs in post-order. When adding SCCs, clients should add them; /// in reverse post-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:246,Safety,avoid,avoid,246,/// The set of invalidated RefSCCs which should be skipped if they are found; /// in \c RCWorklist.; ///; /// This is used to quickly prune out RefSCCs when they get deleted and; /// happen to already be on the worklist. We use this primarily to avoid; /// scanning the list and removing entries from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:239,Safety,avoid,avoid,239,/// The set of invalidated SCCs which should be skipped if they are found; /// in \c CWorklist.; ///; /// This is used to quickly prune out SCCs when they get deleted and happen; /// to already be on the worklist. We use this primarily to avoid scanning; /// the list and removing entries from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:168,Availability,down,down,168,"/// If non-null, the updated current \c SCC being processed.; ///; /// This is set when a graph refinement takes place and the ""current"" point; /// in the graph moves ""down"" or earlier in the post-order walk. This will; /// often cause the ""current"" SCC to be a newly created SCC object and the; /// old one to be added to the above worklist. When that happens, this; /// pointer is non-null and can be used to continue processing the ""top"" of; /// the post-order walk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:21,Deployability,update,updated,21,"/// If non-null, the updated current \c SCC being processed.; ///; /// This is set when a graph refinement takes place and the ""current"" point; /// in the graph moves ""down"" or earlier in the post-order walk. This will; /// often cause the ""current"" SCC to be a newly created SCC object and the; /// old one to be added to the above worklist. When that happens, this; /// pointer is non-null and can be used to continue processing the ""top"" of; /// the post-order walk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:549,Energy Efficiency,adapt,adaptors,549,"/// Preserved analyses across SCCs.; ///; /// We specifically want to allow CGSCC passes to mutate ancestor IR; /// (changing both the CG structure and the function IR itself). However,; /// this means we need to take special care to correctly mark what analyses; /// are preserved *across* SCCs. We have to track this out-of-band here; /// because within the main `PassManager` infrastructure we need to mark; /// everything within an SCC as preserved in order to avoid repeatedly; /// invalidating the same analyses as we unnest pass managers and adaptors.; /// So we track the cross-SCC version of the preserved analyses here from any; /// code that does direct invalidation of SCC analyses, and then use it; /// whenever we move forward in the post-order walk of SCCs before running; /// passes over the new SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:549,Modifiability,adapt,adaptors,549,"/// Preserved analyses across SCCs.; ///; /// We specifically want to allow CGSCC passes to mutate ancestor IR; /// (changing both the CG structure and the function IR itself). However,; /// this means we need to take special care to correctly mark what analyses; /// are preserved *across* SCCs. We have to track this out-of-band here; /// because within the main `PassManager` infrastructure we need to mark; /// everything within an SCC as preserved in order to avoid repeatedly; /// invalidating the same analyses as we unnest pass managers and adaptors.; /// So we track the cross-SCC version of the preserved analyses here from any; /// code that does direct invalidation of SCC analyses, and then use it; /// whenever we move forward in the post-order walk of SCCs before running; /// passes over the new SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:465,Safety,avoid,avoid,465,"/// Preserved analyses across SCCs.; ///; /// We specifically want to allow CGSCC passes to mutate ancestor IR; /// (changing both the CG structure and the function IR itself). However,; /// this means we need to take special care to correctly mark what analyses; /// are preserved *across* SCCs. We have to track this out-of-band here; /// because within the main `PassManager` infrastructure we need to mark; /// everything within an SCC as preserved in order to avoid repeatedly; /// invalidating the same analyses as we unnest pass managers and adaptors.; /// So we track the cross-SCC version of the preserved analyses here from any; /// code that does direct invalidation of SCC analyses, and then use it; /// whenever we move forward in the post-order walk of SCCs before running; /// passes over the new SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:207,Deployability,update,update,207,"/// A hacky area where the inliner can retain history about inlining; /// decisions that mutated the call graph's SCC structure in order to avoid; /// infinite inlining. See the comments in the inliner's CG update logic.; ///; /// FIXME: Keeping this here seems like a big layering issue, we should look; /// for a better technique.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:140,Safety,avoid,avoid,140,"/// A hacky area where the inliner can retain history about inlining; /// decisions that mutated the call graph's SCC structure in order to avoid; /// infinite inlining. See the comments in the inliner's CG update logic.; ///; /// FIXME: Keeping this here seems like a big layering issue, we should look; /// for a better technique.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:214,Testability,log,logic,214,"/// A hacky area where the inliner can retain history about inlining; /// decisions that mutated the call graph's SCC structure in order to avoid; /// infinite inlining. See the comments in the inliner's CG update logic.; ///; /// FIXME: Keeping this here seems like a big layering issue, we should look; /// for a better technique.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:65,Safety,detect,detecting,65,"/// Weak VHs to keep track of indirect calls for the purposes of detecting; /// devirtualization.; ///; /// This is a map to avoid having duplicate entries. If a Value is; /// deallocated, its corresponding WeakTrackingVH will be nulled out. When; /// checking if a Value is in the map or not, also check if the corresponding; /// WeakTrackingVH is null to avoid issues with a new Value sharing the same; /// address as a deallocated one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:125,Safety,avoid,avoid,125,"/// Weak VHs to keep track of indirect calls for the purposes of detecting; /// devirtualization.; ///; /// This is a map to avoid having duplicate entries. If a Value is; /// deallocated, its corresponding WeakTrackingVH will be nulled out. When; /// checking if a Value is in the map or not, also check if the corresponding; /// WeakTrackingVH is null to avoid issues with a new Value sharing the same; /// address as a deallocated one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:357,Safety,avoid,avoid,357,"/// Weak VHs to keep track of indirect calls for the purposes of detecting; /// devirtualization.; ///; /// This is a map to avoid having duplicate entries. If a Value is; /// deallocated, its corresponding WeakTrackingVH will be nulled out. When; /// checking if a Value is in the map or not, also check if the corresponding; /// WeakTrackingVH is null to avoid issues with a new Value sharing the same; /// address as a deallocated one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:503,Safety,safe,safely,503,/// The core module pass which does a post-order walk of the SCCs and; /// runs a CGSCC pass over each one.; ///; /// Designed to allow composition of a CGSCCPass(Manager) and; /// a ModulePassManager. Note that this pass must be run with a module analysis; /// manager as it uses the LazyCallGraph analysis. It will also run the; /// \c CGSCCAnalysisManagerModuleProxy analysis prior to running the CGSCC; /// pass over the module to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Energy Efficiency,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:50,Integrability,wrap,wrap,50,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Modifiability,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:307,Testability,log,logic,307,"/// A proxy from a \c FunctionAnalysisManager to an \c SCC.; ///; /// When a module pass runs and triggers invalidation, both the CGSCC and; /// Function analysis manager proxies on the module get an invalidation event.; /// We don't want to fully duplicate responsibility for most of the; /// invalidation logic. Instead, this layer is only responsible for SCC-local; /// invalidation events. We work with the module's FunctionAnalysisManager to; /// invalidate function analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Security,Access,Accessor,4,/// Accessor for the analysis manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:14,Deployability,update,update,14,/// Helper to update the call graph after running a function pass.; ///; /// Function passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:183,Deployability,update,updates,183,/// Helper to update the call graph after running a function pass.; ///; /// Function passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:300,Deployability,update,update,300,/// Helper to update the call graph after running a function pass.; ///; /// Function passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:152,Integrability,rout,routine,152,/// Helper to update the call graph after running a function pass.; ///; /// Function passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:14,Deployability,update,update,14,/// Helper to update the call graph after running a CGSCC pass.; ///; /// CGSCC passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:177,Deployability,update,updates,177,/// Helper to update the call graph after running a CGSCC pass.; ///; /// CGSCC passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:294,Deployability,update,update,294,/// Helper to update the call graph after running a CGSCC pass.; ///; /// CGSCC passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:146,Integrability,rout,routine,146,/// Helper to update the call graph after running a CGSCC pass.; ///; /// CGSCC passes can only mutate the call graph in specific ways. This; /// routine provides a helper that updates the call graph in those ways; /// including returning whether any changes were made and populating a CG; /// update result struct for the overall CGSCC walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Energy Efficiency,Adapt,Adaptor,4,/// Adaptor that maps from a SCC to its functions.; ///; /// Designed to allow composition of a FunctionPass(Manager) and; /// a CGSCCPassManager. Note that if this pass is constructed with a pointer; /// to a \c CGSCCAnalysisManager it will run the; /// \c FunctionAnalysisManagerCGSCCProxy analysis prior to running the function; /// pass over the SCC to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Modifiability,Adapt,Adaptor,4,/// Adaptor that maps from a SCC to its functions.; ///; /// Designed to allow composition of a FunctionPass(Manager) and; /// a CGSCCPassManager. Note that if this pass is constructed with a pointer; /// to a \c CGSCCAnalysisManager it will run the; /// \c FunctionAnalysisManagerCGSCCProxy analysis prior to running the function; /// pass over the SCC to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:425,Safety,safe,safely,425,/// Adaptor that maps from a SCC to its functions.; ///; /// Designed to allow composition of a FunctionPass(Manager) and; /// a CGSCCPassManager. Note that if this pass is constructed with a pointer; /// to a \c CGSCCAnalysisManager it will run the; /// \c FunctionAnalysisManagerCGSCCProxy analysis prior to running the function; /// pass over the SCC to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Energy Efficiency,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:50,Integrability,wrap,wrap,50,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Modifiability,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:545,Performance,optimiz,optimizations,545,"/// A helper that repeats an SCC pass each time an indirect call is refined to; /// a direct call by that pass.; ///; /// While the CGSCC pass manager works to re-visit SCCs and RefSCCs as they; /// change shape, we may also want to repeat an SCC pass if it simply refines; /// an indirect call to a direct call, even if doing so does not alter the; /// shape of the graph. Note that this only pertains to direct calls to; /// functions where IPO across the SCC may be able to compute more precise; /// results. For intrinsics, we assume scalar optimizations already can fully; /// reason about them.; ///; /// This repetition has the potential to be very large however, as each one; /// might refine a single call site. As a consequence, in practice we use an; /// upper bound on the number of repetitions to limit things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:258,Usability,simpl,simply,258,"/// A helper that repeats an SCC pass each time an indirect call is refined to; /// a direct call by that pass.; ///; /// While the CGSCC pass manager works to re-visit SCCs and RefSCCs as they; /// change shape, we may also want to repeat an SCC pass if it simply refines; /// an indirect call to a direct call, even if doing so does not alter the; /// shape of the graph. Note that this only pertains to direct calls to; /// functions where IPO across the SCC may be able to compute more precise; /// results. For intrinsics, we assume scalar optimizations already can fully; /// reason about them.; ///; /// This repetition has the potential to be very large however, as each one; /// might refine a single call site. As a consequence, in practice we use an; /// upper bound on the number of repetitions to limit things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:13,Integrability,wrap,wrapped,13,"/// Runs the wrapped pass up to \c MaxIterations on the SCC, iterating; /// whenever an indirect call is refined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Energy Efficiency,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:50,Integrability,wrap,wrap,50,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,Modifiability,adapt,adaptor,80,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:23,Testability,log,logging,23,// Clear out the debug logging macro.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3,Usability,Clear,Clear,3,// Clear out the debug logging macro.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:399,Integrability,rout,routines,399,"//===-- CmpInstAnalysis.h - Utils to help fold compare insts ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file holds routines to help analyse compare instructions; // and fold them into constants or other compare instructions; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:45,Availability,mask,mask,45,"/// Encode a icmp predicate into a three bit mask. These bits are carefully; /// arranged to allow folding of expressions such as:; ///; /// (A < B) | (A > B) --> (A != B); ///; /// Note that this is only valid if the first and second predicates have the; /// same sign. It is illegal to do: (A u< B) | (A s> B); ///; /// Three bits are used to represent the condition, as follows:; /// 0 A > B; /// 1 A == B; /// 2 A < B; ///; /// <=> Value Definition; /// 000 0 Always false; /// 001 1 A > B; /// 010 2 A == B; /// 011 3 A >= B; /// 100 4 A < B; /// 101 5 A != B; /// 110 6 A <= B; /// 111 7 Always true; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:96,Availability,mask,mask,96,/// Similar to getICmpCode but for FCmpInst. This encodes a fcmp predicate; /// into a four bit mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h:42,Availability,Mask,Mask,42,/// Decompose an icmp into the form ((X & Mask) pred 0) if possible. The; /// returned predicate is either == or !=. Returns false if decomposition; /// fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CmpInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CodeMetrics.h:131,Security,expose,exposed,131,"/// The number of calls to internal functions with a single caller.; ///; /// These are likely targets for future inlining, likely exposed by; /// interleaved devirtualization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/CodeMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CodeMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:402,Integrability,rout,routines,402,"//===-- ConstantFolding.h - Fold instructions into constants ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into constants when all; // operands are constants, for example ""sub i32 1, 0"" -> ""1"".; //; // Also, to supplement the basic VMCore ConstantExpr simplifications,; // this file declares some additional folding routines that can make use of; // DataLayout information. These functions cannot go in VMCore due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:645,Integrability,rout,routines,645,"//===-- ConstantFolding.h - Fold instructions into constants ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into constants when all; // operands are constants, for example ""sub i32 1, 0"" -> ""1"".; //; // Also, to supplement the basic VMCore ConstantExpr simplifications,; // this file declares some additional folding routines that can make use of; // DataLayout information. These functions cannot go in VMCore due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:758,Integrability,depend,dependency,758,"//===-- ConstantFolding.h - Fold instructions into constants ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into constants when all; // operands are constants, for example ""sub i32 1, 0"" -> ""1"".; //; // Also, to supplement the basic VMCore ConstantExpr simplifications,; // this file declares some additional folding routines that can make use of; // DataLayout information. These functions cannot go in VMCore due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:581,Usability,simpl,simplifications,581,"//===-- ConstantFolding.h - Fold instructions into constants ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into constants when all; // operands are constants, for example ""sub i32 1, 0"" -> ""1"".; //; // Also, to supplement the basic VMCore ConstantExpr simplifications,; // this file declares some additional folding routines that can make use of; // DataLayout information. These functions cannot go in VMCore due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:310,Performance,load,loads,310,"/// ConstantFoldInstruction - Try to constant fold the specified instruction.; /// If successful, the constant result is returned, if not, null is returned.; /// Note that this fails if not all of the operands are constant. Otherwise,; /// this function can only fail when attempting to fold instructions like loads; /// and stores, which have no constant expression form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:264,Performance,load,loads,264,"/// ConstantFoldInstOperands - Attempt to constant fold an instruction with the; /// specified operands. If successful, the constant result is returned, if not,; /// null is returned. Note that this function can fail when attempting to; /// fold instructions like loads and stores, which have no constant expression; /// form.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:169,Availability,failure,failure,169,/// Attempt to constant fold a compare instruction (icmp/fcmp) with the; /// specified operands. Returns null or a constant expression of the specified; /// operands on failure.; /// Denormal inputs may be flushed based on the denormal handling mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:96,Availability,failure,failure,96,/// Attempt to constant fold a unary operation with the specified operand.; /// Returns null on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:149,Availability,failure,failure,149,/// Attempt to constant fold a binary operation with the specified operands.; /// Returns null or a constant expression of the specified operands on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:221,Availability,failure,failure,221,"/// Attempt to constant fold a floating point binary operation with the; /// specified operands, applying the denormal handling mod to the operands.; /// Returns null or a constant expression of the specified operands on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:139,Availability,failure,failure,139,"/// Constant fold a zext, sext or trunc, depending on IsSigned and whether the; /// DestTy is wider or narrower than C. Returns nullptr on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:41,Integrability,depend,depending,41,"/// Constant fold a zext, sext or trunc, depending on IsSigned and whether the; /// DestTy is wider or narrower than C. Returns nullptr on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:94,Availability,mask,mask,94,"/// Attempt to constant fold a shufflevector instruction with the; /// specified operands and mask. See class ShuffleVectorInst for a description; /// of the mask representation. The constant result is returned if successful;; /// if not, null is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:158,Availability,mask,mask,158,"/// Attempt to constant fold a shufflevector instruction with the; /// specified operands and mask. See class ShuffleVectorInst for a description; /// of the mask representation. The constant result is returned if successful;; /// if not, null is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:99,Security,access,accessed,99,"/// Extract value of C at the given Offset reinterpreted as Ty. If bits past; /// the end of C are accessed, they are assumed to be poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:28,Performance,load,load,28,"/// Return the value that a load from C with offset Offset would produce if it; /// is constant and determinable. If this is not determinable, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:28,Performance,load,load,28,"/// Return the value that a load from C would produce if it is constant and; /// determinable. If this is not determinable, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:88,Integrability,rout,routimes,88,/// Check whether the given call has no side-effects.; /// Specifically checks for math routimes which sometimes set errno.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:13,Modifiability,variab,variables,13,/// A map of variables (IR values) to their corresponding index in the; /// constraint system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:16,Modifiability,variab,variable,16,/// Get list of variable names from the Value2Index map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:10,Modifiability,variab,variable,10,"// If all variable coefficients are 0, the constraint does not provide any; // usable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:79,Usability,usab,usable,79,"// If all variable coefficients are 0, the constraint does not provide any; // usable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:10,Modifiability,variab,variable,10,"// If all variable coefficients are 0, the constraint does not provide any; // usable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:79,Usability,usab,usable,79,"// If all variable coefficients are 0, the constraint does not provide any; // usable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:410,Integrability,Depend,Dependence,410,"//===- llvm/Analysis/DDG.h --------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Data-Dependence Graph (DDG).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:9,Integrability,Depend,Dependence,9,/// Data Dependence Graph Node; /// The graph can represent the following types of nodes:; /// 1. Single instruction node containing just one instruction.; /// 2. Multiple instruction node where two or more instructions from; /// the same basic block are merged into one node.; /// 3. Pi-block node which is a group of other DDG nodes that are part of a; /// strongly-connected component of the graph.; /// A pi-block node contains more than one single or multiple instruction; /// nodes. The root node cannot be part of a pi-block.; /// 4. Root node is a special node that connects to all components such that; /// there is always a path from it to any node in the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:9,Integrability,Depend,Dependency,9,/// Data Dependency Graph Edge.; /// An edge in the DDG can represent a def-use relationship or; /// a memory dependence based on the result of DependenceAnalysis.; /// A rooted edge connects the root node to one of the components; /// of the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:110,Integrability,depend,dependence,110,/// Data Dependency Graph Edge.; /// An edge in the DDG can represent a def-use relationship or; /// a memory dependence based on the result of DependenceAnalysis.; /// A rooted edge connects the root node to one of the components; /// of the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:144,Integrability,Depend,DependenceAnalysis,144,/// Data Dependency Graph Edge.; /// An edge in the DDG can represent a def-use relationship or; /// a memory dependence based on the result of DependenceAnalysis.; /// A rooted edge connects the root node to one of the components; /// of the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:36,Integrability,depend,dependence,36,"/// Return true if this is a memory dependence edge, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:96,Integrability,depend,dependence,96,/// Encapsulate some common data and functionality needed for different; /// variations of data dependence graphs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:25,Integrability,depend,dependency,25,"/// Collect all the data dependency infos coming from any pair of memory; /// accesses from \p Src to \p Dst, and store them into \p Deps. Return true; /// if a dependence exists, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:161,Integrability,depend,dependence,161,"/// Collect all the data dependency infos coming from any pair of memory; /// accesses from \p Src to \p Dst, and store them into \p Deps. Return true; /// if a dependence exists, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:78,Security,access,accesses,78,"/// Collect all the data dependency infos coming from any pair of memory; /// accesses from \p Src to \p Dst, and store them into \p Deps. Return true; /// if a dependence exists, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:45,Integrability,depend,dependence,45,/// Return a string representing the type of dependence that the dependence; /// analysis identified between the two given nodes. This function assumes; /// that there is a memory dependence between the given two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:65,Integrability,depend,dependence,65,/// Return a string representing the type of dependence that the dependence; /// analysis identified between the two given nodes. This function assumes; /// that there is a memory dependence between the given two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:180,Integrability,depend,dependence,180,/// Return a string representing the type of dependence that the dependence; /// analysis identified between the two given nodes. This function assumes; /// that there is a memory dependence between the given two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:19,Integrability,Depend,DependenceInfo,19,"// Store a copy of DependenceInfo in the graph, so that individual memory; // dependencies don't need to be stored. Instead when the dependence is; // queried it is recomputed using @DI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:78,Integrability,depend,dependencies,78,"// Store a copy of DependenceInfo in the graph, so that individual memory; // dependencies don't need to be stored. Instead when the dependence is; // queried it is recomputed using @DI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:133,Integrability,depend,dependence,133,"// Store a copy of DependenceInfo in the graph, so that individual memory; // dependencies don't need to be stored. Instead when the dependence is; // queried it is recomputed using @DI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:9,Integrability,Depend,Dependency,9,/// Data Dependency Graph,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:43,Integrability,depend,dependence,43,/// Concrete implementation of a pure data dependence graph builder. This class; /// provides custom implementation for the pure-virtual functions used in the; /// generic dependence graph build algorithm.; ///; /// For information about time complexity of the build algorithm see the; /// comments near the declaration of AbstractDependenceGraphBuilder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:172,Integrability,depend,dependence,172,/// Concrete implementation of a pure data dependence graph builder. This class; /// provides custom implementation for the pure-virtual functions used in the; /// generic dependence graph build algorithm.; ///; /// For information about time complexity of the build algorithm see the; /// comments near the declaration of AbstractDependenceGraphBuilder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:58,Usability,simpl,simple,58,/// Return true if the two nodes \pSrc and \pTgt are both simple nodes and; /// the consecutive instructions after merging belong to the same basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:83,Integrability,Depend,DependenceGraphInfo,83,//===--------------------------------------------------------------------===//; // DependenceGraphInfo Implementation; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:18,Security,access,access,18,// List of memory access instructions from src and dst nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:512,Integrability,Depend,Dependence,512,"//===- llvm/Analysis/DDGPrinter.h -------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; //; // This file defines the DOT printer for the Data-Dependence Graph (DDG).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:130,Availability,avail,available,130,"/// Print attributes of an edge in the DDG graph. If the edge; /// is a MemoryDependence edge, then detailed dependence info; /// available from DependenceAnalysis is displayed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:109,Integrability,depend,dependence,109,"/// Print attributes of an edge in the DDG graph. If the edge; /// is a MemoryDependence edge, then detailed dependence info; /// available from DependenceAnalysis is displayed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:145,Integrability,Depend,DependenceAnalysis,145,"/// Print attributes of an edge in the DDG graph. If the edge; /// is a MemoryDependence edge, then detailed dependence info; /// available from DependenceAnalysis is displayed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:117,Integrability,depend,dependence,117,/// Print a DDG node with more information including containing instructions; /// and detailed information about the dependence edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h:89,Integrability,depend,dependence,89,/// Print a DDG edge with more information including detailed information; /// about the dependence edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDGPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:550,Testability,test,testing,550,"//===---- Delinearization.h - MultiDimensional Index Delinearization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements an analysis pass that tries to delinearize all GEP; // instructions in all loops using the SCEV analysis functionality. This pass is; // only used for testing purposes: if your pass needs delinearization, please; // use the on-demand SCEVAddRecExpr::delinearize() function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:92,Security,access,access,92,/// Compute the array dimensions Sizes from the set of Terms extracted from; /// the memory access function of this SCEVAddRecExpr (second step of; /// delinearization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:29,Security,access,access,29,/// Return in Subscripts the access functions for each dimension in Sizes; /// (third step of delinearization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:111,Security,access,access,111,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:263,Security,access,access,263,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:414,Security,access,access,414,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:786,Security,access,accesses,786,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:889,Security,access,accesses,889,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:1020,Security,access,accesses,1020,"/// Split this SCEVAddRecExpr into two vectors of SCEVs representing the; /// subscripts and sizes of an array access.; ///; /// The delinearization is a 3 step process: the first two steps compute the; /// sizes of each subscript and the third step computes the access functions; /// for the delinearized array:; ///; /// 1. Find the terms in the step functions; /// 2. Compute the array size; /// 3. Compute the access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dime",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:1754,Security,access,access,1754,"he access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dimension: [5i].; ///; /// b. Divide Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k by next outer size n; /// Quotient: {{{0,+,0}_i, +, 1}_j, +, 1}_k; /// Remainder: {{{0,+,2}_i, +, 0}_j, +, 0}_k; /// The Remainder is the subscript of the next array dimension: [2i].; ///; /// The subscript of the outermost dimension is the Quotient: [j+k].; ///; /// Overall, we have: A[][n][m], and the access function: A[j+k][2i][5i].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:2379,Security,access,access,2379,"he access function: divide the SCEV by the array size; /// starting with the innermost dimensions found in step 2. The Quotient; /// is the SCEV to be divided in the next step of the recursion. The; /// Remainder is the subscript of the innermost dimension. Loop over all; /// array dimensions computed in step 2.; ///; /// To compute a uniform array size for several memory accesses to the same; /// object, one can collect in step 1 all the step terms for all the memory; /// accesses, and compute in step 2 a unique array shape. This guarantees; /// that the array shape will be the same across all memory accesses.; ///; /// FIXME: We could derive the result of steps 1 and 2 from a description of; /// the array shape given in metadata.; ///; /// Example:; ///; /// A[][n][m]; ///; /// for i; /// for j; /// for k; /// A[j+k][2i][5i] =; ///; /// The initial SCEV:; ///; /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]; ///; /// 1. Find the different terms in the step functions:; /// -> [2*m, 5, n*m, n*m]; ///; /// 2. Compute the array size: sort and unique them; /// -> [n*m, 2*m, 5]; /// find the GCD of all the terms = 1; /// divide by the GCD and erase constant terms; /// -> [n*m, 2*m]; /// GCD = m; /// divide by GCD -> [n, 2]; /// remove constant terms; /// -> [n]; /// size of the array is A[unknown][n][m]; ///; /// 3. Compute the access function; /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m; /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k; /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k; /// The remainder is the subscript of the innermost array dimension: [5i].; ///; /// b. Divide Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k by next outer size n; /// Quotient: {{{0,+,0}_i, +, 1}_j, +, 1}_k; /// Remainder: {{{0,+,2}_i, +, 0}_j, +, 0}_k; /// The Remainder is the subscript of the next array dimension: [2i].; ///; /// The subscript of the outermost dimension is the Quotient: [j+k].; ///; /// Overall, we have: A[][n][m], and the access function: A[j+k][2i][5i].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:486,Availability,avail,available,486,"/// Gathers the individual index expressions from a GEP instruction.; ///; /// This function optimistically assumes the GEP references into a fixed size; /// array. If this is actually true, this function returns a list of array; /// subscript expressions in \p Subscripts and a list of integers describing; /// the size of the individual array dimensions in \p Sizes. Both lists have; /// either equal length or the size list is one element shorter in case there; /// is no known size available for the outermost array dimension. Returns true; /// if successful and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:256,Performance,load,load,256,"/// Implementation of fixed size array delinearization. Try to delinearize; /// access function for a fixed size multi-dimensional array, by deriving; /// subscripts from GEP instructions. Returns true upon success and false; /// otherwise. \p Inst is the load/store instruction whose pointer operand is; /// the one we want to delinearize. \p AccessFn is its corresponding SCEV; /// expression w.r.t. the surrounding loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:80,Security,access,access,80,"/// Implementation of fixed size array delinearization. Try to delinearize; /// access function for a fixed size multi-dimensional array, by deriving; /// subscripts from GEP instructions. Returns true upon success and false; /// otherwise. \p Inst is the load/store instruction whose pointer operand is; /// the one we want to delinearize. \p AccessFn is its corresponding SCEV; /// expression w.r.t. the surrounding loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:344,Security,Access,AccessFn,344,"/// Implementation of fixed size array delinearization. Try to delinearize; /// access function for a fixed size multi-dimensional array, by deriving; /// subscripts from GEP instructions. Returns true upon success and false; /// otherwise. \p Inst is the load/store instruction whose pointer operand is; /// the one we want to delinearize. \p AccessFn is its corresponding SCEV; /// expression w.r.t. the surrounding loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:421,Availability,mask,mask,421,"/// Return the bits demanded from instruction I.; ///; /// For vector instructions individual vector elements are not distinguished:; /// A bit is demanded if it is demanded for any of the vector elements. The; /// size of the return value corresponds to the type size in bits of the; /// scalar type.; ///; /// Instructions that do not have integer or vector of integer type are; /// accepted, but will always produce a mask with all bits set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:12,Availability,alive,alive,12,/// Compute alive bits of one addition operand from alive output and known; /// operand bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:52,Availability,alive,alive,52,/// Compute alive bits of one addition operand from alive output and known; /// operand bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:12,Availability,alive,alive,12,/// Compute alive bits of one subtraction operand from alive output and known; /// operand bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h:55,Availability,alive,alive,55,/// Compute alive bits of one subtraction operand from alive output and known; /// operand bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DemandedBits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:22,Integrability,Depend,DependenceAnalysis,22,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:383,Integrability,Depend,DependenceAnalysis,383,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:432,Integrability,depend,dependences,432,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:555,Integrability,Depend,Dependence,555,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:668,Integrability,depend,dependence,668,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:764,Integrability,depend,dependence,764,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:826,Integrability,depend,dependence,826,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:891,Integrability,Depend,DependenceGraph,891,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:998,Integrability,depend,dependence,998,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1200,Integrability,Depend,DependenceAnalysis,1200,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1248,Integrability,Depend,DependenceGraph,1248,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1371,Integrability,interface,interface,1371,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1467,Integrability,depend,dependences,1467,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1499,Integrability,depend,dependence,1499,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:463,Security,access,accesses,463,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1219,Security,attack,attacks,1219,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1269,Security,attack,attack,1269,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:566,Testability,Test,Testing,566,"//===-- llvm/Analysis/DependenceAnalysis.h -------------------- -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an implementation of the approach described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // This pass exists to support the DependenceGraph pass. There are two separate; // passes because there's a useful separation of concerns. A dependence exists; // if two conditions are met:; //; // 1) Two instructions reference the same memory location, and; // 2) There is a flow of control leading from one instruction to the other.; //; // DependenceAnalysis attacks the first condition; DependenceGraph will attack; // the second (it's not yet ready).; //; // Please note that this is work in progress and the interface is subject to; // change.; //; // Plausible changes:; // Return a set of more precise dependences instead of just one dependence; // summarizing all.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Integrability,Depend,Dependence,4,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:41,Integrability,depend,dependence,41,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:269,Integrability,depend,dependence,269,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:320,Integrability,depend,dependence,320,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:405,Integrability,depend,dependences,405,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:423,Integrability,depend,dependence,423,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:531,Integrability,depend,dependences,531,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:575,Integrability,depend,dependence,575,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:607,Integrability,Depend,Dependence,607,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:859,Integrability,depend,dependence,859,"/// Dependence - This class represents a dependence between two memory; /// memory references in a function. It contains minimal information and; /// is used in the very common situation where the compiler is unable to; /// determine anything beyond the existence of a dependence; that is, it; /// represents a confused dependence (see also FullDependence). In most; /// cases (for output, flow, and anti dependences), the dependence implies; /// an ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.; ///; /// When a dependence graph is built, each Dependence will be a member of; /// the set of predecessor edges for its destination instruction and a set; /// if successor edges for its source instruction. These sets are represented; /// as singly-linked lists, with the ""next"" fields stored in the dependence; /// itelf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Integrability,Depend,Dependence,4,"/// Dependence::DVEntry - Each level in the distance/direction vector; /// has a direction (or perhaps a union of several directions), and; /// perhaps a distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:42,Integrability,depend,dependence,42,// Peeling the first iteration will break dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Integrability,depend,dependence,45,// Peeling the last iteration will break the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:33,Integrability,depend,dependence,33,// Splitting the loop will break dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:28,Availability,avail,available,28,// NULL implies no distance available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:53,Integrability,depend,dependence,53,/// getSrc - Returns the source instruction for this dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:58,Integrability,depend,dependence,58,/// getDst - Returns the destination instruction for this dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:47,Integrability,depend,dependence,47,/// isInput - Returns true if this is an input dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:49,Integrability,depend,dependence,49,/// isOutput - Returns true if this is an output dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:55,Integrability,depend,dependence,55,/// isFlow - Returns true if this is a flow (aka true) dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Integrability,depend,dependence,45,/// isAnti - Returns true if this is an anti dependence.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:32,Integrability,depend,dependence,32,"/// isOrdered - Returns true if dependence is Output, Flow, or Anti; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:34,Integrability,depend,dependence,34,/// isUnordered - Returns true if dependence is Input; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:72,Integrability,depend,dependence,72,/// isLoopIndependent - Returns true if this is a loop-independent; /// dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:38,Integrability,depend,dependence,38,/// isConfused - Returns true if this dependence is confused; /// (the compiler understands nothing and makes worst-case; /// assumptions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:40,Integrability,depend,dependence,40,/// isConsistent - Returns true if this dependence is consistent; /// (occurs every time the source and destination are executed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:102,Integrability,depend,dependence,102,/// getLevels - Returns the number of common loops surrounding the; /// source and destination of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:174,Integrability,depend,dependence,174,"/// If the direction vector is negative, normalize the direction; /// vector to make it non-negative. Normalization is done by reversing; /// Src and Dst, plus reversing the dependence directions and distances; /// in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:98,Integrability,depend,dependence,98,/// isPeelFirst - Returns true if peeling the first iteration from; /// this loop will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:96,Integrability,depend,dependence,96,/// isPeelLast - Returns true if peeling the last iteration from; /// this loop will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Integrability,depend,dependence,74,/// isSplitable - Returns true if splitting this loop will break; /// the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:147,Modifiability,variab,variable,147,"/// isScalar - Returns true if a particular level is scalar; that is,; /// if no subscript in the source or destination mention the induction; /// variable associated with the loop at this level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:43,Integrability,depend,dependence,43,"/// dump - For debugging purposes, dumps a dependence to OS.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Integrability,depend,dependence,45,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:154,Integrability,depend,dependence,154,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:326,Integrability,depend,dependence,326,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:342,Integrability,Depend,Dependence,342,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:402,Integrability,depend,dependences,402,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:420,Integrability,depend,dependence,420,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:528,Integrability,depend,dependences,528,"/// FullDependence - This class represents a dependence between two memory; /// references in a function. It contains detailed information about the; /// dependence (direction vectors, etc.) and is used when the compiler is; /// able to accurately analyze the interaction of the references; that is,; /// it is not a confused dependence (see Dependence). In most cases; /// (for output, flow, and anti dependences), the dependence implies an; /// ordering, where the source must precede the destination; in contrast,; /// input dependences are unordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:72,Integrability,depend,dependence,72,/// isLoopIndependent - Returns true if this is a loop-independent; /// dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:38,Integrability,depend,dependence,38,/// isConfused - Returns true if this dependence is confused; /// (the compiler understands nothing and makes worst-case; /// assumptions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:40,Integrability,depend,dependence,40,/// isConsistent - Returns true if this dependence is consistent; /// (occurs every time the source and destination are executed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:102,Integrability,depend,dependence,102,/// getLevels - Returns the number of common loops surrounding the; /// source and destination of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:174,Integrability,depend,dependence,174,"/// If the direction vector is negative, normalize the direction; /// vector to make it non-negative. Normalization is done by reversing; /// Src and Dst, plus reversing the dependence directions and distances; /// in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:98,Integrability,depend,dependence,98,/// isPeelFirst - Returns true if peeling the first iteration from; /// this loop will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:96,Integrability,depend,dependence,96,/// isPeelLast - Returns true if peeling the last iteration from; /// this loop will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:73,Integrability,depend,dependence,73,/// isSplitable - Returns true if splitting the loop will break; /// the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:147,Modifiability,variab,variable,147,"/// isScalar - Returns true if a particular level is scalar; that is,; /// if no subscript in the source or destination mention the induction; /// variable associated with the loop at this level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Integrability,Depend,DependenceInfo,4,/// DependenceInfo - This class is the main dependence-analysis driver.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:44,Integrability,depend,dependence-analysis,44,/// DependenceInfo - This class is the main dependence-analysis driver.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:44,Performance,cache,cached,44,/// Handle transitive invalidation when the cached analysis results go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Integrability,depend,depends,4,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:26,Integrability,depend,dependence,26,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:99,Integrability,depend,dependence,99,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:132,Integrability,Depend,Dependence,132,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:14,Testability,Test,Tests,14,"/// depends - Tests for a dependence between the Src and Dst instructions.; /// Returns NULL if no dependence; otherwise, returns a Dependence (or a; /// FullDependence) with as much information as can be gleaned.; /// The flag PossiblyLoopIndependent should be set by the caller; /// if it appears that control flow can reach from Src to Dst; /// without traversing a loop back edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:31,Integrability,depend,dependence,31,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:181,Integrability,depend,dependence,181,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:230,Integrability,depend,dependence,230,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:305,Integrability,depend,dependences,305,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:488,Integrability,depend,dependences,488,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:638,Integrability,depend,dependences,638,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1181,Integrability,depend,dependence,1181,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1266,Integrability,depend,dependence,1266,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1320,Integrability,depend,dependence,1320,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1449,Integrability,depend,dependence,1449,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1630,Integrability,depend,dependence,1630,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1214,Performance,load,load,1214,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1256,Testability,test,test,1256,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:168,Usability,guid,guide,168,/// Subscript - This private struct represents a pair of subscripts from; /// a pair of potentially multi-dimensional array references. We use a; /// vector of them to guide subscript partitioning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:110,Integrability,Depend,Dependence,110,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:272,Integrability,depend,dependence,272,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:387,Integrability,depend,dependence,387,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:446,Integrability,depend,dependence,446,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:515,Integrability,depend,dependence,515,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:583,Integrability,depend,dependence,583,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:121,Testability,Test,Testing,121,"/// Constraint - This private class represents a constraint, as defined; /// in the paper; ///; /// Practical Dependence Testing; /// Goff, Kennedy, Tseng; /// PLDI 1991; ///; /// There are 5 kinds of constraint, in a hierarchy.; /// 1) Any - indicates no constraint, any dependence is possible.; /// 2) Line - A line ax + by = c, where a, b, and c are parameters,; /// representing the dependence equation.; /// 3) Distance - The value d of the dependence distance;; /// 4) Point - A point <x, y> representing the dependence from; /// iteration x to iteration y.; /// 5) Empty - No dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:70,Testability,assert,assert,70,"/// getX - If constraint is a point <X, Y>, returns X.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:70,Testability,assert,assert,70,"/// getY - If constraint is a point <X, Y>, returns Y.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Testability,assert,assert,74,"/// getA - If constraint is a line AX + BY = C, returns A.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Testability,assert,assert,74,"/// getB - If constraint is a line AX + BY = C, returns B.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Testability,assert,assert,74,"/// getC - If constraint is a line AX + BY = C, returns C.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:66,Testability,assert,assert,66,"/// getD - If constraint is a distance, returns D.; /// Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:595,Energy Efficiency,allocate,allocate,595,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:285,Integrability,rout,routine,285,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1566,Integrability,depend,dependence,1566,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:137,Modifiability,variab,variables,137,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:739,Modifiability,variab,variable,739,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1623,Performance,load,load,1623,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:76,Modifiability,extend,extending,76,/// Makes sure all subscript pairs share the same integer type by; /// sign-extending as necessary.; /// Sign-extending a subscript is safe because getelementptr assumes the; /// array subscripts are signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:110,Modifiability,extend,extending,110,/// Makes sure all subscript pairs share the same integer type by; /// sign-extending as necessary.; /// Sign-extending a subscript is safe because getelementptr assumes the; /// array subscripts are signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:135,Safety,safe,safe,135,/// Makes sure all subscript pairs share the same integer type by; /// sign-extending as necessary.; /// Sign-extending a subscript is safe because getelementptr assumes the; /// array subscripts are signed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:129,Modifiability,extend,extended,129,"/// removeMatchingExtensions - Examines a subscript pair.; /// If the source and destination are identically sign (or zero); /// extended, it strips off the extension in an effort to; /// simplify the actual analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:188,Usability,simpl,simplify,188,"/// removeMatchingExtensions - Examines a subscript pair.; /// If the source and destination are identically sign (or zero); /// extended, it strips off the extension in an effort to; /// simplify the actual analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:82,Integrability,wrap,wrapper,82,"/// isKnownPredicate - Compare X and Y using the predicate Pred.; /// Basically a wrapper for SCEV::isKnownPredicate,; /// but tries harder, especially in the presence of sign and zero; /// extensions and symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:73,Integrability,wrap,wrapper,73,"/// isKnownLessThan - Compare to see if S is less than Size; /// Another wrapper for isKnownNegative(S - max(Size, 1)) with some extra; /// checking if S is an AddRec and we can prove lessthan using the loop; /// bounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:169,Integrability,wrap,wrapping,169,"/// isKnownNonNegative - Compare to see if S is known not to be negative; /// Uses the fact that S comes from Ptr, which may be an inbound GEP,; /// Proving there is no wrapping going on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:167,Availability,avail,available,167,"/// collectUpperBound - All subscripts are the same type (on my machine,; /// an i64). The loop bound may be a smaller type. collectUpperBound; /// find the bound, if available, and zero extends it to the Type T.; /// (I zero extend since the bound should always be >= 0.); /// If no upper bound is available, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:299,Availability,avail,available,299,"/// collectUpperBound - All subscripts are the same type (on my machine,; /// an i64). The loop bound may be a smaller type. collectUpperBound; /// find the bound, if available, and zero extends it to the Type T.; /// (I zero extend since the bound should always be >= 0.); /// If no upper bound is available, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:187,Modifiability,extend,extends,187,"/// collectUpperBound - All subscripts are the same type (on my machine,; /// an i64). The loop bound may be a smaller type. collectUpperBound; /// find the bound, if available, and zero extends it to the Type T.; /// (I zero extend since the bound should always be >= 0.); /// If no upper bound is available, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:226,Modifiability,extend,extend,226,"/// collectUpperBound - All subscripts are the same type (on my machine,; /// an i64). The loop bound may be a smaller type. collectUpperBound; /// find the bound, if available, and zero extends it to the Type T.; /// (I zero extend since the bound should always be >= 0.); /// If no upper bound is available, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:61,Integrability,depend,dependence,61,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:107,Integrability,depend,dependence,107,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:157,Integrability,depend,dependence,157,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:196,Integrability,depend,dependence,196,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testZIV,4,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:14,Testability,Test,Tests,14,"/// testZIV - Tests the ZIV subscript pair (Src and Dst) for dependence.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:61,Integrability,depend,dependence,61,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:267,Integrability,depend,dependence,267,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:317,Integrability,depend,dependence,317,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:453,Integrability,depend,dependence,453,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:159,Modifiability,variab,variables,159,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testSIV,4,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:14,Testability,Test,Tests,14,"/// testSIV - Tests the SIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j], where; /// i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction vector entry and, when possible,; /// the distance vector entry.; /// If the dependence isn't proven to exist,; /// marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:63,Integrability,depend,dependence,63,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:365,Integrability,depend,dependence,365,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:415,Integrability,depend,dependence,415,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:160,Modifiability,variab,variables,160,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testRDIV,4,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:15,Testability,Test,Tests,15,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:264,Testability,test,test,264,"/// testRDIV - Tests the RDIV subscript pair (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*j]; /// where i and j are induction variables, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// With minor algebra, this test can also be used for things like; /// [c1 + a1*i + a2*j][c2].; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Marks the Result as inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:61,Integrability,depend,dependence,61,/// testMIV - Tests the MIV subscript pair (Src and Dst) for dependence.; /// Returns true if dependence disproved.; /// Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:94,Integrability,depend,dependence,94,/// testMIV - Tests the MIV subscript pair (Src and Dst) for dependence.; /// Returns true if dependence disproved.; /// Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testMIV,4,/// testMIV - Tests the MIV subscript pair (Src and Dst) for dependence.; /// Returns true if dependence disproved.; /// Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:14,Testability,Test,Tests,14,/// testMIV - Tests the MIV subscript pair (Src and Dst) for dependence.; /// Returns true if dependence disproved.; /// Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:79,Integrability,depend,dependence,79,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:270,Integrability,depend,dependence,270,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:320,Integrability,depend,dependence,320,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:171,Modifiability,variab,variable,171,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:20,Testability,Test,Tests,20,"/// strongSIVtest - Tests the strong SIV subscript pair (Src and Dst); /// for dependence.; /// Things of the form [c1 + a*i] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction and distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:92,Integrability,depend,dependence,92,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:284,Integrability,depend,dependence,284,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:334,Integrability,depend,dependence,334,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:445,Integrability,depend,dependence,445,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:184,Modifiability,variab,variable,184,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:26,Testability,Test,Tests,26,"/// weakCrossingSIVtest - Tests the weak-crossing SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2 - a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// Marks the dependence as splitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:71,Integrability,depend,dependence,71,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:272,Integrability,depend,dependence,272,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:322,Integrability,depend,dependence,322,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:165,Modifiability,variab,variable,165,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:19,Testability,Test,Tests,19,"/// ExactSIVtest - Tests the SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a1*i] and [c2 + a2*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a1 and a2 are constant.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:87,Integrability,depend,dependence,87,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:302,Integrability,depend,dependence,302,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:352,Integrability,depend,dependence,352,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:484,Integrability,depend,dependence,484,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:173,Modifiability,variab,variable,173,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:25,Testability,Test,Tests,25,"/// weakZeroSrcSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1] and [c2 + a*i],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroDstSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:87,Integrability,depend,dependence,87,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:302,Integrability,depend,dependence,302,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:352,Integrability,depend,dependence,352,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:484,Integrability,depend,dependence,484,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:173,Modifiability,variab,variable,173,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:25,Testability,Test,Tests,25,"/// weakZeroDstSIVtest - Tests the weak-zero SIV subscript pair; /// (Src and Dst) for dependence.; /// Things of the form [c1 + a*i] and [c2],; /// where i is an induction variable, c1 and c2 are loop invariant,; /// and a is a constant. See also weakZeroSrcSIVtest.; /// Returns true if any possible dependence is disproved.; /// If there might be a dependence, returns false.; /// Sets appropriate direction entry.; /// Set consistent to false.; /// If loop peeling will break the dependence, mark appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:54,Integrability,depend,dependence,54,"/// exactRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that symbolicRDIVtest doesn't,; /// and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:256,Integrability,depend,dependence,256,"/// exactRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that symbolicRDIVtest doesn't,; /// and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:150,Modifiability,variab,variable,150,"/// exactRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that symbolicRDIVtest doesn't,; /// and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:20,Testability,Test,Tests,20,"/// exactRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that symbolicRDIVtest doesn't,; /// and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:57,Integrability,depend,dependence,57,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:259,Integrability,depend,dependence,259,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:153,Modifiability,variab,variable,153,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:23,Testability,Test,Tests,23,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:448,Testability,test,tests,448,"/// symbolicRDIVtest - Tests the RDIV subscript pair for dependence.; /// Things of the form [c1 + a*i] and [c2 + b*j],; /// where i and j are induction variable, c1 and c2 are loop invariant,; /// and a and b are constants.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Works in some cases that exactRDIVtest doesn't,; /// and vice versa. Can also be used as a backup for; /// ordinary SIV tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:49,Integrability,depend,dependence,49,"/// gcdMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Can sometimes disprove the equal direction for 1 or more loops.; // Can handle some symbolics that even the SIV tests don't get,; /// so we use it as a backup for everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:95,Integrability,depend,dependence,95,"/// gcdMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Can sometimes disprove the equal direction for 1 or more loops.; // Can handle some symbolics that even the SIV tests don't get,; /// so we use it as a backup for everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:17,Testability,Test,Tests,17,"/// gcdMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Can sometimes disprove the equal direction for 1 or more loops.; // Can handle some symbolics that even the SIV tests don't get,; /// so we use it as a backup for everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:276,Testability,test,tests,276,"/// gcdMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Can sometimes disprove the equal direction for 1 or more loops.; // Can handle some symbolics that even the SIV tests don't get,; /// so we use it as a backup for everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:54,Integrability,depend,dependence,54,/// banerjeeMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Computes directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:100,Integrability,depend,dependence,100,/// banerjeeMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Computes directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:22,Testability,Test,Tests,22,/// banerjeeMIVtest - Tests an MIV subscript pair for dependence.; /// Returns true if any possible dependence is disproved.; /// Marks the result as inconsistent.; /// Computes directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:126,Integrability,depend,dependences,126,"/// exploreDirections - Hierarchically expands the direction vector; /// search space, combining the directions of discovered dependences; /// in the DirSet field of Bound. Returns the number of distinct; /// dependences discovered. If the dependence is disproved,; /// it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:209,Integrability,depend,dependences,209,"/// exploreDirections - Hierarchically expands the direction vector; /// search space, combining the directions of discovered dependences; /// in the DirSet field of Bound. Returns the number of distinct; /// dependences discovered. If the dependence is disproved,; /// it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:240,Integrability,depend,dependence,240,"/// exploreDirections - Hierarchically expands the direction vector; /// search space, combining the directions of discovered dependences; /// in the DirSet field of Bound. Returns the number of distinct; /// dependences discovered. If the dependence is disproved,; /// it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Testability,test,testBounds,4,/// testBounds - Returns true iff the current bounds are plausible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:27,Deployability,Update,Updates,27,/// intersectConstraints - Updates X with the intersection; /// of the Constraints X and Y. Returns true if X has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:251,Integrability,depend,dependence,251,"/// propagate - Review the constraints, looking for opportunities; /// to simplify a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:74,Usability,simpl,simplify,74,"/// propagate - Review the constraints, looking for opportunities; /// to simplify a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:140,Usability,simpl,simplification,140,"/// propagate - Review the constraints, looking for opportunities; /// to simplify a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:175,Usability,simpl,simplification,175,"/// propagate - Review the constraints, looking for opportunities; /// to simplify a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:245,Integrability,depend,dependence,245,"/// propagateDistance - Attempt to propagate a distance; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:134,Usability,simpl,simplification,134,"/// propagateDistance - Attempt to propagate a distance; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:169,Usability,simpl,simplification,169,"/// propagateDistance - Attempt to propagate a distance; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:128,Usability,simpl,simplification,128,/// propagatePoint - Attempt to propagate a point; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:237,Integrability,depend,dependence,237,"/// propagateLine - Attempt to propagate a line; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:126,Usability,simpl,simplification,126,"/// propagateLine - Attempt to propagate a line; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:161,Usability,simpl,simplification,161,"/// propagateLine - Attempt to propagate a line; /// constraint into a subscript pair (Src and Dst).; /// Return true if some simplification occurs.; /// If the simplification isn't exact (that is, if it is conservative; /// in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:4,Deployability,update,updateDirection,4,/// updateDirection - Update direction vector entry; /// based on the current constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:22,Deployability,Update,Update,22,/// updateDirection - Update direction vector entry; /// based on the current constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Availability,recover,recover,45,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,Safety,recover,recover,45,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:19,Security,access,access,19,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:109,Security,access,access,109,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:43,Security,access,access,43,"/// Tries to delinearize \p Src and \p Dst access functions for a fixed size; /// multi-dimensional array. Calls tryDelinearizeFixedSizeImpl() to; /// delinearize \p Src and \p Dst separately,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:25,Security,access,access,25,/// Tries to delinearize access function for a multi-dimensional array with; /// symbolic runtime sizes.; /// Returns true upon success and false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:89,Safety,avoid,avoid,89,/// checkSubscript - Helper function for checkSrcSubscript and; /// checkDstSubscript to avoid duplicate code,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Integrability,Depend,DependenceInfo,9,// class DependenceInfo; /// AnalysisPass to compute dependence information in a function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:53,Integrability,depend,dependence,53,// class DependenceInfo; /// AnalysisPass to compute dependence information in a function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Integrability,Depend,DependenceAnalysis,9,// class DependenceAnalysis; /// Printer pass to dump DA results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Integrability,Depend,DependenceAnalysisPrinterPass,9,// class DependenceAnalysisPrinterPass; /// Legacy pass manager pass to access dependence information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:79,Integrability,depend,dependence,79,// class DependenceAnalysisPrinterPass; /// Legacy pass manager pass to access dependence information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:72,Security,access,access,72,// class DependenceAnalysisPrinterPass; /// Legacy pass manager pass to access dependence information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:9,Integrability,Depend,DependenceAnalysisWrapperPass,9,// class DependenceAnalysisWrapperPass; /// createDependenceAnalysisPass - This creates an instance of the; /// DependenceAnalysis wrapper pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:112,Integrability,Depend,DependenceAnalysis,112,// class DependenceAnalysisWrapperPass; /// createDependenceAnalysisPass - This creates an instance of the; /// DependenceAnalysis wrapper pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:131,Integrability,wrap,wrapper,131,// class DependenceAnalysisWrapperPass; /// createDependenceAnalysisPass - This creates an instance of the; /// DependenceAnalysis wrapper pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:21,Integrability,Depend,DependenceGraphBuilder,21,"//===- llvm/Analysis/DependenceGraphBuilder.h -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a builder interface that can be used to populate dependence; // graphs such as DDG and PDG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:411,Integrability,interface,interface,411,"//===- llvm/Analysis/DependenceGraphBuilder.h -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a builder interface that can be used to populate dependence; // graphs such as DDG and PDG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:450,Integrability,depend,dependence,450,"//===- llvm/Analysis/DependenceGraphBuilder.h -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a builder interface that can be used to populate dependence; // graphs such as DDG and PDG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:132,Modifiability,inherit,inherit,132,/// This abstract builder class defines a set of high-level steps for creating; /// DDG-like graphs. The client code is expected to inherit from this class and; /// define concrete implementation for each of the pure virtual functions used; /// in the high-level algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:288,Integrability,depend,dependence,288,"/// The main entry to the graph construction algorithm. It starts by; /// creating nodes in increasing order of granularity and then; /// adds def-use and memory edges. As one of the final stages, it; /// also creates pi-block nodes to facilitate codegen in transformations; /// that use dependence graphs.; ///; /// The algorithmic complexity of this implementation is O(V^2 * I^2), where V; /// is the number of vertecies (nodes) and I is the number of instructions in; /// each node. The total number of instructions, N, is equal to V * I,; /// therefore the worst-case time complexity is O(N^2). The average time; /// complexity is O((N^2)/2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:17,Integrability,depend,dependencies,17,"/// Analyze data dependencies that exist between memory loads or stores,; /// in the graph nodes and create edges between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:56,Performance,load,loads,56,"/// Analyze data dependencies that exist between memory loads or stores,; /// in the graph nodes and create edges between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:302,Integrability,depend,dependence,302,/// Apply graph abstraction to groups of nodes that belong to a strongly; /// connected component of the graph to create larger compound nodes; /// called pi-blocks. The purpose of this abstraction is to isolate sets of; /// program elements that need to stay together during codegen and turn; /// the dependence graph into an acyclic graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:391,Usability,simpl,simple,391,/// Go through all the nodes in the graph and collapse any two nodes; /// 'a' and 'b' if all of the following are true:; /// - the only edge from 'a' is a def-use edge to 'b' and; /// - the only edge to 'b' is a def-use edge from 'a' and; /// - there is no cyclic edge from 'b' to 'a' and; /// - all instructions in 'a' and 'b' belong to the same basic block and; /// - both 'a' and 'b' are simple (single or multi instruction) nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:20,Integrability,depend,dependence,20,/// Create a memory dependence edge going from \p Src to \p Tgt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:25,Usability,simpl,simplification,25,"/// Return true if graph simplification step is requested, and false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:24,Safety,safe,safe,24,/// Return true if it's safe to merge the two nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:4,Integrability,Depend,Dependence,4,/// Dependence information used to create memory dependence edges in the; /// graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:49,Integrability,depend,dependence,49,/// Dependence information used to create memory dependence edges in the; /// graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:383,Performance,Cache,Cache,383,"//===- llvm/Analysis/DomConditionCache.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Cache for branch conditions that affect a certain value for use by; // ValueTracking. Unlike AssumptionCache, this class does not perform any; // automatic analysis or invalidation. The caller is responsible for registering; // all relevant branches (and re-registering them if they change), and for; // removing invalidated values from the cache.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:513,Performance,perform,perform,513,"//===- llvm/Analysis/DomConditionCache.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Cache for branch conditions that affect a certain value for use by; // ValueTracking. Unlike AssumptionCache, this class does not perform any; // automatic analysis or invalidation. The caller is responsible for registering; // all relevant branches (and re-registering them if they change), and for; // removing invalidated values from the cache.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:724,Performance,cache,cache,724,"//===- llvm/Analysis/DomConditionCache.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Cache for branch conditions that affect a certain value for use by; // ValueTracking. Unlike AssumptionCache, this class does not perform any; // automatic analysis or invalidation. The caller is responsible for registering; // all relevant branches (and re-registering them if they change), and for; // removing invalidated values from the cache.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:34,Performance,cache,cache,34,/// Add a branch condition to the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:28,Performance,cache,cache,28,"/// Remove a value from the cache, e.g. because it will be erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:4,Security,Access,Access,4,/// Access the list of branches which affect this value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h:12,Integrability,interface,interface,12,// Accessor interface:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h:3,Security,Access,Accessor,3,// Accessor interface:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DominanceFrontier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomPrinter.h:44,Integrability,interface,interface,44,"//===-- DomPrinter.h - Dom printer external interface ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines external functions that can be called to explicitly; // instantiate the dominance tree printer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:47,Deployability,Update,Updater,47,"//===- DomTreeUpdater.h - DomTree/Post DomTree Updater ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the DomTreeUpdater class, which provides a uniform way to; // update dominator tree related data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:463,Deployability,update,update,463,"//===- DomTreeUpdater.h - DomTree/Post DomTree Updater ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the DomTreeUpdater class, which provides a uniform way to; // update dominator tree related data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:127,Availability,avail,available,127,/// Returns true if there is BasicBlock awaiting deletion.; /// The deletion will only happen until a flush event and; /// all available trees are up-to-date.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:190,Deployability,Update,UpdateStrategy,190,/// Returns true if there is BasicBlock awaiting deletion.; /// The deletion will only happen until a flush event and; /// all available trees are up-to-date.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:79,Deployability,Update,UpdateStrategy,79,/// Returns true if DelBB is awaiting deletion.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:84,Deployability,update,update,84,/// Returns true if either of DT or PDT is valid and the tree has at; /// least one update pending. If DT or PDT is nullptr it is treated; /// as having no pending updates. This function does not check; /// whether there is BasicBlock awaiting deletion.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:164,Deployability,update,updates,164,/// Returns true if either of DT or PDT is valid and the tree has at; /// least one update pending. If DT or PDT is nullptr it is treated; /// as having no pending updates. This function does not check; /// whether there is BasicBlock awaiting deletion.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:285,Deployability,Update,UpdateStrategy,285,/// Returns true if either of DT or PDT is valid and the tree has at; /// least one update pending. If DT or PDT is nullptr it is treated; /// as having no pending updates. This function does not check; /// whether there is BasicBlock awaiting deletion.; /// Returns false under Eager UpdateStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:44,Deployability,update,updates,44,/// Returns true if there are DominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or DT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:91,Deployability,Update,UpdateStrategy,91,/// Returns true if there are DominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or DT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:52,Performance,queue,queued,52,/// Returns true if there are DominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or DT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:48,Deployability,update,updates,48,/// Returns true if there are PostDominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or PDT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:95,Deployability,Update,UpdateStrategy,95,/// Returns true if there are PostDominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or PDT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:56,Performance,queue,queued,56,/// Returns true if there are PostDominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or PDT is nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:979,Availability,avail,available,979,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:83,Deployability,update,updates,83,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:188,Deployability,update,update,188,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:259,Deployability,Update,UpdateStrategy,259,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:275,Deployability,Update,Updates,275,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:345,Deployability,Update,UpdateStrategy,345,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:361,Deployability,Update,Updates,361,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:472,Deployability,update,update,472,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:520,Deployability,update,updates,520,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:591,Deployability,update,updates,591,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:662,Deployability,update,updater,662,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:689,Deployability,update,updates,689,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:819,Deployability,update,updates,819,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:879,Deployability,update,update,879,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:964,Deployability,update,updates,964,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1028,Deployability,update,updates,1028,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1088,Deployability,update,updates,1088,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1204,Deployability,update,updates,1204,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1231,Deployability,update,update,1231,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1316,Deployability,update,updated,1316,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1353,Deployability,update,updates,1353,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1382,Deployability,update,update,1382,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1468,Deployability,update,update,1468,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1526,Deployability,update,update,1526,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:792,Integrability,depend,depending,792,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1389,Integrability,rout,routine,1389,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1077,Performance,queue,queues,1077,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:26,Availability,avail,available,26,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:11,Deployability,update,updates,11,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:83,Deployability,update,updates,83,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:115,Deployability,update,updates,115,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:133,Deployability,update,updates,133,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:268,Deployability,update,updates,268,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:328,Deployability,update,updates,328,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:444,Deployability,update,updates,444,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:471,Deployability,update,update,471,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:556,Deployability,update,updated,556,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:593,Deployability,update,updates,593,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:622,Deployability,update,update,622,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:708,Deployability,update,update,708,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:766,Deployability,update,update,766,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:935,Deployability,update,updates,935,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1015,Deployability,update,updates,1015,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:629,Integrability,rout,routine,629,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:317,Performance,queue,queues,317,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:71,Availability,avail,available,71,/// Notify DTU that the entry block was replaced.; /// Recalculate all available trees and flush all BasicBlocks; /// awaiting deletion immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:77,Availability,avail,available,77,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:287,Availability,avail,available,287,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:148,Deployability,Update,UpdateStrategy,148,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:217,Deployability,Update,UpdateStrategy,217,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:247,Performance,queue,queued,247,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:450,Performance,queue,queued,450,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:319,Testability,Assert,Assert,319,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:77,Availability,avail,available,77,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:334,Availability,avail,available,334,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:195,Deployability,Update,UpdateStrategy,195,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:264,Deployability,Update,UpdateStrategy,264,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:506,Deployability,Update,UpdateStrategy,506,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:294,Performance,queue,queued,294,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:469,Performance,queue,queued,469,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:366,Testability,Assert,Assert,366,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:182,Deployability,update,updates,182,"///@}; ///@{; /// \name Flush APIs; ///; /// CAUTION! By the moment these flush APIs are called, the current CFG needs; /// to be the same as the CFG which DTU is in sync with + all updates; /// submitted.; /// Flush DomTree updates and return DomTree.; /// It flushes Deleted BBs if both trees are up-to-date.; /// It must only be called when it has a DomTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:225,Deployability,update,updates,225,"///@}; ///@{; /// \name Flush APIs; ///; /// CAUTION! By the moment these flush APIs are called, the current CFG needs; /// to be the same as the CFG which DTU is in sync with + all updates; /// submitted.; /// Flush DomTree updates and return DomTree.; /// It flushes Deleted BBs if both trees are up-to-date.; /// It must only be called when it has a DomTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:22,Deployability,update,updates,22,/// Flush PostDomTree updates and return PostDomTree.; /// It flushes Deleted BBs if both trees are up-to-date.; /// It must only be called when it has a PostDomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:33,Availability,avail,available,33,/// Apply all pending updates to available trees and flush all BasicBlocks; /// awaiting deletion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:22,Deployability,update,updates,22,/// Apply all pending updates to available trees and flush all BasicBlocks; /// awaiting deletion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:241,Deployability,Update,UpdateStrategy,241,/// First remove all the instructions of DelBB and then make sure DelBB has a; /// valid terminator instruction which is necessary to have when DelBB still; /// has to be inside of its parent Function while awaiting deletion under Lazy; /// UpdateStrategy to prevent other routines from asserting the state of the; /// IR is inconsistent. Assert if DelBB is nullptr or has predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:273,Integrability,rout,routines,273,/// First remove all the instructions of DelBB and then make sure DelBB has a; /// valid terminator instruction which is necessary to have when DelBB still; /// has to be inside of its parent Function while awaiting deletion under Lazy; /// UpdateStrategy to prevent other routines from asserting the state of the; /// IR is inconsistent. Assert if DelBB is nullptr or has predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:287,Testability,assert,asserting,287,/// First remove all the instructions of DelBB and then make sure DelBB has a; /// valid terminator instruction which is necessary to have when DelBB still; /// has to be inside of its parent Function while awaiting deletion under Lazy; /// UpdateStrategy to prevent other routines from asserting the state of the; /// IR is inconsistent. Assert if DelBB is nullptr or has predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:339,Testability,Assert,Assert,339,/// First remove all the instructions of DelBB and then make sure DelBB has a; /// valid terminator instruction which is necessary to have when DelBB still; /// has to be inside of its parent Function while awaiting deletion under Lazy; /// UpdateStrategy to prevent other routines from asserting the state of the; /// IR is inconsistent. Assert if DelBB is nullptr or has predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:49,Deployability,update,updates,49,/// Helper function to apply all pending DomTree updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:53,Deployability,update,updates,53,/// Helper function to apply all pending PostDomTree updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:56,Availability,avail,available,56,/// Helper function to flush deleted BasicBlocks if all available; /// trees are up-to-date.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:36,Availability,avail,available,36,/// Drop all updates applied by all available trees and delete BasicBlocks if; /// all available trees are up-to-date.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:87,Availability,avail,available,87,/// Drop all updates applied by all available trees and delete BasicBlocks if; /// all available trees are up-to-date.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:13,Deployability,update,updates,13,/// Drop all updates applied by all available trees and delete BasicBlocks if; /// all available trees are up-to-date.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:24,Deployability,update,update,24,/// Returns true if the update appears in the LLVM IR.; /// It is used to check whether an update is valid in; /// insertEdge/deleteEdge or is unnecessary in the batch update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:91,Deployability,update,update,91,/// Returns true if the update appears in the LLVM IR.; /// It is used to check whether an update is valid in; /// insertEdge/deleteEdge or is unnecessary in the batch update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:168,Deployability,update,update,168,/// Returns true if the update appears in the LLVM IR.; /// It is used to check whether an update is valid in; /// insertEdge/deleteEdge or is unnecessary in the batch update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:24,Deployability,update,update,24,/// Returns true if the update is self dominance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:288,Availability,down,downcasting,288,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:274,Modifiability,polymorphi,polymorphisms,274,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:4,Safety,Avoid,Avoid,4,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:183,Safety,avoid,avoiding,183,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:537,Safety,avoid,avoid,537,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:290,Availability,down,downcasting,290,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:276,Modifiability,polymorphi,polymorphisms,276,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:4,Safety,Avoid,Avoid,4,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:184,Safety,avoid,avoiding,184,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:539,Safety,avoid,avoid,539,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h:70,Deployability,update,update,70,// If status of predecessor block has gone above current block; // we update current blocks status.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h:50,Deployability,update,update,50,// Check on predecessors and check for; // Status update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/EHUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h:3,Performance,Load,Load,3,// Load Instruction Count,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h:14,Deployability,update,update,14,/// Correctly update FunctionPropertiesInfo post-inlining. A; /// FunctionPropertiesUpdater keeps the state necessary for tracking the changes; /// llvm::InlineFunction makes. The idea is that inlining will at most modify; /// a few BBs of the Caller (maybe the entry BB and definitely the callsite BB); /// and potentially affect exception handling BBs in the case of invoke; /// inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/FunctionPropertiesAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:403,Integrability,interface,interface,403,"//===- GlobalsModRef.h - Simple Mod/Ref AA for Globals ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for a simple mod/ref and alias analysis over globals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:25,Usability,Simpl,Simple,25,"//===- GlobalsModRef.h - Simple Mod/Ref AA for Globals ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for a simple mod/ref and alias analysis over globals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:419,Usability,simpl,simple,419,"//===- GlobalsModRef.h - Simple Mod/Ref AA for Globals ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for a simple mod/ref and alias analysis over globals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:49,Energy Efficiency,allocate,allocates,49,"/// AllocsForIndirectGlobals - If an instruction allocates memory for an; /// indirect global, this map indicates which one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:59,Usability,simpl,simple,59,/// A map of functions to SCC. The SCCs are described by a simple integer; /// ID that is only useful for comparing for equality (are two functions; /// in the same SCC or not?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:14,Usability,clear,clear,14,/// Handle to clear this analysis on deletion of values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:207,Performance,optimiz,optimizations,207,"/// List of callbacks for globals being tracked by this analysis. Note that; /// these objects are quite large, but we only anticipate having one per; /// global tracked by this analysis. There are numerous optimizations we; /// could perform to the memory utilization here if this becomes a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:235,Performance,perform,perform,235,"/// List of callbacks for globals being tracked by this analysis. Note that; /// these objects are quite large, but we only anticipate having one per; /// global tracked by this analysis. There are numerous optimizations we; /// could perform to the memory utilization here if this becomes a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the GlobalsAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GuardUtils.h:402,Performance,perform,perform,402,"//===-- GuardUtils.h - Utils for work with guards ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform analyzes related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/GuardUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GuardUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h:391,Integrability,Interface,Interface,391,"//===- IndirectCallPromotionAnalysis.h - Indirect call analysis -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Interface to identify indirect call promotion candidates.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h:124,Availability,avail,available,124,// Class for identifying profitable indirect call promotion candidates when; // the indirect-call value profile metadata is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space to read the profile annotation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IndirectCallPromotionAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:108,Deployability,Release,Release,108,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:167,Deployability,deploy,deployments,167,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:370,Integrability,depend,dependencies,370,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:733,Modifiability,plugin,plugin,733,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:741,Modifiability,Plugin,PluginInlineAdvisorAnalysis,741,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:504,Performance,perform,performance,504,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:711,Performance,load,load,711,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:659,Testability,log,logs,659,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:69,Deployability,pipeline,pipeline,69,"/// Provides context on when an inline advisor is constructed in the pipeline; /// (e.g., link phase, inline driver).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:357,Integrability,contract,contractual,357,"/// Capture state between an inlining decision having had been made, and; /// its impact being observable. When collecting model training data, this; /// allows recording features/decisions/partial reward data sets.; ///; /// Derivations of this type are expected to be tightly coupled with their; /// InliningAdvisors. The base type implements the minimal contractual; /// obligations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:69,Modifiability,extend,extend,69,"/// Exactly one of the record* APIs must be called. Implementers may extend; /// behavior by implementing the corresponding record*Impl.; ///; /// Call after inlining succeeded, and did not result in deleting the callee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:133,Availability,failure,failure,133,"// Capture the context of CB before inlining, as a successful inlining may; // change that context, and we want to report success or failure in the; // original context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:4,Integrability,Interface,Interface,4,/// Interface for deciding whether to inline a call site or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:90,Deployability,update,update,90,"/// This must be called when the Inliner pass is entered, to allow the; /// InlineAdvisor update internal state, as result of function passes run; /// between Inliner pass runs (for the same module).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:183,Deployability,update,update,183,"/// This must be called when the Inliner pass is exited, as function passes; /// may be run subsequently. This allows an implementation of InlineAdvisor; /// to prepare for a partial update, based on the optional SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:197,Testability,test,test,197,"/// The default (manual heuristics) implementation of the InlineAdvisor. This; /// implementation does not need to keep state between inliner pass runs, and is; /// reusable as-is for inliner pass test scenarios, as well as for regular use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:55,Modifiability,plugin,plugins,55,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:84,Modifiability,plugin,plugin,84,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:156,Modifiability,Plugin,PluginInlineAdvisorAnalysis,156,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:693,Modifiability,Plugin,PluginInlineAdvisorAnalysis,693,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1267,Modifiability,plugin,plugin,1267,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1335,Modifiability,Plugin,PluginInlineAdvisorAnlysis,1335,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1421,Modifiability,plugin,plugin,1421,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1160,Performance,Optimiz,OptimizationLevel,1160,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1522,Performance,load,loaded,1522,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:13,Integrability,message,message,13,/// Emit ORE message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:13,Integrability,message,message,13,/// Emit ORE message based in cost (default heuristic).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:29,Integrability,message,message,29,/// Add location info to ORE message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:43,Integrability,message,message,43,/// Utility for extracting the inline cost message to a string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:34,Energy Efficiency,allocate,allocate,34,/// Do not inline functions which allocate this many bytes on the stack; /// when the caller is recursive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:386,Availability,avail,available,386,"/// Represents the cost of inlining a function.; ///; /// This supports special values for functions which should ""always"" or; /// ""never"" be inlined. Otherwise, the cost represents a unitless amount;; /// smaller values increase the likelihood of the function being inlined.; ///; /// Objects of this type also provide the adjusted threshold for inlining; /// based on the information available for a particular callsite. They can be; /// directly tested to determine if inlining should occur given the cost and; /// threshold for this cost metric.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:449,Testability,test,tested,449,"/// Represents the cost of inlining a function.; ///; /// This supports special values for functions which should ""always"" or; /// ""never"" be inlined. Otherwise, the cost represents a unitless amount;; /// smaller values increase the likelihood of the function being inlined.; ///; /// Objects of this type also provide the adjusted threshold for inlining; /// based on the information available for a particular callsite. They can be; /// directly tested to determine if inlining should occur given the cost and; /// threshold for this cost metric.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:36,Testability,log,logic,36,"// Trivial constructor, interesting logic in the factory functions below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:4,Testability,Test,Test,4,/// Test whether the inline cost is low enough for inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:48,Availability,error,error,48,"/// Get the inline cost estimate.; /// It is an error to call this on an ""always"" or ""never"" InlineCost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:94,Modifiability,variab,variable,94,/// Get the cost delta from the threshold for inlining.; /// Only valid if the cost is of the variable kind. Returns a negative; /// value if the cost is too high to inline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:67,Integrability,message,message,67,/// InlineResult is basically true or false. For false results the message; /// describes a reason.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:18,Performance,tune,tune,18,"/// Thresholds to tune inline cost analysis. The inline cost analysis decides; /// the condition to apply a threshold and applies it. Otherwise,; /// DefaultThreshold is used. If a threshold is Optional, it is applied only; /// when it has a valid value. Typically, users of inline cost analysis; /// obtain an InlineParams object through one of the \c getInlineParams methods; /// and pass it to \c getInlineCost. Some specialized versions of inliner; /// (such as the pre-inliner) might have custom logic to compute \c InlineParams; /// object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:501,Testability,log,logic,501,"/// Thresholds to tune inline cost analysis. The inline cost analysis decides; /// the condition to apply a threshold and applies it. Otherwise,; /// DefaultThreshold is used. If a threshold is Optional, it is applied only; /// when it has a valid value. Typically, users of inline cost analysis; /// obtain an InlineParams object through one of the \c getInlineParams methods; /// and pass it to \c getInlineCost. Some specialized versions of inliner; /// (such as the pre-inliner) might have custom logic to compute \c InlineParams; /// object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:40,Performance,optimiz,optimized,40,/// Threshold to use when the caller is optimized for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:40,Performance,optimiz,optimized,40,/// Threshold to use when the caller is optimized for minsize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:31,Performance,tune,tune,31,/// Generate the parameters to tune the inline cost analysis based only on the; /// commandline options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:31,Performance,tune,tune,31,"/// Generate the parameters to tune the inline cost analysis based on command; /// line options. If -inline-threshold option is not explicitly passed,; /// \p Threshold is used as the default threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:31,Performance,tune,tune,31,"/// Generate the parameters to tune the inline cost analysis based on command; /// line options. If -inline-threshold option is not explicitly passed,; /// the default threshold is computed from \p OptLevel and \p SizeOptLevel.; /// An \p OptLevel value above 3 is considered an aggressive optimization mode.; /// \p SizeOptLevel of 1 corresponds to the -Os flag and 2 corresponds to; /// the -Oz flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:290,Performance,optimiz,optimization,290,"/// Generate the parameters to tune the inline cost analysis based on command; /// line options. If -inline-threshold option is not explicitly passed,; /// the default threshold is computed from \p OptLevel and \p SizeOptLevel.; /// An \p OptLevel value above 3 is considered an aggressive optimization mode.; /// \p SizeOptLevel of 1 corresponds to the -Os flag and 2 corresponds to; /// the -Oz flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:166,Availability,failure,failure,166,"/// Returns InlineResult::success() if the call site should be always inlined; /// because of user directives, and the inlining is viable. Returns; /// InlineResult::failure() if the inlining may never happen because of user; /// directives or incompatibilities detectable without needing callee traversal.; /// Otherwise returns std::nullopt, meaning that inlining should be decided; /// based on other criteria (e.g. cost modeling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:262,Safety,detect,detectable,262,"/// Returns InlineResult::success() if the call site should be always inlined; /// because of user directives, and the inlining is viable. Returns; /// InlineResult::failure() if the inlining may never happen because of user; /// directives or incompatibilities detectable without needing callee traversal.; /// Otherwise returns std::nullopt, meaning that inlining should be decided; /// based on other criteria (e.g. cost modeling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:22,Safety,detect,detect,22,/// Minimal filter to detect invalid constructs for inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:194,Performance,optimiz,optimizations,194,// This pass is used to annotate instructions during the inline process for; // debugging and analysis. The main purpose of the pass is to see and test; // inliner's decisions when creating new optimizations to InlineCost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:147,Testability,test,test,147,// This pass is used to annotate instructions during the inline process for; // debugging and analysis. The main purpose of the pass is to see and test; // inliner's decisions when creating new optimizations to InlineCost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:61,Modifiability,plugin,plugins,61,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:79,Modifiability,Plugin,Plugins,79,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:234,Modifiability,Plugin,PluginInlineOrderAnalysis,234,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:389,Modifiability,Plugin,PluginInlineOrderAnalysis,389,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:25,Performance,load,loading,25,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:567,Energy Efficiency,efficient,efficiently,567,"//===-- InstructionPrecedenceTracking.h -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:965,Performance,cache,cached,965,"//===-- InstructionPrecedenceTracking.h -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:93,Availability,error,error,93,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:21,Performance,cache,cached,21,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:102,Security,access,accessing,102,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:4,Testability,Assert,Asserts,4,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:107,Availability,error,error,107,/// Asserts whether or not the contents of this tracking is up-to-date. This; /// helps to catch the usage error of accessing a block without properly; /// invalidating after a previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:116,Security,access,accessing,116,/// Asserts whether or not the contents of this tracking is up-to-date. This; /// helps to catch the usage error of accessing a block without properly; /// invalidating after a previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:4,Testability,Assert,Asserts,4,/// Asserts whether or not the contents of this tracking is up-to-date. This; /// helps to catch the usage error of accessing a block without properly; /// invalidating after a previous transform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:135,Deployability,update,updates,135,/// Notifies this tracking that we are going to insert a new instruction \p; /// Inst to the basic block \p BB. It makes all necessary updates to internal; /// caches to keep them consistent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:160,Performance,cache,caches,160,/// Notifies this tracking that we are going to insert a new instruction \p; /// Inst to the basic block \p BB. It makes all necessary updates to internal; /// caches to keep them consistent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:107,Deployability,update,updates,107,/// Notifies this tracking that we are going to remove the instruction \p Inst; /// It makes all necessary updates to internal caches to keep them consistent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:127,Performance,cache,caches,127,/// Notifies this tracking that we are going to remove the instruction \p Inst; /// It makes all necessary updates to internal caches to keep them consistent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:105,Deployability,update,updates,105,/// Notifies this tracking that we are going to replace all uses of \p Inst.; /// It makes all necessary updates to internal caches to keep them consistent.; /// Should typically be called before a RAUW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:125,Performance,cache,caches,125,/// Notifies this tracking that we are going to replace all uses of \p Inst.; /// It makes all necessary updates to internal caches to keep them consistent.; /// Should typically be called before a RAUW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:490,Performance,perform,perform,490,"/// This class allows to keep track on instructions with implicit control flow.; /// These are instructions that may not pass execution to their successors. For; /// example, throwing calls and guards do not always do this. If we need to know; /// for sure that some instruction is guaranteed to execute if the given block; /// is reached, then we need to make sure that there is no implicit control flow; /// instruction (ICFI) preceding it. For example, this check is required if we; /// perform PRE moving non-speculable instruction to other place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:402,Integrability,rout,routines,402,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:829,Integrability,rout,routines,829,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:917,Integrability,rout,routines,917,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:1316,Integrability,rout,routines,1316,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:891,Safety,safe,safe,891,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:49,Usability,simpl,simpler,49,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:441,Usability,simpl,simpler,441,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:729,Usability,simpl,simplification,729,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:936,Usability,simpl,simplified,936,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:1053,Usability,simpl,simplified,1053,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:1331,Usability,simpl,simplify,1331,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:1459,Usability,simpl,simplify,1459,"//===-- InstructionSimplify.h - Fold instrs into simpler forms --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). If the simplification is also an instruction; // then it dominates the original instruction.; //; // These routines implicitly resolve undef uses. The easiest way to be safe when; // using these routines to obtain simplified values for existing instructions is; // to always replace all uses of the instructions with the resulting simplified; // values. This will prevent other code from seeing the same undef uses and; // resolving them to different values.; //; // They require that all the IR that they encounter be valid and inserted into a; // parent function.; //; // Additionally, these routines can't simplify to the instructions that are not; // def-reachable, meaning we can't just scan the basic block for instructions; // to simplify to.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:107,Usability,Simpl,SimplifyQuery,107,"// NOTE: the explicit multiple argument versions of these functions are; // deprecated.; // Please use the SimplifyQuery versions in new code.; /// Given operands for an Add, fold the result or return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:145,Performance,perform,perform,145,"/// Given operands for the multiplication of a FMA, fold the result or return; /// null. In contrast to simplifyFMulInst, this function will not perform; /// simplifications whose unrounded results differ when rounded to the argument; /// type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:104,Usability,simpl,simplifyFMulInst,104,"/// Given operands for the multiplication of a FMA, fold the result or return; /// null. In contrast to simplifyFMulInst, this function will not perform; /// simplifications whose unrounded results differ when rounded to the argument; /// type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:158,Usability,simpl,simplifications,158,"/// Given operands for the multiplication of a FMA, fold the result or return; /// null. In contrast to simplifyFMulInst, this function will not perform; /// simplifications whose unrounded results differ when rounded to the argument; /// type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:134,Availability,mask,mask,134,"/// Given operands for a ShuffleVectorInst, fold the result or return null.; /// See class ShuffleVectorInst for a description of the mask representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
